"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(ssr)/./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Client = __webpack_require__(/*! ./lib/dispatcher/client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\");\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher/dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\");\nconst Pool = __webpack_require__(/*! ./lib/dispatcher/pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst BalancedPool = __webpack_require__(/*! ./lib/dispatcher/balanced-pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js\");\nconst Agent = __webpack_require__(/*! ./lib/dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nconst ProxyAgent = __webpack_require__(/*! ./lib/dispatcher/proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\");\nconst EnvHttpProxyAgent = __webpack_require__(/*! ./lib/dispatcher/env-http-proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\");\nconst RetryAgent = __webpack_require__(/*! ./lib/dispatcher/retry-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js\");\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError } = errors;\nconst api = __webpack_require__(/*! ./lib/api */ \"(ssr)/./node_modules/undici/lib/api/index.js\");\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\");\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(ssr)/./node_modules/undici/lib/mock/mock-client.js\");\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(ssr)/./node_modules/undici/lib/mock/mock-agent.js\");\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(ssr)/./node_modules/undici/lib/mock/mock-pool.js\");\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(ssr)/./node_modules/undici/lib/mock/mock-errors.js\");\nconst RetryHandler = __webpack_require__(/*! ./lib/handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\");\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(ssr)/./node_modules/undici/lib/global.js\");\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/decorator-handler */ \"(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\");\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirect-interceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\");\nObject.assign(Dispatcher.prototype, api);\nmodule.exports.Dispatcher = Dispatcher;\nmodule.exports.Client = Client;\nmodule.exports.Pool = Pool;\nmodule.exports.BalancedPool = BalancedPool;\nmodule.exports.Agent = Agent;\nmodule.exports.ProxyAgent = ProxyAgent;\nmodule.exports.EnvHttpProxyAgent = EnvHttpProxyAgent;\nmodule.exports.RetryAgent = RetryAgent;\nmodule.exports.RetryHandler = RetryHandler;\nmodule.exports.DecoratorHandler = DecoratorHandler;\nmodule.exports.RedirectHandler = RedirectHandler;\nmodule.exports.createRedirectInterceptor = createRedirectInterceptor;\nmodule.exports.interceptors = {\n    redirect: __webpack_require__(/*! ./lib/interceptor/redirect */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect.js\"),\n    retry: __webpack_require__(/*! ./lib/interceptor/retry */ \"(ssr)/./node_modules/undici/lib/interceptor/retry.js\"),\n    dump: __webpack_require__(/*! ./lib/interceptor/dump */ \"(ssr)/./node_modules/undici/lib/interceptor/dump.js\")\n};\nmodule.exports.buildConnector = buildConnector;\nmodule.exports.errors = errors;\nmodule.exports.util = {\n    parseHeaders: util.parseHeaders,\n    headerNameToString: util.headerNameToString\n};\nfunction makeDispatcher(fn) {\n    return (url, opts, handler)=>{\n        if (typeof opts === 'function') {\n            handler = opts;\n            opts = null;\n        }\n        if (!url || typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL)) {\n            throw new InvalidArgumentError('invalid url');\n        }\n        if (opts != null && typeof opts !== 'object') {\n            throw new InvalidArgumentError('invalid opts');\n        }\n        if (opts && opts.path != null) {\n            if (typeof opts.path !== 'string') {\n                throw new InvalidArgumentError('invalid opts.path');\n            }\n            let path = opts.path;\n            if (!opts.path.startsWith('/')) {\n                path = `/${path}`;\n            }\n            url = new URL(util.parseOrigin(url).origin + path);\n        } else {\n            if (!opts) {\n                opts = typeof url === 'object' ? url : {};\n            }\n            url = util.parseURL(url);\n        }\n        const { agent, dispatcher = getGlobalDispatcher() } = opts;\n        if (agent) {\n            throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?');\n        }\n        return fn.call(dispatcher, {\n            ...opts,\n            origin: url.origin,\n            path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n            method: opts.method || (opts.body ? 'PUT' : 'GET')\n        }, handler);\n    };\n}\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher;\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher;\nconst fetchImpl = (__webpack_require__(/*! ./lib/web/fetch */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\").fetch);\nmodule.exports.fetch = async function fetch(init, options = undefined) {\n    try {\n        return await fetchImpl(init, options);\n    } catch (err) {\n        if (err && typeof err === 'object') {\n            Error.captureStackTrace(err);\n        }\n        throw err;\n    }\n};\nmodule.exports.Headers = __webpack_require__(/*! ./lib/web/fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\").Headers;\nmodule.exports.Response = __webpack_require__(/*! ./lib/web/fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\").Response;\nmodule.exports.Request = __webpack_require__(/*! ./lib/web/fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\").Request;\nmodule.exports.FormData = __webpack_require__(/*! ./lib/web/fetch/formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\").FormData;\nmodule.exports.File = globalThis.File ?? (__webpack_require__(/*! node:buffer */ \"node:buffer\").File);\nmodule.exports.FileReader = __webpack_require__(/*! ./lib/web/fileapi/filereader */ \"(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js\").FileReader;\nconst { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/web/fetch/global */ \"(ssr)/./node_modules/undici/lib/web/fetch/global.js\");\nmodule.exports.setGlobalOrigin = setGlobalOrigin;\nmodule.exports.getGlobalOrigin = getGlobalOrigin;\nconst { CacheStorage } = __webpack_require__(/*! ./lib/web/cache/cachestorage */ \"(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js\");\nconst { kConstruct } = __webpack_require__(/*! ./lib/web/cache/symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\");\n// Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n// in an older version of Node, it doesn't have any use without fetch.\nmodule.exports.caches = new CacheStorage(kConstruct);\nconst { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/web/cookies */ \"(ssr)/./node_modules/undici/lib/web/cookies/index.js\");\nmodule.exports.deleteCookie = deleteCookie;\nmodule.exports.getCookies = getCookies;\nmodule.exports.getSetCookies = getSetCookies;\nmodule.exports.setCookie = setCookie;\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/web/fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nmodule.exports.parseMIMEType = parseMIMEType;\nmodule.exports.serializeAMimeType = serializeAMimeType;\nconst { CloseEvent, ErrorEvent, MessageEvent } = __webpack_require__(/*! ./lib/web/websocket/events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nmodule.exports.WebSocket = __webpack_require__(/*! ./lib/web/websocket/websocket */ \"(ssr)/./node_modules/undici/lib/web/websocket/websocket.js\").WebSocket;\nmodule.exports.CloseEvent = CloseEvent;\nmodule.exports.ErrorEvent = ErrorEvent;\nmodule.exports.MessageEvent = MessageEvent;\nmodule.exports.request = makeDispatcher(api.request);\nmodule.exports.stream = makeDispatcher(api.stream);\nmodule.exports.pipeline = makeDispatcher(api.pipeline);\nmodule.exports.connect = makeDispatcher(api.connect);\nmodule.exports.upgrade = makeDispatcher(api.upgrade);\nmodule.exports.MockClient = MockClient;\nmodule.exports.MockPool = MockPool;\nmodule.exports.MockAgent = MockAgent;\nmodule.exports.mockErrors = mockErrors;\nconst { EventSource } = __webpack_require__(/*! ./lib/web/eventsource/eventsource */ \"(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js\");\nmodule.exports.EventSource = EventSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUMscUZBQXlCO0FBQ2hELE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDZGQUE2QjtBQUN4RCxNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQyxpRkFBdUI7QUFDNUMsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMsbUdBQWdDO0FBQzdELE1BQU1JLFFBQVFKLG1CQUFPQSxDQUFDLG1GQUF3QjtBQUM5QyxNQUFNSyxhQUFhTCxtQkFBT0EsQ0FBQywrRkFBOEI7QUFDekQsTUFBTU0sb0JBQW9CTixtQkFBT0EsQ0FBQyxpSEFBdUM7QUFDekUsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsK0ZBQThCO0FBQ3pELE1BQU1RLFNBQVNSLG1CQUFPQSxDQUFDLHlFQUFtQjtBQUMxQyxNQUFNUyxPQUFPVCxtQkFBT0EsQ0FBQyxxRUFBaUI7QUFDdEMsTUFBTSxFQUFFVSxvQkFBb0IsRUFBRSxHQUFHRjtBQUNqQyxNQUFNRyxNQUFNWCxtQkFBT0EsQ0FBQywrREFBVztBQUMvQixNQUFNWSxpQkFBaUJaLG1CQUFPQSxDQUFDLDJFQUFvQjtBQUNuRCxNQUFNYSxhQUFhYixtQkFBT0EsQ0FBQyxtRkFBd0I7QUFDbkQsTUFBTWMsWUFBWWQsbUJBQU9BLENBQUMsaUZBQXVCO0FBQ2pELE1BQU1lLFdBQVdmLG1CQUFPQSxDQUFDLCtFQUFzQjtBQUMvQyxNQUFNZ0IsYUFBYWhCLG1CQUFPQSxDQUFDLG1GQUF3QjtBQUNuRCxNQUFNaUIsZUFBZWpCLG1CQUFPQSxDQUFDLDZGQUE2QjtBQUMxRCxNQUFNLEVBQUVrQixtQkFBbUIsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR25CLG1CQUFPQSxDQUFDLCtEQUFjO0FBQzNFLE1BQU1vQixtQkFBbUJwQixtQkFBT0EsQ0FBQyxxR0FBaUM7QUFDbEUsTUFBTXFCLGtCQUFrQnJCLG1CQUFPQSxDQUFDLG1HQUFnQztBQUNo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RCwyQkFBMkIsR0FBR3NEO0FBRTlCdEQsc0JBQXNCLEdBQUdRLGVBQWV2QixJQUFJdUUsT0FBTztBQUNuRHhELHFCQUFxQixHQUFHUSxlQUFldkIsSUFBSXdFLE1BQU07QUFDakR6RCx1QkFBdUIsR0FBR1EsZUFBZXZCLElBQUl5RSxRQUFRO0FBQ3JEMUQsc0JBQXNCLEdBQUdRLGVBQWV2QixJQUFJMEUsT0FBTztBQUNuRDNELHNCQUFzQixHQUFHUSxlQUFldkIsSUFBSTJFLE9BQU87QUFFbkQ1RCx5QkFBeUIsR0FBR2I7QUFDNUJhLHVCQUF1QixHQUFHWDtBQUMxQlcsd0JBQXdCLEdBQUdaO0FBQzNCWSx5QkFBeUIsR0FBR1Y7QUFFNUIsTUFBTSxFQUFFdUUsV0FBVyxFQUFFLEdBQUd2RixtQkFBT0EsQ0FBQyx5R0FBbUM7QUFFbkUwQiwwQkFBMEIsR0FBRzZEIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9jbGllbnQnKVxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcicpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9wb29sJylcbmNvbnN0IEJhbGFuY2VkUG9vbCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvYmFsYW5jZWQtcG9vbCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvYWdlbnQnKVxuY29uc3QgUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvcHJveHktYWdlbnQnKVxuY29uc3QgRW52SHR0cFByb3h5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50JylcbmNvbnN0IFJldHJ5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50JylcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vbGliL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2xpYi9jb3JlL3V0aWwnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gZXJyb3JzXG5jb25zdCBhcGkgPSByZXF1aXJlKCcuL2xpYi9hcGknKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Nvbm5lY3QnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1jbGllbnQnKVxuY29uc3QgTW9ja0FnZW50ID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWFnZW50JylcbmNvbnN0IE1vY2tQb29sID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLXBvb2wnKVxuY29uc3QgbW9ja0Vycm9ycyA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1lcnJvcnMnKVxuY29uc3QgUmV0cnlIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9yZXRyeS1oYW5kbGVyJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciwgc2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi9saWIvZ2xvYmFsJylcbmNvbnN0IERlY29yYXRvckhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyJylcbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QtaW50ZXJjZXB0b3InKVxuXG5PYmplY3QuYXNzaWduKERpc3BhdGNoZXIucHJvdG90eXBlLCBhcGkpXG5cbm1vZHVsZS5leHBvcnRzLkRpc3BhdGNoZXIgPSBEaXNwYXRjaGVyXG5tb2R1bGUuZXhwb3J0cy5DbGllbnQgPSBDbGllbnRcbm1vZHVsZS5leHBvcnRzLlBvb2wgPSBQb29sXG5tb2R1bGUuZXhwb3J0cy5CYWxhbmNlZFBvb2wgPSBCYWxhbmNlZFBvb2xcbm1vZHVsZS5leHBvcnRzLkFnZW50ID0gQWdlbnRcbm1vZHVsZS5leHBvcnRzLlByb3h5QWdlbnQgPSBQcm94eUFnZW50XG5tb2R1bGUuZXhwb3J0cy5FbnZIdHRwUHJveHlBZ2VudCA9IEVudkh0dHBQcm94eUFnZW50XG5tb2R1bGUuZXhwb3J0cy5SZXRyeUFnZW50ID0gUmV0cnlBZ2VudFxubW9kdWxlLmV4cG9ydHMuUmV0cnlIYW5kbGVyID0gUmV0cnlIYW5kbGVyXG5cbm1vZHVsZS5leHBvcnRzLkRlY29yYXRvckhhbmRsZXIgPSBEZWNvcmF0b3JIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cy5SZWRpcmVjdEhhbmRsZXIgPSBSZWRpcmVjdEhhbmRsZXJcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yXG5tb2R1bGUuZXhwb3J0cy5pbnRlcmNlcHRvcnMgPSB7XG4gIHJlZGlyZWN0OiByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdCcpLFxuICByZXRyeTogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvcmV0cnknKSxcbiAgZHVtcDogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvZHVtcCcpXG59XG5cbm1vZHVsZS5leHBvcnRzLmJ1aWxkQ29ubmVjdG9yID0gYnVpbGRDb25uZWN0b3Jcbm1vZHVsZS5leHBvcnRzLmVycm9ycyA9IGVycm9yc1xubW9kdWxlLmV4cG9ydHMudXRpbCA9IHtcbiAgcGFyc2VIZWFkZXJzOiB1dGlsLnBhcnNlSGVhZGVycyxcbiAgaGVhZGVyTmFtZVRvU3RyaW5nOiB1dGlsLmhlYWRlck5hbWVUb1N0cmluZ1xufVxuXG5mdW5jdGlvbiBtYWtlRGlzcGF0Y2hlciAoZm4pIHtcbiAgcmV0dXJuICh1cmwsIG9wdHMsIGhhbmRsZXIpID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIgPSBvcHRzXG4gICAgICBvcHRzID0gbnVsbFxuICAgIH1cblxuICAgIGlmICghdXJsIHx8ICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdXJsICE9PSAnb2JqZWN0JyAmJiAhKHVybCBpbnN0YW5jZW9mIFVSTCkpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdXJsJylcbiAgICB9XG5cbiAgICBpZiAob3B0cyAhPSBudWxsICYmIHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmIChvcHRzICYmIG9wdHMucGF0aCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMucGF0aCcpXG4gICAgICB9XG5cbiAgICAgIGxldCBwYXRoID0gb3B0cy5wYXRoXG4gICAgICBpZiAoIW9wdHMucGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcGF0aCA9IGAvJHtwYXRofWBcbiAgICAgIH1cblxuICAgICAgdXJsID0gbmV3IFVSTCh1dGlsLnBhcnNlT3JpZ2luKHVybCkub3JpZ2luICsgcGF0aClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIG9wdHMgPSB0eXBlb2YgdXJsID09PSAnb2JqZWN0JyA/IHVybCA6IHt9XG4gICAgICB9XG5cbiAgICAgIHVybCA9IHV0aWwucGFyc2VVUkwodXJsKVxuICAgIH1cblxuICAgIGNvbnN0IHsgYWdlbnQsIGRpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyKCkgfSA9IG9wdHNcblxuICAgIGlmIChhZ2VudCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBvcHRzLmFnZW50LiBEaWQgeW91IG1lYW4gb3B0cy5jbGllbnQ/JylcbiAgICB9XG5cbiAgICByZXR1cm4gZm4uY2FsbChkaXNwYXRjaGVyLCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgcGF0aDogdXJsLnNlYXJjaCA/IGAke3VybC5wYXRobmFtZX0ke3VybC5zZWFyY2h9YCA6IHVybC5wYXRobmFtZSxcbiAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QgfHwgKG9wdHMuYm9keSA/ICdQVVQnIDogJ0dFVCcpXG4gICAgfSwgaGFuZGxlcilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5zZXRHbG9iYWxEaXNwYXRjaGVyID0gc2V0R2xvYmFsRGlzcGF0Y2hlclxubW9kdWxlLmV4cG9ydHMuZ2V0R2xvYmFsRGlzcGF0Y2hlciA9IGdldEdsb2JhbERpc3BhdGNoZXJcblxuY29uc3QgZmV0Y2hJbXBsID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoJykuZmV0Y2hcbm1vZHVsZS5leHBvcnRzLmZldGNoID0gYXN5bmMgZnVuY3Rpb24gZmV0Y2ggKGluaXQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hJbXBsKGluaXQsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycilcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMuSGVhZGVycyA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9oZWFkZXJzJykuSGVhZGVyc1xubW9kdWxlLmV4cG9ydHMuUmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UnKS5SZXNwb25zZVxubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9yZXF1ZXN0JykuUmVxdWVzdFxubW9kdWxlLmV4cG9ydHMuRm9ybURhdGEgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEnKS5Gb3JtRGF0YVxubW9kdWxlLmV4cG9ydHMuRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSA/PyByZXF1aXJlKCdub2RlOmJ1ZmZlcicpLkZpbGVcbm1vZHVsZS5leHBvcnRzLkZpbGVSZWFkZXIgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmlsZWFwaS9maWxlcmVhZGVyJykuRmlsZVJlYWRlclxuXG5jb25zdCB7IHNldEdsb2JhbE9yaWdpbiwgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsJylcblxubW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsT3JpZ2luID0gc2V0R2xvYmFsT3JpZ2luXG5tb2R1bGUuZXhwb3J0cy5nZXRHbG9iYWxPcmlnaW4gPSBnZXRHbG9iYWxPcmlnaW5cblxuY29uc3QgeyBDYWNoZVN0b3JhZ2UgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9jYWNoZS9jYWNoZXN0b3JhZ2UnKVxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvY2FjaGUvc3ltYm9scycpXG5cbi8vIENhY2hlICYgQ2FjaGVTdG9yYWdlIGFyZSB0aWdodGx5IGNvdXBsZWQgd2l0aCBmZXRjaC4gRXZlbiBpZiBpdCBtYXkgcnVuXG4vLyBpbiBhbiBvbGRlciB2ZXJzaW9uIG9mIE5vZGUsIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgdXNlIHdpdGhvdXQgZmV0Y2guXG5tb2R1bGUuZXhwb3J0cy5jYWNoZXMgPSBuZXcgQ2FjaGVTdG9yYWdlKGtDb25zdHJ1Y3QpXG5cbmNvbnN0IHsgZGVsZXRlQ29va2llLCBnZXRDb29raWVzLCBnZXRTZXRDb29raWVzLCBzZXRDb29raWUgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9jb29raWVzJylcblxubW9kdWxlLmV4cG9ydHMuZGVsZXRlQ29va2llID0gZGVsZXRlQ29va2llXG5tb2R1bGUuZXhwb3J0cy5nZXRDb29raWVzID0gZ2V0Q29va2llc1xubW9kdWxlLmV4cG9ydHMuZ2V0U2V0Q29va2llcyA9IGdldFNldENvb2tpZXNcbm1vZHVsZS5leHBvcnRzLnNldENvb2tpZSA9IHNldENvb2tpZVxuXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL2RhdGEtdXJsJylcblxubW9kdWxlLmV4cG9ydHMucGFyc2VNSU1FVHlwZSA9IHBhcnNlTUlNRVR5cGVcbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZUFNaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZVxuXG5jb25zdCB7IENsb3NlRXZlbnQsIEVycm9yRXZlbnQsIE1lc3NhZ2VFdmVudCB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL3dlYnNvY2tldC9ldmVudHMnKVxubW9kdWxlLmV4cG9ydHMuV2ViU29ja2V0ID0gcmVxdWlyZSgnLi9saWIvd2ViL3dlYnNvY2tldC93ZWJzb2NrZXQnKS5XZWJTb2NrZXRcbm1vZHVsZS5leHBvcnRzLkNsb3NlRXZlbnQgPSBDbG9zZUV2ZW50XG5tb2R1bGUuZXhwb3J0cy5FcnJvckV2ZW50ID0gRXJyb3JFdmVudFxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUV2ZW50ID0gTWVzc2FnZUV2ZW50XG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkucmVxdWVzdClcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5zdHJlYW0pXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5waXBlbGluZSlcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkuY29ubmVjdClcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSBtYWtlRGlzcGF0Y2hlcihhcGkudXBncmFkZSlcblxubW9kdWxlLmV4cG9ydHMuTW9ja0NsaWVudCA9IE1vY2tDbGllbnRcbm1vZHVsZS5leHBvcnRzLk1vY2tQb29sID0gTW9ja1Bvb2xcbm1vZHVsZS5leHBvcnRzLk1vY2tBZ2VudCA9IE1vY2tBZ2VudFxubW9kdWxlLmV4cG9ydHMubW9ja0Vycm9ycyA9IG1vY2tFcnJvcnNcblxuY29uc3QgeyBFdmVudFNvdXJjZSB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2V2ZW50c291cmNlL2V2ZW50c291cmNlJylcblxubW9kdWxlLmV4cG9ydHMuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZVxuIl0sIm5hbWVzIjpbIkNsaWVudCIsInJlcXVpcmUiLCJEaXNwYXRjaGVyIiwiUG9vbCIsIkJhbGFuY2VkUG9vbCIsIkFnZW50IiwiUHJveHlBZ2VudCIsIkVudkh0dHBQcm94eUFnZW50IiwiUmV0cnlBZ2VudCIsImVycm9ycyIsInV0aWwiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImFwaSIsImJ1aWxkQ29ubmVjdG9yIiwiTW9ja0NsaWVudCIsIk1vY2tBZ2VudCIsIk1vY2tQb29sIiwibW9ja0Vycm9ycyIsIlJldHJ5SGFuZGxlciIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJzZXRHbG9iYWxEaXNwYXRjaGVyIiwiRGVjb3JhdG9ySGFuZGxlciIsIlJlZGlyZWN0SGFuZGxlciIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IiLCJPYmplY3QiLCJhc3NpZ24iLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiaW50ZXJjZXB0b3JzIiwicmVkaXJlY3QiLCJyZXRyeSIsImR1bXAiLCJwYXJzZUhlYWRlcnMiLCJoZWFkZXJOYW1lVG9TdHJpbmciLCJtYWtlRGlzcGF0Y2hlciIsImZuIiwidXJsIiwib3B0cyIsImhhbmRsZXIiLCJVUkwiLCJwYXRoIiwic3RhcnRzV2l0aCIsInBhcnNlT3JpZ2luIiwib3JpZ2luIiwicGFyc2VVUkwiLCJhZ2VudCIsImRpc3BhdGNoZXIiLCJjYWxsIiwic2VhcmNoIiwicGF0aG5hbWUiLCJtZXRob2QiLCJib2R5IiwiZmV0Y2hJbXBsIiwiZmV0Y2giLCJpbml0Iiwib3B0aW9ucyIsInVuZGVmaW5lZCIsImVyciIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJIZWFkZXJzIiwiUmVzcG9uc2UiLCJSZXF1ZXN0IiwiRm9ybURhdGEiLCJGaWxlIiwiZ2xvYmFsVGhpcyIsIkZpbGVSZWFkZXIiLCJzZXRHbG9iYWxPcmlnaW4iLCJnZXRHbG9iYWxPcmlnaW4iLCJDYWNoZVN0b3JhZ2UiLCJrQ29uc3RydWN0IiwiY2FjaGVzIiwiZGVsZXRlQ29va2llIiwiZ2V0Q29va2llcyIsImdldFNldENvb2tpZXMiLCJzZXRDb29raWUiLCJwYXJzZU1JTUVUeXBlIiwic2VyaWFsaXplQU1pbWVUeXBlIiwiQ2xvc2VFdmVudCIsIkVycm9yRXZlbnQiLCJNZXNzYWdlRXZlbnQiLCJXZWJTb2NrZXQiLCJyZXF1ZXN0Iiwic3RyZWFtIiwicGlwZWxpbmUiLCJjb25uZWN0IiwidXBncmFkZSIsIkV2ZW50U291cmNlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst kListener = Symbol('kListener');\nconst kSignal = Symbol('kSignal');\nfunction abort(self) {\n    if (self.abort) {\n        self.abort(self[kSignal]?.reason);\n    } else {\n        self.reason = self[kSignal]?.reason ?? new RequestAbortedError();\n    }\n    removeSignal(self);\n}\nfunction addSignal(self, signal) {\n    self.reason = null;\n    self[kSignal] = null;\n    self[kListener] = null;\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        abort(self);\n        return;\n    }\n    self[kSignal] = signal;\n    self[kListener] = ()=>{\n        abort(self);\n    };\n    addAbortListener(self[kSignal], self[kListener]);\n}\nfunction removeSignal(self) {\n    if (!self[kSignal]) {\n        return;\n    }\n    if ('removeEventListener' in self[kSignal]) {\n        self[kSignal].removeEventListener('abort', self[kListener]);\n    } else {\n        self[kSignal].removeListener('abort', self[kListener]);\n    }\n    self[kSignal] = null;\n    self[kListener] = null;\n}\nmodule.exports = {\n    addSignal,\n    removeSignal\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUVBLGdCQUFnQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLGtFQUFjO0FBQ25ELE1BQU0sRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0QsbUJBQU9BLENBQUMsc0VBQWdCO0FBRXhELE1BQU1FLFlBQVlDLE9BQU87QUFDekIsTUFBTUMsVUFBVUQsT0FBTztBQUV2QixTQUFTRSxNQUFPQyxJQUFJO0lBQ2xCLElBQUlBLEtBQUtELEtBQUssRUFBRTtRQUNkQyxLQUFLRCxLQUFLLENBQUNDLElBQUksQ0FBQ0YsUUFBUSxFQUFFRztJQUM1QixPQUFPO1FBQ0xELEtBQUtDLE1BQU0sR0FBR0QsSUFBSSxDQUFDRixRQUFRLEVBQUVHLFVBQVUsSUFBSU47SUFDN0M7SUFDQU8sYUFBYUY7QUFDZjtBQUVBLFNBQVNHLFVBQVdILElBQUksRUFBRUksTUFBTTtJQUM5QkosS0FBS0MsTUFBTSxHQUFHO0lBRWRELElBQUksQ0FBQ0YsUUFBUSxHQUFHO0lBQ2hCRSxJQUFJLENBQUNKLFVBQVUsR0FBRztJQUVsQixJQUFJLENBQUNRLFFBQVE7UUFDWDtJQUNGO0lBRUEsSUFBSUEsT0FBT0MsT0FBTyxFQUFFO1FBQ2xCTixNQUFNQztRQUNOO0lBQ0Y7SUFFQUEsSUFBSSxDQUFDRixRQUFRLEdBQUdNO0lBQ2hCSixJQUFJLENBQUNKLFVBQVUsR0FBRztRQUNoQkcsTUFBTUM7SUFDUjtJQUVBUCxpQkFBaUJPLElBQUksQ0FBQ0YsUUFBUSxFQUFFRSxJQUFJLENBQUNKLFVBQVU7QUFDakQ7QUFFQSxTQUFTTSxhQUFjRixJQUFJO0lBQ3pCLElBQUksQ0FBQ0EsSUFBSSxDQUFDRixRQUFRLEVBQUU7UUFDbEI7SUFDRjtJQUVBLElBQUkseUJBQXlCRSxJQUFJLENBQUNGLFFBQVEsRUFBRTtRQUMxQ0UsSUFBSSxDQUFDRixRQUFRLENBQUNRLG1CQUFtQixDQUFDLFNBQVNOLElBQUksQ0FBQ0osVUFBVTtJQUM1RCxPQUFPO1FBQ0xJLElBQUksQ0FBQ0YsUUFBUSxDQUFDUyxjQUFjLENBQUMsU0FBU1AsSUFBSSxDQUFDSixVQUFVO0lBQ3ZEO0lBRUFJLElBQUksQ0FBQ0YsUUFBUSxHQUFHO0lBQ2hCRSxJQUFJLENBQUNKLFVBQVUsR0FBRztBQUNwQjtBQUVBWSxPQUFPQyxPQUFPLEdBQUc7SUFDZk47SUFDQUQ7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXGFib3J0LXNpZ25hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGFkZEFib3J0TGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3Qga0xpc3RlbmVyID0gU3ltYm9sKCdrTGlzdGVuZXInKVxuY29uc3Qga1NpZ25hbCA9IFN5bWJvbCgna1NpZ25hbCcpXG5cbmZ1bmN0aW9uIGFib3J0IChzZWxmKSB7XG4gIGlmIChzZWxmLmFib3J0KSB7XG4gICAgc2VsZi5hYm9ydChzZWxmW2tTaWduYWxdPy5yZWFzb24pXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5yZWFzb24gPSBzZWxmW2tTaWduYWxdPy5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICB9XG4gIHJlbW92ZVNpZ25hbChzZWxmKVxufVxuXG5mdW5jdGlvbiBhZGRTaWduYWwgKHNlbGYsIHNpZ25hbCkge1xuICBzZWxmLnJlYXNvbiA9IG51bGxcblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG5cbiAgaWYgKCFzaWduYWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGFib3J0KHNlbGYpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gc2lnbmFsXG4gIHNlbGZba0xpc3RlbmVyXSA9ICgpID0+IHtcbiAgICBhYm9ydChzZWxmKVxuICB9XG5cbiAgYWRkQWJvcnRMaXN0ZW5lcihzZWxmW2tTaWduYWxdLCBzZWxmW2tMaXN0ZW5lcl0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNpZ25hbCAoc2VsZikge1xuICBpZiAoIXNlbGZba1NpZ25hbF0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gc2VsZltrU2lnbmFsXSkge1xuICAgIHNlbGZba1NpZ25hbF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH0gZWxzZSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRTaWduYWwsXG4gIHJlbW92ZVNpZ25hbFxufVxuIl0sIm5hbWVzIjpbImFkZEFib3J0TGlzdGVuZXIiLCJyZXF1aXJlIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsImtMaXN0ZW5lciIsIlN5bWJvbCIsImtTaWduYWwiLCJhYm9ydCIsInNlbGYiLCJyZWFzb24iLCJyZW1vdmVTaWduYWwiLCJhZGRTaWduYWwiLCJzaWduYWwiLCJhYm9ydGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\");\nclass ConnectHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== 'object') {\n            throw new InvalidArgumentError('invalid opts');\n        }\n        if (typeof callback !== 'function') {\n            throw new InvalidArgumentError('invalid callback');\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n            throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n        }\n        super('UNDICI_CONNECT');\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.callback = callback;\n        this.abort = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(this.callback);\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders() {\n        throw new SocketError('bad connect', null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        removeSignal(this);\n        this.callback = null;\n        let headers = rawHeaders;\n        // Indicates is an HTTP2Session\n        if (headers != null) {\n            headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        }\n        this.runInAsyncScope(callback, null, null, {\n            statusCode,\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction connect(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            connect.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const connectHandler = new ConnectHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: 'CONNECT'\n        }, connectHandler);\n    } catch (err) {\n        if (typeof callback !== 'function') {\n            throw err;\n        }\n        const opaque = opts?.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = connect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNLEVBQUVDLGFBQWEsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQywwQ0FBa0I7QUFDcEQsTUFBTSxFQUFFRSxvQkFBb0IsRUFBRUMsV0FBVyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDLHNFQUFnQjtBQUN0RSxNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQyxrRUFBYztBQUNuQyxNQUFNLEVBQUVLLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDLDJFQUFnQjtBQUU1RCxNQUFNTyx1QkFBdUJOO0lBQzNCLFlBQWFPLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJTixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9PLGFBQWEsWUFBWTtZQUNsQyxNQUFNLElBQUlQLHFCQUFxQjtRQUNqQztRQUVBLE1BQU0sRUFBRVEsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHSjtRQUU1QyxJQUFJRSxVQUFVLE9BQU9BLE9BQU9HLEVBQUUsS0FBSyxjQUFjLE9BQU9ILE9BQU9JLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJWixxQkFBcUI7UUFDakM7UUFFQSxLQUFLLENBQUM7UUFFTixJQUFJLENBQUNTLE1BQU0sR0FBR0EsVUFBVTtRQUN4QixJQUFJLENBQUNDLGVBQWUsR0FBR0EsbUJBQW1CO1FBQzFDLElBQUksQ0FBQ0gsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNNLEtBQUssR0FBRztRQUViVixVQUFVLElBQUksRUFBRUs7SUFDbEI7SUFFQU0sVUFBV0QsS0FBSyxFQUFFRSxPQUFPLEVBQUU7UUFDekIsSUFBSSxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNmSCxNQUFNLElBQUksQ0FBQ0csTUFBTTtZQUNqQjtRQUNGO1FBRUFuQixPQUFPLElBQUksQ0FBQ1UsUUFBUTtRQUVwQixJQUFJLENBQUNNLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNFLE9BQU8sR0FBR0E7SUFDakI7SUFFQUUsWUFBYTtRQUNYLE1BQU0sSUFBSWhCLFlBQVksZUFBZTtJQUN2QztJQUVBaUIsVUFBV0MsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLE1BQU0sRUFBRTtRQUN6QyxNQUFNLEVBQUVkLFFBQVEsRUFBRUUsTUFBTSxFQUFFTSxPQUFPLEVBQUUsR0FBRyxJQUFJO1FBRTFDWCxhQUFhLElBQUk7UUFFakIsSUFBSSxDQUFDRyxRQUFRLEdBQUc7UUFFaEIsSUFBSWUsVUFBVUY7UUFDZCwrQkFBK0I7UUFDL0IsSUFBSUUsV0FBVyxNQUFNO1lBQ25CQSxVQUFVLElBQUksQ0FBQ1osZUFBZSxLQUFLLFFBQVFSLEtBQUtxQixlQUFlLENBQUNILGNBQWNsQixLQUFLc0IsWUFBWSxDQUFDSjtRQUNsRztRQUVBLElBQUksQ0FBQ0ssZUFBZSxDQUFDbEIsVUFBVSxNQUFNLE1BQU07WUFDekNZO1lBQ0FHO1lBQ0FEO1lBQ0FaO1lBQ0FNO1FBQ0Y7SUFDRjtJQUVBVyxRQUFTQyxHQUFHLEVBQUU7UUFDWixNQUFNLEVBQUVwQixRQUFRLEVBQUVFLE1BQU0sRUFBRSxHQUFHLElBQUk7UUFFakNMLGFBQWEsSUFBSTtRQUVqQixJQUFJRyxVQUFVO1lBQ1osSUFBSSxDQUFDQSxRQUFRLEdBQUc7WUFDaEJxQixlQUFlO2dCQUNiLElBQUksQ0FBQ0gsZUFBZSxDQUFDbEIsVUFBVSxNQUFNb0IsS0FBSztvQkFBRWxCO2dCQUFPO1lBQ3JEO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsU0FBU29CLFFBQVN2QixJQUFJLEVBQUVDLFFBQVE7SUFDOUIsSUFBSUEsYUFBYXVCLFdBQVc7UUFDMUIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCSixRQUFRSyxJQUFJLENBQUMsSUFBSSxFQUFFNUIsTUFBTSxDQUFDcUIsS0FBS1E7Z0JBQzdCLE9BQU9SLE1BQU1NLE9BQU9OLE9BQU9LLFFBQVFHO1lBQ3JDO1FBQ0Y7SUFDRjtJQUVBLElBQUk7UUFDRixNQUFNQyxpQkFBaUIsSUFBSS9CLGVBQWVDLE1BQU1DO1FBQ2hELElBQUksQ0FBQzhCLFFBQVEsQ0FBQztZQUFFLEdBQUcvQixJQUFJO1lBQUVnQyxRQUFRO1FBQVUsR0FBR0Y7SUFDaEQsRUFBRSxPQUFPVCxLQUFLO1FBQ1osSUFBSSxPQUFPcEIsYUFBYSxZQUFZO1lBQ2xDLE1BQU1vQjtRQUNSO1FBQ0EsTUFBTWxCLFNBQVNILE1BQU1HO1FBQ3JCbUIsZUFBZSxJQUFNckIsU0FBU29CLEtBQUs7Z0JBQUVsQjtZQUFPO0lBQzlDO0FBQ0Y7QUFFQThCLE9BQU9DLE9BQU8sR0FBR1giLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktY29ubmVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgQ29ubmVjdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9DT05ORUNUJylcblxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmNhbGxiYWNrKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCBjb25uZWN0JywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG5cbiAgICBsZXQgaGVhZGVycyA9IHJhd0hlYWRlcnNcbiAgICAvLyBJbmRpY2F0ZXMgaXMgYW4gSFRUUDJTZXNzaW9uXG4gICAgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB9XG5cbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzb2NrZXQsXG4gICAgICBvcGFxdWUsXG4gICAgICBjb250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25uZWN0IChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25uZWN0LmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gbmV3IENvbm5lY3RIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuICAgIHRoaXMuZGlzcGF0Y2goeyAuLi5vcHRzLCBtZXRob2Q6ICdDT05ORUNUJyB9LCBjb25uZWN0SGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIkFzeW5jUmVzb3VyY2UiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlNvY2tldEVycm9yIiwidXRpbCIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsIkNvbm5lY3RIYW5kbGVyIiwib3B0cyIsImNhbGxiYWNrIiwic2lnbmFsIiwib3BhcXVlIiwicmVzcG9uc2VIZWFkZXJzIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJvbkNvbm5lY3QiLCJjb250ZXh0IiwicmVhc29uIiwib25IZWFkZXJzIiwib25VcGdyYWRlIiwic3RhdHVzQ29kZSIsInJhd0hlYWRlcnMiLCJzb2NrZXQiLCJoZWFkZXJzIiwicGFyc2VSYXdIZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwicnVuSW5Bc3luY1Njb3BlIiwib25FcnJvciIsImVyciIsInF1ZXVlTWljcm90YXNrIiwiY29ubmVjdCIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FsbCIsImRhdGEiLCJjb25uZWN0SGFuZGxlciIsImRpc3BhdGNoIiwibWV0aG9kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Readable, Duplex, PassThrough } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst kResume = Symbol('resume');\nclass PipelineRequest extends Readable {\n    constructor(){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = null;\n    }\n    _read() {\n        const { [kResume]: resume } = this;\n        if (resume) {\n            this[kResume] = null;\n            resume();\n        }\n    }\n    _destroy(err, callback) {\n        this._read();\n        callback(err);\n    }\n}\nclass PipelineResponse extends Readable {\n    constructor(resume){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = resume;\n    }\n    _read() {\n        this[kResume]();\n    }\n    _destroy(err, callback) {\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        callback(err);\n    }\n}\nclass PipelineHandler extends AsyncResource {\n    constructor(opts, handler){\n        if (!opts || typeof opts !== 'object') {\n            throw new InvalidArgumentError('invalid opts');\n        }\n        if (typeof handler !== 'function') {\n            throw new InvalidArgumentError('invalid handler');\n        }\n        const { signal, method, opaque, onInfo, responseHeaders } = opts;\n        if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n            throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n        }\n        if (method === 'CONNECT') {\n            throw new InvalidArgumentError('invalid method');\n        }\n        if (onInfo && typeof onInfo !== 'function') {\n            throw new InvalidArgumentError('invalid onInfo callback');\n        }\n        super('UNDICI_PIPELINE');\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.handler = handler;\n        this.abort = null;\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.req = new PipelineRequest().on('error', util.nop);\n        this.ret = new Duplex({\n            readableObjectMode: opts.objectMode,\n            autoDestroy: true,\n            read: ()=>{\n                const { body } = this;\n                if (body?.resume) {\n                    body.resume();\n                }\n            },\n            write: (chunk, encoding, callback)=>{\n                const { req } = this;\n                if (req.push(chunk, encoding) || req._readableState.destroyed) {\n                    callback();\n                } else {\n                    req[kResume] = callback;\n                }\n            },\n            destroy: (err, callback)=>{\n                const { body, req, res, ret, abort } = this;\n                if (!err && !ret._readableState.endEmitted) {\n                    err = new RequestAbortedError();\n                }\n                if (abort && err) {\n                    abort();\n                }\n                util.destroy(body, err);\n                util.destroy(req, err);\n                util.destroy(res, err);\n                removeSignal(this);\n                callback(err);\n            }\n        }).on('prefinish', ()=>{\n            const { req } = this;\n            // Node < 15 does not call _final in same tick.\n            req.push(null);\n        });\n        this.res = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        const { ret, res } = this;\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(!res, 'pipeline cannot be retried');\n        assert(!ret.destroyed);\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume) {\n        const { opaque, handler, context } = this;\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.res = new PipelineResponse(resume);\n        let body;\n        try {\n            this.handler = null;\n            const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n            body = this.runInAsyncScope(handler, null, {\n                statusCode,\n                headers,\n                opaque,\n                body: this.res,\n                context\n            });\n        } catch (err) {\n            this.res.on('error', util.nop);\n            throw err;\n        }\n        if (!body || typeof body.on !== 'function') {\n            throw new InvalidReturnValueError('expected Readable');\n        }\n        body.on('data', (chunk)=>{\n            const { ret, body } = this;\n            if (!ret.push(chunk) && body.pause) {\n                body.pause();\n            }\n        }).on('error', (err)=>{\n            const { ret } = this;\n            util.destroy(ret, err);\n        }).on('end', ()=>{\n            const { ret } = this;\n            ret.push(null);\n        }).on('close', ()=>{\n            const { ret } = this;\n            if (!ret._readableState.ended) {\n                util.destroy(ret, new RequestAbortedError());\n            }\n        });\n        this.body = body;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        res.push(null);\n    }\n    onError(err) {\n        const { ret } = this;\n        this.handler = null;\n        util.destroy(ret, err);\n    }\n}\nfunction pipeline(opts, handler) {\n    try {\n        const pipelineHandler = new PipelineHandler(opts, handler);\n        this.dispatch({\n            ...opts,\n            body: pipelineHandler.req\n        }, pipelineHandler);\n        return pipelineHandler.ret;\n    } catch (err) {\n        return new PassThrough().destroy(err);\n    }\n}\nmodule.exports = pipeline;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxRQUFRLEVBQ1JDLE1BQU0sRUFDTkMsV0FBVyxFQUNaLEdBQUdDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3pCLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyx1QkFBdUIsRUFDdkJDLG1CQUFtQixFQUNwQixHQUFHSCxtQkFBT0EsQ0FBQyxzRUFBZ0I7QUFDNUIsTUFBTUksT0FBT0osbUJBQU9BLENBQUMsa0VBQWM7QUFDbkMsTUFBTSxFQUFFSyxhQUFhLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMsMENBQWtCO0FBQ3BELE1BQU0sRUFBRU0sU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR1AsbUJBQU9BLENBQUMsMkVBQWdCO0FBQzVELE1BQU1RLFNBQVNSLG1CQUFPQSxDQUFDLGdDQUFhO0FBRXBDLE1BQU1TLFVBQVVDLE9BQU87QUFFdkIsTUFBTUMsd0JBQXdCZDtJQUM1QixhQUFlO1FBQ2IsS0FBSyxDQUFDO1lBQUVlLGFBQWE7UUFBSztRQUUxQixJQUFJLENBQUNILFFBQVEsR0FBRztJQUNsQjtJQUVBSSxRQUFTO1FBQ1AsTUFBTSxFQUFFLENBQUNKLFFBQVEsRUFBRUssTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUVsQyxJQUFJQSxRQUFRO1lBQ1YsSUFBSSxDQUFDTCxRQUFRLEdBQUc7WUFDaEJLO1FBQ0Y7SUFDRjtJQUVBQyxTQUFVQyxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUN2QixJQUFJLENBQUNKLEtBQUs7UUFFVkksU0FBU0Q7SUFDWDtBQUNGO0FBRUEsTUFBTUUseUJBQXlCckI7SUFDN0IsWUFBYWlCLE1BQU0sQ0FBRTtRQUNuQixLQUFLLENBQUM7WUFBRUYsYUFBYTtRQUFLO1FBQzFCLElBQUksQ0FBQ0gsUUFBUSxHQUFHSztJQUNsQjtJQUVBRCxRQUFTO1FBQ1AsSUFBSSxDQUFDSixRQUFRO0lBQ2Y7SUFF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Q1osTUFBTSxFQUFFbUIsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNwQixJQUFJLENBQUNaLE9BQU8sR0FBRztRQUNmbkIsS0FBS3lDLE9BQU8sQ0FBQ1YsS0FBS25CO0lBQ3BCO0FBQ0Y7QUFFQSxTQUFTOEMsU0FBVXhDLElBQUksRUFBRUMsT0FBTztJQUM5QixJQUFJO1FBQ0YsTUFBTXdDLGtCQUFrQixJQUFJMUMsZ0JBQWdCQyxNQUFNQztRQUNsRCxJQUFJLENBQUN5QyxRQUFRLENBQUM7WUFBRSxHQUFHMUMsSUFBSTtZQUFFaUIsTUFBTXdCLGdCQUFnQjlCLEdBQUc7UUFBQyxHQUFHOEI7UUFDdEQsT0FBT0EsZ0JBQWdCNUIsR0FBRztJQUM1QixFQUFFLE9BQU9uQixLQUFLO1FBQ1osT0FBTyxJQUFJakIsY0FBYzhDLE9BQU8sQ0FBQzdCO0lBQ25DO0FBQ0Y7QUFFQWlELE9BQU9DLE9BQU8sR0FBR0oiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktcGlwZWxpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUmVhZGFibGUsXG4gIER1cGxleCxcbiAgUGFzc1Rocm91Z2hcbn0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuY29uc3Qga1Jlc3VtZSA9IFN5bWJvbCgncmVzdW1lJylcblxuY2xhc3MgUGlwZWxpbmVSZXF1ZXN0IGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoeyBhdXRvRGVzdHJveTogdHJ1ZSB9KVxuXG4gICAgdGhpc1trUmVzdW1lXSA9IG51bGxcbiAgfVxuXG4gIF9yZWFkICgpIHtcbiAgICBjb25zdCB7IFtrUmVzdW1lXTogcmVzdW1lIH0gPSB0aGlzXG5cbiAgICBpZiAocmVzdW1lKSB7XG4gICAgICB0aGlzW2tSZXN1bWVdID0gbnVsbFxuICAgICAgcmVzdW1lKClcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3JlYWQoKVxuXG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG59XG5cbmNsYXNzIFBpcGVsaW5lUmVzcG9uc2UgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChyZXN1bWUpIHtcbiAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pXG4gICAgdGhpc1trUmVzdW1lXSA9IHJlc3VtZVxuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIHRoaXNba1Jlc3VtZV0oKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWVyciAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG59XG5cbmNsYXNzIFBpcGVsaW5lSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoYW5kbGVyJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfUElQRUxJTkUnKVxuXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbFxuXG4gICAgdGhpcy5yZXEgPSBuZXcgUGlwZWxpbmVSZXF1ZXN0KCkub24oJ2Vycm9yJywgdXRpbC5ub3ApXG5cbiAgICB0aGlzLnJldCA9IG5ldyBEdXBsZXgoe1xuICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiBvcHRzLm9iamVjdE1vZGUsXG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIHJlYWQ6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBib2R5IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKGJvZHk/LnJlc3VtZSkge1xuICAgICAgICAgIGJvZHkucmVzdW1lKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRlOiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcSB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChyZXEucHVzaChjaHVuaywgZW5jb2RpbmcpIHx8IHJlcS5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxW2tSZXN1bWVdID0gY2FsbGJhY2tcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IChlcnIsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYm9keSwgcmVxLCByZXMsIHJldCwgYWJvcnQgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIWVyciAmJiAhcmV0Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWJvcnQgJiYgZXJyKSB7XG4gICAgICAgICAgYWJvcnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcSwgZXJyKVxuICAgICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG5cbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgIH0pLm9uKCdwcmVmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlcSB9ID0gdGhpc1xuXG4gICAgICAvLyBOb2RlIDwgMTUgZG9lcyBub3QgY2FsbCBfZmluYWwgaW4gc2FtZSB0aWNrLlxuICAgICAgcmVxLnB1c2gobnVsbClcbiAgICB9KVxuXG4gICAgdGhpcy5yZXMgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcmV0LCByZXMgfSA9IHRoaXNcblxuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQoIXJlcywgJ3BpcGVsaW5lIGNhbm5vdCBiZSByZXRyaWVkJylcbiAgICBhc3NlcnQoIXJldC5kZXN0cm95ZWQpXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSkge1xuICAgIGNvbnN0IHsgb3BhcXVlLCBoYW5kbGVyLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5yZXMgPSBuZXcgUGlwZWxpbmVSZXNwb25zZShyZXN1bWUpXG5cbiAgICBsZXQgYm9keVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmhhbmRsZXIgPSBudWxsXG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgICAgYm9keSA9IHRoaXMucnVuSW5Bc3luY1Njb3BlKGhhbmRsZXIsIG51bGwsIHtcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgb3BhcXVlLFxuICAgICAgICBib2R5OiB0aGlzLnJlcyxcbiAgICAgICAgY29udGV4dFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMucmVzLm9uKCdlcnJvcicsIHV0aWwubm9wKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKCFib2R5IHx8IHR5cGVvZiBib2R5Lm9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoJ2V4cGVjdGVkIFJlYWRhYmxlJylcbiAgICB9XG5cbiAgICBib2R5XG4gICAgICAub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQsIGJvZHkgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIXJldC5wdXNoKGNodW5rKSAmJiBib2R5LnBhdXNlKSB7XG4gICAgICAgICAgYm9keS5wYXVzZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXQsIGVycilcbiAgICAgIH0pXG4gICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICByZXQucHVzaChudWxsKVxuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kocmV0LCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmV0dXJuIHJlcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuICAgIHJlcy5wdXNoKG51bGwpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuICAgIHRoaXMuaGFuZGxlciA9IG51bGxcbiAgICB1dGlsLmRlc3Ryb3kocmV0LCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUgKG9wdHMsIGhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwaXBlbGluZUhhbmRsZXIgPSBuZXcgUGlwZWxpbmVIYW5kbGVyKG9wdHMsIGhhbmRsZXIpXG4gICAgdGhpcy5kaXNwYXRjaCh7IC4uLm9wdHMsIGJvZHk6IHBpcGVsaW5lSGFuZGxlci5yZXEgfSwgcGlwZWxpbmVIYW5kbGVyKVxuICAgIHJldHVybiBwaXBlbGluZUhhbmRsZXIucmV0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2goKS5kZXN0cm95KGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lXG4iXSwibmFtZXMiOlsiUmVhZGFibGUiLCJEdXBsZXgiLCJQYXNzVGhyb3VnaCIsInJlcXVpcmUiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsInV0aWwiLCJBc3luY1Jlc291cmNlIiwiYWRkU2lnbmFsIiwicmVtb3ZlU2lnbmFsIiwiYXNzZXJ0Iiwia1Jlc3VtZSIsIlN5bWJvbCIsIlBpcGVsaW5lUmVxdWVzdCIsImF1dG9EZXN0cm95IiwiX3JlYWQiLCJyZXN1bWUiLCJfZGVzdHJveSIsImVyciIsImNhbGxiYWNrIiwiUGlwZWxpbmVSZXNwb25zZSIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsIlBpcGVsaW5lSGFuZGxlciIsIm9wdHMiLCJoYW5kbGVyIiwic2lnbmFsIiwibWV0aG9kIiwib3BhcXVlIiwib25JbmZvIiwicmVzcG9uc2VIZWFkZXJzIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJjb250ZXh0IiwicmVxIiwibm9wIiwicmV0IiwicmVhZGFibGVPYmplY3RNb2RlIiwib2JqZWN0TW9kZSIsInJlYWQiLCJib2R5Iiwid3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwicHVzaCIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJyZXMiLCJvbkNvbm5lY3QiLCJyZWFzb24iLCJvbkhlYWRlcnMiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJydW5JbkFzeW5jU2NvcGUiLCJwYXVzZSIsImVuZGVkIiwib25EYXRhIiwib25Db21wbGV0ZSIsInRyYWlsZXJzIiwib25FcnJvciIsInBpcGVsaW5lIiwicGlwZWxpbmVIYW5kbGVyIiwiZGlzcGF0Y2giLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { Readable } = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/undici/lib/api/readable.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nclass RequestHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== 'object') {\n            throw new InvalidArgumentError('invalid opts');\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;\n        try {\n            if (typeof callback !== 'function') {\n                throw new InvalidArgumentError('invalid callback');\n            }\n            if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n                throw new InvalidArgumentError('invalid highWaterMark');\n            }\n            if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n                throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n            }\n            if (method === 'CONNECT') {\n                throw new InvalidArgumentError('invalid method');\n            }\n            if (onInfo && typeof onInfo !== 'function') {\n                throw new InvalidArgumentError('invalid onInfo callback');\n            }\n            super('UNDICI_REQUEST');\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on('error', util.nop), err);\n            }\n            throw err;\n        }\n        this.method = method;\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.body = body;\n        this.trailers = {};\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError;\n        this.highWaterMark = highWaterMark;\n        this.signal = signal;\n        this.reason = null;\n        this.removeAbortListener = null;\n        if (util.isStream(body)) {\n            body.on('error', (err)=>{\n                this.onError(err);\n            });\n        }\n        if (this.signal) {\n            if (this.signal.aborted) {\n                this.reason = this.signal.reason ?? new RequestAbortedError();\n            } else {\n                this.removeAbortListener = util.addAbortListener(this.signal, ()=>{\n                    this.reason = this.signal.reason ?? new RequestAbortedError();\n                    if (this.res) {\n                        util.destroy(this.res, this.reason);\n                    } else if (this.abort) {\n                        this.abort(this.reason);\n                    }\n                    if (this.removeAbortListener) {\n                        this.res?.off('close', this.removeAbortListener);\n                        this.removeAbortListener();\n                        this.removeAbortListener = null;\n                    }\n                });\n            }\n        }\n    }\n    onConnect(abort, context) {\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(this.callback);\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;\n        const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;\n        const contentType = parsedHeaders['content-type'];\n        const contentLength = parsedHeaders['content-length'];\n        const res = new Readable({\n            resume,\n            abort,\n            contentType,\n            contentLength: this.method !== 'HEAD' && contentLength ? Number(contentLength) : null,\n            highWaterMark\n        });\n        if (this.removeAbortListener) {\n            res.on('close', this.removeAbortListener);\n        }\n        this.callback = null;\n        this.res = res;\n        if (callback !== null) {\n            if (this.throwOnError && statusCode >= 400) {\n                this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                    callback,\n                    body: res,\n                    contentType,\n                    statusCode,\n                    statusMessage,\n                    headers\n                });\n            } else {\n                this.runInAsyncScope(callback, null, null, {\n                    statusCode,\n                    headers,\n                    trailers: this.trailers,\n                    opaque,\n                    body: res,\n                    context\n                });\n            }\n        }\n    }\n    onData(chunk) {\n        return this.res.push(chunk);\n    }\n    onComplete(trailers) {\n        util.parseHeaders(trailers, this.trailers);\n        this.res.push(null);\n    }\n    onError(err) {\n        const { res, callback, body, opaque } = this;\n        if (callback) {\n            // TODO: Does this need queueMicrotask?\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (res) {\n            this.res = null;\n            // Ensure all queued handlers are invoked before destroying res.\n            queueMicrotask(()=>{\n                util.destroy(res, err);\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n        if (this.removeAbortListener) {\n            res?.off('close', this.removeAbortListener);\n            this.removeAbortListener();\n            this.removeAbortListener = null;\n        }\n    }\n}\nfunction request(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            request.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new RequestHandler(opts, callback));\n    } catch (err) {\n        if (typeof callback !== 'function') {\n            throw err;\n        }\n        const opaque = opts?.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = request;\nmodule.exports.RequestHandler = RequestHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxtRUFBWTtBQUN6QyxNQUFNLEVBQUVFLG9CQUFvQixFQUFFQyxtQkFBbUIsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQyxzRUFBZ0I7QUFDOUUsTUFBTUksT0FBT0osbUJBQU9BLENBQUMsa0VBQWM7QUFDbkMsTUFBTSxFQUFFSywyQkFBMkIsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQywyREFBUTtBQUN4RCxNQUFNLEVBQUVNLGFBQWEsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQywwQ0FBa0I7QUFFcEQsTUFBTU8sdUJBQXVCRDtJQUMzQixZQUFhRSxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixJQUFJLENBQUNELFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSU4scUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFUSxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxZQUFZLEVBQUVDLGFBQWEsRUFBRSxHQUFHVDtRQUUvRixJQUFJO1lBQ0YsSUFBSSxPQUFPQyxhQUFhLFlBQVk7Z0JBQ2xDLE1BQU0sSUFBSVAscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSWUsaUJBQWtCLFFBQU9BLGtCQUFrQixZQUFZQSxnQkFBZ0IsSUFBSTtnQkFDN0UsTUFBTSxJQUFJZixxQkFBcUI7WUFDakM7WUFFQSxJQUFJUSxVQUFVLE9BQU9BLE9BQU9RLEVBQUUsS0FBSyxjQUFjLE9BQU9SLE9BQU9TLGdCQUFnQixLQUFLLFlBQVk7Z0JBQzlGLE1BQU0sSUFBSWpCLHFCQUFxQjtZQUNqQztZQUVBLElBQUlTLFdBQVcsV0FBVztnQkFDeEIsTUFBTSxJ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QUFPb0MsUUFBUUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLElBQUksQ0FBQ0MsUUFBUSxDQUFDcEQsTUFBTSxJQUFJRCxlQUFlQyxNQUFNQztJQUMvQyxFQUFFLE9BQU9XLEtBQUs7UUFDWixJQUFJLE9BQU9YLGFBQWEsWUFBWTtZQUNsQyxNQUFNVztRQUNSO1FBQ0EsTUFBTVIsU0FBU0osTUFBTUk7UUFDckJ3QyxlQUFlLElBQU0zQyxTQUFTVyxLQUFLO2dCQUFFUjtZQUFPO0lBQzlDO0FBQ0Y7QUFFQWlELE9BQU9DLE9BQU8sR0FBR1Q7QUFDakJRLDZCQUE2QixHQUFHdEQiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktcmVxdWVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcblxuY2xhc3MgUmVxdWVzdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMsIHRocm93T25FcnJvciwgaGlnaFdhdGVyTWFyayB9ID0gb3B0c1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgaWYgKGhpZ2hXYXRlck1hcmsgJiYgKHR5cGVvZiBoaWdoV2F0ZXJNYXJrICE9PSAnbnVtYmVyJyB8fCBoaWdoV2F0ZXJNYXJrIDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhpZ2hXYXRlck1hcmsnKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgICAgfVxuXG4gICAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIHN1cGVyKCdVTkRJQ0lfUkVRVUVTVCcpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keS5vbignZXJyb3InLCB1dGlsLm5vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnJlcyA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLnRyYWlsZXJzID0ge31cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbFxuICAgIHRoaXMudGhyb3dPbkVycm9yID0gdGhyb3dPbkVycm9yXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFya1xuICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsXG4gICAgdGhpcy5yZWFzb24gPSBudWxsXG4gICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyID0gbnVsbFxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIGJvZHkub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaWduYWwpIHtcbiAgICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHRoaXMucmVhc29uID0gdGhpcy5zaWduYWwucmVhc29uID8/IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lciA9IHV0aWwuYWRkQWJvcnRMaXN0ZW5lcih0aGlzLnNpZ25hbCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVhc29uID0gdGhpcy5zaWduYWwucmVhc29uID8/IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgICAgICBpZiAodGhpcy5yZXMpIHtcbiAgICAgICAgICAgIHV0aWwuZGVzdHJveSh0aGlzLnJlcywgdGhpcy5yZWFzb24pXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0KHRoaXMucmVhc29uKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzPy5vZmYoJ2Nsb3NlJywgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lciA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBhYm9ydCwgY29udGV4dCwgcmVzcG9uc2VIZWFkZXJzLCBoaWdoV2F0ZXJNYXJrIH0gPSB0aGlzXG5cbiAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIDogaGVhZGVyc1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcGFyc2VkSGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcGFyc2VkSGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuICAgIGNvbnN0IHJlcyA9IG5ldyBSZWFkYWJsZSh7XG4gICAgICByZXN1bWUsXG4gICAgICBhYm9ydCxcbiAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgY29udGVudExlbmd0aDogdGhpcy5tZXRob2QgIT09ICdIRUFEJyAmJiBjb250ZW50TGVuZ3RoXG4gICAgICAgID8gTnVtYmVyKGNvbnRlbnRMZW5ndGgpXG4gICAgICAgIDogbnVsbCxcbiAgICAgIGhpZ2hXYXRlck1hcmtcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcikge1xuICAgICAgcmVzLm9uKCdjbG9zZScsIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcilcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgIHRoaXMucmVzID0gcmVzXG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrLCBudWxsLFxuICAgICAgICAgIHsgY2FsbGJhY2ssIGJvZHk6IHJlcywgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICB0cmFpbGVyczogdGhpcy50cmFpbGVycyxcbiAgICAgICAgICBvcGFxdWUsXG4gICAgICAgICAgYm9keTogcmVzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzLnB1c2goY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHV0aWwucGFyc2VIZWFkZXJzKHRyYWlsZXJzLCB0aGlzLnRyYWlsZXJzKVxuICAgIHRoaXMucmVzLnB1c2gobnVsbClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmVzLCBjYWxsYmFjaywgYm9keSwgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IERvZXMgdGhpcyBuZWVkIHF1ZXVlTWljcm90YXNrP1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICAvLyBFbnN1cmUgYWxsIHF1ZXVlZCBoYW5kbGVycyBhcmUgaW52b2tlZCBiZWZvcmUgZGVzdHJveWluZyByZXMuXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcikge1xuICAgICAgcmVzPy5vZmYoJ2Nsb3NlJywgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKVxuICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKClcbiAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lciA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdCAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmRpc3BhdGNoKG9wdHMsIG5ldyBSZXF1ZXN0SGFuZGxlcihvcHRzLCBjYWxsYmFjaykpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzPy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdFxubW9kdWxlLmV4cG9ydHMuUmVxdWVzdEhhbmRsZXIgPSBSZXF1ZXN0SGFuZGxlclxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJSZWFkYWJsZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsInV0aWwiLCJnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2siLCJBc3luY1Jlc291cmNlIiwiUmVxdWVzdEhhbmRsZXIiLCJvcHRzIiwiY2FsbGJhY2siLCJzaWduYWwiLCJtZXRob2QiLCJvcGFxdWUiLCJib2R5Iiwib25JbmZvIiwicmVzcG9uc2VIZWFkZXJzIiwidGhyb3dPbkVycm9yIiwiaGlnaFdhdGVyTWFyayIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVyciIsImlzU3RyZWFtIiwiZGVzdHJveSIsIm5vcCIsInJlcyIsImFib3J0IiwidHJhaWxlcnMiLCJjb250ZXh0IiwicmVhc29uIiwicmVtb3ZlQWJvcnRMaXN0ZW5lciIsIm9uRXJyb3IiLCJhYm9ydGVkIiwiYWRkQWJvcnRMaXN0ZW5lciIsIm9mZiIsIm9uQ29ubmVjdCIsIm9uSGVhZGVycyIsInN0YXR1c0NvZGUiLCJyYXdIZWFkZXJzIiwicmVzdW1lIiwic3RhdHVzTWVzc2FnZSIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJwYXJzZWRIZWFkZXJzIiwiY29udGVudFR5cGUiLCJjb250ZW50TGVuZ3RoIiwiTnVtYmVyIiwicnVuSW5Bc3luY1Njb3BlIiwib25EYXRhIiwiY2h1bmsiLCJwdXNoIiwib25Db21wbGV0ZSIsInF1ZXVlTWljcm90YXNrIiwicmVxdWVzdCIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FsbCIsImRhdGEiLCJkaXNwYXRjaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { finished, PassThrough } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { InvalidArgumentError, InvalidReturnValueError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\");\nclass StreamHandler extends AsyncResource {\n    constructor(opts, factory, callback){\n        if (!opts || typeof opts !== 'object') {\n            throw new InvalidArgumentError('invalid opts');\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;\n        try {\n            if (typeof callback !== 'function') {\n                throw new InvalidArgumentError('invalid callback');\n            }\n            if (typeof factory !== 'function') {\n                throw new InvalidArgumentError('invalid factory');\n            }\n            if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n                throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n            }\n            if (method === 'CONNECT') {\n                throw new InvalidArgumentError('invalid method');\n            }\n            if (onInfo && typeof onInfo !== 'function') {\n                throw new InvalidArgumentError('invalid onInfo callback');\n            }\n            super('UNDICI_STREAM');\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on('error', util.nop), err);\n            }\n            throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.factory = factory;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.context = null;\n        this.trailers = null;\n        this.body = body;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError || false;\n        if (util.isStream(body)) {\n            body.on('error', (err)=>{\n                this.onError(err);\n            });\n        }\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(this.callback);\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { factory, opaque, context, callback, responseHeaders } = this;\n        const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.factory = null;\n        let res;\n        if (this.throwOnError && statusCode >= 400) {\n            const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;\n            const contentType = parsedHeaders['content-type'];\n            res = new PassThrough();\n            this.callback = null;\n            this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                callback,\n                body: res,\n                contentType,\n                statusCode,\n                statusMessage,\n                headers\n            });\n        } else {\n            if (factory === null) {\n                return;\n            }\n            res = this.runInAsyncScope(factory, null, {\n                statusCode,\n                headers,\n                opaque,\n                context\n            });\n            if (!res || typeof res.write !== 'function' || typeof res.end !== 'function' || typeof res.on !== 'function') {\n                throw new InvalidReturnValueError('expected Writable');\n            }\n            // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n            finished(res, {\n                readable: false\n            }, (err)=>{\n                const { callback, res, opaque, trailers, abort } = this;\n                this.res = null;\n                if (err || !res.readable) {\n                    util.destroy(res, err);\n                }\n                this.callback = null;\n                this.runInAsyncScope(callback, null, err || null, {\n                    opaque,\n                    trailers\n                });\n                if (err) {\n                    abort();\n                }\n            });\n        }\n        res.on('drain', resume);\n        this.res = res;\n        const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState?.needDrain;\n        return needDrain !== true;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res ? res.write(chunk) : true;\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        if (!res) {\n            return;\n        }\n        this.trailers = util.parseHeaders(trailers);\n        res.end();\n    }\n    onError(err) {\n        const { res, callback, opaque, body } = this;\n        removeSignal(this);\n        this.factory = null;\n        if (res) {\n            this.res = null;\n            util.destroy(res, err);\n        } else if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n    }\n}\nfunction stream(opts, factory, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            stream.call(this, opts, factory, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new StreamHandler(opts, factory, callback));\n    } catch (err) {\n        if (typeof callback !== 'function') {\n            throw err;\n        }\n        const opaque = opts?.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = stream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3BDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxXQUFXLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsZ0NBQWE7QUFDdkQsTUFBTSxFQUFFRyxvQkFBb0IsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR0osbUJBQU9BLENBQUMsc0VBQWdCO0FBQ2xGLE1BQU1LLE9BQU9MLG1CQUFPQSxDQUFDLGtFQUFjO0FBQ25DLE1BQU0sRUFBRU0sMkJBQTJCLEVBQUUsR0FBR04sbUJBQU9BLENBQUMsMkRBQVE7QUFDeEQsTUFBTSxFQUFFTyxhQUFhLEVBQUUsR0FBR1AsbUJBQU9BLENBQUMsMENBQWtCO0FBQ3BELE1BQU0sRUFBRVEsU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR1QsbUJBQU9BLENBQUMsMkVBQWdCO0FBRTVELE1BQU1VLHNCQUFzQkg7SUFDMUIsWUFBYUksSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsQ0FBRTtRQUNwQyxJQUFJLENBQUNGLFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSVIscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFVyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxZQUFZLEVBQUUsR0FBR1Q7UUFFaEYsSUFBSTtZQUNGLElBQUksT0FBT0UsYUFBYSxZQUFZO2dCQUNsQyxNQUFNLElBQUlWLHFCQUFxQjtZQUNqQztZQUVBLElBQUksT0FBT1MsWUFBWSxZQUFZO2dCQUNqQyxNQUFNLElBQUlULHFCQUFxQjtZQUNqQztZQUVBLElBQUlXLFVBQVUsT0FBT0EsT0FBT08sRUFBRSxLQUFLLGNBQWMsT0FBT1AsT0FBT1EsZ0JBQWdCLEtBQUssWUFBWTtnQkFDOUYsTUFBTSxJQUFJ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aXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxcYXBpLXN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBmaW5pc2hlZCwgUGFzc1Rocm91Z2ggfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgU3RyZWFtSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBib2R5LCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycywgdGhyb3dPbkVycm9yIH0gPSBvcHRzXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGZhY3RvcnknKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgICAgfVxuXG4gICAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIHN1cGVyKCdVTkRJQ0lfU1RSRUFNJylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5Lm9uKCdlcnJvcicsIHV0aWwubm9wKSwgZXJyKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5yZXMgPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gICAgdGhpcy50cmFpbGVycyA9IG51bGxcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbFxuICAgIHRoaXMudGhyb3dPbkVycm9yID0gdGhyb3dPbkVycm9yIHx8IGZhbHNlXG5cbiAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgYm9keS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmNhbGxiYWNrKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCB7IGZhY3RvcnksIG9wYXF1ZSwgY29udGV4dCwgY2FsbGJhY2ssIHJlc3BvbnNlSGVhZGVycyB9ID0gdGhpc1xuXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5mYWN0b3J5ID0gbnVsbFxuXG4gICAgbGV0IHJlc1xuXG4gICAgaWYgKHRoaXMudGhyb3dPbkVycm9yICYmIHN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIDogaGVhZGVyc1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBwYXJzZWRIZWFkZXJzWydjb250ZW50LXR5cGUnXVxuICAgICAgcmVzID0gbmV3IFBhc3NUaHJvdWdoKClcblxuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjaywgbnVsbCxcbiAgICAgICAgeyBjYWxsYmFjaywgYm9keTogcmVzLCBjb250ZW50VHlwZSwgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycyB9XG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmYWN0b3J5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZXMgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShmYWN0b3J5LCBudWxsLCB7XG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG9wYXF1ZSxcbiAgICAgICAgY29udGV4dFxuICAgICAgfSlcblxuICAgICAgaWYgKFxuICAgICAgICAhcmVzIHx8XG4gICAgICAgIHR5cGVvZiByZXMud3JpdGUgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIHJlcy5lbmQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIHJlcy5vbiAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcignZXhwZWN0ZWQgV3JpdGFibGUnKVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBBdm9pZCBmaW5pc2hlZC4gSXQgcmVnaXN0ZXJzIGFuIHVubmVjZXNzYXJ5IGFtb3VudCBvZiBsaXN0ZW5lcnMuXG4gICAgICBmaW5pc2hlZChyZXMsIHsgcmVhZGFibGU6IGZhbHNlIH0sIChlcnIpID0+IHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgcmVzLCBvcGFxdWUsIHRyYWlsZXJzLCBhYm9ydCB9ID0gdGhpc1xuXG4gICAgICAgIHRoaXMucmVzID0gbnVsbFxuICAgICAgICBpZiAoZXJyIHx8ICFyZXMucmVhZGFibGUpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyIHx8IG51bGwsIHsgb3BhcXVlLCB0cmFpbGVycyB9KVxuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBhYm9ydCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmVzLm9uKCdkcmFpbicsIHJlc3VtZSlcblxuICAgIHRoaXMucmVzID0gcmVzXG5cbiAgICBjb25zdCBuZWVkRHJhaW4gPSByZXMud3JpdGFibGVOZWVkRHJhaW4gIT09IHVuZGVmaW5lZFxuICAgICAgPyByZXMud3JpdGFibGVOZWVkRHJhaW5cbiAgICAgIDogcmVzLl93cml0YWJsZVN0YXRlPy5uZWVkRHJhaW5cblxuICAgIHJldHVybiBuZWVkRHJhaW4gIT09IHRydWVcbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuXG4gICAgcmV0dXJuIHJlcyA/IHJlcy53cml0ZShjaHVuaykgOiB0cnVlXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmICghcmVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRyYWlsZXJzID0gdXRpbC5wYXJzZUhlYWRlcnModHJhaWxlcnMpXG5cbiAgICByZXMuZW5kKClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmVzLCBjYWxsYmFjaywgb3BhcXVlLCBib2R5IH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuZmFjdG9yeSA9IG51bGxcblxuICAgIGlmIChyZXMpIHtcbiAgICAgIHRoaXMucmVzID0gbnVsbFxuICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChib2R5KSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJlYW0gKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHN0cmVhbS5jYWxsKHRoaXMsIG9wdHMsIGZhY3RvcnksIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmRpc3BhdGNoKG9wdHMsIG5ldyBTdHJlYW1IYW5kbGVyKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJlYW1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiZmluaXNoZWQiLCJQYXNzVGhyb3VnaCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiSW52YWxpZFJldHVyblZhbHVlRXJyb3IiLCJ1dGlsIiwiZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIiwiQXN5bmNSZXNvdXJjZSIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsIlN0cmVhbUhhbmRsZXIiLCJvcHRzIiwiZmFjdG9yeSIsImNhbGxiYWNrIiwic2lnbmFsIiwibWV0aG9kIiwib3BhcXVlIiwiYm9keSIsIm9uSW5mbyIsInJlc3BvbnNlSGVhZGVycyIsInRocm93T25FcnJvciIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVyciIsImlzU3RyZWFtIiwiZGVzdHJveSIsIm5vcCIsInJlcyIsImFib3J0IiwiY29udGV4dCIsInRyYWlsZXJzIiwib25FcnJvciIsIm9uQ29ubmVjdCIsInJlYXNvbiIsIm9uSGVhZGVycyIsInN0YXR1c0NvZGUiLCJyYXdIZWFkZXJzIiwicmVzdW1lIiwic3RhdHVzTWVzc2FnZSIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJwYXJzZWRIZWFkZXJzIiwiY29udGVudFR5cGUiLCJydW5JbkFzeW5jU2NvcGUiLCJ3cml0ZSIsImVuZCIsInJlYWRhYmxlIiwibmVlZERyYWluIiwid3JpdGFibGVOZWVkRHJhaW4iLCJ1bmRlZmluZWQiLCJfd3JpdGFibGVTdGF0ZSIsIm9uRGF0YSIsImNodW5rIiwib25Db21wbGV0ZSIsInF1ZXVlTWljcm90YXNrIiwic3RyZWFtIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsIiwiZGF0YSIsImRpc3BhdGNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nclass UpgradeHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== 'object') {\n            throw new InvalidArgumentError('invalid opts');\n        }\n        if (typeof callback !== 'function') {\n            throw new InvalidArgumentError('invalid callback');\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n            throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n        }\n        super('UNDICI_UPGRADE');\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.abort = null;\n        this.context = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(this.callback);\n        this.abort = abort;\n        this.context = null;\n    }\n    onHeaders() {\n        throw new SocketError('bad upgrade', null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        assert.strictEqual(statusCode, 101);\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction upgrade(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            upgrade.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const upgradeHandler = new UpgradeHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: opts.method || 'GET',\n            upgrade: opts.protocol || 'Websocket'\n        }, upgradeHandler);\n    } catch (err) {\n        if (typeof callback !== 'function') {\n            throw err;\n        }\n        const opaque = opts?.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = upgrade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG9CQUFvQixFQUFFQyxXQUFXLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsc0VBQWdCO0FBQ3RFLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDLDBDQUFrQjtBQUNwRCxNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQyxrRUFBYztBQUNuQyxNQUFNLEVBQUVHLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDLDJFQUFnQjtBQUM1RCxNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUVwQyxNQUFNTSx1QkFBdUJMO0lBQzNCLFlBQWFNLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJVCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9VLGFBQWEsWUFBWTtZQUNsQyxNQUFNLElBQUlWLHFCQUFxQjtRQUNqQztRQUVBLE1BQU0sRUFBRVcsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHSjtRQUU1QyxJQUFJRSxVQUFVLE9BQU9BLE9BQU9HLEVBQUUsS0FBSyxjQUFjLE9BQU9ILE9BQU9JLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJZixxQkFBcUI7UUFDakM7UUFFQSxLQUFLLENBQUM7UUFFTixJQUFJLENBQUNhLGVBQWUsR0FBR0EsbUJBQW1CO1FBQzFDLElBQUksQ0FBQ0QsTUFBTSxHQUFHQSxVQUFVO1FBQ3hCLElBQUksQ0FBQ0YsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNNLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBRWZaLFVBQVUsSUFBSSxFQUFFTTtJQUNsQjtJQUVBTyxVQUFXRixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUN6QixJQUFJLElBQUksQ0FBQ0UsTUFBTSxFQUFFO1lBQ2ZILE1BQU0sSUFBSSxDQUFDRyxNQUFNO1lBQ2pCO1FBQ0Y7UUFFQVosT0FBTyxJQUFJLENBQUNHLFFBQVE7UUFFcEIsSUFBSSxDQUFDTSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDakI7SUFFQUcsWUFBYTtRQUNYLE1BQU0sSUFBSW5CLFlBQVksZUFBZTtJQUN2QztJQUVBb0IsVUFBV0MsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLE1BQU0sRUFBRTtRQUN6QyxNQUFNLEVBQUVkLFFBQVEsRUFBRUUsTUFBTSxFQUFFSyxPQUFPLEVBQUUsR0FBRyxJQUFJO1FBRTFDVixPQUFPa0IsV0FBVyxDQUFDSCxZQUFZO1FBRS9CaEIsYUFBYSxJQUFJO1FBRWpCLElBQUksQ0FBQ0ksUUFBUSxHQUFHO1FBQ2hCLE1BQU1nQixVQUFVLElBQUksQ0FBQ2IsZUFBZSxLQUFLLFFBQVFULEtBQUt1QixlQUFlLENBQUNKLGNBQWNuQixLQUFLd0IsWUFBWSxDQUFDTDtRQUN0RyxJQUFJLENBQUNNLGVBQWUsQ0FBQ25CLFVBQVUsTUFBTSxNQUFNO1lBQ3pDZ0I7WUFDQUY7WUFDQVo7WUFDQUs7UUFDRjtJQUNGO0lBRUFhLFFBQVNDLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRXJCLFFBQVEsRUFBRUUsTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUVqQ04sYUFBYSxJQUFJO1FBRWpCLElBQUlJLFVBQVU7WUFDWixJQUFJLENBQUNBLFFBQVEsR0FBRztZQUNoQnNCLGVBQWU7Z0JBQ2IsSUFBSSxDQUFDSCxlQUFlLENBQUNuQixVQUFVLE1BQU1xQixLQUFLO29CQUFFbkI7Z0JBQU87WUFDckQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTcUIsUUFBU3hCLElBQUksRUFBRUMsUUFBUTtJQUM5QixJQUFJQSxhQUFhd0IsV0FBVztRQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JKLFFBQVFLLElBQUksQ0FBQyxJQUFJLEVBQUU3QixNQUFNLENBQUNzQixLQUFLUTtnQkFDN0IsT0FBT1IsTUFBTU0sT0FBT04sT0FBT0ssUUFBUUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU1DLGlCQUFpQixJQUFJaEMsZUFBZUMsTUFBTUM7UUFDaEQsSUFBSSxDQUFDK0IsUUFBUSxDQUFDO1lBQ1osR0FBR2hDLElBQUk7WUFDUGlDLFFBQVFqQyxLQUFLaUMsTUFBTSxJQUFJO1lBQ3ZCVCxTQUFTeEIsS0FBS2tDLFFBQVEsSUFBSTtRQUM1QixHQUFHSDtJQUNMLEVBQUUsT0FBT1QsS0FBSztRQUNaLElBQUksT0FBT3JCLGFBQWEsWUFBWTtZQUNsQyxNQUFNcUI7UUFDUjtRQUNBLE1BQU1uQixTQUFTSCxNQUFNRztRQUNyQm9CLGVBQWUsSUFBTXRCLFNBQVNxQixLQUFLO2dCQUFFbkI7WUFBTztJQUM5QztBQUNGO0FBRUFnQyxPQUFPQyxPQUFPLEdBQUdaIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxcYXBpLXVwZ3JhZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbmNsYXNzIFVwZ3JhZGVIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBvcGFxdWUsIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfVVBHUkFERScpXG5cbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY2FsbGJhY2spXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gIH1cblxuICBvbkhlYWRlcnMgKCkge1xuICAgIHRocm93IG5ldyBTb2NrZXRFcnJvcignYmFkIHVwZ3JhZGUnLCBudWxsKVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIGFzc2VydC5zdHJpY3RFcXVhbChzdGF0dXNDb2RlLCAxMDEpXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHNvY2tldCxcbiAgICAgIG9wYXF1ZSxcbiAgICAgIGNvbnRleHRcbiAgICB9KVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGUgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHVwZ3JhZGUuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdXBncmFkZUhhbmRsZXIgPSBuZXcgVXBncmFkZUhhbmRsZXIob3B0cywgY2FsbGJhY2spXG4gICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgIHVwZ3JhZGU6IG9wdHMucHJvdG9jb2wgfHwgJ1dlYnNvY2tldCdcbiAgICB9LCB1cGdyYWRlSGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGdyYWRlXG4iXSwibmFtZXMiOlsiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJTb2NrZXRFcnJvciIsInJlcXVpcmUiLCJBc3luY1Jlc291cmNlIiwidXRpbCIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsImFzc2VydCIsIlVwZ3JhZGVIYW5kbGVyIiwib3B0cyIsImNhbGxiYWNrIiwic2lnbmFsIiwib3BhcXVlIiwicmVzcG9uc2VIZWFkZXJzIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJjb250ZXh0Iiwib25Db25uZWN0IiwicmVhc29uIiwib25IZWFkZXJzIiwib25VcGdyYWRlIiwic3RhdHVzQ29kZSIsInJhd0hlYWRlcnMiLCJzb2NrZXQiLCJzdHJpY3RFcXVhbCIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJydW5JbkFzeW5jU2NvcGUiLCJvbkVycm9yIiwiZXJyIiwicXVldWVNaWNyb3Rhc2siLCJ1cGdyYWRlIiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsIiwiZGF0YSIsInVwZ3JhZGVIYW5kbGVyIiwiZGlzcGF0Y2giLCJtZXRob2QiLCJwcm90b2NvbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(ssr)/./node_modules/undici/lib/api/api-request.js\");\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(ssr)/./node_modules/undici/lib/api/api-stream.js\");\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(ssr)/./node_modules/undici/lib/api/api-pipeline.js\");\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(ssr)/./node_modules/undici/lib/api/api-upgrade.js\");\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(ssr)/./node_modules/undici/lib/api/api-connect.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsdUhBQWlEO0FBQ2pEQSxvSEFBK0M7QUFDL0NBLDBIQUFtRDtBQUNuREEsdUhBQWlEO0FBQ2pEQSx1SEFBaUQiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMucmVxdWVzdCA9IHJlcXVpcmUoJy4vYXBpLXJlcXVlc3QnKVxubW9kdWxlLmV4cG9ydHMuc3RyZWFtID0gcmVxdWlyZSgnLi9hcGktc3RyZWFtJylcbm1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9hcGktcGlwZWxpbmUnKVxubW9kdWxlLmV4cG9ydHMudXBncmFkZSA9IHJlcXVpcmUoJy4vYXBpLXVwZ3JhZGUnKVxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IHJlcXVpcmUoJy4vYXBpLWNvbm5lY3QnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1ZXN0IiwicmVxdWlyZSIsInN0cmVhbSIsInBpcGVsaW5lIiwidXBncmFkZSIsImNvbm5lY3QiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Ported from https://github.com/nodejs/undici/pull/907\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst kConsume = Symbol('kConsume');\nconst kReading = Symbol('kReading');\nconst kBody = Symbol('kBody');\nconst kAbort = Symbol('kAbort');\nconst kContentType = Symbol('kContentType');\nconst kContentLength = Symbol('kContentLength');\nconst noop = ()=>{};\nclass BodyReadable extends Readable {\n    constructor({ resume, abort, contentType = '', contentLength, highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n     }){\n        super({\n            autoDestroy: true,\n            read: resume,\n            highWaterMark\n        });\n        this._readableState.dataEmitted = false;\n        this[kAbort] = abort;\n        this[kConsume] = null;\n        this[kBody] = null;\n        this[kContentType] = contentType;\n        this[kContentLength] = contentLength;\n        // Is stream being consumed through Readable API?\n        // This is an optimization so that we avoid checking\n        // for 'data' and 'readable' listeners in the hot path\n        // inside push().\n        this[kReading] = false;\n    }\n    destroy(err) {\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        if (err) {\n            this[kAbort]();\n        }\n        return super.destroy(err);\n    }\n    _destroy(err, callback) {\n        // Workaround for Node \"bug\". If the stream is destroyed in same\n        // tick as it is created, then a user who is waiting for a\n        // promise (i.e micro tick) for installing a 'error' listener will\n        // never get a chance and will always encounter an unhandled exception.\n        if (!this[kReading]) {\n            setImmediate(()=>{\n                callback(err);\n            });\n        } else {\n            callback(err);\n        }\n    }\n    on(ev, ...args) {\n        if (ev === 'data' || ev === 'readable') {\n            this[kReading] = true;\n        }\n        return super.on(ev, ...args);\n    }\n    addListener(ev, ...args) {\n        return this.on(ev, ...args);\n    }\n    off(ev, ...args) {\n        const ret = super.off(ev, ...args);\n        if (ev === 'data' || ev === 'readable') {\n            this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;\n        }\n        return ret;\n    }\n    removeListener(ev, ...args) {\n        return this.off(ev, ...args);\n    }\n    push(chunk) {\n        if (this[kConsume] && chunk !== null) {\n            consumePush(this[kConsume], chunk);\n            return this[kReading] ? super.push(chunk) : true;\n        }\n        return super.push(chunk);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-text\n    async text() {\n        return consume(this, 'text');\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-json\n    async json() {\n        return consume(this, 'json');\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-blob\n    async blob() {\n        return consume(this, 'blob');\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n    async arrayBuffer() {\n        return consume(this, 'arrayBuffer');\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-formdata\n    async formData() {\n        // TODO: Implement.\n        throw new NotSupportedError();\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-bodyused\n    get bodyUsed() {\n        return util.isDisturbed(this);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-body\n    get body() {\n        if (!this[kBody]) {\n            this[kBody] = ReadableStreamFrom(this);\n            if (this[kConsume]) {\n                // TODO: Is this the best way to force a lock?\n                this[kBody].getReader(); // Ensure stream is locked.\n                assert(this[kBody].locked);\n            }\n        }\n        return this[kBody];\n    }\n    async dump(opts) {\n        let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024;\n        const signal = opts?.signal;\n        if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n            throw new InvalidArgumentError('signal must be an AbortSignal');\n        }\n        signal?.throwIfAborted();\n        if (this._readableState.closeEmitted) {\n            return null;\n        }\n        return await new Promise((resolve, reject)=>{\n            if (this[kContentLength] > limit) {\n                this.destroy(new AbortError());\n            }\n            const onAbort = ()=>{\n                this.destroy(signal.reason ?? new AbortError());\n            };\n            signal?.addEventListener('abort', onAbort);\n            this.on('close', function() {\n                signal?.removeEventListener('abort', onAbort);\n                if (signal?.aborted) {\n                    reject(signal.reason ?? new AbortError());\n                } else {\n                    resolve(null);\n                }\n            }).on('error', noop).on('data', function(chunk) {\n                limit -= chunk.length;\n                if (limit <= 0) {\n                    this.destroy();\n                }\n            }).resume();\n        });\n    }\n}\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n    // Consume is an implicit lock.\n    return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n    return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n    assert(!stream[kConsume]);\n    return new Promise((resolve, reject)=>{\n        if (isUnusable(stream)) {\n            const rState = stream._readableState;\n            if (rState.destroyed && rState.closeEmitted === false) {\n                stream.on('error', (err)=>{\n                    reject(err);\n                }).on('close', ()=>{\n                    reject(new TypeError('unusable'));\n                });\n            } else {\n                reject(rState.errored ?? new TypeError('unusable'));\n            }\n        } else {\n            queueMicrotask(()=>{\n                stream[kConsume] = {\n                    type,\n                    stream,\n                    resolve,\n                    reject,\n                    length: 0,\n                    body: []\n                };\n                stream.on('error', function(err) {\n                    consumeFinish(this[kConsume], err);\n                }).on('close', function() {\n                    if (this[kConsume].body !== null) {\n                        consumeFinish(this[kConsume], new RequestAbortedError());\n                    }\n                });\n                consumeStart(stream[kConsume]);\n            });\n        }\n    });\n}\nfunction consumeStart(consume) {\n    if (consume.body === null) {\n        return;\n    }\n    const { _readableState: state } = consume.stream;\n    if (state.bufferIndex) {\n        const start = state.bufferIndex;\n        const end = state.buffer.length;\n        for(let n = start; n < end; n++){\n            consumePush(consume, state.buffer[n]);\n        }\n    } else {\n        for (const chunk of state.buffer){\n            consumePush(consume, chunk);\n        }\n    }\n    if (state.endEmitted) {\n        consumeEnd(this[kConsume]);\n    } else {\n        consume.stream.on('end', function() {\n            consumeEnd(this[kConsume]);\n        });\n    }\n    consume.stream.resume();\n    while(consume.stream.read() != null){\n    // Loop\n    }\n}\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n */ function chunksDecode(chunks, length) {\n    if (chunks.length === 0 || length === 0) {\n        return '';\n    }\n    const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);\n    const bufferLength = buffer.length;\n    // Skip BOM.\n    const start = bufferLength > 2 && buffer[0] === 0xef && buffer[1] === 0xbb && buffer[2] === 0xbf ? 3 : 0;\n    return buffer.utf8Slice(start, bufferLength);\n}\nfunction consumeEnd(consume) {\n    const { type, body, resolve, stream, length } = consume;\n    try {\n        if (type === 'text') {\n            resolve(chunksDecode(body, length));\n        } else if (type === 'json') {\n            resolve(JSON.parse(chunksDecode(body, length)));\n        } else if (type === 'arrayBuffer') {\n            const dst = new Uint8Array(length);\n            let pos = 0;\n            for (const buf of body){\n                dst.set(buf, pos);\n                pos += buf.byteLength;\n            }\n            resolve(dst.buffer);\n        } else if (type === 'blob') {\n            resolve(new Blob(body, {\n                type: stream[kContentType]\n            }));\n        }\n        consumeFinish(consume);\n    } catch (err) {\n        stream.destroy(err);\n    }\n}\nfunction consumePush(consume, chunk) {\n    consume.length += chunk.length;\n    consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n    if (consume.body === null) {\n        return;\n    }\n    if (err) {\n        consume.reject(err);\n    } else {\n        consume.resolve();\n    }\n    consume.type = null;\n    consume.stream = null;\n    consume.resolve = null;\n    consume.reject = null;\n    consume.length = 0;\n    consume.body = null;\n}\nmodule.exports = {\n    Readable: BodyReadable,\n    chunksDecode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsd0RBQXdEO0FBRXhEO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDcEMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0QsbUJBQU9BLENBQUMsZ0NBQWE7QUFDMUMsTUFBTSxFQUFFRSxtQkFBbUIsRUFBRUMsaUJBQWlCLEVBQUVDLG9CQUFvQixFQUFFQyxVQUFVLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMsc0VBQWdCO0FBQzdHLE1BQU1NLE9BQU9OLG1CQUFPQSxDQUFDLGtFQUFjO0FBQ25DLE1BQU0sRUFBRU8sa0JBQWtCLEVBQUUsR0FBR1AsbUJBQU9BLENBQUMsa0VBQWM7QUFFckQsTUFBTVEsV0FBV0MsT0FBTztBQUN4QixNQUFNQyxXQUFXRCxPQUFPO0FBQ3hCLE1BQU1FLFFBQVFGLE9BQU87QUFDckIsTUFBTUcsU0FBU0gsT0FBTztBQUN0QixNQUFNSSxlQUFlSixPQUFPO0FBQzVCLE1BQU1LLGlCQUFpQkwsT0FBTztBQUU5QixNQUFNTSxPQUFPLEtBQU87QUFFcEIsTUFBTUMscUJBQXFCZjtJQUN6QixZQUFhLEVBQ1hnQixNQUFNLEVBQ05DLEtBQUssRUFDTEMsY0FBYyxFQUFFLEVBQ2hCQyxhQUFhLEVBQ2JDLGdCQUFnQixLQUFLLEtBQUssNkJBQTZCO0lBQTlCLEVBQzFCLENBQUU7UUFDRCxLQUFLLENBQUM7WUFDSkMsYUFBYTtZQUNiQyxNQUFNTjtZQUNOSTtRQUNGO1FBRUEsSUFBSSxDQUFDRyxjQUFjLENBQUNDLFdBQVcsR0FBRztRQUVsQyxJQUFJLENBQUNiLE9BQU8sR0FBR007UUFDZixJQUFJLENBQUNWLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNHLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0UsYUFBYSxHQUFHTTtRQUNyQixJQUFJLENBQUNMLGVBQWUsR0FBR007UUFFdkIsaURBQWlEO1FBQ2pELG9E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RUEsU0FBU3dDLGNBQWVyQyxPQUFPLEVBQUVqQixHQUFHO0lBQ2xDLElBQUlpQixRQUFRTyxJQUFJLEtBQUssTUFBTTtRQUN6QjtJQUNGO0lBRUEsSUFBSXhCLEtBQUs7UUFDUGlCLFFBQVFvQixNQUFNLENBQUNyQztJQUNqQixPQUFPO1FBQ0xpQixRQUFRbUIsT0FBTztJQUNqQjtJQUVBbkIsUUFBUStCLElBQUksR0FBRztJQUNmL0IsUUFBUThCLE1BQU0sR0FBRztJQUNqQjlCLFFBQVFtQixPQUFPLEdBQUc7SUFDbEJuQixRQUFRb0IsTUFBTSxHQUFHO0lBQ2pCcEIsUUFBUTBCLE1BQU0sR0FBRztJQUNqQjFCLFFBQVFPLElBQUksR0FBRztBQUNqQjtBQUVBc0QsT0FBT0MsT0FBTyxHQUFHO0lBQUV6RyxVQUFVZTtJQUFjMEU7QUFBYSIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXHJlYWRhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvOTA3XG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IsIE5vdFN1cHBvcnRlZEVycm9yLCBJbnZhbGlkQXJndW1lbnRFcnJvciwgQWJvcnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlYWRhYmxlU3RyZWFtRnJvbSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuY29uc3Qga0NvbnN1bWUgPSBTeW1ib2woJ2tDb25zdW1lJylcbmNvbnN0IGtSZWFkaW5nID0gU3ltYm9sKCdrUmVhZGluZycpXG5jb25zdCBrQm9keSA9IFN5bWJvbCgna0JvZHknKVxuY29uc3Qga0Fib3J0ID0gU3ltYm9sKCdrQWJvcnQnKVxuY29uc3Qga0NvbnRlbnRUeXBlID0gU3ltYm9sKCdrQ29udGVudFR5cGUnKVxuY29uc3Qga0NvbnRlbnRMZW5ndGggPSBTeW1ib2woJ2tDb250ZW50TGVuZ3RoJylcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNsYXNzIEJvZHlSZWFkYWJsZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHtcbiAgICByZXN1bWUsXG4gICAgYWJvcnQsXG4gICAgY29udGVudFR5cGUgPSAnJyxcbiAgICBjb250ZW50TGVuZ3RoLFxuICAgIGhpZ2hXYXRlck1hcmsgPSA2NCAqIDEwMjQgLy8gU2FtZSBhcyBub2RlanMgZnMgc3RyZWFtcy5cbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgcmVhZDogcmVzdW1lLFxuICAgICAgaGlnaFdhdGVyTWFya1xuICAgIH0pXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkID0gZmFsc2VcblxuICAgIHRoaXNba0Fib3J0XSA9IGFib3J0XG4gICAgdGhpc1trQ29uc3VtZV0gPSBudWxsXG4gICAgdGhpc1trQm9keV0gPSBudWxsXG4gICAgdGhpc1trQ29udGVudFR5cGVdID0gY29udGVudFR5cGVcbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IGNvbnRlbnRMZW5ndGhcblxuICAgIC8vIElzIHN0cmVhbSBiZWluZyBjb25zdW1lZCB0aHJvdWdoIFJlYWRhYmxlIEFQST9cbiAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB0aGF0IHdlIGF2b2lkIGNoZWNraW5nXG4gICAgLy8gZm9yICdkYXRhJyBhbmQgJ3JlYWRhYmxlJyBsaXN0ZW5lcnMgaW4gdGhlIGhvdCBwYXRoXG4gICAgLy8gaW5zaWRlIHB1c2goKS5cbiAgICB0aGlzW2tSZWFkaW5nXSA9IGZhbHNlXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBpZiAoIWVyciAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKGVycikge1xuICAgICAgdGhpc1trQWJvcnRdKClcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuZGVzdHJveShlcnIpXG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIC8vIFdvcmthcm91bmQgZm9yIE5vZGUgXCJidWdcIi4gSWYgdGhlIHN0cmVhbSBpcyBkZXN0cm95ZWQgaW4gc2FtZVxuICAgIC8vIHRpY2sgYXMgaXQgaXMgY3JlYXRlZCwgdGhlbiBhIHVzZXIgd2hvIGlzIHdhaXRpbmcgZm9yIGFcbiAgICAvLyBwcm9taXNlIChpLmUgbWljcm8gdGljaykgZm9yIGluc3RhbGxpbmcgYSAnZXJyb3InIGxpc3RlbmVyIHdpbGxcbiAgICAvLyBuZXZlciBnZXQgYSBjaGFuY2UgYW5kIHdpbGwgYWx3YXlzIGVuY291bnRlciBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgIGlmICghdGhpc1trUmVhZGluZ10pIHtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICB9XG4gIH1cblxuICBvbiAoZXYsIC4uLmFyZ3MpIHtcbiAgICBpZiAoZXYgPT09ICdkYXRhJyB8fCBldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpc1trUmVhZGluZ10gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5vbihldiwgLi4uYXJncylcbiAgfVxuXG4gIGFkZExpc3RlbmVyIChldiwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCAuLi5hcmdzKVxuICB9XG5cbiAgb2ZmIChldiwgLi4uYXJncykge1xuICAgIGNvbnN0IHJldCA9IHN1cGVyLm9mZihldiwgLi4uYXJncylcbiAgICBpZiAoZXYgPT09ICdkYXRhJyB8fCBldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpc1trUmVhZGluZ10gPSAoXG4gICAgICAgIHRoaXMubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCB8fFxuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVyIChldiwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLm9mZihldiwgLi4uYXJncylcbiAgfVxuXG4gIHB1c2ggKGNodW5rKSB7XG4gICAgaWYgKHRoaXNba0NvbnN1bWVdICYmIGNodW5rICE9PSBudWxsKSB7XG4gICAgICBjb25zdW1lUHVzaCh0aGlzW2tDb25zdW1lXSwgY2h1bmspXG4gICAgICByZXR1cm4gdGhpc1trUmVhZGluZ10gPyBzdXBlci5wdXNoKGNodW5rKSA6IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnB1c2goY2h1bmspXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktdGV4dFxuICBhc3luYyB0ZXh0ICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAndGV4dCcpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktanNvblxuICBhc3luYyBqc29uICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnanNvbicpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYmxvYlxuICBhc3luYyBibG9iICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnYmxvYicpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYXJyYXlidWZmZXJcbiAgYXN5bmMgYXJyYXlCdWZmZXIgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdhcnJheUJ1ZmZlcicpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktZm9ybWRhdGFcbiAgYXN5bmMgZm9ybURhdGEgKCkge1xuICAgIC8vIFRPRE86IEltcGxlbWVudC5cbiAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJvZHl1c2VkXG4gIGdldCBib2R5VXNlZCAoKSB7XG4gICAgcmV0dXJuIHV0aWwuaXNEaXN0dXJiZWQodGhpcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ib2R5XG4gIGdldCBib2R5ICgpIHtcbiAgICBpZiAoIXRoaXNba0JvZHldKSB7XG4gICAgICB0aGlzW2tCb2R5XSA9IFJlYWRhYmxlU3RyZWFtRnJvbSh0aGlzKVxuICAgICAgaWYgKHRoaXNba0NvbnN1bWVdKSB7XG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgdGhlIGJlc3Qgd2F5IHRvIGZvcmNlIGEgbG9jaz9cbiAgICAgICAgdGhpc1trQm9keV0uZ2V0UmVhZGVyKCkgLy8gRW5zdXJlIHN0cmVhbSBpcyBsb2NrZWQuXG4gICAgICAgIGFzc2VydCh0aGlzW2tCb2R5XS5sb2NrZWQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzW2tCb2R5XVxuICB9XG5cbiAgYXN5bmMgZHVtcCAob3B0cykge1xuICAgIGxldCBsaW1pdCA9IE51bWJlci5pc0Zpbml0ZShvcHRzPy5saW1pdCkgPyBvcHRzLmxpbWl0IDogMTI4ICogMTAyNFxuICAgIGNvbnN0IHNpZ25hbCA9IG9wdHM/LnNpZ25hbFxuXG4gICAgaWYgKHNpZ25hbCAhPSBudWxsICYmICh0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBBYm9ydFNpZ25hbCcpXG4gICAgfVxuXG4gICAgc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpXG5cbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5jbG9zZUVtaXR0ZWQpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzW2tDb250ZW50TGVuZ3RoXSA+IGxpbWl0KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShuZXcgQWJvcnRFcnJvcigpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koc2lnbmFsLnJlYXNvbiA/PyBuZXcgQWJvcnRFcnJvcigpKVxuICAgICAgfVxuICAgICAgc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpXG5cbiAgICAgIHRoaXNcbiAgICAgICAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzaWduYWw/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydClcbiAgICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbiA/PyBuZXcgQWJvcnRFcnJvcigpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgbm9vcClcbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgbGltaXQgLT0gY2h1bmsubGVuZ3RoXG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKClcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWRhYmxlc3RyZWFtLWxvY2tlZFxuZnVuY3Rpb24gaXNMb2NrZWQgKHNlbGYpIHtcbiAgLy8gQ29uc3VtZSBpcyBhbiBpbXBsaWNpdCBsb2NrLlxuICByZXR1cm4gKHNlbGZba0JvZHldICYmIHNlbGZba0JvZHldLmxvY2tlZCA9PT0gdHJ1ZSkgfHwgc2VsZltrQ29uc3VtZV1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHktdW51c2FibGVcbmZ1bmN0aW9uIGlzVW51c2FibGUgKHNlbGYpIHtcbiAgcmV0dXJuIHV0aWwuaXNEaXN0dXJiZWQoc2VsZikgfHwgaXNMb2NrZWQoc2VsZilcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29uc3VtZSAoc3RyZWFtLCB0eXBlKSB7XG4gIGFzc2VydCghc3RyZWFtW2tDb25zdW1lXSlcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChpc1VudXNhYmxlKHN0cmVhbSkpIHtcbiAgICAgIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICAgICAgaWYgKHJTdGF0ZS5kZXN0cm95ZWQgJiYgclN0YXRlLmNsb3NlRW1pdHRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyZWFtXG4gICAgICAgICAgLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCd1bnVzYWJsZScpKVxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoclN0YXRlLmVycm9yZWQgPz8gbmV3IFR5cGVFcnJvcigndW51c2FibGUnKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBzdHJlYW1ba0NvbnN1bWVdID0ge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICBib2R5OiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtXG4gICAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN1bWVGaW5pc2godGhpc1trQ29uc3VtZV0sIGVycilcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpc1trQ29uc3VtZV0uYm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgY29uc3VtZVN0YXJ0KHN0cmVhbVtrQ29uc3VtZV0pXG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY29uc3VtZVN0YXJ0IChjb25zdW1lKSB7XG4gIGlmIChjb25zdW1lLmJvZHkgPT09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHsgX3JlYWRhYmxlU3RhdGU6IHN0YXRlIH0gPSBjb25zdW1lLnN0cmVhbVxuXG4gIGlmIChzdGF0ZS5idWZmZXJJbmRleCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGUuYnVmZmVySW5kZXhcbiAgICBjb25zdCBlbmQgPSBzdGF0ZS5idWZmZXIubGVuZ3RoXG4gICAgZm9yIChsZXQgbiA9IHN0YXJ0OyBuIDwgZW5kOyBuKyspIHtcbiAgICAgIGNvbnN1bWVQdXNoKGNvbnN1bWUsIHN0YXRlLmJ1ZmZlcltuXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBzdGF0ZS5idWZmZXIpIHtcbiAgICAgIGNvbnN1bWVQdXNoKGNvbnN1bWUsIGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgY29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdW1lLnN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSlcbiAgICB9KVxuICB9XG5cbiAgY29uc3VtZS5zdHJlYW0ucmVzdW1lKClcblxuICB3aGlsZSAoY29uc3VtZS5zdHJlYW0ucmVhZCgpICE9IG51bGwpIHtcbiAgICAvLyBMb29wXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBjaHVua3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY2h1bmtzRGVjb2RlIChjaHVua3MsIGxlbmd0aCkge1xuICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCB8fCBsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuICBjb25zdCBidWZmZXIgPSBjaHVua3MubGVuZ3RoID09PSAxID8gY2h1bmtzWzBdIDogQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aClcbiAgY29uc3QgYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aFxuXG4gIC8vIFNraXAgQk9NLlxuICBjb25zdCBzdGFydCA9XG4gICAgYnVmZmVyTGVuZ3RoID4gMiAmJlxuICAgIGJ1ZmZlclswXSA9PT0gMHhlZiAmJlxuICAgIGJ1ZmZlclsxXSA9PT0gMHhiYiAmJlxuICAgIGJ1ZmZlclsyXSA9PT0gMHhiZlxuICAgICAgPyAzXG4gICAgICA6IDBcbiAgcmV0dXJuIGJ1ZmZlci51dGY4U2xpY2Uoc3RhcnQsIGJ1ZmZlckxlbmd0aClcbn1cblxuZnVuY3Rpb24gY29uc3VtZUVuZCAoY29uc3VtZSkge1xuICBjb25zdCB7IHR5cGUsIGJvZHksIHJlc29sdmUsIHN0cmVhbSwgbGVuZ3RoIH0gPSBjb25zdW1lXG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXNvbHZlKGNodW5rc0RlY29kZShib2R5LCBsZW5ndGgpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICByZXNvbHZlKEpTT04ucGFyc2UoY2h1bmtzRGVjb2RlKGJvZHksIGxlbmd0aCkpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2FycmF5QnVmZmVyJykge1xuICAgICAgY29uc3QgZHN0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuXG4gICAgICBsZXQgcG9zID0gMFxuICAgICAgZm9yIChjb25zdCBidWYgb2YgYm9keSkge1xuICAgICAgICBkc3Quc2V0KGJ1ZiwgcG9zKVxuICAgICAgICBwb3MgKz0gYnVmLmJ5dGVMZW5ndGhcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShkc3QuYnVmZmVyKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICByZXNvbHZlKG5ldyBCbG9iKGJvZHksIHsgdHlwZTogc3RyZWFtW2tDb250ZW50VHlwZV0gfSkpXG4gICAgfVxuXG4gICAgY29uc3VtZUZpbmlzaChjb25zdW1lKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3VtZVB1c2ggKGNvbnN1bWUsIGNodW5rKSB7XG4gIGNvbnN1bWUubGVuZ3RoICs9IGNodW5rLmxlbmd0aFxuICBjb25zdW1lLmJvZHkucHVzaChjaHVuaylcbn1cblxuZnVuY3Rpb24gY29uc3VtZUZpbmlzaCAoY29uc3VtZSwgZXJyKSB7XG4gIGlmIChjb25zdW1lLmJvZHkgPT09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChlcnIpIHtcbiAgICBjb25zdW1lLnJlamVjdChlcnIpXG4gIH0gZWxzZSB7XG4gICAgY29uc3VtZS5yZXNvbHZlKClcbiAgfVxuXG4gIGNvbnN1bWUudHlwZSA9IG51bGxcbiAgY29uc3VtZS5zdHJlYW0gPSBudWxsXG4gIGNvbnN1bWUucmVzb2x2ZSA9IG51bGxcbiAgY29uc3VtZS5yZWplY3QgPSBudWxsXG4gIGNvbnN1bWUubGVuZ3RoID0gMFxuICBjb25zdW1lLmJvZHkgPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBSZWFkYWJsZTogQm9keVJlYWRhYmxlLCBjaHVua3NEZWNvZGUgfVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJSZWFkYWJsZSIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJOb3RTdXBwb3J0ZWRFcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiQWJvcnRFcnJvciIsInV0aWwiLCJSZWFkYWJsZVN0cmVhbUZyb20iLCJrQ29uc3VtZSIsIlN5bWJvbCIsImtSZWFkaW5nIiwia0JvZHkiLCJrQWJvcnQiLCJrQ29udGVudFR5cGUiLCJrQ29udGVudExlbmd0aCIsIm5vb3AiLCJCb2R5UmVhZGFibGUiLCJyZXN1bWUiLCJhYm9ydCIsImNvbnRlbnRUeXBlIiwiY29udGVudExlbmd0aCIsImhpZ2hXYXRlck1hcmsiLCJhdXRvRGVzdHJveSIsInJlYWQiLCJfcmVhZGFibGVTdGF0ZSIsImRhdGFFbWl0dGVkIiwiZGVzdHJveSIsImVyciIsImVuZEVtaXR0ZWQiLCJfZGVzdHJveSIsImNhbGxiYWNrIiwic2V0SW1tZWRpYXRlIiwib24iLCJldiIsImFyZ3MiLCJhZGRMaXN0ZW5lciIsIm9mZiIsInJldCIsImxpc3RlbmVyQ291bnQiLCJyZW1vdmVMaXN0ZW5lciIsInB1c2giLCJjaHVuayIsImNvbnN1bWVQdXNoIiwidGV4dCIsImNvbnN1bWUiLCJqc29uIiwiYmxvYiIsImFycmF5QnVmZmVyIiwiZm9ybURhdGEiLCJib2R5VXNlZCIsImlzRGlzdHVyYmVkIiwiYm9keSIsImdldFJlYWRlciIsImxvY2tlZCIsImR1bXAiLCJvcHRzIiwibGltaXQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInNpZ25hbCIsInRocm93SWZBYm9ydGVkIiwiY2xvc2VFbWl0dGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbkFib3J0IiwicmVhc29uIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhYm9ydGVkIiwibGVuZ3RoIiwiaXNMb2NrZWQiLCJzZWxmIiwiaXNVbnVzYWJsZSIsInN0cmVhbSIsInR5cGUiLCJyU3RhdGUiLCJkZXN0cm95ZWQiLCJUeXBlRXJyb3IiLCJlcnJvcmVkIiwicXVldWVNaWNyb3Rhc2siLCJjb25zdW1lRmluaXNoIiwiY29uc3VtZVN0YXJ0Iiwic3RhdGUiLCJidWZmZXJJbmRleCIsInN0YXJ0IiwiZW5kIiwiYnVmZmVyIiwibiIsImNvbnN1bWVFbmQiLCJjaHVua3NEZWNvZGUiLCJjaHVua3MiLCJCdWZmZXIiLCJjb25jYXQiLCJidWZmZXJMZW5ndGgiLCJ1dGY4U2xpY2UiLCJKU09OIiwicGFyc2UiLCJkc3QiLCJVaW50OEFycmF5IiwicG9zIiwiYnVmIiwic2V0IiwiYnl0ZUxlbmd0aCIsIkJsb2IiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/util.js":
/*!*********************************************!*\
  !*** ./node_modules/undici/lib/api/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { ResponseStatusCodeError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { chunksDecode } = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/undici/lib/api/readable.js\");\nconst CHUNK_LIMIT = 128 * 1024;\nasync function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {\n    assert(body);\n    let chunks = [];\n    let length = 0;\n    try {\n        for await (const chunk of body){\n            chunks.push(chunk);\n            length += chunk.length;\n            if (length > CHUNK_LIMIT) {\n                chunks = [];\n                length = 0;\n                break;\n            }\n        }\n    } catch  {\n        chunks = [];\n        length = 0;\n    // Do nothing....\n    }\n    const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`;\n    if (statusCode === 204 || !contentType || !length) {\n        queueMicrotask(()=>callback(new ResponseStatusCodeError(message, statusCode, headers)));\n        return;\n    }\n    const stackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    let payload;\n    try {\n        if (isContentTypeApplicationJson(contentType)) {\n            payload = JSON.parse(chunksDecode(chunks, length));\n        } else if (isContentTypeText(contentType)) {\n            payload = chunksDecode(chunks, length);\n        }\n    } catch  {\n    // process in a callback to avoid throwing in the microtask queue\n    } finally{\n        Error.stackTraceLimit = stackTraceLimit;\n    }\n    queueMicrotask(()=>callback(new ResponseStatusCodeError(message, statusCode, headers, payload)));\n}\nconst isContentTypeApplicationJson = (contentType)=>{\n    return contentType.length > 15 && contentType[11] === '/' && contentType[0] === 'a' && contentType[1] === 'p' && contentType[2] === 'p' && contentType[3] === 'l' && contentType[4] === 'i' && contentType[5] === 'c' && contentType[6] === 'a' && contentType[7] === 't' && contentType[8] === 'i' && contentType[9] === 'o' && contentType[10] === 'n' && contentType[12] === 'j' && contentType[13] === 's' && contentType[14] === 'o' && contentType[15] === 'n';\n};\nconst isContentTypeText = (contentType)=>{\n    return contentType.length > 4 && contentType[4] === '/' && contentType[0] === 't' && contentType[1] === 'e' && contentType[2] === 'x' && contentType[3] === 't';\n};\nmodule.exports = {\n    getResolveErrorBodyCallback,\n    isContentTypeApplicationJson,\n    isContentTypeText\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvdXRpbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDcEMsTUFBTSxFQUNKQyx1QkFBdUIsRUFDeEIsR0FBR0QsbUJBQU9BLENBQUMsc0VBQWdCO0FBRTVCLE1BQU0sRUFBRUUsWUFBWSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDLG1FQUFZO0FBQzdDLE1BQU1HLGNBQWMsTUFBTTtBQUUxQixlQUFlQyw0QkFBNkIsRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxhQUFhLEVBQUVDLE9BQU8sRUFBRTtJQUM3R1gsT0FBT087SUFFUCxJQUFJSyxTQUFTLEVBQUU7SUFDZixJQUFJQyxTQUFTO0lBRWIsSUFBSTtRQUNGLFdBQVcsTUFBTUMsU0FBU1AsS0FBTTtZQUM5QkssT0FBT0csSUFBSSxDQUFDRDtZQUNaRCxVQUFVQyxNQUFNRCxNQUFNO1lBQ3RCLElBQUlBLFNBQVNULGFBQWE7Z0JBQ3hCUSxTQUFTLEVBQUU7Z0JBQ1hDLFNBQVM7Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0YsRUFBRSxPQUFNO1FBQ05ELFNBQVMsRUFBRTtRQUNYQyxTQUFTO0lBQ1QsaUJBQWlCO0lBQ25CO0lBRUEsTUFBTUcsVUFBVSxDQUFDLHFCQUFxQixFQUFFUCxhQUFhQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUVBLGVBQWUsR0FBRyxJQUFJO0lBRWhHLElBQUlELGVBQWUsT0FBTyxDQUFDRCxlQUFlLENBQUNLLFFBQVE7UUFDakRJLGVBQWUsSUFBTVgsU0FBUyxJQUFJSix3QkFBd0JjLFNBQVNQLFlBQVlFO1FBQy9FO0lBQ0Y7SUFFQSxNQUFNTyxrQkFBa0JDLE1BQU1ELGVBQWU7SUFDN0NDLE1BQU1ELGVBQWUsR0FBRztJQUN4QixJQUFJRTtJQUVKLElBQUk7UUFDRixJQUFJQyw2QkFBNkJiLGNBQWM7WUFDN0NZLFVBQVVFLEtBQUtDLEtBQUssQ0FBQ3BCLGFBQWFTLFFBQVFDO1FBQzVDLE9BQU8sSUFBSVcsa0JBQWtCaEIsY0FBYztZQUN6Q1ksVUFBVWpCLGFBQWFTLFFBQVFDO1FBQ2pDO0lBQ0YsRUFBRSxPQUFNO0lBQ04saUVBQWlFO0lBQ25FLFNBQVU7UUFDUk0sTUFBTUQsZUFBZSxHQUFHQTtJQUMxQjtJQUNBRCxlQUFlLElBQU1YLFNBQVMsSUFBSUosd0JBQXdCYyxTQUFTUCxZQUFZRSxTQUFTUztBQUMxRjtBQUVBLE1BQU1DLCtCQUErQixDQUFDYjtJQUNwQyxPQUNFQSxZQUFZSyxNQUFNLEdBQUcsTUFDckJMLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxHQUFHLEtBQUs7QUFFeEI7QUFFQSxNQUFNZ0Isb0JBQW9CLENBQUNoQjtJQUN6QixPQUNFQSxZQUFZSyxNQUFNLEdBQUcsS0FDckJMLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUs7QUFFdkI7QUFFQWlCLE9BQU9DLE9BQU8sR0FBRztJQUNmckI7SUFDQWdCO0lBQ0FHO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHtcbiAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNvbnN0IHsgY2h1bmtzRGVjb2RlIH0gPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbmNvbnN0IENIVU5LX0xJTUlUID0gMTI4ICogMTAyNFxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgKHsgY2FsbGJhY2ssIGJvZHksIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH0pIHtcbiAgYXNzZXJ0KGJvZHkpXG5cbiAgbGV0IGNodW5rcyA9IFtdXG4gIGxldCBsZW5ndGggPSAwXG5cbiAgdHJ5IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgICAgbGVuZ3RoICs9IGNodW5rLmxlbmd0aFxuICAgICAgaWYgKGxlbmd0aCA+IENIVU5LX0xJTUlUKSB7XG4gICAgICAgIGNodW5rcyA9IFtdXG4gICAgICAgIGxlbmd0aCA9IDBcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIGNodW5rcyA9IFtdXG4gICAgbGVuZ3RoID0gMFxuICAgIC8vIERvIG5vdGhpbmcuLi4uXG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0gYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWBcblxuICBpZiAoc3RhdHVzQ29kZSA9PT0gMjA0IHx8ICFjb250ZW50VHlwZSB8fCAhbGVuZ3RoKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGhlYWRlcnMpKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0YWNrVHJhY2VMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdFxuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwXG4gIGxldCBwYXlsb2FkXG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNDb250ZW50VHlwZUFwcGxpY2F0aW9uSnNvbihjb250ZW50VHlwZSkpIHtcbiAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rc0RlY29kZShjaHVua3MsIGxlbmd0aCkpXG4gICAgfSBlbHNlIGlmIChpc0NvbnRlbnRUeXBlVGV4dChjb250ZW50VHlwZSkpIHtcbiAgICAgIHBheWxvYWQgPSBjaHVua3NEZWNvZGUoY2h1bmtzLCBsZW5ndGgpXG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBwcm9jZXNzIGluIGEgY2FsbGJhY2sgdG8gYXZvaWQgdGhyb3dpbmcgaW4gdGhlIG1pY3JvdGFzayBxdWV1ZVxuICB9IGZpbmFsbHkge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHN0YWNrVHJhY2VMaW1pdFxuICB9XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBwYXlsb2FkKSkpXG59XG5cbmNvbnN0IGlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24gPSAoY29udGVudFR5cGUpID0+IHtcbiAgcmV0dXJuIChcbiAgICBjb250ZW50VHlwZS5sZW5ndGggPiAxNSAmJlxuICAgIGNvbnRlbnRUeXBlWzExXSA9PT0gJy8nICYmXG4gICAgY29udGVudFR5cGVbMF0gPT09ICdhJyAmJlxuICAgIGNvbnRlbnRUeXBlWzFdID09PSAncCcgJiZcbiAgICBjb250ZW50VHlwZVsyXSA9PT0gJ3AnICYmXG4gICAgY29udGVudFR5cGVbM10gPT09ICdsJyAmJlxuICAgIGNvbnRlbnRUeXBlWzRdID09PSAnaScgJiZcbiAgICBjb250ZW50VHlwZVs1XSA9PT0gJ2MnICYmXG4gICAgY29udGVudFR5cGVbNl0gPT09ICdhJyAmJlxuICAgIGNvbnRlbnRUeXBlWzddID09PSAndCcgJiZcbiAgICBjb250ZW50VHlwZVs4XSA9PT0gJ2knICYmXG4gICAgY29udGVudFR5cGVbOV0gPT09ICdvJyAmJlxuICAgIGNvbnRlbnRUeXBlWzEwXSA9PT0gJ24nICYmXG4gICAgY29udGVudFR5cGVbMTJdID09PSAnaicgJiZcbiAgICBjb250ZW50VHlwZVsxM10gPT09ICdzJyAmJlxuICAgIGNvbnRlbnRUeXBlWzE0XSA9PT0gJ28nICYmXG4gICAgY29udGVudFR5cGVbMTVdID09PSAnbidcbiAgKVxufVxuXG5jb25zdCBpc0NvbnRlbnRUeXBlVGV4dCA9IChjb250ZW50VHlwZSkgPT4ge1xuICByZXR1cm4gKFxuICAgIGNvbnRlbnRUeXBlLmxlbmd0aCA+IDQgJiZcbiAgICBjb250ZW50VHlwZVs0XSA9PT0gJy8nICYmXG4gICAgY29udGVudFR5cGVbMF0gPT09ICd0JyAmJlxuICAgIGNvbnRlbnRUeXBlWzFdID09PSAnZScgJiZcbiAgICBjb250ZW50VHlwZVsyXSA9PT0gJ3gnICYmXG4gICAgY29udGVudFR5cGVbM10gPT09ICd0J1xuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssXG4gIGlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24sXG4gIGlzQ29udGVudFR5cGVUZXh0XG59XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIlJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIiwiY2h1bmtzRGVjb2RlIiwiQ0hVTktfTElNSVQiLCJnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2siLCJjYWxsYmFjayIsImJvZHkiLCJjb250ZW50VHlwZSIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwiaGVhZGVycyIsImNodW5rcyIsImxlbmd0aCIsImNodW5rIiwicHVzaCIsIm1lc3NhZ2UiLCJxdWV1ZU1pY3JvdGFzayIsInN0YWNrVHJhY2VMaW1pdCIsIkVycm9yIiwicGF5bG9hZCIsImlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24iLCJKU09OIiwicGFyc2UiLCJpc0NvbnRlbnRUeXBlVGV4dCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst net = __webpack_require__(/*! node:net */ \"node:net\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nlet tls // include tls conditionally since it is not always available\n;\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\nlet SessionCache;\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {\n    SessionCache = class WeakSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n            this._sessionRegistry = new global.FinalizationRegistry((key)=>{\n                if (this._sessionCache.size < this._maxCachedSessions) {\n                    return;\n                }\n                const ref = this._sessionCache.get(key);\n                if (ref !== undefined && ref.deref() === undefined) {\n                    this._sessionCache.delete(key);\n                }\n            });\n        }\n        get(sessionKey) {\n            const ref = this._sessionCache.get(sessionKey);\n            return ref ? ref.deref() : null;\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            this._sessionCache.set(sessionKey, new WeakRef(session));\n            this._sessionRegistry.register(session, sessionKey);\n        }\n    };\n} else {\n    SessionCache = class SimpleSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n        }\n        get(sessionKey) {\n            return this._sessionCache.get(sessionKey);\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            if (this._sessionCache.size >= this._maxCachedSessions) {\n                // remove the oldest session\n                const { value: oldestKey } = this._sessionCache.keys().next();\n                this._sessionCache.delete(oldestKey);\n            }\n            this._sessionCache.set(sessionKey, session);\n        }\n    };\n}\nfunction buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n        throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n    }\n    const options = {\n        path: socketPath,\n        ...opts\n    };\n    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n    timeout = timeout == null ? 10e3 : timeout;\n    allowH2 = allowH2 != null ? allowH2 : false;\n    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n        let socket;\n        if (protocol === 'https:') {\n            if (!tls) {\n                tls = __webpack_require__(/*! node:tls */ \"node:tls\");\n            }\n            servername = servername || options.servername || util.getServerName(host) || null;\n            const sessionKey = servername || hostname;\n            const session = customSession || sessionCache.get(sessionKey) || null;\n            assert(sessionKey);\n            socket = tls.connect({\n                highWaterMark: 16384,\n                ...options,\n                servername,\n                session,\n                localAddress,\n                // TODO(HTTP/2): Add support for h2c\n                ALPNProtocols: allowH2 ? [\n                    'http/1.1',\n                    'h2'\n                ] : [\n                    'http/1.1'\n                ],\n                socket: httpSocket,\n                port: port || 443,\n                host: hostname\n            });\n            socket.on('session', function(session) {\n                // TODO (fix): Can a session become invalid once established? Don't think so?\n                sessionCache.set(sessionKey, session);\n            });\n        } else {\n            assert(!httpSocket, 'httpSocket can only be sent on TLS update');\n            socket = net.connect({\n                highWaterMark: 64 * 1024,\n                ...options,\n                localAddress,\n                port: port || 80,\n                host: hostname\n            });\n        }\n        // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n        if (options.keepAlive == null || options.keepAlive) {\n            const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n            socket.setKeepAlive(true, keepAliveInitialDelay);\n        }\n        const cancelTimeout = setupTimeout(()=>onConnectTimeout(socket), timeout);\n        socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function() {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(null, this);\n            }\n        }).on('error', function(err) {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(err);\n            }\n        });\n        return socket;\n    };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n    if (!timeout) {\n        return ()=>{};\n    }\n    let s1 = null;\n    let s2 = null;\n    const timeoutId = setTimeout(()=>{\n        // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(()=>{\n            if (process.platform === 'win32') {\n                // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n                s2 = setImmediate(()=>onConnectTimeout());\n            } else {\n                onConnectTimeout();\n            }\n        });\n    }, timeout);\n    return ()=>{\n        clearTimeout(timeoutId);\n        clearImmediate(s1);\n        clearImmediate(s2);\n    };\n}\nfunction onConnectTimeout(socket) {\n    let message = 'Connect Timeout Error';\n    if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n        message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')})`;\n    }\n    util.destroy(socket, new ConnectTimeoutError(message));\n}\nmodule.exports = buildConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxNQUFNQyxtQkFBT0EsQ0FBQywwQkFBVTtBQUM5QixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQyw0REFBUTtBQUM3QixNQUFNLEVBQUVHLG9CQUFvQixFQUFFQyxtQkFBbUIsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQyxnRUFBVTtBQUV4RSxJQUFJSyxJQUFJLDZEQUE2RDs7QUFFckUsbURBQW1EO0FBQ25ELHdEQUF3RDtBQUN4RCx1REFBdUQ7QUFDdkQscUJBQXFCO0FBRXJCLElBQUlDO0FBQ0osc0RBQXNEO0FBQ3RELHNFQUFzRTtBQUN0RSxJQUFJQyxPQUFPQyxvQkFBb0IsSUFBSSxDQUFFQyxDQUFBQSxRQUFRQyxHQUFHLENBQUNDLGdCQUFnQixJQUFJRixRQUFRQyxHQUFHLENBQUNFLFlBQVksR0FBRztJQUM5Rk4sZUFBZSxNQUFNTztRQUNuQixZQUFhQyxpQkFBaUIsQ0FBRTtZQUM5QixJQUFJLENBQUNDLGtCQUFrQixHQUFHRDtZQUMxQixJQUFJLENBQUNFLGFBQWEsR0FBRyxJQUFJQztZQUN6QixJQUFJLENBQUNDLGdCQUFnQixHQUFHLElBQUlYLE9BQU9DLG9CQUFvQixDQUFDLENBQUNXO2dCQUN2RCxJQUFJLElBQUksQ0FBQ0gsYUFBYSxDQUFDSSxJQUFJLEdBQUcsSUFBSSxDQUFDTCxrQkFBa0IsRUFBRTtvQkFDckQ7Z0JBQ0Y7Z0JBRUEsTUFBTU0sTUFBTSxJQUFJLENBQUNMLGFBQWEsQ0FBQ00sR0FBRyxDQUFDSDtnQkFDbkMsSUFBSUUsUUFBUUUsYUFBYUYsSUFBSUcsS0FBSyxPQUFPRCxXQUFXO29CQUNsRCxJQUFJLENBQUNQLGFBQWEsQ0FBQ1MsTUFBTSxDQUFDTjtnQkFDNUI7WUFDRjtRQUNGO1FBRUFHLElBQUtJLFVBQVUsRUFBRTtZQUNmLE1B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LGFBQWEsSUFBTVQ7WUFDMUIsT0FBTztnQkFDTEE7WUFDRjtRQUNGO0lBQ0YsR0FBRzNCO0lBQ0gsT0FBTztRQUNMc0MsYUFBYUo7UUFDYkssZUFBZVA7UUFDZk8sZUFBZU47SUFDakI7QUFDRjtBQUVBLFNBQVNOLGlCQUFrQlYsTUFBTTtJQUMvQixJQUFJdUIsVUFBVTtJQUNkLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ3pCLE9BQU8wQixrQ0FBa0MsR0FBRztRQUM1REgsV0FBVyxDQUFDLHVCQUF1QixFQUFFdkIsT0FBTzBCLGtDQUFrQyxDQUFDQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUY7SUFDQWpGLEtBQUtrRixPQUFPLENBQUM1QixRQUFRLElBQUlwRCxvQkFBb0IyRTtBQUMvQztBQUVBTSxPQUFPQyxPQUFPLEdBQUdsRCIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxjb25uZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIENvbm5lY3RUaW1lb3V0RXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxubGV0IHRscyAvLyBpbmNsdWRlIHRscyBjb25kaXRpb25hbGx5IHNpbmNlIGl0IGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlXG5cbi8vIFRPRE86IHNlc3Npb24gcmUtdXNlIGRvZXMgbm90IHdhaXQgZm9yIHRoZSBmaXJzdFxuLy8gY29ubmVjdGlvbiB0byByZXNvbHZlIHRoZSBzZXNzaW9uIGFuZCBtaWdodCB0aGVyZWZvcmVcbi8vIHJlc29sdmUgdGhlIHNhbWUgc2VydmVybmFtZSBtdWx0aXBsZSB0aW1lcyBldmVuIHdoZW5cbi8vIHJlLXVzZSBpcyBlbmFibGVkLlxuXG5sZXQgU2Vzc2lvbkNhY2hlXG4vLyBGSVhNRTogcmVtb3ZlIHdvcmthcm91bmQgd2hlbiB0aGUgTm9kZSBidWcgaXMgZml4ZWRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDhcbmlmIChnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgIShwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFIHx8IHByb2Nlc3MuZW52LlVORElDSV9OT19GRykpIHtcbiAgU2Vzc2lvbkNhY2hlID0gY2xhc3MgV2Vha1Nlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgIHRoaXMuX3Nlc3Npb25SZWdpc3RyeSA9IG5ldyBnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkoKGtleSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkNhY2hlLnNpemUgPCB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChrZXkpXG4gICAgICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCAmJiByZWYuZGVyZWYoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZ2V0IChzZXNzaW9uS2V5KSB7XG4gICAgICBjb25zdCByZWYgPSB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgICByZXR1cm4gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgbmV3IFdlYWtSZWYoc2Vzc2lvbikpXG4gICAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkucmVnaXN0ZXIoc2Vzc2lvbiwgc2Vzc2lvbktleSlcbiAgICB9XG4gIH1cbn0gZWxzZSB7XG4gIFNlc3Npb25DYWNoZSA9IGNsYXNzIFNpbXBsZVNlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICB9XG5cbiAgICBnZXQgKHNlc3Npb25LZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zZXNzaW9uQ2FjaGUuc2l6ZSA+PSB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAvLyByZW1vdmUgdGhlIG9sZGVzdCBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IG9sZGVzdEtleSB9ID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmtleXMoKS5uZXh0KClcbiAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShvbGRlc3RLZXkpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRDb25uZWN0b3IgKHsgYWxsb3dIMiwgbWF4Q2FjaGVkU2Vzc2lvbnMsIHNvY2tldFBhdGgsIHRpbWVvdXQsIHNlc3Npb246IGN1c3RvbVNlc3Npb24sIC4uLm9wdHMgfSkge1xuICBpZiAobWF4Q2FjaGVkU2Vzc2lvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4Q2FjaGVkU2Vzc2lvbnMpIHx8IG1heENhY2hlZFNlc3Npb25zIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENhY2hlZFNlc3Npb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHsgcGF0aDogc29ja2V0UGF0aCwgLi4ub3B0cyB9XG4gIGNvbnN0IHNlc3Npb25DYWNoZSA9IG5ldyBTZXNzaW9uQ2FjaGUobWF4Q2FjaGVkU2Vzc2lvbnMgPT0gbnVsbCA/IDEwMCA6IG1heENhY2hlZFNlc3Npb25zKVxuICB0aW1lb3V0ID0gdGltZW91dCA9PSBudWxsID8gMTBlMyA6IHRpbWVvdXRcbiAgYWxsb3dIMiA9IGFsbG93SDIgIT0gbnVsbCA/IGFsbG93SDIgOiBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdCAoeyBob3N0bmFtZSwgaG9zdCwgcHJvdG9jb2wsIHBvcnQsIHNlcnZlcm5hbWUsIGxvY2FsQWRkcmVzcywgaHR0cFNvY2tldCB9LCBjYWxsYmFjaykge1xuICAgIGxldCBzb2NrZXRcbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICBpZiAoIXRscykge1xuICAgICAgICB0bHMgPSByZXF1aXJlKCdub2RlOnRscycpXG4gICAgICB9XG4gICAgICBzZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBvcHRpb25zLnNlcnZlcm5hbWUgfHwgdXRpbC5nZXRTZXJ2ZXJOYW1lKGhvc3QpIHx8IG51bGxcblxuICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHNlcnZlcm5hbWUgfHwgaG9zdG5hbWVcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBjdXN0b21TZXNzaW9uIHx8IHNlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSkgfHwgbnVsbFxuXG4gICAgICBhc3NlcnQoc2Vzc2lvbktleSlcblxuICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAxNjM4NCwgLy8gVExTIGluIG5vZGUgY2FuJ3QgaGF2ZSBiaWdnZXIgSFdNIGFueXdheS4uLlxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzZXJ2ZXJuYW1lLFxuICAgICAgICBzZXNzaW9uLFxuICAgICAgICBsb2NhbEFkZHJlc3MsXG4gICAgICAgIC8vIFRPRE8oSFRUUC8yKTogQWRkIHN1cHBvcnQgZm9yIGgyY1xuICAgICAgICBBTFBOUHJvdG9jb2xzOiBhbGxvd0gyID8gWydodHRwLzEuMScsICdoMiddIDogWydodHRwLzEuMSddLFxuICAgICAgICBzb2NrZXQ6IGh0dHBTb2NrZXQsIC8vIHVwZ3JhZGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgcG9ydDogcG9ydCB8fCA0NDMsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXRcbiAgICAgICAgLm9uKCdzZXNzaW9uJywgZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBDYW4gYSBzZXNzaW9uIGJlY29tZSBpbnZhbGlkIG9uY2UgZXN0YWJsaXNoZWQ/IERvbid0IHRoaW5rIHNvP1xuICAgICAgICAgIHNlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCFodHRwU29ja2V0LCAnaHR0cFNvY2tldCBjYW4gb25seSBiZSBzZW50IG9uIFRMUyB1cGRhdGUnKVxuICAgICAgc29ja2V0ID0gbmV0LmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjQsIC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGxvY2FsQWRkcmVzcyxcbiAgICAgICAgcG9ydDogcG9ydCB8fCA4MCxcbiAgICAgICAgaG9zdDogaG9zdG5hbWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gU2V0IFRDUCBrZWVwIGFsaXZlIG9wdGlvbnMgb24gdGhlIHNvY2tldCBoZXJlIGluc3RlYWQgb2YgaW4gY29ubmVjdCgpIGZvciB0aGUgY2FzZSBvZiBhc3NpZ25pbmcgdGhlIHNvY2tldFxuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSA9PSBudWxsIHx8IG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICBjb25zdCBrZWVwQWxpdmVJbml0aWFsRGVsYXkgPSBvcHRpb25zLmtlZXBBbGl2ZUluaXRpYWxEZWxheSA9PT0gdW5kZWZpbmVkID8gNjBlMyA6IG9wdGlvbnMua2VlcEFsaXZlSW5pdGlhbERlbGF5XG4gICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIGtlZXBBbGl2ZUluaXRpYWxEZWxheSlcbiAgICB9XG5cbiAgICBjb25zdCBjYW5jZWxUaW1lb3V0ID0gc2V0dXBUaW1lb3V0KCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoc29ja2V0KSwgdGltZW91dClcblxuICAgIHNvY2tldFxuICAgICAgLnNldE5vRGVsYXkodHJ1ZSlcbiAgICAgIC5vbmNlKHByb3RvY29sID09PSAnaHR0cHM6JyA/ICdzZWN1cmVDb25uZWN0JyA6ICdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWxUaW1lb3V0KClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IobnVsbCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQoKVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICByZXR1cm4gc29ja2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBUaW1lb3V0IChvbkNvbm5lY3RUaW1lb3V0LCB0aW1lb3V0KSB7XG4gIGlmICghdGltZW91dCkge1xuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG5cbiAgbGV0IHMxID0gbnVsbFxuICBsZXQgczIgPSBudWxsXG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIHNldEltbWVkaWF0ZSBpcyBhZGRlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcmlvcml0aXplIHNvY2tldCBlcnJvciBldmVudHMgb3ZlciB0aW1lb3V0c1xuICAgIHMxID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIC8vIFdpbmRvd3MgbmVlZHMgYW4gZXh0cmEgc2V0SW1tZWRpYXRlIHByb2JhYmx5IGR1ZSB0byBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcyBpbiB0aGUgc29ja2V0IGxvZ2ljXG4gICAgICAgIHMyID0gc2V0SW1tZWRpYXRlKCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uQ29ubmVjdFRpbWVvdXQoKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIHRpbWVvdXQpXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICBjbGVhckltbWVkaWF0ZShzMSlcbiAgICBjbGVhckltbWVkaWF0ZShzMilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbm5lY3RUaW1lb3V0IChzb2NrZXQpIHtcbiAgbGV0IG1lc3NhZ2UgPSAnQ29ubmVjdCBUaW1lb3V0IEVycm9yJ1xuICBpZiAoQXJyYXkuaXNBcnJheShzb2NrZXQuYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRlZEFkZHJlc3NlcykpIHtcbiAgICBtZXNzYWdlICs9IGAgKGF0dGVtcHRlZCBhZGRyZXNzZXM6ICR7c29ja2V0LmF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0ZWRBZGRyZXNzZXMuam9pbignLCAnKX0pYFxuICB9XG4gIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBDb25uZWN0VGltZW91dEVycm9yKG1lc3NhZ2UpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQ29ubmVjdG9yXG4iXSwibmFtZXMiOlsibmV0IiwicmVxdWlyZSIsImFzc2VydCIsInV0aWwiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkNvbm5lY3RUaW1lb3V0RXJyb3IiLCJ0bHMiLCJTZXNzaW9uQ2FjaGUiLCJnbG9iYWwiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1Y4X0NPVkVSQUdFIiwiVU5ESUNJX05PX0ZHIiwiV2Vha1Nlc3Npb25DYWNoZSIsIm1heENhY2hlZFNlc3Npb25zIiwiX21heENhY2hlZFNlc3Npb25zIiwiX3Nlc3Npb25DYWNoZSIsIk1hcCIsIl9zZXNzaW9uUmVnaXN0cnkiLCJrZXkiLCJzaXplIiwicmVmIiwiZ2V0IiwidW5kZWZpbmVkIiwiZGVyZWYiLCJkZWxldGUiLCJzZXNzaW9uS2V5Iiwic2V0Iiwic2Vzc2lvbiIsIldlYWtSZWYiLCJyZWdpc3RlciIsIlNpbXBsZVNlc3Npb25DYWNoZSIsInZhbHVlIiwib2xkZXN0S2V5Iiwia2V5cyIsIm5leHQiLCJidWlsZENvbm5lY3RvciIsImFsbG93SDIiLCJzb2NrZXRQYXRoIiwidGltZW91dCIsImN1c3RvbVNlc3Npb24iLCJvcHRzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwib3B0aW9ucyIsInBhdGgiLCJzZXNzaW9uQ2FjaGUiLCJjb25uZWN0IiwiaG9zdG5hbWUiLCJob3N0IiwicHJvdG9jb2wiLCJwb3J0Iiwic2VydmVybmFtZSIsImxvY2FsQWRkcmVzcyIsImh0dHBTb2NrZXQiLCJjYWxsYmFjayIsInNvY2tldCIsImdldFNlcnZlck5hbWUiLCJoaWdoV2F0ZXJNYXJrIiwiQUxQTlByb3RvY29scyIsIm9uIiwia2VlcEFsaXZlIiwia2VlcEFsaXZlSW5pdGlhbERlbGF5Iiwic2V0S2VlcEFsaXZlIiwiY2FuY2VsVGltZW91dCIsInNldHVwVGltZW91dCIsIm9uQ29ubmVjdFRpbWVvdXQiLCJzZXROb0RlbGF5Iiwib25jZSIsImNiIiwiZXJyIiwiczEiLCJzMiIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJzZXRJbW1lZGlhdGUiLCJwbGF0Zm9ybSIsImNsZWFyVGltZW91dCIsImNsZWFySW1tZWRpYXRlIiwibWVzc2FnZSIsIkFycmF5IiwiaXNBcnJheSIsImF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0ZWRBZGRyZXNzZXMiLCJqb2luIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/core/constants.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n/** @type {Record<string, string | undefined>} */ const headerNameLowerCasedRecord = {};\n// https://developer.mozilla.org/docs/Web/HTTP/Headers\nconst wellknownHeaderNames = [\n    'Accept',\n    'Accept-Encoding',\n    'Accept-Language',\n    'Accept-Ranges',\n    'Access-Control-Allow-Credentials',\n    'Access-Control-Allow-Headers',\n    'Access-Control-Allow-Methods',\n    'Access-Control-Allow-Origin',\n    'Access-Control-Expose-Headers',\n    'Access-Control-Max-Age',\n    'Access-Control-Request-Headers',\n    'Access-Control-Request-Method',\n    'Age',\n    'Allow',\n    'Alt-Svc',\n    'Alt-Used',\n    'Authorization',\n    'Cache-Control',\n    'Clear-Site-Data',\n    'Connection',\n    'Content-Disposition',\n    'Content-Encoding',\n    'Content-Language',\n    'Content-Length',\n    'Content-Location',\n    'Content-Range',\n    'Content-Security-Policy',\n    'Content-Security-Policy-Report-Only',\n    'Content-Type',\n    'Cookie',\n    'Cross-Origin-Embedder-Policy',\n    'Cross-Origin-Opener-Policy',\n    'Cross-Origin-Resource-Policy',\n    'Date',\n    'Device-Memory',\n    'Downlink',\n    'ECT',\n    'ETag',\n    'Expect',\n    'Expect-CT',\n    'Expires',\n    'Forwarded',\n    'From',\n    'Host',\n    'If-Match',\n    'If-Modified-Since',\n    'If-None-Match',\n    'If-Range',\n    'If-Unmodified-Since',\n    'Keep-Alive',\n    'Last-Modified',\n    'Link',\n    'Location',\n    'Max-Forwards',\n    'Origin',\n    'Permissions-Policy',\n    'Pragma',\n    'Proxy-Authenticate',\n    'Proxy-Authorization',\n    'RTT',\n    'Range',\n    'Referer',\n    'Referrer-Policy',\n    'Refresh',\n    'Retry-After',\n    'Sec-WebSocket-Accept',\n    'Sec-WebSocket-Extensions',\n    'Sec-WebSocket-Key',\n    'Sec-WebSocket-Protocol',\n    'Sec-WebSocket-Version',\n    'Server',\n    'Server-Timing',\n    'Service-Worker-Allowed',\n    'Service-Worker-Navigation-Preload',\n    'Set-Cookie',\n    'SourceMap',\n    'Strict-Transport-Security',\n    'Supports-Loading-Mode',\n    'TE',\n    'Timing-Allow-Origin',\n    'Trailer',\n    'Transfer-Encoding',\n    'Upgrade',\n    'Upgrade-Insecure-Requests',\n    'User-Agent',\n    'Vary',\n    'Via',\n    'WWW-Authenticate',\n    'X-Content-Type-Options',\n    'X-DNS-Prefetch-Control',\n    'X-Frame-Options',\n    'X-Permitted-Cross-Domain-Policies',\n    'X-Powered-By',\n    'X-Requested-With',\n    'X-XSS-Protection'\n];\nfor(let i = 0; i < wellknownHeaderNames.length; ++i){\n    const key = wellknownHeaderNames[i];\n    const lowerCasedKey = key.toLowerCase();\n    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;\n}\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(headerNameLowerCasedRecord, null);\nmodule.exports = {\n    wellknownHeaderNames,\n    headerNameLowerCasedRecord\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLCtDQUErQyxHQUMvQyxNQUFNQSw2QkFBNkIsQ0FBQztBQUVwQyxzREFBc0Q7QUFDdEQsTUFBTUMsdUJBQXVCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxxQkFBcUJFLE1BQU0sRUFBRSxFQUFFRCxFQUFHO0lBQ3BELE1BQU1FLE1BQU1ILG9CQUFvQixDQUFDQyxFQUFFO0lBQ25DLE1BQU1HLGdCQUFnQkQsSUFBSUUsV0FBVztJQUNyQ04sMEJBQTBCLENBQUNJLElBQUksR0FBR0osMEJBQTBCLENBQUNLLGNBQWMsR0FDekVBO0FBQ0o7QUFFQSw2RkFBNkY7QUFDN0ZFLE9BQU9DLGNBQWMsQ0FBQ1IsNEJBQTRCO0FBRWxEUyxPQUFPQyxPQUFPLEdBQUc7SUFDZlQ7SUFDQUQ7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPn0gKi9cbmNvbnN0IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkID0ge31cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRUUC9IZWFkZXJzXG5jb25zdCB3ZWxsa25vd25IZWFkZXJOYW1lcyA9IFtcbiAgJ0FjY2VwdCcsXG4gICdBY2NlcHQtRW5jb2RpbmcnLFxuICAnQWNjZXB0LUxhbmd1YWdlJyxcbiAgJ0FjY2VwdC1SYW5nZXMnLFxuICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHMnLFxuICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycycsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbicsXG4gICdBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycycsXG4gICdBY2Nlc3MtQ29udHJvbC1NYXgtQWdlJyxcbiAgJ0FjY2Vzcy1Db250cm9sLVJlcXVlc3QtSGVhZGVycycsXG4gICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LU1ldGhvZCcsXG4gICdBZ2UnLFxuICAnQWxsb3cnLFxuICAnQWx0LVN2YycsXG4gICdBbHQtVXNlZCcsXG4gICdBdXRob3JpemF0aW9uJyxcbiAgJ0NhY2hlLUNvbnRyb2wnLFxuICAnQ2xlYXItU2l0ZS1EYXRhJyxcbiAgJ0Nvbm5lY3Rpb24nLFxuICAnQ29udGVudC1EaXNwb3NpdGlvbicsXG4gICdDb250ZW50LUVuY29kaW5nJyxcbiAgJ0NvbnRlbnQtTGFuZ3VhZ2UnLFxuICAnQ29udGVudC1MZW5ndGgnLFxuICAnQ29udGVudC1Mb2NhdGlvbicsXG4gICdDb250ZW50LVJhbmdlJyxcbiAgJ0NvbnRlbnQtU2VjdXJpdHktUG9saWN5JyxcbiAgJ0NvbnRlbnQtU2VjdXJpdHktUG9saWN5LVJlcG9ydC1Pbmx5JyxcbiAgJ0NvbnRlbnQtVHlwZScsXG4gICdDb29raWUnLFxuICAnQ3Jvc3MtT3JpZ2luLUVtYmVkZGVyLVBvbGljeScsXG4gICdDcm9zcy1PcmlnaW4tT3BlbmVyLVBvbGljeScsXG4gICdDcm9zcy1PcmlnaW4tUmVzb3VyY2UtUG9saWN5JyxcbiAgJ0RhdGUnLFxuICAnRGV2aWNlLU1lbW9yeScsXG4gICdEb3dubGluaycsXG4gICdFQ1QnLFxuICAnRVRhZycsXG4gICdFeHBlY3QnLFxuICAnRXhwZWN0LUNUJyxcbiAgJ0V4cGlyZXMnLFxuICAnRm9yd2FyZGVkJyxcbiAgJ0Zyb20nLFxuICAnSG9zdCcsXG4gICdJZi1NYXRjaCcsXG4gICdJZi1Nb2RpZmllZC1TaW5jZScsXG4gICdJZi1Ob25lLU1hdGNoJyxcbiAgJ0lmLVJhbmdlJyxcbiAgJ0lmLVVubW9kaWZpZWQtU2luY2UnLFxuICAnS2VlcC1BbGl2ZScsXG4gICdMYXN0LU1vZGlmaWVkJyxcbiAgJ0xpbmsnLFxuICAnTG9jYXRpb24nLFxuICAnTWF4LUZvcndhcmRzJyxcbiAgJ09yaWdpbicsXG4gICdQZXJtaXNzaW9ucy1Qb2xpY3knLFxuICAnUHJhZ21hJyxcbiAgJ1Byb3h5LUF1dGhlbnRpY2F0ZScsXG4gICdQcm94eS1BdXRob3JpemF0aW9uJyxcbiAgJ1JUVCcsXG4gICdSYW5nZScsXG4gICdSZWZlcmVyJyxcbiAgJ1JlZmVycmVyLVBvbGljeScsXG4gICdSZWZyZXNoJyxcbiAgJ1JldHJ5LUFmdGVyJyxcbiAgJ1NlYy1XZWJTb2NrZXQtQWNjZXB0JyxcbiAgJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycsXG4gICdTZWMtV2ViU29ja2V0LUtleScsXG4gICdTZWMtV2ViU29ja2V0LVByb3RvY29sJyxcbiAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbicsXG4gICdTZXJ2ZXInLFxuICAnU2VydmVyLVRpbWluZycsXG4gICdTZXJ2aWNlLVdvcmtlci1BbGxvd2VkJyxcbiAgJ1NlcnZpY2UtV29ya2VyLU5hdmlnYXRpb24tUHJlbG9hZCcsXG4gICdTZXQtQ29va2llJyxcbiAgJ1NvdXJjZU1hcCcsXG4gICdTdHJpY3QtVHJhbnNwb3J0LVNlY3VyaXR5JyxcbiAgJ1N1cHBvcnRzLUxvYWRpbmctTW9kZScsXG4gICdURScsXG4gICdUaW1pbmctQWxsb3ctT3JpZ2luJyxcbiAgJ1RyYWlsZXInLFxuICAnVHJhbnNmZXItRW5jb2RpbmcnLFxuICAnVXBncmFkZScsXG4gICdVcGdyYWRlLUluc2VjdXJlLVJlcXVlc3RzJyxcbiAgJ1VzZXItQWdlbnQnLFxuICAnVmFyeScsXG4gICdWaWEnLFxuICAnV1dXLUF1dGhlbnRpY2F0ZScsXG4gICdYLUNvbnRlbnQtVHlwZS1PcHRpb25zJyxcbiAgJ1gtRE5TLVByZWZldGNoLUNvbnRyb2wnLFxuICAnWC1GcmFtZS1PcHRpb25zJyxcbiAgJ1gtUGVybWl0dGVkLUNyb3NzLURvbWFpbi1Qb2xpY2llcycsXG4gICdYLVBvd2VyZWQtQnknLFxuICAnWC1SZXF1ZXN0ZWQtV2l0aCcsXG4gICdYLVhTUy1Qcm90ZWN0aW9uJ1xuXVxuXG5mb3IgKGxldCBpID0gMDsgaSA8IHdlbGxrbm93bkhlYWRlck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gIGNvbnN0IGtleSA9IHdlbGxrbm93bkhlYWRlck5hbWVzW2ldXG4gIGNvbnN0IGxvd2VyQ2FzZWRLZXkgPSBrZXkudG9Mb3dlckNhc2UoKVxuICBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtrZXldID0gaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRbbG93ZXJDYXNlZEtleV0gPVxuICAgIGxvd2VyQ2FzZWRLZXlcbn1cblxuLy8gTm90ZTogb2JqZWN0IHByb3RvdHlwZXMgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGJlIHJlZmVyZW5jZWQuIGUuZy4gYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQsIG51bGwpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3ZWxsa25vd25IZWFkZXJOYW1lcyxcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRcbn1cbiJdLCJuYW1lcyI6WyJoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCIsIndlbGxrbm93bkhlYWRlck5hbWVzIiwiaSIsImxlbmd0aCIsImtleSIsImxvd2VyQ2FzZWRLZXkiLCJ0b0xvd2VyQ2FzZSIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/diagnostics.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/core/diagnostics.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst diagnosticsChannel = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\");\nconst util = __webpack_require__(/*! node:util */ \"node:util\");\nconst undiciDebugLog = util.debuglog('undici');\nconst fetchDebuglog = util.debuglog('fetch');\nconst websocketDebuglog = util.debuglog('websocket');\nlet isClientSet = false;\nconst channels = {\n    // Client\n    beforeConnect: diagnosticsChannel.channel('undici:client:beforeConnect'),\n    connected: diagnosticsChannel.channel('undici:client:connected'),\n    connectError: diagnosticsChannel.channel('undici:client:connectError'),\n    sendHeaders: diagnosticsChannel.channel('undici:client:sendHeaders'),\n    // Request\n    create: diagnosticsChannel.channel('undici:request:create'),\n    bodySent: diagnosticsChannel.channel('undici:request:bodySent'),\n    headers: diagnosticsChannel.channel('undici:request:headers'),\n    trailers: diagnosticsChannel.channel('undici:request:trailers'),\n    error: diagnosticsChannel.channel('undici:request:error'),\n    // WebSocket\n    open: diagnosticsChannel.channel('undici:websocket:open'),\n    close: diagnosticsChannel.channel('undici:websocket:close'),\n    socketError: diagnosticsChannel.channel('undici:websocket:socket_error'),\n    ping: diagnosticsChannel.channel('undici:websocket:ping'),\n    pong: diagnosticsChannel.channel('undici:websocket:pong')\n};\nif (undiciDebugLog.enabled || fetchDebuglog.enabled) {\n    const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;\n    // Track all Client events\n    diagnosticsChannel.channel('undici:client:beforeConnect').subscribe((evt)=>{\n        const { connectParams: { version, protocol, port, host } } = evt;\n        debuglog('connecting to %s using %s%s', `${host}${port ? `:${port}` : ''}`, protocol, version);\n    });\n    diagnosticsChannel.channel('undici:client:connected').subscribe((evt)=>{\n        const { connectParams: { version, protocol, port, host } } = evt;\n        debuglog('connected to %s using %s%s', `${host}${port ? `:${port}` : ''}`, protocol, version);\n    });\n    diagnosticsChannel.channel('undici:client:connectError').subscribe((evt)=>{\n        const { connectParams: { version, protocol, port, host }, error } = evt;\n        debuglog('connection to %s using %s%s errored - %s', `${host}${port ? `:${port}` : ''}`, protocol, version, error.message);\n    });\n    diagnosticsChannel.channel('undici:client:sendHeaders').subscribe((evt)=>{\n        const { request: { method, path, origin } } = evt;\n        debuglog('sending request to %s %s/%s', method, origin, path);\n    });\n    // Track Request events\n    diagnosticsChannel.channel('undici:request:headers').subscribe((evt)=>{\n        const { request: { method, path, origin }, response: { statusCode } } = evt;\n        debuglog('received response to %s %s/%s - HTTP %d', method, origin, path, statusCode);\n    });\n    diagnosticsChannel.channel('undici:request:trailers').subscribe((evt)=>{\n        const { request: { method, path, origin } } = evt;\n        debuglog('trailers received from %s %s/%s', method, origin, path);\n    });\n    diagnosticsChannel.channel('undici:request:error').subscribe((evt)=>{\n        const { request: { method, path, origin }, error } = evt;\n        debuglog('request to %s %s/%s errored - %s', method, origin, path, error.message);\n    });\n    isClientSet = true;\n}\nif (websocketDebuglog.enabled) {\n    if (!isClientSet) {\n        const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;\n        diagnosticsChannel.channel('undici:client:beforeConnect').subscribe((evt)=>{\n            const { connectParams: { version, protocol, port, host } } = evt;\n            debuglog('connecting to %s%s using %s%s', host, port ? `:${port}` : '', protocol, version);\n        });\n        diagnosticsChannel.channel('undici:client:connected').subscribe((evt)=>{\n            const { connectParams: { version, protocol, port, host } } = evt;\n            debuglog('connected to %s%s using %s%s', host, port ? `:${port}` : '', protocol, version);\n        });\n        diagnosticsChannel.channel('undici:client:connectError').subscribe((evt)=>{\n            const { connectParams: { version, protocol, port, host }, error } = evt;\n            debuglog('connection to %s%s using %s%s errored - %s', host, port ? `:${port}` : '', protocol, version, error.message);\n        });\n        diagnosticsChannel.channel('undici:client:sendHeaders').subscribe((evt)=>{\n            const { request: { method, path, origin } } = evt;\n            debuglog('sending request to %s %s/%s', method, origin, path);\n        });\n    }\n    // Track all WebSocket events\n    diagnosticsChannel.channel('undici:websocket:open').subscribe((evt)=>{\n        const { address: { address, port } } = evt;\n        websocketDebuglog('connection opened %s%s', address, port ? `:${port}` : '');\n    });\n    diagnosticsChannel.channel('undici:websocket:close').subscribe((evt)=>{\n        const { websocket, code, reason } = evt;\n        websocketDebuglog('closed connection to %s - %s %s', websocket.url, code, reason);\n    });\n    diagnosticsChannel.channel('undici:websocket:socket_error').subscribe((err)=>{\n        websocketDebuglog('connection errored - %s', err.message);\n    });\n    diagnosticsChannel.channel('undici:websocket:ping').subscribe((evt)=>{\n        websocketDebuglog('ping received');\n    });\n    diagnosticsChannel.channel('undici:websocket:pong').subscribe((evt)=>{\n        websocketDebuglog('pong received');\n    });\n}\nmodule.exports = {\n    channels\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2RpYWdub3N0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsTUFBTUEscUJBQXFCQyxtQkFBT0EsQ0FBQywwREFBMEI7QUFDN0QsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUMsNEJBQVc7QUFFaEMsTUFBTUUsaUJBQWlCRCxLQUFLRSxRQUFRLENBQUM7QUFDckMsTUFBTUMsZ0JBQWdCSCxLQUFLRSxRQUFRLENBQUM7QUFDcEMsTUFBTUUsb0JBQW9CSixLQUFLRSxRQUFRLENBQUM7QUFDeEMsSUFBSUcsY0FBYztBQUNsQixNQUFNQyxXQUFXO0lBQ2YsU0FBUztJQUNUQyxlQUFlVCxtQkFBbUJVLE9BQU8sQ0FBQztJQUMxQ0MsV0FBV1gsbUJBQW1CVSxPQUFPLENBQUM7SUFDdENFLGNBQWNaLG1CQUFtQlUsT0FBTyxDQUFDO0lBQ3pDRyxhQUFhYixtQkFBbUJVLE9BQU8sQ0FBQztJQUN4QyxVQUFVO0lBQ1ZJLFFBQVFkLG1CQUFtQlUsT0FBTyxDQUFDO0lBQ25DSyxVQUFVZixtQkFBbUJVLE9BQU8sQ0FBQztJQUNyQ00sU0FBU2hCLG1CQUFtQlUsT0FBTyxDQUFDO0lBQ3BDTyxVQUFVakIsbUJBQW1CVSxPQUFPLENBQUM7SUFDckNRLE9BQU9sQixtQkFBbUJVLE9BQU8sQ0FBQztJQUNsQyxZQUFZO0lBQ1pTLE1BQU1uQixtQkFBbUJVLE9BQU8sQ0FBQztJQUNqQ1UsT0FBT3BCLG1CQUFtQlUsT0FBTyxDQUFDO0lBQ2xDVyxhQUFhckIsbUJBQW1CVSxPQUFPLENBQUM7SUFDeENZLE1BQU10QixtQkFBbUJVLE9BQU8sQ0FBQztJQUNqQ2EsTUFBTXZCLG1CQUFtQlUsT0FBTyxDQUFDO0FBQ25DO0FBRUEsSUFBSVAsZUFBZXFCLE9BQU8sSUFBSW5CLGNBQWNtQixPQUFPLEVBQUU7SUFDbkQsTUFBTXBCLFdBQVdDLGNBQWNtQixPQUFPLEdBQUduQixnQkFBZ0JGO0lBRXpELDBCQUEwQjtJQUMxQkgsbUJB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QWlDZSxTQUFTLENBQUNtQixDQUFBQTtRQUNwRXRDLGtCQUFrQiwyQkFBMkJzQyxJQUFJWixPQUFPO0lBQzFEO0lBRUFoQyxtQkFBbUJVLE9BQU8sQ0FBQyx5QkFBeUJlLFNBQVMsQ0FBQ0MsQ0FBQUE7UUFDNURwQixrQkFBa0I7SUFDcEI7SUFFQU4sbUJBQW1CVSxPQUFPLENBQUMseUJBQXlCZSxTQUFTLENBQUNDLENBQUFBO1FBQzVEcEIsa0JBQWtCO0lBQ3BCO0FBQ0Y7QUFFQXVDLE9BQU9DLE9BQU8sR0FBRztJQUNmdEM7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxkaWFnbm9zdGljcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IGRpYWdub3N0aWNzQ2hhbm5lbCA9IHJlcXVpcmUoJ25vZGU6ZGlhZ25vc3RpY3NfY2hhbm5lbCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuY29uc3QgdW5kaWNpRGVidWdMb2cgPSB1dGlsLmRlYnVnbG9nKCd1bmRpY2knKVxuY29uc3QgZmV0Y2hEZWJ1Z2xvZyA9IHV0aWwuZGVidWdsb2coJ2ZldGNoJylcbmNvbnN0IHdlYnNvY2tldERlYnVnbG9nID0gdXRpbC5kZWJ1Z2xvZygnd2Vic29ja2V0JylcbmxldCBpc0NsaWVudFNldCA9IGZhbHNlXG5jb25zdCBjaGFubmVscyA9IHtcbiAgLy8gQ2xpZW50XG4gIGJlZm9yZUNvbm5lY3Q6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKSxcbiAgY29ubmVjdGVkOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0ZWQnKSxcbiAgY29ubmVjdEVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3InKSxcbiAgc2VuZEhlYWRlcnM6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJyksXG4gIC8vIFJlcXVlc3RcbiAgY3JlYXRlOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Y3JlYXRlJyksXG4gIGJvZHlTZW50OiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Ym9keVNlbnQnKSxcbiAgaGVhZGVyczogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnKSxcbiAgdHJhaWxlcnM6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycpLFxuICBlcnJvcjogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJyksXG4gIC8vIFdlYlNvY2tldFxuICBvcGVuOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpvcGVuJyksXG4gIGNsb3NlOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpjbG9zZScpLFxuICBzb2NrZXRFcnJvcjogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6c29ja2V0X2Vycm9yJyksXG4gIHBpbmc6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBpbmcnKSxcbiAgcG9uZzogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cG9uZycpXG59XG5cbmlmICh1bmRpY2lEZWJ1Z0xvZy5lbmFibGVkIHx8IGZldGNoRGVidWdsb2cuZW5hYmxlZCkge1xuICBjb25zdCBkZWJ1Z2xvZyA9IGZldGNoRGVidWdsb2cuZW5hYmxlZCA/IGZldGNoRGVidWdsb2cgOiB1bmRpY2lEZWJ1Z0xvZ1xuXG4gIC8vIFRyYWNrIGFsbCBDbGllbnQgZXZlbnRzXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH1cbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coXG4gICAgICAnY29ubmVjdGluZyB0byAlcyB1c2luZyAlcyVzJyxcbiAgICAgIGAke2hvc3R9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfWAsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHZlcnNpb25cbiAgICApXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdGVkJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9XG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKFxuICAgICAgJ2Nvbm5lY3RlZCB0byAlcyB1c2luZyAlcyVzJyxcbiAgICAgIGAke2hvc3R9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfWAsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHZlcnNpb25cbiAgICApXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9LFxuICAgICAgZXJyb3JcbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coXG4gICAgICAnY29ubmVjdGlvbiB0byAlcyB1c2luZyAlcyVzIGVycm9yZWQgLSAlcycsXG4gICAgICBgJHtob3N0fSR7cG9ydCA/IGA6JHtwb3J0fWAgOiAnJ31gLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgZXJyb3IubWVzc2FnZVxuICAgIClcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpzZW5kSGVhZGVycycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfVxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZygnc2VuZGluZyByZXF1ZXN0IHRvICVzICVzLyVzJywgbWV0aG9kLCBvcmlnaW4sIHBhdGgpXG4gIH0pXG5cbiAgLy8gVHJhY2sgUmVxdWVzdCBldmVudHNcbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH0sXG4gICAgICByZXNwb25zZTogeyBzdGF0dXNDb2RlIH1cbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coXG4gICAgICAncmVjZWl2ZWQgcmVzcG9uc2UgdG8gJXMgJXMvJXMgLSBIVFRQICVkJyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG9yaWdpbixcbiAgICAgIHBhdGgsXG4gICAgICBzdGF0dXNDb2RlXG4gICAgKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfVxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZygndHJhaWxlcnMgcmVjZWl2ZWQgZnJvbSAlcyAlcy8lcycsIG1ldGhvZCwgb3JpZ2luLCBwYXRoKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDplcnJvcicpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfSxcbiAgICAgIGVycm9yXG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKFxuICAgICAgJ3JlcXVlc3QgdG8gJXMgJXMvJXMgZXJyb3JlZCAtICVzJyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG9yaWdpbixcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvci5tZXNzYWdlXG4gICAgKVxuICB9KVxuXG4gIGlzQ2xpZW50U2V0ID0gdHJ1ZVxufVxuXG5pZiAod2Vic29ja2V0RGVidWdsb2cuZW5hYmxlZCkge1xuICBpZiAoIWlzQ2xpZW50U2V0KSB7XG4gICAgY29uc3QgZGVidWdsb2cgPSB1bmRpY2lEZWJ1Z0xvZy5lbmFibGVkID8gdW5kaWNpRGVidWdMb2cgOiB3ZWJzb2NrZXREZWJ1Z2xvZ1xuICAgIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9XG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z2xvZyhcbiAgICAgICAgJ2Nvbm5lY3RpbmcgdG8gJXMlcyB1c2luZyAlcyVzJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJyxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIClcbiAgICB9KVxuXG4gICAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdGVkJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfVxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdsb2coXG4gICAgICAgICdjb25uZWN0ZWQgdG8gJXMlcyB1c2luZyAlcyVzJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJyxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIClcbiAgICB9KVxuXG4gICAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfSxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnbG9nKFxuICAgICAgICAnY29ubmVjdGlvbiB0byAlcyVzIHVzaW5nICVzJXMgZXJyb3JlZCAtICVzJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJyxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgIClcbiAgICB9KVxuXG4gICAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6c2VuZEhlYWRlcnMnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdDogeyBtZXRob2QsIHBhdGgsIG9yaWdpbiB9XG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z2xvZygnc2VuZGluZyByZXF1ZXN0IHRvICVzICVzLyVzJywgbWV0aG9kLCBvcmlnaW4sIHBhdGgpXG4gICAgfSlcbiAgfVxuXG4gIC8vIFRyYWNrIGFsbCBXZWJTb2NrZXQgZXZlbnRzXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0Om9wZW4nKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzOiB7IGFkZHJlc3MsIHBvcnQgfVxuICAgIH0gPSBldnRcbiAgICB3ZWJzb2NrZXREZWJ1Z2xvZygnY29ubmVjdGlvbiBvcGVuZWQgJXMlcycsIGFkZHJlc3MsIHBvcnQgPyBgOiR7cG9ydH1gIDogJycpXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6Y2xvc2UnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7IHdlYnNvY2tldCwgY29kZSwgcmVhc29uIH0gPSBldnRcbiAgICB3ZWJzb2NrZXREZWJ1Z2xvZyhcbiAgICAgICdjbG9zZWQgY29ubmVjdGlvbiB0byAlcyAtICVzICVzJyxcbiAgICAgIHdlYnNvY2tldC51cmwsXG4gICAgICBjb2RlLFxuICAgICAgcmVhc29uXG4gICAgKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnNvY2tldF9lcnJvcicpLnN1YnNjcmliZShlcnIgPT4ge1xuICAgIHdlYnNvY2tldERlYnVnbG9nKCdjb25uZWN0aW9uIGVycm9yZWQgLSAlcycsIGVyci5tZXNzYWdlKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBpbmcnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICB3ZWJzb2NrZXREZWJ1Z2xvZygncGluZyByZWNlaXZlZCcpXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cG9uZycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIHdlYnNvY2tldERlYnVnbG9nKCdwb25nIHJlY2VpdmVkJylcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoYW5uZWxzXG59XG4iXSwibmFtZXMiOlsiZGlhZ25vc3RpY3NDaGFubmVsIiwicmVxdWlyZSIsInV0aWwiLCJ1bmRpY2lEZWJ1Z0xvZyIsImRlYnVnbG9nIiwiZmV0Y2hEZWJ1Z2xvZyIsIndlYnNvY2tldERlYnVnbG9nIiwiaXNDbGllbnRTZXQiLCJjaGFubmVscyIsImJlZm9yZUNvbm5lY3QiLCJjaGFubmVsIiwiY29ubmVjdGVkIiwiY29ubmVjdEVycm9yIiwic2VuZEhlYWRlcnMiLCJjcmVhdGUiLCJib2R5U2VudCIsImhlYWRlcnMiLCJ0cmFpbGVycyIsImVycm9yIiwib3BlbiIsImNsb3NlIiwic29ja2V0RXJyb3IiLCJwaW5nIiwicG9uZyIsImVuYWJsZWQiLCJzdWJzY3JpYmUiLCJldnQiLCJjb25uZWN0UGFyYW1zIiwidmVyc2lvbiIsInByb3RvY29sIiwicG9ydCIsImhvc3QiLCJtZXNzYWdlIiwicmVxdWVzdCIsIm1ldGhvZCIsInBhdGgiLCJvcmlnaW4iLCJyZXNwb25zZSIsInN0YXR1c0NvZGUiLCJhZGRyZXNzIiwid2Vic29ja2V0IiwiY29kZSIsInJlYXNvbiIsInVybCIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/diagnostics.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nclass UndiciError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'UndiciError';\n        this.code = 'UND_ERR';\n    }\n}\nclass ConnectTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'ConnectTimeoutError';\n        this.message = message || 'Connect Timeout Error';\n        this.code = 'UND_ERR_CONNECT_TIMEOUT';\n    }\n}\nclass HeadersTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'HeadersTimeoutError';\n        this.message = message || 'Headers Timeout Error';\n        this.code = 'UND_ERR_HEADERS_TIMEOUT';\n    }\n}\nclass HeadersOverflowError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'HeadersOverflowError';\n        this.message = message || 'Headers Overflow Error';\n        this.code = 'UND_ERR_HEADERS_OVERFLOW';\n    }\n}\nclass BodyTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'BodyTimeoutError';\n        this.message = message || 'Body Timeout Error';\n        this.code = 'UND_ERR_BODY_TIMEOUT';\n    }\n}\nclass ResponseStatusCodeError extends UndiciError {\n    constructor(message, statusCode, headers, body){\n        super(message);\n        this.name = 'ResponseStatusCodeError';\n        this.message = message || 'Response Status Code Error';\n        this.code = 'UND_ERR_RESPONSE_STATUS_CODE';\n        this.body = body;\n        this.status = statusCode;\n        this.statusCode = statusCode;\n        this.headers = headers;\n    }\n}\nclass InvalidArgumentError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'InvalidArgumentError';\n        this.message = message || 'Invalid Argument Error';\n        this.code = 'UND_ERR_INVALID_ARG';\n    }\n}\nclass InvalidReturnValueError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'InvalidReturnValueError';\n        this.message = message || 'Invalid Return Value Error';\n        this.code = 'UND_ERR_INVALID_RETURN_VALUE';\n    }\n}\nclass AbortError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'AbortError';\n        this.message = message || 'The operation was aborted';\n    }\n}\nclass RequestAbortedError extends AbortError {\n    constructor(message){\n        super(message);\n        this.name = 'AbortError';\n        this.message = message || 'Request aborted';\n        this.code = 'UND_ERR_ABORTED';\n    }\n}\nclass InformationalError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'InformationalError';\n        this.message = message || 'Request information';\n        this.code = 'UND_ERR_INFO';\n    }\n}\nclass RequestContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'RequestContentLengthMismatchError';\n        this.message = message || 'Request body length does not match content-length header';\n        this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';\n    }\n}\nclass ResponseContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'ResponseContentLengthMismatchError';\n        this.message = message || 'Response body length does not match content-length header';\n        this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';\n    }\n}\nclass ClientDestroyedError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'ClientDestroyedError';\n        this.message = message || 'The client is destroyed';\n        this.code = 'UND_ERR_DESTROYED';\n    }\n}\nclass ClientClosedError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'ClientClosedError';\n        this.message = message || 'The client is closed';\n        this.code = 'UND_ERR_CLOSED';\n    }\n}\nclass SocketError extends UndiciError {\n    constructor(message, socket){\n        super(message);\n        this.name = 'SocketError';\n        this.message = message || 'Socket error';\n        this.code = 'UND_ERR_SOCKET';\n        this.socket = socket;\n    }\n}\nclass NotSupportedError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'NotSupportedError';\n        this.message = message || 'Not supported error';\n        this.code = 'UND_ERR_NOT_SUPPORTED';\n    }\n}\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'MissingUpstreamError';\n        this.message = message || 'No upstream has been added to the BalancedPool';\n        this.code = 'UND_ERR_BPL_MISSING_UPSTREAM';\n    }\n}\nclass HTTPParserError extends Error {\n    constructor(message, code, data){\n        super(message);\n        this.name = 'HTTPParserError';\n        this.code = code ? `HPE_${code}` : undefined;\n        this.data = data ? data.toString() : undefined;\n    }\n}\nclass ResponseExceededMaxSizeError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = 'ResponseExceededMaxSizeError';\n        this.message = message || 'Response content exceeded max size';\n        this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE';\n    }\n}\nclass RequestRetryError extends UndiciError {\n    constructor(message, code, { headers, data }){\n        super(message);\n        this.name = 'RequestRetryError';\n        this.message = message || 'Request retry error';\n        this.code = 'UND_ERR_REQ_RETRY';\n        this.statusCode = code;\n        this.data = data;\n        this.headers = headers;\n    }\n}\nclass SecureProxyConnectionError extends UndiciError {\n    constructor(cause, message, options){\n        super(message, {\n            cause,\n            ...options ?? {}\n        });\n        this.name = 'SecureProxyConnectionError';\n        this.message = message || 'Secure Proxy Connection failed';\n        this.code = 'UND_ERR_PRX_TLS';\n        this.cause = cause;\n    }\n}\nmodule.exports = {\n    AbortError,\n    HTTPParserError,\n    UndiciError,\n    HeadersTimeoutError,\n    HeadersOverflowError,\n    BodyTimeoutError,\n    RequestContentLengthMismatchError,\n    ConnectTimeoutError,\n    ResponseStatusCodeError,\n    InvalidArgumentError,\n    InvalidReturnValueError,\n    RequestAbortedError,\n    ClientDestroyedError,\n    ClientClosedError,\n    InformationalError,\n    SocketError,\n    NotSupportedError,\n    ResponseContentLengthMismatchError,\n    BalancedPoolMissingUpstreamError,\n    ResponseExceededMaxSizeError,\n    RequestRetryError,\n    SecureProxyConnectionError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLG9CQUFvQkM7SUFDeEIsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1DLDRCQUE0Qkw7SUFDaEMsWUFBYUUsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1FLDRCQUE0Qk47SUFDaEMsWUFBYUUsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1HLDZCQUE2QlA7SUFDakMsWUFBYUUsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1JLHlCQUF5QlI7SUFDN0IsWUFBYUUsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1LLGdDQUFnQ1Q7SUFDcEMsWUFBYUUsT0FBTyxFQUFFUSxVQUFVLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxDQUFFO1FBQy9DLEtB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LElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNqQixPQUFPLEdBQUdBO0lBQ2pCO0FBQ0Y7QUFFQSxNQUFNc0IsbUNBQW1DakM7SUFDdkMsWUFBYWtDLEtBQUssRUFBRWhDLE9BQU8sRUFBRWlDLE9BQU8sQ0FBRTtRQUNwQyxLQUFLLENBQUNqQyxTQUFTO1lBQUVnQztZQUFPLEdBQUlDLFdBQVcsQ0FBQyxDQUFDO1FBQUU7UUFDM0MsSUFBSSxDQUFDaEMsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM4QixLQUFLLEdBQUdBO0lBQ2Y7QUFDRjtBQUVBRSxPQUFPQyxPQUFPLEdBQUc7SUFDZnJCO0lBQ0FXO0lBQ0EzQjtJQUNBTTtJQUNBQztJQUNBQztJQUNBVztJQUNBZDtJQUNBSTtJQUNBSztJQUNBQztJQUNBRTtJQUNBSTtJQUNBQztJQUNBSjtJQUNBSztJQUNBRTtJQUNBTDtJQUNBTTtJQUNBSztJQUNBQztJQUNBQztBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY2xhc3MgVW5kaWNpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnVW5kaWNpRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlInXG4gIH1cbn1cblxuY2xhc3MgQ29ubmVjdFRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0Nvbm5lY3QgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DT05ORUNUX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc1RpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzVGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0hlYWRlcnMgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc092ZXJmbG93RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSGVhZGVyc092ZXJmbG93RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSGVhZGVycyBPdmVyZmxvdyBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX09WRVJGTE9XJ1xuICB9XG59XG5cbmNsYXNzIEJvZHlUaW1lb3V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQm9keVRpbWVvdXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdCb2R5IFRpbWVvdXQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQk9EWV9USU1FT1VUJ1xuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlU3RhdHVzQ29kZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIFN0YXR1cyBDb2RlIEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU1BPTlNFX1NUQVRVU19DT0RFJ1xuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0ludmFsaWQgQXJndW1lbnQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9BUkcnXG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFJldHVyblZhbHVlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSW52YWxpZCBSZXR1cm4gVmFsdWUgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnXG4gIH1cbn1cblxuY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdEFib3J0ZWRFcnJvciBleHRlbmRzIEFib3J0RXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCBhYm9ydGVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0FCT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgSW5mb3JtYXRpb25hbEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0luZm9ybWF0aW9uYWxFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGluZm9ybWF0aW9uJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lORk8nXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50RGVzdHJveWVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQ2xpZW50RGVzdHJveWVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIGNsaWVudCBpcyBkZXN0cm95ZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfREVTVFJPWUVEJ1xuICB9XG59XG5cbmNsYXNzIENsaWVudENsb3NlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0NsaWVudENsb3NlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBjbGllbnQgaXMgY2xvc2VkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0NMT1NFRCdcbiAgfVxufVxuXG5jbGFzcyBTb2NrZXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIHNvY2tldCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1NvY2tldEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1NvY2tldCBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9TT0NLRVQnXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgfVxufVxuXG5jbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdOb3Qgc3VwcG9ydGVkIGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX05PVF9TVVBQT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ1Vwc3RyZWFtRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnTm8gdXBzdHJlYW0gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIEJhbGFuY2VkUG9vbCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9CUExfTUlTU0lOR19VUFNUUkVBTSdcbiAgfVxufVxuXG5jbGFzcyBIVFRQUGFyc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBjb2RlLCBkYXRhKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSFRUUFBhcnNlckVycm9yJ1xuICAgIHRoaXMuY29kZSA9IGNvZGUgPyBgSFBFXyR7Y29kZX1gIDogdW5kZWZpbmVkXG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IGRhdGEudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBjb250ZW50IGV4Y2VlZGVkIG1heCBzaXplJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU19FWENFRURFRF9NQVhfU0laRSdcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0UmV0cnlFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIHsgaGVhZGVycywgZGF0YSB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdFJldHJ5RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCByZXRyeSBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfUkVUUlknXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gY29kZVxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gIH1cbn1cblxuY2xhc3MgU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChjYXVzZSwgbWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UsIC4uLihvcHRpb25zID8/IHt9KSB9KVxuICAgIHRoaXMubmFtZSA9ICdTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdTZWN1cmUgUHJveHkgQ29ubmVjdGlvbiBmYWlsZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUFJYX1RMUydcbiAgICB0aGlzLmNhdXNlID0gY2F1c2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWJvcnRFcnJvcixcbiAgSFRUUFBhcnNlckVycm9yLFxuICBVbmRpY2lFcnJvcixcbiAgSGVhZGVyc1RpbWVvdXRFcnJvcixcbiAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gIEJvZHlUaW1lb3V0RXJyb3IsXG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQ29ubmVjdFRpbWVvdXRFcnJvcixcbiAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IsXG4gIFJlcXVlc3RSZXRyeUVycm9yLFxuICBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvclxufVxuIl0sIm5hbWVzIjpbIlVuZGljaUVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsImNvZGUiLCJDb25uZWN0VGltZW91dEVycm9yIiwiSGVhZGVyc1RpbWVvdXRFcnJvciIsIkhlYWRlcnNPdmVyZmxvd0Vycm9yIiwiQm9keVRpbWVvdXRFcnJvciIsIlJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIiwic3RhdHVzQ29kZSIsImhlYWRlcnMiLCJib2R5Iiwic3RhdHVzIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciIsIkFib3J0RXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciIsIkNsaWVudERlc3Ryb3llZEVycm9yIiwiQ2xpZW50Q2xvc2VkRXJyb3IiLCJTb2NrZXRFcnJvciIsInNvY2tldCIsIk5vdFN1cHBvcnRlZEVycm9yIiwiQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IiLCJIVFRQUGFyc2VyRXJyb3IiLCJkYXRhIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yIiwiUmVxdWVzdFJldHJ5RXJyb3IiLCJTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvciIsImNhdXNlIiwib3B0aW9ucyIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError, NotSupportedError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { isValidHTTPToken, isValidHeaderValue, isStream, destroy, isBuffer, isFormDataLike, isIterable, isBlobLike, buildURL, validateHandler, getServerName, normalizedMethodRecords } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { channels } = __webpack_require__(/*! ./diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\");\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/;\nconst kHandler = Symbol('handler');\nclass Request {\n    constructor(origin, { path, method, body, headers, query, idempotent, blocking, upgrade, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue, servername }, handler){\n        if (typeof path !== 'string') {\n            throw new InvalidArgumentError('path must be a string');\n        } else if (path[0] !== '/' && !(path.startsWith('http://') || path.startsWith('https://')) && method !== 'CONNECT') {\n            throw new InvalidArgumentError('path must be an absolute URL or start with a slash');\n        } else if (invalidPathRegex.test(path)) {\n            throw new InvalidArgumentError('invalid request path');\n        }\n        if (typeof method !== 'string') {\n            throw new InvalidArgumentError('method must be a string');\n        } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {\n            throw new InvalidArgumentError('invalid request method');\n        }\n        if (upgrade && typeof upgrade !== 'string') {\n            throw new InvalidArgumentError('upgrade must be a string');\n        }\n        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError('invalid headersTimeout');\n        }\n        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError('invalid bodyTimeout');\n        }\n        if (reset != null && typeof reset !== 'boolean') {\n            throw new InvalidArgumentError('invalid reset');\n        }\n        if (expectContinue != null && typeof expectContinue !== 'boolean') {\n            throw new InvalidArgumentError('invalid expectContinue');\n        }\n        this.headersTimeout = headersTimeout;\n        this.bodyTimeout = bodyTimeout;\n        this.throwOnError = throwOnError === true;\n        this.method = method;\n        this.abort = null;\n        if (body == null) {\n            this.body = null;\n        } else if (isStream(body)) {\n            this.body = body;\n            const rState = this.body._readableState;\n            if (!rState || !rState.autoDestroy) {\n                this.endHandler = function autoDestroy() {\n                    destroy(this);\n                };\n                this.body.on('end', this.endHandler);\n            }\n            this.errorHandler = (err)=>{\n                if (this.abort) {\n                    this.abort(err);\n                } else {\n                    this.error = err;\n                }\n            };\n            this.body.on('error', this.errorHandler);\n        } else if (isBuffer(body)) {\n            this.body = body.byteLength ? body : null;\n        } else if (ArrayBuffer.isView(body)) {\n            this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;\n        } else if (body instanceof ArrayBuffer) {\n            this.body = body.byteLength ? Buffer.from(body) : null;\n        } else if (typeof body === 'string') {\n            this.body = body.length ? Buffer.from(body) : null;\n        } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {\n            this.body = body;\n        } else {\n            throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable');\n        }\n        this.completed = false;\n        this.aborted = false;\n        this.upgrade = upgrade || null;\n        this.path = query ? buildURL(path, query) : path;\n        this.origin = origin;\n        this.idempotent = idempotent == null ? method === 'HEAD' || method === 'GET' : idempotent;\n        this.blocking = blocking == null ? false : blocking;\n        this.reset = reset == null ? null : reset;\n        this.host = null;\n        this.contentLength = null;\n        this.contentType = null;\n        this.headers = [];\n        // Only for H2\n        this.expectContinue = expectContinue != null ? expectContinue : false;\n        if (Array.isArray(headers)) {\n            if (headers.length % 2 !== 0) {\n                throw new InvalidArgumentError('headers array must be even');\n            }\n            for(let i = 0; i < headers.length; i += 2){\n                processHeader(this, headers[i], headers[i + 1]);\n            }\n        } else if (headers && typeof headers === 'object') {\n            if (headers[Symbol.iterator]) {\n                for (const header of headers){\n                    if (!Array.isArray(header) || header.length !== 2) {\n                        throw new InvalidArgumentError('headers must be in key-value pair format');\n                    }\n                    processHeader(this, header[0], header[1]);\n                }\n            } else {\n                const keys = Object.keys(headers);\n                for(let i = 0; i < keys.length; ++i){\n                    processHeader(this, keys[i], headers[keys[i]]);\n                }\n            }\n        } else if (headers != null) {\n            throw new InvalidArgumentError('headers must be an object or an array');\n        }\n        validateHandler(handler, method, upgrade);\n        this.servername = servername || getServerName(this.host);\n        this[kHandler] = handler;\n        if (channels.create.hasSubscribers) {\n            channels.create.publish({\n                request: this\n            });\n        }\n    }\n    onBodySent(chunk) {\n        if (this[kHandler].onBodySent) {\n            try {\n                return this[kHandler].onBodySent(chunk);\n            } catch (err) {\n                this.abort(err);\n            }\n        }\n    }\n    onRequestSent() {\n        if (channels.bodySent.hasSubscribers) {\n            channels.bodySent.publish({\n                request: this\n            });\n        }\n        if (this[kHandler].onRequestSent) {\n            try {\n                return this[kHandler].onRequestSent();\n            } catch (err) {\n                this.abort(err);\n            }\n        }\n    }\n    onConnect(abort) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (this.error) {\n            abort(this.error);\n        } else {\n            this.abort = abort;\n            return this[kHandler].onConnect(abort);\n        }\n    }\n    onResponseStarted() {\n        return this[kHandler].onResponseStarted?.();\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (channels.headers.hasSubscribers) {\n            channels.headers.publish({\n                request: this,\n                response: {\n                    statusCode,\n                    headers,\n                    statusText\n                }\n            });\n        }\n        try {\n            return this[kHandler].onHeaders(statusCode, headers, resume, statusText);\n        } catch (err) {\n            this.abort(err);\n        }\n    }\n    onData(chunk) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        try {\n            return this[kHandler].onData(chunk);\n        } catch (err) {\n            this.abort(err);\n            return false;\n        }\n    }\n    onUpgrade(statusCode, headers, socket) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onUpgrade(statusCode, headers, socket);\n    }\n    onComplete(trailers) {\n        this.onFinally();\n        assert(!this.aborted);\n        this.completed = true;\n        if (channels.trailers.hasSubscribers) {\n            channels.trailers.publish({\n                request: this,\n                trailers\n            });\n        }\n        try {\n            return this[kHandler].onComplete(trailers);\n        } catch (err) {\n            // TODO (fix): This might be a bad idea?\n            this.onError(err);\n        }\n    }\n    onError(error) {\n        this.onFinally();\n        if (channels.error.hasSubscribers) {\n            channels.error.publish({\n                request: this,\n                error\n            });\n        }\n        if (this.aborted) {\n            return;\n        }\n        this.aborted = true;\n        return this[kHandler].onError(error);\n    }\n    onFinally() {\n        if (this.errorHandler) {\n            this.body.off('error', this.errorHandler);\n            this.errorHandler = null;\n        }\n        if (this.endHandler) {\n            this.body.off('end', this.endHandler);\n            this.endHandler = null;\n        }\n    }\n    addHeader(key, value) {\n        processHeader(this, key, value);\n        return this;\n    }\n}\nfunction processHeader(request, key, val) {\n    if (val && typeof val === 'object' && !Array.isArray(val)) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    } else if (val === undefined) {\n        return;\n    }\n    let headerName = headerNameLowerCasedRecord[key];\n    if (headerName === undefined) {\n        headerName = key.toLowerCase();\n        if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {\n            throw new InvalidArgumentError('invalid header key');\n        }\n    }\n    if (Array.isArray(val)) {\n        const arr = [];\n        for(let i = 0; i < val.length; i++){\n            if (typeof val[i] === 'string') {\n                if (!isValidHeaderValue(val[i])) {\n                    throw new InvalidArgumentError(`invalid ${key} header`);\n                }\n                arr.push(val[i]);\n            } else if (val[i] === null) {\n                arr.push('');\n            } else if (typeof val[i] === 'object') {\n                throw new InvalidArgumentError(`invalid ${key} header`);\n            } else {\n                arr.push(`${val[i]}`);\n            }\n        }\n        val = arr;\n    } else if (typeof val === 'string') {\n        if (!isValidHeaderValue(val)) {\n            throw new InvalidArgumentError(`invalid ${key} header`);\n        }\n    } else if (val === null) {\n        val = '';\n    } else {\n        val = `${val}`;\n    }\n    if (request.host === null && headerName === 'host') {\n        if (typeof val !== 'string') {\n            throw new InvalidArgumentError('invalid host header');\n        }\n        // Consumed by Client\n        request.host = val;\n    } else if (request.contentLength === null && headerName === 'content-length') {\n        request.contentLength = parseInt(val, 10);\n        if (!Number.isFinite(request.contentLength)) {\n            throw new InvalidArgumentError('invalid content-length header');\n        }\n    } else if (request.contentType === null && headerName === 'content-type') {\n        request.contentType = val;\n        request.headers.push(key, val);\n    } else if (headerName === 'transfer-encoding' || headerName === 'keep-alive' || headerName === 'upgrade') {\n        throw new InvalidArgumentError(`invalid ${headerName} header`);\n    } else if (headerName === 'connection') {\n        const value = typeof val === 'string' ? val.toLowerCase() : null;\n        if (value !== 'close' && value !== 'keep-alive') {\n            throw new InvalidArgumentError('invalid connection header');\n        }\n        if (value === 'close') {\n            request.reset = true;\n        }\n    } else if (headerName === 'expect') {\n        throw new NotSupportedError('expect header not supported');\n    } else {\n        request.headers.push(key, val);\n    }\n}\nmodule.exports = Request;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLG9CQUFvQixFQUNwQkMsaUJBQWlCLEVBQ2xCLEdBQUdDLG1CQUFPQSxDQUFDLGdFQUFVO0FBQ3RCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3BDLE1BQU0sRUFDSkUsZ0JBQWdCLEVBQ2hCQyxrQkFBa0IsRUFDbEJDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLGNBQWMsRUFDZEMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFFBQVEsRUFDUkMsZUFBZSxFQUNmQyxhQUFhLEVBQ2JDLHVCQUF1QixFQUN4QixHQUFHYixtQkFBT0EsQ0FBQyw0REFBUTtBQUNwQixNQUFNLEVBQUVjLFFBQVEsRUFBRSxHQUFHZCxtQkFBT0EsQ0FBQyw2RUFBa0I7QUFDL0MsTUFBTSxFQUFFZSwwQkFBMEIsRUFBRSxHQUFHZixtQkFBT0EsQ0FBQyxzRUFBYTtBQUU1RCxrRkFBa0Y7QUFDbEYsTUFBTWdCLG1CQUFtQjtBQUV6QixNQUFNQyxXQUFXQyxPQUFPO0FBRXhCLE1BQU1DO0lBQ0osWUFBYUMsTUFBTSxFQUFFLEVBQ25CQyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsSUFBSSxFQUNKQyxPQUFPLEVBQ1BDLEtBQUssRUFDTEMsVUFBVSxFQUNWQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEMsY0FBYyxFQUNkQyxXQUFXLEVBQ1hDLEtBQUssRUFDTEMsWUFBWSxFQUNaQyxjQUFjLEVBQ2RDLFVBQVUsRUFDWCxFQUFFQyxPQUFPLENBQUU7UUFDVixJQUFJLE9BQU9kLFNBQVMsVUFBVTtZQUM1QixNQUFNLElBQUl2QixxQkFBcUI7UUFDakMsT0FBTyxJQUNMdUIsSUFBSSxDQUFDLEVBQUUsS0FBSyxPQUNaLENBQUVBLENBQUFBLEtBQUtlLFVBQVUsQ0FBQyxjQUFjZixLQUFLZSxVQUFVLENBQUMsV0FBVSxLQUMxRGQsV0FB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Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHtcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgaXNWYWxpZEhlYWRlclZhbHVlLFxuICBpc1N0cmVhbSxcbiAgZGVzdHJveSxcbiAgaXNCdWZmZXIsXG4gIGlzRm9ybURhdGFMaWtlLFxuICBpc0l0ZXJhYmxlLFxuICBpc0Jsb2JMaWtlLFxuICBidWlsZFVSTCxcbiAgdmFsaWRhdGVIYW5kbGVyLFxuICBnZXRTZXJ2ZXJOYW1lLFxuICBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc1xufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IHsgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuLy8gVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHBhdGggaXMgdmFsaWQgZG9lcyBub3QgY29udGFpbiBjb250cm9sIGNoYXJzIFxceDAwIHRvIFxceDIwXG5jb25zdCBpbnZhbGlkUGF0aFJlZ2V4ID0gL1teXFx1MDAyMS1cXHUwMGZmXS9cblxuY29uc3Qga0hhbmRsZXIgPSBTeW1ib2woJ2hhbmRsZXInKVxuXG5jbGFzcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIHBhdGgsXG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgICBxdWVyeSxcbiAgICBpZGVtcG90ZW50LFxuICAgIGJsb2NraW5nLFxuICAgIHVwZ3JhZGUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgYm9keVRpbWVvdXQsXG4gICAgcmVzZXQsXG4gICAgdGhyb3dPbkVycm9yLFxuICAgIGV4cGVjdENvbnRpbnVlLFxuICAgIHNlcnZlcm5hbWVcbiAgfSwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGF0aFswXSAhPT0gJy8nICYmXG4gICAgICAhKHBhdGguc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHBhdGguc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkgJiZcbiAgICAgIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkwgb3Igc3RhcnQgd2l0aCBhIHNsYXNoJylcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQYXRoUmVnZXgudGVzdChwYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgcGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzW21ldGhvZF0gPT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZEhUVFBUb2tlbihtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVxdWVzdCBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlICYmIHR5cGVvZiB1cGdyYWRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1cGdyYWRlIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyc1RpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGJvZHlUaW1lb3V0KSB8fCBib2R5VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgYm9keVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChyZXNldCAhPSBudWxsICYmIHR5cGVvZiByZXNldCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVzZXQnKVxuICAgIH1cblxuICAgIGlmIChleHBlY3RDb250aW51ZSAhPSBudWxsICYmIHR5cGVvZiBleHBlY3RDb250aW51ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZXhwZWN0Q29udGludWUnKVxuICAgIH1cblxuICAgIHRoaXMuaGVhZGVyc1RpbWVvdXQgPSBoZWFkZXJzVGltZW91dFxuXG4gICAgdGhpcy5ib2R5VGltZW91dCA9IGJvZHlUaW1lb3V0XG5cbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvciA9PT0gdHJ1ZVxuXG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2RcblxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgfSBlbHNlIGlmIChpc1N0cmVhbShib2R5KSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keVxuXG4gICAgICBjb25zdCByU3RhdGUgPSB0aGlzLmJvZHkuX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmICghclN0YXRlIHx8ICFyU3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lbmRIYW5kbGVyID0gZnVuY3Rpb24gYXV0b0Rlc3Ryb3kgKCkge1xuICAgICAgICAgIGRlc3Ryb3kodGhpcylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkub24oJ2VuZCcsIHRoaXMuZW5kSGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnIgPT4ge1xuICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ib2R5Lm9uKCdlcnJvcicsIHRoaXMuZXJyb3JIYW5kbGVyKVxuICAgIH0gZWxzZSBpZiAoaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkuYnl0ZUxlbmd0aCA/IGJvZHkgOiBudWxsXG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkuYnVmZmVyLmJ5dGVMZW5ndGggPyBCdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpIDogbnVsbFxuICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBCdWZmZXIuZnJvbShib2R5KSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5sZW5ndGggPyBCdWZmZXIuZnJvbShib2R5KSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKGlzRm9ybURhdGFMaWtlKGJvZHkpIHx8IGlzSXRlcmFibGUoYm9keSkgfHwgaXNCbG9iTGlrZShib2R5KSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2JvZHkgbXVzdCBiZSBhIHN0cmluZywgYSBCdWZmZXIsIGEgUmVhZGFibGUgc3RyZWFtLCBhbiBpdGVyYWJsZSwgb3IgYW4gYXN5bmMgaXRlcmFibGUnKVxuICAgIH1cblxuICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2VcblxuICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLnVwZ3JhZGUgPSB1cGdyYWRlIHx8IG51bGxcblxuICAgIHRoaXMucGF0aCA9IHF1ZXJ5ID8gYnVpbGRVUkwocGF0aCwgcXVlcnkpIDogcGF0aFxuXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cblxuICAgIHRoaXMuaWRlbXBvdGVudCA9IGlkZW1wb3RlbnQgPT0gbnVsbFxuICAgICAgPyBtZXRob2QgPT09ICdIRUFEJyB8fCBtZXRob2QgPT09ICdHRVQnXG4gICAgICA6IGlkZW1wb3RlbnRcblxuICAgIHRoaXMuYmxvY2tpbmcgPSBibG9ja2luZyA9PSBudWxsID8gZmFsc2UgOiBibG9ja2luZ1xuXG4gICAgdGhpcy5yZXNldCA9IHJlc2V0ID09IG51bGwgPyBudWxsIDogcmVzZXRcblxuICAgIHRoaXMuaG9zdCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsXG5cbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuXG4gICAgLy8gT25seSBmb3IgSDJcbiAgICB0aGlzLmV4cGVjdENvbnRpbnVlID0gZXhwZWN0Q29udGludWUgIT0gbnVsbCA/IGV4cGVjdENvbnRpbnVlIDogZmFsc2VcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBpZiAoaGVhZGVycy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBhcnJheSBtdXN0IGJlIGV2ZW4nKVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGhlYWRlcnNbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcikgfHwgaGVhZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgaW4ga2V5LXZhbHVlIHBhaXIgZm9ybWF0JylcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0hlYWRlcih0aGlzLCBoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5c1tpXSwgaGVhZGVyc1trZXlzW2ldXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIHZhbGlkYXRlSGFuZGxlcihoYW5kbGVyLCBtZXRob2QsIHVwZ3JhZGUpXG5cbiAgICB0aGlzLnNlcnZlcm5hbWUgPSBzZXJ2ZXJuYW1lIHx8IGdldFNlcnZlck5hbWUodGhpcy5ob3N0KVxuXG4gICAgdGhpc1trSGFuZGxlcl0gPSBoYW5kbGVyXG5cbiAgICBpZiAoY2hhbm5lbHMuY3JlYXRlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jcmVhdGUucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMgfSlcbiAgICB9XG4gIH1cblxuICBvbkJvZHlTZW50IChjaHVuaykge1xuICAgIGlmICh0aGlzW2tIYW5kbGVyXS5vbkJvZHlTZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Cb2R5U2VudChjaHVuaylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblJlcXVlc3RTZW50ICgpIHtcbiAgICBpZiAoY2hhbm5lbHMuYm9keVNlbnQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmJvZHlTZW50LnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0hhbmRsZXJdLm9uUmVxdWVzdFNlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vblJlcXVlc3RTZW50KClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZClcblxuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICBhYm9ydCh0aGlzLmVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkNvbm5lY3QoYWJvcnQpXG4gICAgfVxuICB9XG5cbiAgb25SZXNwb25zZVN0YXJ0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vblJlc3BvbnNlU3RhcnRlZD8uKClcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZClcblxuICAgIGlmIChjaGFubmVscy5oZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5oZWFkZXJzLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCByZXNwb25zZTogeyBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNUZXh0IH0gfSlcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmFib3J0KGVycilcbiAgICB9XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZClcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25EYXRhKGNodW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgdGhpcy5vbkZpbmFsbHkoKVxuXG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWVcbiAgICBpZiAoY2hhbm5lbHMudHJhaWxlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLnRyYWlsZXJzLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCB0cmFpbGVycyB9KVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db21wbGV0ZSh0cmFpbGVycylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IFRoaXMgbWlnaHQgYmUgYSBiYWQgaWRlYT9cbiAgICAgIHRoaXMub25FcnJvcihlcnIpXG4gICAgfVxuICB9XG5cbiAgb25FcnJvciAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRmluYWxseSgpXG5cbiAgICBpZiAoY2hhbm5lbHMuZXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmVycm9yLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCBlcnJvciB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmFib3J0ZWQgPSB0cnVlXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIG9uRmluYWxseSAoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICB0aGlzLmJvZHkub2ZmKCdlcnJvcicsIHRoaXMuZXJyb3JIYW5kbGVyKVxuICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kSGFuZGxlcikge1xuICAgICAgdGhpcy5ib2R5Lm9mZignZW5kJywgdGhpcy5lbmRIYW5kbGVyKVxuICAgICAgdGhpcy5lbmRIYW5kbGVyID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGFkZEhlYWRlciAoa2V5LCB2YWx1ZSkge1xuICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIgKHJlcXVlc3QsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCkpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgaGVhZGVyTmFtZSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2tleV1cblxuICBpZiAoaGVhZGVyTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGVhZGVyTmFtZSA9IGtleS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2hlYWRlck5hbWVdID09PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRIVFRQVG9rZW4oaGVhZGVyTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoZWFkZXIga2V5JylcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY29uc3QgYXJyID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiB2YWxbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbFtpXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgICAgIH1cbiAgICAgICAgYXJyLnB1c2godmFsW2ldKVxuICAgICAgfSBlbHNlIGlmICh2YWxbaV0gPT09IG51bGwpIHtcbiAgICAgICAgYXJyLnB1c2goJycpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWxbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyci5wdXNoKGAke3ZhbFtpXX1gKVxuICAgICAgfVxuICAgIH1cbiAgICB2YWwgPSBhcnJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgdmFsID0gJydcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBgJHt2YWx9YFxuICB9XG5cbiAgaWYgKHJlcXVlc3QuaG9zdCA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnaG9zdCcpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBob3N0IGhlYWRlcicpXG4gICAgfVxuICAgIC8vIENvbnN1bWVkIGJ5IENsaWVudFxuICAgIHJlcXVlc3QuaG9zdCA9IHZhbFxuICB9IGVsc2UgaWYgKHJlcXVlc3QuY29udGVudExlbmd0aCA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnY29udGVudC1sZW5ndGgnKSB7XG4gICAgcmVxdWVzdC5jb250ZW50TGVuZ3RoID0gcGFyc2VJbnQodmFsLCAxMClcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShyZXF1ZXN0LmNvbnRlbnRMZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29udGVudC1sZW5ndGggaGVhZGVyJylcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVxdWVzdC5jb250ZW50VHlwZSA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnY29udGVudC10eXBlJykge1xuICAgIHJlcXVlc3QuY29udGVudFR5cGUgPSB2YWxcbiAgICByZXF1ZXN0LmhlYWRlcnMucHVzaChrZXksIHZhbClcbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAndHJhbnNmZXItZW5jb2RpbmcnIHx8IGhlYWRlck5hbWUgPT09ICdrZWVwLWFsaXZlJyB8fCBoZWFkZXJOYW1lID09PSAndXBncmFkZScpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtoZWFkZXJOYW1lfSBoZWFkZXJgKVxuICB9IGVsc2UgaWYgKGhlYWRlck5hbWUgPT09ICdjb25uZWN0aW9uJykge1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB2YWwudG9Mb3dlckNhc2UoKSA6IG51bGxcbiAgICBpZiAodmFsdWUgIT09ICdjbG9zZScgJiYgdmFsdWUgIT09ICdrZWVwLWFsaXZlJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbm5lY3Rpb24gaGVhZGVyJylcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICdjbG9zZScpIHtcbiAgICAgIHJlcXVlc3QucmVzZXQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlck5hbWUgPT09ICdleHBlY3QnKSB7XG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCdleHBlY3QgaGVhZGVyIG5vdCBzdXBwb3J0ZWQnKVxuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QuaGVhZGVycy5wdXNoKGtleSwgdmFsKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdFxuIl0sIm5hbWVzIjpbIkludmFsaWRBcmd1bWVudEVycm9yIiwiTm90U3VwcG9ydGVkRXJyb3IiLCJyZXF1aXJlIiwiYXNzZXJ0IiwiaXNWYWxpZEhUVFBUb2tlbiIsImlzVmFsaWRIZWFkZXJWYWx1ZSIsImlzU3RyZWFtIiwiZGVzdHJveSIsImlzQnVmZmVyIiwiaXNGb3JtRGF0YUxpa2UiLCJpc0l0ZXJhYmxlIiwiaXNCbG9iTGlrZSIsImJ1aWxkVVJMIiwidmFsaWRhdGVIYW5kbGVyIiwiZ2V0U2VydmVyTmFtZSIsIm5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzIiwiY2hhbm5lbHMiLCJoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCIsImludmFsaWRQYXRoUmVnZXgiLCJrSGFuZGxlciIsIlN5bWJvbCIsIlJlcXVlc3QiLCJvcmlnaW4iLCJwYXRoIiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJxdWVyeSIsImlkZW1wb3RlbnQiLCJibG9ja2luZyIsInVwZ3JhZGUiLCJoZWFkZXJzVGltZW91dCIsImJvZHlUaW1lb3V0IiwicmVzZXQiLCJ0aHJvd09uRXJyb3IiLCJleHBlY3RDb250aW51ZSIsInNlcnZlcm5hbWUiLCJoYW5kbGVyIiwic3RhcnRzV2l0aCIsInRlc3QiLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImFib3J0IiwiclN0YXRlIiwiX3JlYWRhYmxlU3RhdGUiLCJhdXRvRGVzdHJveSIsImVuZEhhbmRsZXIiLCJvbiIsImVycm9ySGFuZGxlciIsImVyciIsImVycm9yIiwiYnl0ZUxlbmd0aCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImJ5dGVPZmZzZXQiLCJsZW5ndGgiLCJjb21wbGV0ZWQiLCJhYm9ydGVkIiwiaG9zdCIsImNvbnRlbnRMZW5ndGgiLCJjb250ZW50VHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJwcm9jZXNzSGVhZGVyIiwiaXRlcmF0b3IiLCJoZWFkZXIiLCJrZXlzIiwiT2JqZWN0IiwiY3JlYXRlIiwiaGFzU3Vic2NyaWJlcnMiLCJwdWJsaXNoIiwicmVxdWVzdCIsIm9uQm9keVNlbnQiLCJjaHVuayIsIm9uUmVxdWVzdFNlbnQiLCJib2R5U2VudCIsIm9uQ29ubmVjdCIsIm9uUmVzcG9uc2VTdGFydGVkIiwib25IZWFkZXJzIiwic3RhdHVzQ29kZSIsInJlc3VtZSIsInN0YXR1c1RleHQiLCJyZXNwb25zZSIsIm9uRGF0YSIsIm9uVXBncmFkZSIsInNvY2tldCIsIm9uQ29tcGxldGUiLCJ0cmFpbGVycyIsIm9uRmluYWxseSIsIm9uRXJyb3IiLCJvZmYiLCJhZGRIZWFkZXIiLCJrZXkiLCJ2YWx1ZSIsInZhbCIsImhlYWRlck5hbWUiLCJ0b0xvd2VyQ2FzZSIsImFyciIsInB1c2giLCJwYXJzZUludCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kClose: Symbol('close'),\n    kDestroy: Symbol('destroy'),\n    kDispatch: Symbol('dispatch'),\n    kUrl: Symbol('url'),\n    kWriting: Symbol('writing'),\n    kResuming: Symbol('resuming'),\n    kQueue: Symbol('queue'),\n    kConnect: Symbol('connect'),\n    kConnecting: Symbol('connecting'),\n    kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n    kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n    kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n    kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n    kKeepAlive: Symbol('keep alive'),\n    kHeadersTimeout: Symbol('headers timeout'),\n    kBodyTimeout: Symbol('body timeout'),\n    kServerName: Symbol('server name'),\n    kLocalAddress: Symbol('local address'),\n    kHost: Symbol('host'),\n    kNoRef: Symbol('no ref'),\n    kBodyUsed: Symbol('used'),\n    kBody: Symbol('abstracted request body'),\n    kRunning: Symbol('running'),\n    kBlocking: Symbol('blocking'),\n    kPending: Symbol('pending'),\n    kSize: Symbol('size'),\n    kBusy: Symbol('busy'),\n    kQueued: Symbol('queued'),\n    kFree: Symbol('free'),\n    kConnected: Symbol('connected'),\n    kClosed: Symbol('closed'),\n    kNeedDrain: Symbol('need drain'),\n    kReset: Symbol('reset'),\n    kDestroyed: Symbol.for('nodejs.stream.destroyed'),\n    kResume: Symbol('resume'),\n    kOnError: Symbol('on error'),\n    kMaxHeadersSize: Symbol('max headers size'),\n    kRunningIdx: Symbol('running index'),\n    kPendingIdx: Symbol('pending index'),\n    kError: Symbol('error'),\n    kClients: Symbol('clients'),\n    kClient: Symbol('client'),\n    kParser: Symbol('parser'),\n    kOnDestroyed: Symbol('destroy callbacks'),\n    kPipelining: Symbol('pipelining'),\n    kSocket: Symbol('socket'),\n    kHostHeader: Symbol('host header'),\n    kConnector: Symbol('connector'),\n    kStrictContentLength: Symbol('strict content length'),\n    kMaxRedirections: Symbol('maxRedirections'),\n    kMaxRequests: Symbol('maxRequestsPerClient'),\n    kProxy: Symbol('proxy agent options'),\n    kCounter: Symbol('socket request counter'),\n    kInterceptors: Symbol('dispatch interceptors'),\n    kMaxResponseSize: Symbol('max response size'),\n    kHTTP2Session: Symbol('http2Session'),\n    kHTTP2SessionState: Symbol('http2Session state'),\n    kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),\n    kConstruct: Symbol('constructable'),\n    kListeners: Symbol('listeners'),\n    kHTTPContext: Symbol('http context'),\n    kMaxConcurrentStreams: Symbol('max concurrent streams'),\n    kNoProxyAgent: Symbol('no proxy agent'),\n    kHttpProxyAgent: Symbol('http proxy agent'),\n    kHttpsProxyAgent: Symbol('https proxy agent')\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsUUFBUUMsT0FBTztJQUNmQyxVQUFVRCxPQUFPO0lBQ2pCRSxXQUFXRixPQUFPO0lBQ2xCRyxNQUFNSCxPQUFPO0lBQ2JJLFVBQVVKLE9BQU87SUFDakJLLFdBQVdMLE9BQU87SUFDbEJNLFFBQVFOLE9BQU87SUFDZk8sVUFBVVAsT0FBTztJQUNqQlEsYUFBYVIsT0FBTztJQUNwQlMsMEJBQTBCVCxPQUFPO0lBQ2pDVSxzQkFBc0JWLE9BQU87SUFDN0JXLDRCQUE0QlgsT0FBTztJQUNuQ1ksd0JBQXdCWixPQUFPO0lBQy9CYSxZQUFZYixPQUFPO0lBQ25CYyxpQkFBaUJkLE9BQU87SUFDeEJlLGNBQWNmLE9BQU87SUFDckJnQixhQUFhaEIsT0FBTztJQUNwQmlCLGVBQWVqQixPQUFPO0lBQ3RCa0IsT0FBT2xCLE9BQU87SUFDZG1CLFFBQVFuQixPQUFPO0lBQ2ZvQixXQUFXcEIsT0FBTztJQUNsQnFCLE9BQU9yQixPQUFPO0lBQ2RzQixVQUFVdEIsT0FBTztJQUNqQnVCLFdBQVd2QixPQUFPO0lBQ2xCd0IsVUFBVXhCLE9BQU87SUFDakJ5QixPQUFPekIsT0FBTztJQUNkMEIsT0FBTzFCLE9BQU87SUFDZDJCLFNBQVMzQixPQUFPO0lBQ2hCNEIsT0FBTzVCLE9BQU87SUFDZDZCLFlBQVk3QixPQUFPO0lBQ25COEIsU0FBUzlCLE9BQU87SUFDaEIrQixZQUFZL0IsT0FBTztJQUNuQmdDLFFBQVFoQyxPQUFPO0lBQ2ZpQyxZQUFZakMsT0FBT2tDLEdBQUcsQ0FBQztJQUN2QkMsU0FBU25DLE9BQU87SUFDaEJvQyxVQUFVcEMsT0FBTztJQUNqQnFDLGlCQUFpQnJDLE9BQU87SUFDeEJzQyxhQUFhdEMsT0FBTztJQUNwQnVDLGFBQWF2QyxPQUFPO0lBQ3BCd0MsUUFBUXhDLE9BQU87SUFDZnlDLFVBQVV6QyxPQUFPO0lBQ2pCMEMsU0FBUzFDLE9BQU87SUFDaEIyQyxTQUFTM0MsT0FBTztJQUNoQjRDLGNBQWM1QyxPQUFPO0lBQ3JCNkMsYUFBYTdDLE9BQU87SUFDcEI4QyxTQUFTOUMsT0FBTztJQUNoQitDLGFBQWEvQyxPQUFPO0lBQ3BCZ0QsWUFBWWhELE9BQU87SUFDbkJpRCxzQkFBc0JqRCxPQUFPO0lBQzdCa0Qsa0JBQWtCbEQsT0FBTztJQUN6Qm1ELGNBQWNuRCxPQUFPO0lBQ3JCb0QsUUFBUXBELE9BQU87SUFDZnFELFVBQVVyRCxPQUFPO0lBQ2pCc0QsZUFBZXRELE9BQU87SUFDdEJ1RCxrQkFBa0J2RCxPQUFPO0lBQ3pCd0QsZUFBZXhELE9BQU87SUFDdEJ5RCxvQkFBb0J6RCxPQUFPO0lBQzNCMEQsMkJBQTJCMUQsT0FBTztJQUNsQzJELFlBQVkzRCxPQUFPO0lBQ25CNEQsWUFBWTVELE9BQU87SUFDbkI2RCxjQUFjN0QsT0FBTztJQUNyQjhELHVCQUF1QjlELE9BQU87SUFDOUIrRCxlQUFlL0QsT0FBTztJQUN0QmdFLGlCQUFpQmhFLE9BQU87SUFDeEJpRSxrQkFBa0JqRSxPQUFPO0FBQzNCIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXHN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtDbG9zZTogU3ltYm9sKCdjbG9zZScpLFxuICBrRGVzdHJveTogU3ltYm9sKCdkZXN0cm95JyksXG4gIGtEaXNwYXRjaDogU3ltYm9sKCdkaXNwYXRjaCcpLFxuICBrVXJsOiBTeW1ib2woJ3VybCcpLFxuICBrV3JpdGluZzogU3ltYm9sKCd3cml0aW5nJyksXG4gIGtSZXN1bWluZzogU3ltYm9sKCdyZXN1bWluZycpLFxuICBrUXVldWU6IFN5bWJvbCgncXVldWUnKSxcbiAga0Nvbm5lY3Q6IFN5bWJvbCgnY29ubmVjdCcpLFxuICBrQ29ubmVjdGluZzogU3ltYm9sKCdjb25uZWN0aW5nJyksXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dDogU3ltYm9sKCdkZWZhdWx0IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dDogU3ltYm9sKCdtYXgga2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkOiBTeW1ib2woJ2tlZXAgYWxpdmUgdGltZW91dCB0aHJlc2hvbGQnKSxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZTogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZTogU3ltYm9sKCdrZWVwIGFsaXZlJyksXG4gIGtIZWFkZXJzVGltZW91dDogU3ltYm9sKCdoZWFkZXJzIHRpbWVvdXQnKSxcbiAga0JvZHlUaW1lb3V0OiBTeW1ib2woJ2JvZHkgdGltZW91dCcpLFxuICBrU2VydmVyTmFtZTogU3ltYm9sKCdzZXJ2ZXIgbmFtZScpLFxuICBrTG9jYWxBZGRyZXNzOiBTeW1ib2woJ2xvY2FsIGFkZHJlc3MnKSxcbiAga0hvc3Q6IFN5bWJvbCgnaG9zdCcpLFxuICBrTm9SZWY6IFN5bWJvbCgnbm8gcmVmJyksXG4gIGtCb2R5VXNlZDogU3ltYm9sKCd1c2VkJyksXG4gIGtCb2R5OiBTeW1ib2woJ2Fic3RyYWN0ZWQgcmVxdWVzdCBib2R5JyksXG4gIGtSdW5uaW5nOiBTeW1ib2woJ3J1bm5pbmcnKSxcbiAga0Jsb2NraW5nOiBTeW1ib2woJ2Jsb2NraW5nJyksXG4gIGtQZW5kaW5nOiBTeW1ib2woJ3BlbmRpbmcnKSxcbiAga1NpemU6IFN5bWJvbCgnc2l6ZScpLFxuICBrQnVzeTogU3ltYm9sKCdidXN5JyksXG4gIGtRdWV1ZWQ6IFN5bWJvbCgncXVldWVkJyksXG4gIGtGcmVlOiBTeW1ib2woJ2ZyZWUnKSxcbiAga0Nvbm5lY3RlZDogU3ltYm9sKCdjb25uZWN0ZWQnKSxcbiAga0Nsb3NlZDogU3ltYm9sKCdjbG9zZWQnKSxcbiAga05lZWREcmFpbjogU3ltYm9sKCduZWVkIGRyYWluJyksXG4gIGtSZXNldDogU3ltYm9sKCdyZXNldCcpLFxuICBrRGVzdHJveWVkOiBTeW1ib2wuZm9yKCdub2RlanMuc3RyZWFtLmRlc3Ryb3llZCcpLFxuICBrUmVzdW1lOiBTeW1ib2woJ3Jlc3VtZScpLFxuICBrT25FcnJvcjogU3ltYm9sKCdvbiBlcnJvcicpLFxuICBrTWF4SGVhZGVyc1NpemU6IFN5bWJvbCgnbWF4IGhlYWRlcnMgc2l6ZScpLFxuICBrUnVubmluZ0lkeDogU3ltYm9sKCdydW5uaW5nIGluZGV4JyksXG4gIGtQZW5kaW5nSWR4OiBTeW1ib2woJ3BlbmRpbmcgaW5kZXgnKSxcbiAga0Vycm9yOiBTeW1ib2woJ2Vycm9yJyksXG4gIGtDbGllbnRzOiBTeW1ib2woJ2NsaWVudHMnKSxcbiAga0NsaWVudDogU3ltYm9sKCdjbGllbnQnKSxcbiAga1BhcnNlcjogU3ltYm9sKCdwYXJzZXInKSxcbiAga09uRGVzdHJveWVkOiBTeW1ib2woJ2Rlc3Ryb3kgY2FsbGJhY2tzJyksXG4gIGtQaXBlbGluaW5nOiBTeW1ib2woJ3BpcGVsaW5pbmcnKSxcbiAga1NvY2tldDogU3ltYm9sKCdzb2NrZXQnKSxcbiAga0hvc3RIZWFkZXI6IFN5bWJvbCgnaG9zdCBoZWFkZXInKSxcbiAga0Nvbm5lY3RvcjogU3ltYm9sKCdjb25uZWN0b3InKSxcbiAga1N0cmljdENvbnRlbnRMZW5ndGg6IFN5bWJvbCgnc3RyaWN0IGNvbnRlbnQgbGVuZ3RoJyksXG4gIGtNYXhSZWRpcmVjdGlvbnM6IFN5bWJvbCgnbWF4UmVkaXJlY3Rpb25zJyksXG4gIGtNYXhSZXF1ZXN0czogU3ltYm9sKCdtYXhSZXF1ZXN0c1BlckNsaWVudCcpLFxuICBrUHJveHk6IFN5bWJvbCgncHJveHkgYWdlbnQgb3B0aW9ucycpLFxuICBrQ291bnRlcjogU3ltYm9sKCdzb2NrZXQgcmVxdWVzdCBjb3VudGVyJyksXG4gIGtJbnRlcmNlcHRvcnM6IFN5bWJvbCgnZGlzcGF0Y2ggaW50ZXJjZXB0b3JzJyksXG4gIGtNYXhSZXNwb25zZVNpemU6IFN5bWJvbCgnbWF4IHJlc3BvbnNlIHNpemUnKSxcbiAga0hUVFAyU2Vzc2lvbjogU3ltYm9sKCdodHRwMlNlc3Npb24nKSxcbiAga0hUVFAyU2Vzc2lvblN0YXRlOiBTeW1ib2woJ2h0dHAyU2Vzc2lvbiBzdGF0ZScpLFxuICBrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5OiBTeW1ib2woJ3JldHJ5IGFnZW50IGRlZmF1bHQgcmV0cnknKSxcbiAga0NvbnN0cnVjdDogU3ltYm9sKCdjb25zdHJ1Y3RhYmxlJyksXG4gIGtMaXN0ZW5lcnM6IFN5bWJvbCgnbGlzdGVuZXJzJyksXG4gIGtIVFRQQ29udGV4dDogU3ltYm9sKCdodHRwIGNvbnRleHQnKSxcbiAga01heENvbmN1cnJlbnRTdHJlYW1zOiBTeW1ib2woJ21heCBjb25jdXJyZW50IHN0cmVhbXMnKSxcbiAga05vUHJveHlBZ2VudDogU3ltYm9sKCdubyBwcm94eSBhZ2VudCcpLFxuICBrSHR0cFByb3h5QWdlbnQ6IFN5bWJvbCgnaHR0cCBwcm94eSBhZ2VudCcpLFxuICBrSHR0cHNQcm94eUFnZW50OiBTeW1ib2woJ2h0dHBzIHByb3h5IGFnZW50Jylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia0Nsb3NlIiwiU3ltYm9sIiwia0Rlc3Ryb3kiLCJrRGlzcGF0Y2giLCJrVXJsIiwia1dyaXRpbmciLCJrUmVzdW1pbmciLCJrUXVldWUiLCJrQ29ubmVjdCIsImtDb25uZWN0aW5nIiwia0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0Iiwia0tlZXBBbGl2ZU1heFRpbWVvdXQiLCJrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCIsImtLZWVwQWxpdmVUaW1lb3V0VmFsdWUiLCJrS2VlcEFsaXZlIiwia0hlYWRlcnNUaW1lb3V0Iiwia0JvZHlUaW1lb3V0Iiwia1NlcnZlck5hbWUiLCJrTG9jYWxBZGRyZXNzIiwia0hvc3QiLCJrTm9SZWYiLCJrQm9keVVzZWQiLCJrQm9keSIsImtSdW5uaW5nIiwia0Jsb2NraW5nIiwia1BlbmRpbmciLCJrU2l6ZSIsImtCdXN5Iiwia1F1ZXVlZCIsImtGcmVlIiwia0Nvbm5lY3RlZCIsImtDbG9zZWQiLCJrTmVlZERyYWluIiwia1Jlc2V0Iiwia0Rlc3Ryb3llZCIsImZvciIsImtSZXN1bWUiLCJrT25FcnJvciIsImtNYXhIZWFkZXJzU2l6ZSIsImtSdW5uaW5nSWR4Iiwia1BlbmRpbmdJZHgiLCJrRXJyb3IiLCJrQ2xpZW50cyIsImtDbGllbnQiLCJrUGFyc2VyIiwia09uRGVzdHJveWVkIiwia1BpcGVsaW5pbmciLCJrU29ja2V0Iiwia0hvc3RIZWFkZXIiLCJrQ29ubmVjdG9yIiwia1N0cmljdENvbnRlbnRMZW5ndGgiLCJrTWF4UmVkaXJlY3Rpb25zIiwia01heFJlcXVlc3RzIiwia1Byb3h5Iiwia0NvdW50ZXIiLCJrSW50ZXJjZXB0b3JzIiwia01heFJlc3BvbnNlU2l6ZSIsImtIVFRQMlNlc3Npb24iLCJrSFRUUDJTZXNzaW9uU3RhdGUiLCJrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5Iiwia0NvbnN0cnVjdCIsImtMaXN0ZW5lcnMiLCJrSFRUUENvbnRleHQiLCJrTWF4Q29uY3VycmVudFN0cmVhbXMiLCJrTm9Qcm94eUFnZW50Iiwia0h0dHBQcm94eUFnZW50Iiwia0h0dHBzUHJveHlBZ2VudCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/tree.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/tree.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { wellknownHeaderNames, headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\");\nclass TstNode {\n    /**\n   * @param {string} key\n   * @param {any} value\n   * @param {number} index\n   */ constructor(key, value, index){\n        /** @type {any} */ this.value = null;\n        /** @type {null | TstNode} */ this.left = null;\n        /** @type {null | TstNode} */ this.middle = null;\n        /** @type {null | TstNode} */ this.right = null;\n        if (index === undefined || index >= key.length) {\n            throw new TypeError('Unreachable');\n        }\n        const code = this.code = key.charCodeAt(index);\n        // check code is ascii string\n        if (code > 0x7F) {\n            throw new TypeError('key must be ascii string');\n        }\n        if (key.length !== ++index) {\n            this.middle = new TstNode(key, value, index);\n        } else {\n            this.value = value;\n        }\n    }\n    /**\n   * @param {string} key\n   * @param {any} value\n   */ add(key, value) {\n        const length = key.length;\n        if (length === 0) {\n            throw new TypeError('Unreachable');\n        }\n        let index = 0;\n        let node = this;\n        while(true){\n            const code = key.charCodeAt(index);\n            // check code is ascii string\n            if (code > 0x7F) {\n                throw new TypeError('key must be ascii string');\n            }\n            if (node.code === code) {\n                if (length === ++index) {\n                    node.value = value;\n                    break;\n                } else if (node.middle !== null) {\n                    node = node.middle;\n                } else {\n                    node.middle = new TstNode(key, value, index);\n                    break;\n                }\n            } else if (node.code < code) {\n                if (node.left !== null) {\n                    node = node.left;\n                } else {\n                    node.left = new TstNode(key, value, index);\n                    break;\n                }\n            } else if (node.right !== null) {\n                node = node.right;\n            } else {\n                node.right = new TstNode(key, value, index);\n                break;\n            }\n        }\n    }\n    /**\n   * @param {Uint8Array} key\n   * @return {TstNode | null}\n   */ search(key) {\n        const keylength = key.length;\n        let index = 0;\n        let node = this;\n        while(node !== null && index < keylength){\n            let code = key[index];\n            // A-Z\n            // First check if it is bigger than 0x5a.\n            // Lowercase letters have higher char codes than uppercase ones.\n            // Also we assume that headers will mostly contain lowercase characters.\n            if (code <= 0x5a && code >= 0x41) {\n                // Lowercase for uppercase.\n                code |= 32;\n            }\n            while(node !== null){\n                if (code === node.code) {\n                    if (keylength === ++index) {\n                        // Returns Node since it is the last key.\n                        return node;\n                    }\n                    node = node.middle;\n                    break;\n                }\n                node = node.code < code ? node.left : node.right;\n            }\n        }\n        return null;\n    }\n}\nclass TernarySearchTree {\n    /**\n   * @param {string} key\n   * @param {any} value\n   * */ insert(key, value) {\n        if (this.node === null) {\n            this.node = new TstNode(key, value, 0);\n        } else {\n            this.node.add(key, value);\n        }\n    }\n    /**\n   * @param {Uint8Array} key\n   * @return {any}\n   */ lookup(key) {\n        return this.node?.search(key)?.value ?? null;\n    }\n    constructor(){\n        /** @type {TstNode | null} */ this.node = null;\n    }\n}\nconst tree = new TernarySearchTree();\nfor(let i = 0; i < wellknownHeaderNames.length; ++i){\n    const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];\n    tree.insert(key, key);\n}\nmodule.exports = {\n    TernarySearchTree,\n    tree\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3RyZWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLG9CQUFvQixFQUNwQkMsMEJBQTBCLEVBQzNCLEdBQUdDLG1CQUFPQSxDQUFDLHNFQUFhO0FBRXpCLE1BQU1DO0lBV0o7Ozs7R0FJQyxHQUNELFlBQWFDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLENBQUU7UUFmaEMsZ0JBQWdCLFFBQ2hCRCxRQUFRO1FBQ1IsMkJBQTJCLFFBQzNCRSxPQUFPO1FBQ1AsMkJBQTJCLFFBQzNCQyxTQUFTO1FBQ1QsMkJBQTJCLFFBQzNCQyxRQUFRO1FBU04sSUFBSUgsVUFBVUksYUFBYUosU0FBU0YsSUFBSU8sTUFBTSxFQUFFO1lBQzlDLE1BQU0sSUFBSUMsVUFBVTtRQUN0QjtRQUNBLE1BQU1DLE9BQU8sSUFBSSxDQUFDQSxJQUFJLEdBQUdULElBQUlVLFVBQVUsQ0FBQ1I7UUFDeEMsNkJBQTZCO1FBQzdCLElBQUlPLE9BQU8sTUFBTTtZQUNmLE1BQU0sSUFBSUQsVUFBVTtRQUN0QjtRQUNBLElBQUlSLElBQUlPLE1BQU0sS0FBSyxFQUFFTCxPQUFPO1lBQzFCLElBQUksQ0FBQ0UsTUFBTSxHQUFHLElBQUlMLFFBQVFDLEtBQUtDLE9BQU9DO1FBQ3hDLE9BQU87WUFDTCxJQUFJLENBQUNELEtBQUssR0FBR0E7UUFDZjtJQUNGO0lBRUE7OztHQUdDLEdBQ0RVLElBQUtYLEdBQUcsRUFBRUMsS0FBSyxFQUFFO1FBQ2YsTUFBTU0sU0FBU1AsSUFBSU8sTUFBTTtRQUN6QixJQUFJQSxXQUFXLEdBQUc7WUFDaEIsTUFBTSxJQUFJQyxVQUFVO1FBQ3RCO1FBQ0EsSUFBSU4sUUFBUTtRQUNaLElBQUlVLE9BQU8sSUFBSTtRQUNmLE1BQU8sS0FBTTtZQUNYLE1BQU1ILE9BQU9ULElBQUlVLFVBQVUsQ0FBQ1I7WUFDNUIsNkJBQTZCO1lBQzdCLElBQUlPLE9BQU8sTUFBTTtnQkFDZixNQUFNLElBQUlELFVBQVU7WUFDdEI7WUFDQSxJQUFJSSxLQUFLSCxJQUFJLEtBQUtBLE1BQU07Z0JBQ3RCLElBQUlGLFdBQVcsRUFBRUwsT0FBTztvQkFDdEJVLEtBQUtYLEtBQUssR0FBR0E7b0JBQ2I7Z0JBQ0YsT0FBTyxJQUFJVyxLQUFLUixNQUFNLEtBQUssTUFBTTtvQkFDL0JRLE9BQU9BLEtBQUtSLE1BQU07Z0JBQ3BCLE9BQU87b0JBQ0xRLEtBQUtSLE1BQU0sR0FBRyxJQUFJTCxRQUFRQyxLQUFLQyxPQUFPQztvQkFDdEM7Z0JBQ0Y7WUFDRixPQUFPLElBQUlVLEtBQUtILElBQUksR0FBR0EsTUFBTTtnQkFDM0IsSUFBSUcsS0FBS1QsSUFBSSxLQUFLLE1BQU07b0JBQ3RCUyxPQUFPQSxLQUFLVCxJQUFJO2dCQUNsQixPQUFPO29CQUNMUyxLQUFLVCxJQUFJLEdBQUcsSUFBSUosUUFBUUMsS0FBS0MsT0FBT0M7b0JBQ3BDO2dCQUNGO1lBQ0YsT0FBTyxJQUFJVSxLQUFLUCxLQUFLLEtBQUssTUFBTTtnQkFDOUJPLE9BQU9BLEtBQUtQLEtBQUs7WUFDbkIsT0FBTztnQkFDTE8sS0FBS1AsS0FBSyxHQUFHLElBQUlOLFFBQVFDLEtBQUtDLE9BQU9DO2dCQUNyQztZQUNGO1FBQ0Y7SUFDRjtJQUVBOzs7R0FHQyxHQUNEVyxPQUFRYixHQUFHLEVBQUU7UUFDWCxNQUFNYyxZQUFZZCxJQUFJTyxNQUFNO1FBQzVCLElBQUlMLFFBQVE7UUFDWixJQUFJVSxPQUFPLElBQUk7UUFDZixNQUFPQSxTQUFTLFFBQVFWLFFBQVFZLFVBQVc7WUFDekMsSUFBSUwsT0FBT1QsR0FBRyxDQUFDRSxNQUFNO1lBQ3JCLE1BQU07WUFDTix5Q0FBeUM7WUFDekMsZ0VBQWdFO1lBQ2hFLHdFQUF3RTtZQUN4RSxJQUFJTyxRQUFRLFFBQVFBLFFBQVEsTUFBTTtnQkFDaEMsMkJBQTJCO2dCQUMzQkEsUUFBUTtZQUNWO1lBQ0EsTUFBT0csU0FBUyxLQUFNO2dCQUNwQixJQUFJSCxTQUFTRyxLQUFLSCxJQUFJLEVBQUU7b0JBQ3RCLElBQUlLLGNBQWMsRUFBRVosT0FBTzt3QkFDekIseUNBQXlDO3dCQUN6QyxPQUFPVTtvQkFDVDtvQkFDQUEsT0FBT0EsS0FBS1IsTUFBTTtvQkFDbEI7Z0JBQ0Y7Z0JBQ0FRLE9BQU9BLEtBQUtILElBQUksR0FBR0EsT0FBT0csS0FBS1QsSUFBSSxHQUFHUyxLQUFLUCxLQUFLO1lBQ2xEO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7QUFDRjtBQUVBLE1BQU1VO0lBSUo7OztLQUdHLEdBQ0hDLE9BQVFoQixHQUFHLEVBQUVDLEtBQUssRUFBRTtRQUNsQixJQUFJLElBQUksQ0FBQ1csSUFBSSxLQUFLLE1BQU07WUFDdEIsSUFBSSxDQUFDQSxJQUFJLEdBQUcsSUFBSWIsUUFBUUMsS0FBS0MsT0FBTztRQUN0QyxPQUFPO1lBQ0wsSUFBSSxDQUFDVyxJQUFJLENBQUNELEdBQUcsQ0FBQ1gsS0FBS0M7UUFDckI7SUFDRjtJQUVBOzs7R0FHQyxHQUNEZ0IsT0FBUWpCLEdBQUcsRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDWSxJQUFJLEVBQUVDLE9BQU9iLE1BQU1DLFNBQVM7SUFDMUM7O1FBckJBLDJCQUEyQixRQUMzQlcsT0FBTzs7QUFxQlQ7QUFFQSxNQUFNTSxPQUFPLElBQUlIO0FBRWpCLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJdkIscUJBQXFCVyxNQUFNLEVBQUUsRUFBRVksRUFBRztJQUNwRCxNQUFNbkIsTUFBTUgsMEJBQTBCLENBQUNELG9CQUFvQixDQUFDdUIsRUFBRSxDQUFDO0lBQy9ERCxLQUFLRixNQUFNLENBQUNoQixLQUFLQTtBQUNuQjtBQUVBb0IsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZOO0lBQ0FHO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxcdHJlZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICB3ZWxsa25vd25IZWFkZXJOYW1lcyxcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNsYXNzIFRzdE5vZGUge1xuICAvKiogQHR5cGUge2FueX0gKi9cbiAgdmFsdWUgPSBudWxsXG4gIC8qKiBAdHlwZSB7bnVsbCB8IFRzdE5vZGV9ICovXG4gIGxlZnQgPSBudWxsXG4gIC8qKiBAdHlwZSB7bnVsbCB8IFRzdE5vZGV9ICovXG4gIG1pZGRsZSA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgcmlnaHQgPSBudWxsXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICBjb2RlXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID49IGtleS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVhY2hhYmxlJylcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IHRoaXMuY29kZSA9IGtleS5jaGFyQ29kZUF0KGluZGV4KVxuICAgIC8vIGNoZWNrIGNvZGUgaXMgYXNjaWkgc3RyaW5nXG4gICAgaWYgKGNvZGUgPiAweDdGKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXkgbXVzdCBiZSBhc2NpaSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gKytpbmRleCkge1xuICAgICAgdGhpcy5taWRkbGUgPSBuZXcgVHN0Tm9kZShrZXksIHZhbHVlLCBpbmRleClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqL1xuICBhZGQgKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBsZW5ndGggPSBrZXkubGVuZ3RoXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgIH1cbiAgICBsZXQgaW5kZXggPSAwXG4gICAgbGV0IG5vZGUgPSB0aGlzXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBrZXkuY2hhckNvZGVBdChpbmRleClcbiAgICAgIC8vIGNoZWNrIGNvZGUgaXMgYXNjaWkgc3RyaW5nXG4gICAgICBpZiAoY29kZSA+IDB4N0YpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5IG11c3QgYmUgYXNjaWkgc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNvZGUgPT09IGNvZGUpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gKytpbmRleCkge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5taWRkbGUgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5taWRkbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLm1pZGRsZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jb2RlIDwgY29kZSkge1xuICAgICAgICBpZiAobm9kZS5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubGVmdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubGVmdCA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbm9kZS5yaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yaWdodCA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGtleVxuICAgKiBAcmV0dXJuIHtUc3ROb2RlIHwgbnVsbH1cbiAgICovXG4gIHNlYXJjaCAoa2V5KSB7XG4gICAgY29uc3Qga2V5bGVuZ3RoID0ga2V5Lmxlbmd0aFxuICAgIGxldCBpbmRleCA9IDBcbiAgICBsZXQgbm9kZSA9IHRoaXNcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBpbmRleCA8IGtleWxlbmd0aCkge1xuICAgICAgbGV0IGNvZGUgPSBrZXlbaW5kZXhdXG4gICAgICAvLyBBLVpcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIGl0IGlzIGJpZ2dlciB0aGFuIDB4NWEuXG4gICAgICAvLyBMb3dlcmNhc2UgbGV0dGVycyBoYXZlIGhpZ2hlciBjaGFyIGNvZGVzIHRoYW4gdXBwZXJjYXNlIG9uZXMuXG4gICAgICAvLyBBbHNvIHdlIGFzc3VtZSB0aGF0IGhlYWRlcnMgd2lsbCBtb3N0bHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycy5cbiAgICAgIGlmIChjb2RlIDw9IDB4NWEgJiYgY29kZSA+PSAweDQxKSB7XG4gICAgICAgIC8vIExvd2VyY2FzZSBmb3IgdXBwZXJjYXNlLlxuICAgICAgICBjb2RlIHw9IDMyXG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY29kZSA9PT0gbm9kZS5jb2RlKSB7XG4gICAgICAgICAgaWYgKGtleWxlbmd0aCA9PT0gKytpbmRleCkge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBOb2RlIHNpbmNlIGl0IGlzIHRoZSBsYXN0IGtleS5cbiAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLm1pZGRsZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUuY29kZSA8IGNvZGUgPyBub2RlLmxlZnQgOiBub2RlLnJpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY2xhc3MgVGVybmFyeVNlYXJjaFRyZWUge1xuICAvKiogQHR5cGUge1RzdE5vZGUgfCBudWxsfSAqL1xuICBub2RlID0gbnVsbFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiAqL1xuICBpbnNlcnQgKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5ub2RlID09PSBudWxsKSB7XG4gICAgICB0aGlzLm5vZGUgPSBuZXcgVHN0Tm9kZShrZXksIHZhbHVlLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGUuYWRkKGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0ga2V5XG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGxvb2t1cCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZT8uc2VhcmNoKGtleSk/LnZhbHVlID8/IG51bGxcbiAgfVxufVxuXG5jb25zdCB0cmVlID0gbmV3IFRlcm5hcnlTZWFyY2hUcmVlKClcblxuZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWxsa25vd25IZWFkZXJOYW1lcy5sZW5ndGg7ICsraSkge1xuICBjb25zdCBrZXkgPSBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFt3ZWxsa25vd25IZWFkZXJOYW1lc1tpXV1cbiAgdHJlZS5pbnNlcnQoa2V5LCBrZXkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUZXJuYXJ5U2VhcmNoVHJlZSxcbiAgdHJlZVxufVxuIl0sIm5hbWVzIjpbIndlbGxrbm93bkhlYWRlck5hbWVzIiwiaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQiLCJyZXF1aXJlIiwiVHN0Tm9kZSIsImtleSIsInZhbHVlIiwiaW5kZXgiLCJsZWZ0IiwibWlkZGxlIiwicmlnaHQiLCJ1bmRlZmluZWQiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJjb2RlIiwiY2hhckNvZGVBdCIsImFkZCIsIm5vZGUiLCJzZWFyY2giLCJrZXlsZW5ndGgiLCJUZXJuYXJ5U2VhcmNoVHJlZSIsImluc2VydCIsImxvb2t1cCIsInRyZWUiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/tree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { kDestroyed, kBodyUsed, kListeners, kBody } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { IncomingMessage } = __webpack_require__(/*! node:http */ \"node:http\");\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst net = __webpack_require__(/*! node:net */ \"node:net\");\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\");\nconst { stringify } = __webpack_require__(/*! node:querystring */ \"node:querystring\");\nconst { EventEmitter: EE } = __webpack_require__(/*! node:events */ \"node:events\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\");\nconst { tree } = __webpack_require__(/*! ./tree */ \"(ssr)/./node_modules/undici/lib/core/tree.js\");\nconst [nodeMajor, nodeMinor] = process.versions.node.split('.').map((v)=>Number(v));\nclass BodyAsyncIterable {\n    constructor(body){\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n    }\n    async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], 'disturbed');\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n    }\n}\nfunction wrapRequestBody(body) {\n    if (isStream(body)) {\n        // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n        // so that it can be dispatched again?\n        // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n        if (bodyLength(body) === 0) {\n            body.on('data', function() {\n                assert(false);\n            });\n        }\n        if (typeof body.readableDidRead !== 'boolean') {\n            body[kBodyUsed] = false;\n            EE.prototype.on.call(body, 'data', function() {\n                this[kBodyUsed] = true;\n            });\n        }\n        return body;\n    } else if (body && typeof body.pipeTo === 'function') {\n        // TODO (fix): We can't access ReadableStream internal state\n        // to determine whether or not it has been disturbed. This is just\n        // a workaround.\n        return new BodyAsyncIterable(body);\n    } else if (body && typeof body !== 'string' && !ArrayBuffer.isView(body) && isIterable(body)) {\n        // TODO: Should we allow re-using iterable if !this.opts.idempotent\n        // or through some other flag?\n        return new BodyAsyncIterable(body);\n    } else {\n        return body;\n    }\n}\nfunction nop() {}\nfunction isStream(obj) {\n    return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function';\n}\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike(object) {\n    if (object === null) {\n        return false;\n    } else if (object instanceof Blob) {\n        return true;\n    } else if (typeof object !== 'object') {\n        return false;\n    } else {\n        const sTag = object[Symbol.toStringTag];\n        return (sTag === 'Blob' || sTag === 'File') && ('stream' in object && typeof object.stream === 'function' || 'arrayBuffer' in object && typeof object.arrayBuffer === 'function');\n    }\n}\nfunction buildURL(url, queryParams) {\n    if (url.includes('?') || url.includes('#')) {\n        throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n    }\n    const stringified = stringify(queryParams);\n    if (stringified) {\n        url += '?' + stringified;\n    }\n    return url;\n}\nfunction isValidPort(port) {\n    const value = parseInt(port, 10);\n    return value === Number(port) && value >= 0 && value <= 65535;\n}\nfunction isHttpOrHttpsPrefixed(value) {\n    return value != null && value[0] === 'h' && value[1] === 't' && value[2] === 't' && value[3] === 'p' && (value[4] === ':' || value[4] === 's' && value[5] === ':');\n}\nfunction parseURL(url) {\n    if (typeof url === 'string') {\n        url = new URL(url);\n        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n            throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');\n        }\n        return url;\n    }\n    if (!url || typeof url !== 'object') {\n        throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.');\n    }\n    if (!(url instanceof URL)) {\n        if (url.port != null && url.port !== '' && isValidPort(url.port) === false) {\n            throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.');\n        }\n        if (url.path != null && typeof url.path !== 'string') {\n            throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.');\n        }\n        if (url.pathname != null && typeof url.pathname !== 'string') {\n            throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.');\n        }\n        if (url.hostname != null && typeof url.hostname !== 'string') {\n            throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.');\n        }\n        if (url.origin != null && typeof url.origin !== 'string') {\n            throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.');\n        }\n        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n            throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');\n        }\n        const port = url.port != null ? url.port : url.protocol === 'https:' ? 443 : 80;\n        let origin = url.origin != null ? url.origin : `${url.protocol || ''}//${url.hostname || ''}:${port}`;\n        let path = url.path != null ? url.path : `${url.pathname || ''}${url.search || ''}`;\n        if (origin[origin.length - 1] === '/') {\n            origin = origin.slice(0, origin.length - 1);\n        }\n        if (path && path[0] !== '/') {\n            path = `/${path}`;\n        }\n        // new URL(path, origin) is unsafe when `path` contains an absolute URL\n        // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n        // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n        // If first parameter is an absolute URL, a given second param will be ignored.\n        return new URL(`${origin}${path}`);\n    }\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n        throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');\n    }\n    return url;\n}\nfunction parseOrigin(url) {\n    url = parseURL(url);\n    if (url.pathname !== '/' || url.search || url.hash) {\n        throw new InvalidArgumentError('invalid url');\n    }\n    return url;\n}\nfunction getHostname(host) {\n    if (host[0] === '[') {\n        const idx = host.indexOf(']');\n        assert(idx !== -1);\n        return host.substring(1, idx);\n    }\n    const idx = host.indexOf(':');\n    if (idx === -1) return host;\n    return host.substring(0, idx);\n}\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName(host) {\n    if (!host) {\n        return null;\n    }\n    assert.strictEqual(typeof host, 'string');\n    const servername = getHostname(host);\n    if (net.isIP(servername)) {\n        return '';\n    }\n    return servername;\n}\nfunction deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nfunction isAsyncIterable(obj) {\n    return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function');\n}\nfunction isIterable(obj) {\n    return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'));\n}\nfunction bodyLength(body) {\n    if (body == null) {\n        return 0;\n    } else if (isStream(body)) {\n        const state = body._readableState;\n        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;\n    } else if (isBlobLike(body)) {\n        return body.size != null ? body.size : null;\n    } else if (isBuffer(body)) {\n        return body.byteLength;\n    }\n    return null;\n}\nfunction isDestroyed(body) {\n    return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));\n}\nfunction destroy(stream, err) {\n    if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n        return;\n    }\n    if (typeof stream.destroy === 'function') {\n        if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n            // See: https://github.com/nodejs/node/pull/38505/files\n            stream.socket = null;\n        }\n        stream.destroy(err);\n    } else if (err) {\n        queueMicrotask(()=>{\n            stream.emit('error', err);\n        });\n    }\n    if (stream.destroyed !== true) {\n        stream[kDestroyed] = true;\n    }\n}\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/;\nfunction parseKeepAliveTimeout(val) {\n    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);\n    return m ? parseInt(m[1], 10) * 1000 : null;\n}\n/**\n * Retrieves a header name and returns its lowercase value.\n * @param {string | Buffer} value Header name\n * @returns {string}\n */ function headerNameToString(value) {\n    return typeof value === 'string' ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString('latin1').toLowerCase();\n}\n/**\n * Receive the buffer as a string and return its lowercase value.\n * @param {Buffer} value Header name\n * @returns {string}\n */ function bufferToLowerCasedHeaderName(value) {\n    return tree.lookup(value) ?? value.toString('latin1').toLowerCase();\n}\n/**\n * @param {Record<string, string | string[]> | (Buffer | string | (Buffer | string)[])[]} headers\n * @param {Record<string, string | string[]>} [obj]\n * @returns {Record<string, string | string[]>}\n */ function parseHeaders(headers, obj) {\n    if (obj === undefined) obj = {};\n    for(let i = 0; i < headers.length; i += 2){\n        const key = headerNameToString(headers[i]);\n        let val = obj[key];\n        if (val) {\n            if (typeof val === 'string') {\n                val = [\n                    val\n                ];\n                obj[key] = val;\n            }\n            val.push(headers[i + 1].toString('utf8'));\n        } else {\n            const headersValue = headers[i + 1];\n            if (typeof headersValue === 'string') {\n                obj[key] = headersValue;\n            } else {\n                obj[key] = Array.isArray(headersValue) ? headersValue.map((x)=>x.toString('utf8')) : headersValue.toString('utf8');\n            }\n        }\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if ('content-length' in obj && 'content-disposition' in obj) {\n        obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1');\n    }\n    return obj;\n}\nfunction parseRawHeaders(headers) {\n    const len = headers.length;\n    const ret = new Array(len);\n    let hasContentLength = false;\n    let contentDispositionIdx = -1;\n    let key;\n    let val;\n    let kLen = 0;\n    for(let n = 0; n < headers.length; n += 2){\n        key = headers[n];\n        val = headers[n + 1];\n        typeof key !== 'string' && (key = key.toString());\n        typeof val !== 'string' && (val = val.toString('utf8'));\n        kLen = key.length;\n        if (kLen === 14 && key[7] === '-' && (key === 'content-length' || key.toLowerCase() === 'content-length')) {\n            hasContentLength = true;\n        } else if (kLen === 19 && key[7] === '-' && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {\n            contentDispositionIdx = n + 1;\n        }\n        ret[n] = key;\n        ret[n + 1] = val;\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (hasContentLength && contentDispositionIdx !== -1) {\n        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1');\n    }\n    return ret;\n}\nfunction isBuffer(buffer) {\n    // See, https://github.com/mcollina/undici/pull/319\n    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);\n}\nfunction validateHandler(handler, method, upgrade) {\n    if (!handler || typeof handler !== 'object') {\n        throw new InvalidArgumentError('handler must be an object');\n    }\n    if (typeof handler.onConnect !== 'function') {\n        throw new InvalidArgumentError('invalid onConnect method');\n    }\n    if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method');\n    }\n    if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n        throw new InvalidArgumentError('invalid onBodySent method');\n    }\n    if (upgrade || method === 'CONNECT') {\n        if (typeof handler.onUpgrade !== 'function') {\n            throw new InvalidArgumentError('invalid onUpgrade method');\n        }\n    } else {\n        if (typeof handler.onHeaders !== 'function') {\n            throw new InvalidArgumentError('invalid onHeaders method');\n        }\n        if (typeof handler.onData !== 'function') {\n            throw new InvalidArgumentError('invalid onData method');\n        }\n        if (typeof handler.onComplete !== 'function') {\n            throw new InvalidArgumentError('invalid onComplete method');\n        }\n    }\n}\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed(body) {\n    // TODO (fix): Why is body[kBodyUsed] needed?\n    return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));\n}\nfunction isErrored(body) {\n    return !!(body && stream.isErrored(body));\n}\nfunction isReadable(body) {\n    return !!(body && stream.isReadable(body));\n}\nfunction getSocketInfo(socket) {\n    return {\n        localAddress: socket.localAddress,\n        localPort: socket.localPort,\n        remoteAddress: socket.remoteAddress,\n        remotePort: socket.remotePort,\n        remoteFamily: socket.remoteFamily,\n        timeout: socket.timeout,\n        bytesWritten: socket.bytesWritten,\n        bytesRead: socket.bytesRead\n    };\n}\n/** @type {globalThis['ReadableStream']} */ function ReadableStreamFrom(iterable) {\n    // We cannot use ReadableStream.from here because it does not return a byte stream.\n    let iterator;\n    return new ReadableStream({\n        async start () {\n            iterator = iterable[Symbol.asyncIterator]();\n        },\n        async pull (controller) {\n            const { done, value } = await iterator.next();\n            if (done) {\n                queueMicrotask(()=>{\n                    controller.close();\n                    controller.byobRequest?.respond(0);\n                });\n            } else {\n                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);\n                if (buf.byteLength) {\n                    controller.enqueue(new Uint8Array(buf));\n                }\n            }\n            return controller.desiredSize > 0;\n        },\n        async cancel (reason) {\n            await iterator.return();\n        },\n        type: 'bytes'\n    });\n}\n// The chunk should be a FormData instance and contains\n// all the required methods.\nfunction isFormDataLike(object) {\n    return object && typeof object === 'object' && typeof object.append === 'function' && typeof object.delete === 'function' && typeof object.get === 'function' && typeof object.getAll === 'function' && typeof object.has === 'function' && typeof object.set === 'function' && object[Symbol.toStringTag] === 'FormData';\n}\nfunction addAbortListener(signal, listener) {\n    if ('addEventListener' in signal) {\n        signal.addEventListener('abort', listener, {\n            once: true\n        });\n        return ()=>signal.removeEventListener('abort', listener);\n    }\n    signal.addListener('abort', listener);\n    return ()=>signal.removeListener('abort', listener);\n}\nconst hasToWellFormed = typeof String.prototype.toWellFormed === 'function';\nconst hasIsWellFormed = typeof String.prototype.isWellFormed === 'function';\n/**\n * @param {string} val\n */ function toUSVString(val) {\n    return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);\n}\n/**\n * @param {string} val\n */ // TODO: move this to webidl\nfunction isUSVString(val) {\n    return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;\n}\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */ function isTokenCharCode(c) {\n    switch(c){\n        case 0x22:\n        case 0x28:\n        case 0x29:\n        case 0x2c:\n        case 0x2f:\n        case 0x3a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x5b:\n        case 0x5c:\n        case 0x5d:\n        case 0x7b:\n        case 0x7d:\n            // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n            return false;\n        default:\n            // VCHAR %x21-7E\n            return c >= 0x21 && c <= 0x7e;\n    }\n}\n/**\n * @param {string} characters\n */ function isValidHTTPToken(characters) {\n    if (characters.length === 0) {\n        return false;\n    }\n    for(let i = 0; i < characters.length; ++i){\n        if (!isTokenCharCode(characters.charCodeAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n// headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */ const headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n/**\n * @param {string} characters\n */ function isValidHeaderValue(characters) {\n    return !headerCharRegex.test(characters);\n}\n// Parsed accordingly to RFC 9110\n// https://www.rfc-editor.org/rfc/rfc9110#field.content-range\nfunction parseRangeHeader(range) {\n    if (range == null || range === '') return {\n        start: 0,\n        end: null,\n        size: null\n    };\n    const m = range ? range.match(/^bytes (\\d+)-(\\d+)\\/(\\d+)?$/) : null;\n    return m ? {\n        start: parseInt(m[1]),\n        end: m[2] ? parseInt(m[2]) : null,\n        size: m[3] ? parseInt(m[3]) : null\n    } : null;\n}\nfunction addListener(obj, name, listener) {\n    const listeners = obj[kListeners] ??= [];\n    listeners.push([\n        name,\n        listener\n    ]);\n    obj.on(name, listener);\n    return obj;\n}\nfunction removeAllListeners(obj) {\n    for (const [name, listener] of obj[kListeners] ?? []){\n        obj.removeListener(name, listener);\n    }\n    obj[kListeners] = null;\n}\nfunction errorRequest(client, request, err) {\n    try {\n        request.onError(err);\n        assert(request.aborted);\n    } catch (err) {\n        client.emit('error', err);\n    }\n}\nconst kEnumerableProperty = Object.create(null);\nkEnumerableProperty.enumerable = true;\nconst normalizedMethodRecordsBase = {\n    delete: 'DELETE',\n    DELETE: 'DELETE',\n    get: 'GET',\n    GET: 'GET',\n    head: 'HEAD',\n    HEAD: 'HEAD',\n    options: 'OPTIONS',\n    OPTIONS: 'OPTIONS',\n    post: 'POST',\n    POST: 'POST',\n    put: 'PUT',\n    PUT: 'PUT'\n};\nconst normalizedMethodRecords = {\n    ...normalizedMethodRecordsBase,\n    patch: 'patch',\n    PATCH: 'PATCH'\n};\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizedMethodRecordsBase, null);\nObject.setPrototypeOf(normalizedMethodRecords, null);\nmodule.exports = {\n    kEnumerableProperty,\n    nop,\n    isDisturbed,\n    isErrored,\n    isReadable,\n    toUSVString,\n    isUSVString,\n    isBlobLike,\n    parseOrigin,\n    parseURL,\n    getServerName,\n    isStream,\n    isIterable,\n    isAsyncIterable,\n    isDestroyed,\n    headerNameToString,\n    bufferToLowerCasedHeaderName,\n    addListener,\n    removeAllListeners,\n    errorRequest,\n    parseRawHeaders,\n    parseHeaders,\n    parseKeepAliveTimeout,\n    destroy,\n    bodyLength,\n    deepClone,\n    ReadableStreamFrom,\n    isBuffer,\n    validateHandler,\n    getSocketInfo,\n    isFormDataLike,\n    buildURL,\n    addAbortListener,\n    isValidHTTPToken,\n    isValidHeaderValue,\n    isTokenCharCode,\n    parseRangeHeader,\n    normalizedMethodRecordsBase,\n    normalizedMethodRecords,\n    isValidPort,\n    isHttpOrHttpsPrefixed,\n    nodeMajor,\n    nodeMinor,\n    safeHTTPMethods: [\n        'GET',\n        'HEAD',\n        'OPTIONS',\n        'TRACE'\n    ],\n    wrapRequestBody\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRSxHQUFHSixtQkFBT0EsQ0FBQyxrRUFBVztBQUN4RSxNQUFNLEVBQUVLLGVBQWUsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQyw0QkFBVztBQUMvQyxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNTyxNQUFNUCxtQkFBT0EsQ0FBQywwQkFBVTtBQUM5QixNQUFNLEVBQUVRLElBQUksRUFBRSxHQUFHUixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUN0QyxNQUFNUyxXQUFXVCxtQkFBT0EsQ0FBQyw0QkFBVztBQUNwQyxNQUFNLEVBQUVVLFNBQVMsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQywwQ0FBa0I7QUFDaEQsTUFBTSxFQUFFVyxjQUFjQyxFQUFFLEVBQUUsR0FBR1osbUJBQU9BLENBQUMsZ0NBQWE7QUFDbEQsTUFBTSxFQUFFYSxvQkFBb0IsRUFBRSxHQUFHYixtQkFBT0EsQ0FBQyxnRUFBVTtBQUNuRCxNQUFNLEVBQUVjLDBCQUEwQixFQUFFLEdBQUdkLG1CQUFPQSxDQUFDLHNFQUFhO0FBQzVELE1BQU0sRUFBRWUsSUFBSSxFQUFFLEdBQUdmLG1CQUFPQSxDQUFDLDREQUFRO0FBRWpDLE1BQU0sQ0FBQ2dCLFdBQVdDLFVBQVUsR0FBR0MsUUFBUUMsUUFBUSxDQUFDQyxJQUFJLENBQUNDLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDLENBQUFBLElBQUtDLE9BQU9EO0FBRWhGLE1BQU1FO0lBQ0osWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLElBQUksQ0FBQ3RCLE1BQU0sR0FBR3NCO1FBQ2QsSUFBSSxDQUFDeEIsVUFBVSxHQUFHO0lBQ3BCO0lBRUEsT0FBUSxDQUFDeUIs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RUFBRSxPQUFPckgsS0FBSztRQUNabUgsT0FBTzlHLElBQUksQ0FBQyxTQUFTTDtJQUN2QjtBQUNGO0FBRUEsTUFBTXNILHNCQUFzQnJILE9BQU9zSCxNQUFNLENBQUM7QUFDMUNELG9CQUFvQkUsVUFBVSxHQUFHO0FBRWpDLE1BQU1DLDhCQUE4QjtJQUNsQ3pDLFFBQVE7SUFDUjBDLFFBQVE7SUFDUnpDLEtBQUs7SUFDTDBDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsS0FBSztJQUNMQyxLQUFLO0FBQ1A7QUFFQSxNQUFNQywwQkFBMEI7SUFDOUIsR0FBR1gsMkJBQTJCO0lBQzlCWSxPQUFPO0lBQ1BDLE9BQU87QUFDVDtBQUVBLDZGQUE2RjtBQUM3RnJJLE9BQU9zSSxjQUFjLENBQUNkLDZCQUE2QjtBQUNuRHhILE9BQU9zSSxjQUFjLENBQUNILHlCQUF5QjtBQUUvQ0ksT0FBT0MsT0FBTyxHQUFHO0lBQ2ZuQjtJQUNBOUs7SUFDQXdHO0lBQ0FDO0lBQ0FDO0lBQ0FnRDtJQUNBQztJQUNBeEo7SUFDQTBCO0lBQ0FWO0lBQ0FpQjtJQUNBOUM7SUFDQVM7SUFDQTRDO0lBQ0FVO0lBQ0FlO0lBQ0FHO0lBQ0E0RTtJQUNBc0I7SUFDQUM7SUFDQXRGO0lBQ0FaO0lBQ0FUO0lBQ0FSO0lBQ0FoRTtJQUNBaUQ7SUFDQTRFO0lBQ0FqRTtJQUNBMEM7SUFDQWM7SUFDQTJCO0lBQ0E5SDtJQUNBcUk7SUFDQWlCO0lBQ0FJO0lBQ0FOO0lBQ0FRO0lBQ0FhO0lBQ0FXO0lBQ0E5SztJQUNBSTtJQUNBMUM7SUFDQUM7SUFDQXlOLGlCQUFpQjtRQUFDO1FBQU87UUFBUTtRQUFXO0tBQVE7SUFDcEQ3TTtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXHV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsga0Rlc3Ryb3llZCwga0JvZHlVc2VkLCBrTGlzdGVuZXJzLCBrQm9keSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgSW5jb21pbmdNZXNzYWdlIH0gPSByZXF1aXJlKCdub2RlOmh0dHAnKVxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbm9kZTpuZXQnKVxuY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCBub2RlVXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnbm9kZTpxdWVyeXN0cmluZycpXG5jb25zdCB7IEV2ZW50RW1pdHRlcjogRUUgfSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbmNvbnN0IHsgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgdHJlZSB9ID0gcmVxdWlyZSgnLi90cmVlJylcblxuY29uc3QgW25vZGVNYWpvciwgbm9kZU1pbm9yXSA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLm1hcCh2ID0+IE51bWJlcih2KSlcblxuY2xhc3MgQm9keUFzeW5jSXRlcmFibGUge1xuICBjb25zdHJ1Y3RvciAoYm9keSkge1xuICAgIHRoaXNba0JvZHldID0gYm9keVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IGZhbHNlXG4gIH1cblxuICBhc3luYyAqIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgIGFzc2VydCghdGhpc1trQm9keVVzZWRdLCAnZGlzdHVyYmVkJylcbiAgICB0aGlzW2tCb2R5VXNlZF0gPSB0cnVlXG4gICAgeWllbGQgKiB0aGlzW2tCb2R5XVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBSZXF1ZXN0Qm9keSAoYm9keSkge1xuICBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICAvLyBUT0RPIChmaXgpOiBQcm92aWRlIHNvbWUgd2F5IGZvciB0aGUgdXNlciB0byBjYWNoZSB0aGUgZmlsZSB0byBlLmcuIC90bXBcbiAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGFnYWluP1xuICAgIC8vIFRPRE8gKGZpeCk6IERvIHdlIG5lZWQgMTAwLWV4cGVjdCBzdXBwb3J0IHRvIHByb3ZpZGUgYSB3YXkgdG8gZG8gdGhpcyBwcm9wZXJseT9cbiAgICBpZiAoYm9keUxlbmd0aChib2R5KSA9PT0gMCkge1xuICAgICAgYm9keVxuICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYm9keS5yZWFkYWJsZURpZFJlYWQgIT09ICdib29sZWFuJykge1xuICAgICAgYm9keVtrQm9keVVzZWRdID0gZmFsc2VcbiAgICAgIEVFLnByb3RvdHlwZS5vbi5jYWxsKGJvZHksICdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzW2tCb2R5VXNlZF0gPSB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBib2R5XG4gIH0gZWxzZSBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5waXBlVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUT0RPIChmaXgpOiBXZSBjYW4ndCBhY2Nlc3MgUmVhZGFibGVTdHJlYW0gaW50ZXJuYWwgc3RhdGVcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gZGlzdHVyYmVkLiBUaGlzIGlzIGp1c3RcbiAgICAvLyBhIHdvcmthcm91bmQuXG4gICAgcmV0dXJuIG5ldyBCb2R5QXN5bmNJdGVyYWJsZShib2R5KVxuICB9IGVsc2UgaWYgKFxuICAgIGJvZHkgJiZcbiAgICB0eXBlb2YgYm9keSAhPT0gJ3N0cmluZycgJiZcbiAgICAhQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpICYmXG4gICAgaXNJdGVyYWJsZShib2R5KVxuICApIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgd2UgYWxsb3cgcmUtdXNpbmcgaXRlcmFibGUgaWYgIXRoaXMub3B0cy5pZGVtcG90ZW50XG4gICAgLy8gb3IgdGhyb3VnaCBzb21lIG90aGVyIGZsYWc/XG4gICAgcmV0dXJuIG5ldyBCb2R5QXN5bmNJdGVyYWJsZShib2R5KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBib2R5XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9wICgpIHt9XG5cbmZ1bmN0aW9uIGlzU3RyZWFtIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnBpcGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5vbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9mZXRjaC1ibG9iL2Jsb2IvOGFiNTg3ZDM0MDgwZGU5NDE0MGI1NGYwNzE2ODQ1MWU3ZDBiNjU1ZS9pbmRleC5qcyNMMjI5LUwyNDEgKE1JVCBMaWNlbnNlKVxuZnVuY3Rpb24gaXNCbG9iTGlrZSAob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNUYWcgPSBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXVxuXG4gICAgcmV0dXJuIChzVGFnID09PSAnQmxvYicgfHwgc1RhZyA9PT0gJ0ZpbGUnKSAmJiAoXG4gICAgICAoJ3N0cmVhbScgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgKCdhcnJheUJ1ZmZlcicgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicpXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVVJMICh1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gIGlmICh1cmwuaW5jbHVkZXMoJz8nKSB8fCB1cmwuaW5jbHVkZXMoJyMnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgcGFyYW1zIGNhbm5vdCBiZSBwYXNzZWQgd2hlbiB1cmwgYWxyZWFkeSBjb250YWlucyBcIj9cIiBvciBcIiNcIi4nKVxuICB9XG5cbiAgY29uc3Qgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMpXG5cbiAgaWYgKHN0cmluZ2lmaWVkKSB7XG4gICAgdXJsICs9ICc/JyArIHN0cmluZ2lmaWVkXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3J0IChwb3J0KSB7XG4gIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQocG9ydCwgMTApXG4gIHJldHVybiAoXG4gICAgdmFsdWUgPT09IE51bWJlcihwb3J0KSAmJlxuICAgIHZhbHVlID49IDAgJiZcbiAgICB2YWx1ZSA8PSA2NTUzNVxuICApXG59XG5cbmZ1bmN0aW9uIGlzSHR0cE9ySHR0cHNQcmVmaXhlZCAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgdmFsdWVbMF0gPT09ICdoJyAmJlxuICAgIHZhbHVlWzFdID09PSAndCcgJiZcbiAgICB2YWx1ZVsyXSA9PT0gJ3QnICYmXG4gICAgdmFsdWVbM10gPT09ICdwJyAmJlxuICAgIChcbiAgICAgIHZhbHVlWzRdID09PSAnOicgfHxcbiAgICAgIChcbiAgICAgICAgdmFsdWVbNF0gPT09ICdzJyAmJlxuICAgICAgICB2YWx1ZVs1XSA9PT0gJzonXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHBhcnNlVVJMICh1cmwpIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG5cbiAgICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2w6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJylcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsXG4gIH1cblxuICBpZiAoIXVybCB8fCB0eXBlb2YgdXJsICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IFRoZSBVUkwgYXJndW1lbnQgbXVzdCBiZSBhIG5vbi1udWxsIG9iamVjdC4nKVxuICB9XG5cbiAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIGlmICh1cmwucG9ydCAhPSBudWxsICYmIHVybC5wb3J0ICE9PSAnJyAmJiBpc1ZhbGlkUG9ydCh1cmwucG9ydCkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMOiBwb3J0IG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyIG9yIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLnBhdGggIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHBhdGg6IHRoZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLnBhdGhuYW1lICE9IG51bGwgJiYgdHlwZW9mIHVybC5wYXRobmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcGF0aG5hbWU6IHRoZSBwYXRobmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5ob3N0bmFtZSAhPSBudWxsICYmIHR5cGVvZiB1cmwuaG9zdG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIGhvc3RuYW1lOiB0aGUgaG9zdG5hbWUgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwub3JpZ2luICE9IG51bGwgJiYgdHlwZW9mIHVybC5vcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIG9yaWdpbjogdGhlIG9yaWdpbiBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKCFpc0h0dHBPckh0dHBzUHJlZml4ZWQodXJsLm9yaWdpbiB8fCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpXG4gICAgfVxuXG4gICAgY29uc3QgcG9ydCA9IHVybC5wb3J0ICE9IG51bGxcbiAgICAgID8gdXJsLnBvcnRcbiAgICAgIDogKHVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MClcbiAgICBsZXQgb3JpZ2luID0gdXJsLm9yaWdpbiAhPSBudWxsXG4gICAgICA/IHVybC5vcmlnaW5cbiAgICAgIDogYCR7dXJsLnByb3RvY29sIHx8ICcnfS8vJHt1cmwuaG9zdG5hbWUgfHwgJyd9OiR7cG9ydH1gXG4gICAgbGV0IHBhdGggPSB1cmwucGF0aCAhPSBudWxsXG4gICAgICA/IHVybC5wYXRoXG4gICAgICA6IGAke3VybC5wYXRobmFtZSB8fCAnJ30ke3VybC5zZWFyY2ggfHwgJyd9YFxuXG4gICAgaWYgKG9yaWdpbltvcmlnaW4ubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgb3JpZ2luID0gb3JpZ2luLnNsaWNlKDAsIG9yaWdpbi5sZW5ndGggLSAxKVxuICAgIH1cblxuICAgIGlmIChwYXRoICYmIHBhdGhbMF0gIT09ICcvJykge1xuICAgICAgcGF0aCA9IGAvJHtwYXRofWBcbiAgICB9XG4gICAgLy8gbmV3IFVSTChwYXRoLCBvcmlnaW4pIGlzIHVuc2FmZSB3aGVuIGBwYXRoYCBjb250YWlucyBhbiBhYnNvbHV0ZSBVUkxcbiAgICAvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvVVJMOlxuICAgIC8vIElmIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJlbGF0aXZlIFVSTCwgc2Vjb25kIHBhcmFtIGlzIHJlcXVpcmVkLCBhbmQgd2lsbCBiZSB1c2VkIGFzIHRoZSBiYXNlIFVSTC5cbiAgICAvLyBJZiBmaXJzdCBwYXJhbWV0ZXIgaXMgYW4gYWJzb2x1dGUgVVJMLCBhIGdpdmVuIHNlY29uZCBwYXJhbSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgcmV0dXJuIG5ldyBVUkwoYCR7b3JpZ2lufSR7cGF0aH1gKVxuICB9XG5cbiAgaWYgKCFpc0h0dHBPckh0dHBzUHJlZml4ZWQodXJsLm9yaWdpbiB8fCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICB9XG5cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBwYXJzZU9yaWdpbiAodXJsKSB7XG4gIHVybCA9IHBhcnNlVVJMKHVybClcblxuICBpZiAodXJsLnBhdGhuYW1lICE9PSAnLycgfHwgdXJsLnNlYXJjaCB8fCB1cmwuaGFzaCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB1cmwnKVxuICB9XG5cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBnZXRIb3N0bmFtZSAoaG9zdCkge1xuICBpZiAoaG9zdFswXSA9PT0gJ1snKSB7XG4gICAgY29uc3QgaWR4ID0gaG9zdC5pbmRleE9mKCddJylcblxuICAgIGFzc2VydChpZHggIT09IC0xKVxuICAgIHJldHVybiBob3N0LnN1YnN0cmluZygxLCBpZHgpXG4gIH1cblxuICBjb25zdCBpZHggPSBob3N0LmluZGV4T2YoJzonKVxuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIGhvc3RcblxuICByZXR1cm4gaG9zdC5zdWJzdHJpbmcoMCwgaWR4KVxufVxuXG4vLyBJUCBhZGRyZXNzZXMgYXJlIG5vdCB2YWxpZCBzZXJ2ZXIgbmFtZXMgcGVyIFJGQzYwNjZcbi8vID4gQ3VycmVudGx5LCB0aGUgb25seSBzZXJ2ZXIgbmFtZXMgc3VwcG9ydGVkIGFyZSBETlMgaG9zdG5hbWVzXG5mdW5jdGlvbiBnZXRTZXJ2ZXJOYW1lIChob3N0KSB7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGhvc3QsICdzdHJpbmcnKVxuXG4gIGNvbnN0IHNlcnZlcm5hbWUgPSBnZXRIb3N0bmFtZShob3N0KVxuICBpZiAobmV0LmlzSVAoc2VydmVybmFtZSkpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBzZXJ2ZXJuYW1lXG59XG5cbmZ1bmN0aW9uIGRlZXBDbG9uZSAob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJylcbn1cblxuZnVuY3Rpb24gaXNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiAodHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSlcbn1cblxuZnVuY3Rpb24gYm9keUxlbmd0aCAoYm9keSkge1xuICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDBcbiAgfSBlbHNlIGlmIChpc1N0cmVhbShib2R5KSkge1xuICAgIGNvbnN0IHN0YXRlID0gYm9keS5fcmVhZGFibGVTdGF0ZVxuICAgIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5vYmplY3RNb2RlID09PSBmYWxzZSAmJiBzdGF0ZS5lbmRlZCA9PT0gdHJ1ZSAmJiBOdW1iZXIuaXNGaW5pdGUoc3RhdGUubGVuZ3RoKVxuICAgICAgPyBzdGF0ZS5sZW5ndGhcbiAgICAgIDogbnVsbFxuICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5zaXplICE9IG51bGwgPyBib2R5LnNpemUgOiBudWxsXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0Rlc3Ryb3llZCAoYm9keSkge1xuICByZXR1cm4gYm9keSAmJiAhIShib2R5LmRlc3Ryb3llZCB8fCBib2R5W2tEZXN0cm95ZWRdIHx8IChzdHJlYW0uaXNEZXN0cm95ZWQ/Lihib2R5KSkpXG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKHN0cmVhbSwgZXJyKSB7XG4gIGlmIChzdHJlYW0gPT0gbnVsbCB8fCAhaXNTdHJlYW0oc3RyZWFtKSB8fCBpc0Rlc3Ryb3llZChzdHJlYW0pKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihzdHJlYW0pLmNvbnN0cnVjdG9yID09PSBJbmNvbWluZ01lc3NhZ2UpIHtcbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzg1MDUvZmlsZXNcbiAgICAgIHN0cmVhbS5zb2NrZXQgPSBudWxsXG4gICAgfVxuXG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9IGVsc2UgaWYgKGVycikge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9KVxuICB9XG5cbiAgaWYgKHN0cmVhbS5kZXN0cm95ZWQgIT09IHRydWUpIHtcbiAgICBzdHJlYW1ba0Rlc3Ryb3llZF0gPSB0cnVlXG4gIH1cbn1cblxuY29uc3QgS0VFUEFMSVZFX1RJTUVPVVRfRVhQUiA9IC90aW1lb3V0PShcXGQrKS9cbmZ1bmN0aW9uIHBhcnNlS2VlcEFsaXZlVGltZW91dCAodmFsKSB7XG4gIGNvbnN0IG0gPSB2YWwudG9TdHJpbmcoKS5tYXRjaChLRUVQQUxJVkVfVElNRU9VVF9FWFBSKVxuICByZXR1cm4gbSA/IHBhcnNlSW50KG1bMV0sIDEwKSAqIDEwMDAgOiBudWxsXG59XG5cbi8qKlxuICogUmV0cmlldmVzIGEgaGVhZGVyIG5hbWUgYW5kIHJldHVybnMgaXRzIGxvd2VyY2FzZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgQnVmZmVyfSB2YWx1ZSBIZWFkZXIgbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaGVhZGVyTmFtZVRvU3RyaW5nICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgID8gaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRbdmFsdWVdID8/IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICA6IHRyZWUubG9va3VwKHZhbHVlKSA/PyB2YWx1ZS50b1N0cmluZygnbGF0aW4xJykudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIFJlY2VpdmUgdGhlIGJ1ZmZlciBhcyBhIHN0cmluZyBhbmQgcmV0dXJuIGl0cyBsb3dlcmNhc2UgdmFsdWUuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgSGVhZGVyIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUgKHZhbHVlKSB7XG4gIHJldHVybiB0cmVlLmxvb2t1cCh2YWx1ZSkgPz8gdmFsdWUudG9TdHJpbmcoJ2xhdGluMScpLnRvTG93ZXJDYXNlKClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPiB8IChCdWZmZXIgfCBzdHJpbmcgfCAoQnVmZmVyIHwgc3RyaW5nKVtdKVtdfSBoZWFkZXJzXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPn0gW29ial1cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT59XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyAoaGVhZGVycywgb2JqKSB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgb2JqID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcnNbaV0pXG4gICAgbGV0IHZhbCA9IG9ialtrZXldXG5cbiAgICBpZiAodmFsKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsID0gW3ZhbF1cbiAgICAgICAgb2JqW2tleV0gPSB2YWxcbiAgICAgIH1cbiAgICAgIHZhbC5wdXNoKGhlYWRlcnNbaSArIDFdLnRvU3RyaW5nKCd1dGY4JykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlYWRlcnNWYWx1ZSA9IGhlYWRlcnNbaSArIDFdXG4gICAgICBpZiAodHlwZW9mIGhlYWRlcnNWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqW2tleV0gPSBoZWFkZXJzVmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gQXJyYXkuaXNBcnJheShoZWFkZXJzVmFsdWUpID8gaGVhZGVyc1ZhbHVlLm1hcCh4ID0+IHgudG9TdHJpbmcoJ3V0ZjgnKSkgOiBoZWFkZXJzVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NjUyOFxuICBpZiAoJ2NvbnRlbnQtbGVuZ3RoJyBpbiBvYmogJiYgJ2NvbnRlbnQtZGlzcG9zaXRpb24nIGluIG9iaikge1xuICAgIG9ialsnY29udGVudC1kaXNwb3NpdGlvbiddID0gQnVmZmVyLmZyb20ob2JqWydjb250ZW50LWRpc3Bvc2l0aW9uJ10pLnRvU3RyaW5nKCdsYXRpbjEnKVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiBwYXJzZVJhd0hlYWRlcnMgKGhlYWRlcnMpIHtcbiAgY29uc3QgbGVuID0gaGVhZGVycy5sZW5ndGhcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5KGxlbilcblxuICBsZXQgaGFzQ29udGVudExlbmd0aCA9IGZhbHNlXG4gIGxldCBjb250ZW50RGlzcG9zaXRpb25JZHggPSAtMVxuICBsZXQga2V5XG4gIGxldCB2YWxcbiAgbGV0IGtMZW4gPSAwXG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAga2V5ID0gaGVhZGVyc1tuXVxuICAgIHZhbCA9IGhlYWRlcnNbbiArIDFdXG5cbiAgICB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiAoa2V5ID0ga2V5LnRvU3RyaW5nKCkpXG4gICAgdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycgJiYgKHZhbCA9IHZhbC50b1N0cmluZygndXRmOCcpKVxuXG4gICAga0xlbiA9IGtleS5sZW5ndGhcbiAgICBpZiAoa0xlbiA9PT0gMTQgJiYga2V5WzddID09PSAnLScgJiYgKGtleSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJyB8fCBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIGhhc0NvbnRlbnRMZW5ndGggPSB0cnVlXG4gICAgfSBlbHNlIGlmIChrTGVuID09PSAxOSAmJiBrZXlbN10gPT09ICctJyAmJiAoa2V5ID09PSAnY29udGVudC1kaXNwb3NpdGlvbicgfHwga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWRpc3Bvc2l0aW9uJykpIHtcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbklkeCA9IG4gKyAxXG4gICAgfVxuICAgIHJldFtuXSA9IGtleVxuICAgIHJldFtuICsgMV0gPSB2YWxcbiAgfVxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NjUyOFxuICBpZiAoaGFzQ29udGVudExlbmd0aCAmJiBjb250ZW50RGlzcG9zaXRpb25JZHggIT09IC0xKSB7XG4gICAgcmV0W2NvbnRlbnREaXNwb3NpdGlvbklkeF0gPSBCdWZmZXIuZnJvbShyZXRbY29udGVudERpc3Bvc2l0aW9uSWR4XSkudG9TdHJpbmcoJ2xhdGluMScpXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChidWZmZXIpIHtcbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbWNvbGxpbmEvdW5kaWNpL3B1bGwvMzE5XG4gIHJldHVybiBidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSGFuZGxlciAoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKSB7XG4gIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbm5lY3QgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkJvZHlTZW50ICE9PSAnZnVuY3Rpb24nICYmIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQm9keVNlbnQgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uVXBncmFkZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uVXBncmFkZSBtZXRob2QnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25IZWFkZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25IZWFkZXJzIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRGF0YSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRGF0YSBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Db21wbGV0ZSBtZXRob2QnKVxuICAgIH1cbiAgfVxufVxuXG4vLyBBIGJvZHkgaXMgZGlzdHVyYmVkIGlmIGl0IGhhcyBiZWVuIHJlYWQgZnJvbSBhbmQgaXQgY2Fubm90XG4vLyBiZSByZS11c2VkIHdpdGhvdXQgbG9zaW5nIHN0YXRlIG9yIGRhdGEuXG5mdW5jdGlvbiBpc0Rpc3R1cmJlZCAoYm9keSkge1xuICAvLyBUT0RPIChmaXgpOiBXaHkgaXMgYm9keVtrQm9keVVzZWRdIG5lZWRlZD9cbiAgcmV0dXJuICEhKGJvZHkgJiYgKHN0cmVhbS5pc0Rpc3R1cmJlZChib2R5KSB8fCBib2R5W2tCb2R5VXNlZF0pKVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yZWQgKGJvZHkpIHtcbiAgcmV0dXJuICEhKGJvZHkgJiYgc3RyZWFtLmlzRXJyb3JlZChib2R5KSlcbn1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZSAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiBzdHJlYW0uaXNSZWFkYWJsZShib2R5KSlcbn1cblxuZnVuY3Rpb24gZ2V0U29ja2V0SW5mbyAoc29ja2V0KSB7XG4gIHJldHVybiB7XG4gICAgbG9jYWxBZGRyZXNzOiBzb2NrZXQubG9jYWxBZGRyZXNzLFxuICAgIGxvY2FsUG9ydDogc29ja2V0LmxvY2FsUG9ydCxcbiAgICByZW1vdGVBZGRyZXNzOiBzb2NrZXQucmVtb3RlQWRkcmVzcyxcbiAgICByZW1vdGVQb3J0OiBzb2NrZXQucmVtb3RlUG9ydCxcbiAgICByZW1vdGVGYW1pbHk6IHNvY2tldC5yZW1vdGVGYW1pbHksXG4gICAgdGltZW91dDogc29ja2V0LnRpbWVvdXQsXG4gICAgYnl0ZXNXcml0dGVuOiBzb2NrZXQuYnl0ZXNXcml0dGVuLFxuICAgIGJ5dGVzUmVhZDogc29ja2V0LmJ5dGVzUmVhZFxuICB9XG59XG5cbi8qKiBAdHlwZSB7Z2xvYmFsVGhpc1snUmVhZGFibGVTdHJlYW0nXX0gKi9cbmZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnJvbSAoaXRlcmFibGUpIHtcbiAgLy8gV2UgY2Fubm90IHVzZSBSZWFkYWJsZVN0cmVhbS5mcm9tIGhlcmUgYmVjYXVzZSBpdCBkb2VzIG5vdCByZXR1cm4gYSBieXRlIHN0cmVhbS5cblxuICBsZXQgaXRlcmF0b3JcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICB7XG4gICAgICBhc3luYyBzdGFydCAoKSB7XG4gICAgICAgIGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKVxuICAgICAgICAgICAgY29udHJvbGxlci5ieW9iUmVxdWVzdD8ucmVzcG9uZCgwKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSA/IHZhbHVlIDogQnVmZmVyLmZyb20odmFsdWUpXG4gICAgICAgICAgaWYgKGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICB0eXBlOiAnYnl0ZXMnXG4gICAgfVxuICApXG59XG5cbi8vIFRoZSBjaHVuayBzaG91bGQgYmUgYSBGb3JtRGF0YSBpbnN0YW5jZSBhbmQgY29udGFpbnNcbi8vIGFsbCB0aGUgcmVxdWlyZWQgbWV0aG9kcy5cbmZ1bmN0aW9uIGlzRm9ybURhdGFMaWtlIChvYmplY3QpIHtcbiAgcmV0dXJuIChcbiAgICBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QuYXBwZW5kID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5kZWxldGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmdldCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZ2V0QWxsID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5oYXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnXG4gIClcbn1cblxuZnVuY3Rpb24gYWRkQWJvcnRMaXN0ZW5lciAoc2lnbmFsLCBsaXN0ZW5lcikge1xuICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHNpZ25hbCkge1xuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSlcbiAgICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG4gIH1cbiAgc2lnbmFsLmFkZExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxuICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxufVxuXG5jb25zdCBoYXNUb1dlbGxGb3JtZWQgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50b1dlbGxGb3JtZWQgPT09ICdmdW5jdGlvbidcbmNvbnN0IGhhc0lzV2VsbEZvcm1lZCA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLmlzV2VsbEZvcm1lZCA9PT0gJ2Z1bmN0aW9uJ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqL1xuZnVuY3Rpb24gdG9VU1ZTdHJpbmcgKHZhbCkge1xuICByZXR1cm4gaGFzVG9XZWxsRm9ybWVkID8gYCR7dmFsfWAudG9XZWxsRm9ybWVkKCkgOiBub2RlVXRpbC50b1VTVlN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICovXG4vLyBUT0RPOiBtb3ZlIHRoaXMgdG8gd2ViaWRsXG5mdW5jdGlvbiBpc1VTVlN0cmluZyAodmFsKSB7XG4gIHJldHVybiBoYXNJc1dlbGxGb3JtZWQgPyBgJHt2YWx9YC5pc1dlbGxGb3JtZWQoKSA6IHRvVVNWU3RyaW5nKHZhbCkgPT09IGAke3ZhbH1gXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMi42XG4gKiBAcGFyYW0ge251bWJlcn0gY1xuICovXG5mdW5jdGlvbiBpc1Rva2VuQ2hhckNvZGUgKGMpIHtcbiAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAweDIyOlxuICAgIGNhc2UgMHgyODpcbiAgICBjYXNlIDB4Mjk6XG4gICAgY2FzZSAweDJjOlxuICAgIGNhc2UgMHgyZjpcbiAgICBjYXNlIDB4M2E6XG4gICAgY2FzZSAweDNiOlxuICAgIGNhc2UgMHgzYzpcbiAgICBjYXNlIDB4M2Q6XG4gICAgY2FzZSAweDNlOlxuICAgIGNhc2UgMHgzZjpcbiAgICBjYXNlIDB4NDA6XG4gICAgY2FzZSAweDViOlxuICAgIGNhc2UgMHg1YzpcbiAgICBjYXNlIDB4NWQ6XG4gICAgY2FzZSAweDdiOlxuICAgIGNhc2UgMHg3ZDpcbiAgICAgIC8vIERRVU9URSBhbmQgXCIoKSwvOjs8PT4/QFtcXF17fVwiXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVkNIQVIgJXgyMS03RVxuICAgICAgcmV0dXJuIGMgPj0gMHgyMSAmJiBjIDw9IDB4N2VcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJzXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIVFRQVG9rZW4gKGNoYXJhY3RlcnMpIHtcbiAgaWYgKGNoYXJhY3RlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyYWN0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFpc1Rva2VuQ2hhckNvZGUoY2hhcmFjdGVycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGhlYWRlckNoYXJSZWdleCBoYXZlIGJlZW4gbGlmdGVkIGZyb21cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21haW4vbGliL19odHRwX2NvbW1vbi5qc1xuXG4vKipcbiAqIE1hdGNoZXMgaWYgdmFsIGNvbnRhaW5zIGFuIGludmFsaWQgZmllbGQtdmNoYXJcbiAqICBmaWVsZC12YWx1ZSAgICA9ICooIGZpZWxkLWNvbnRlbnQgLyBvYnMtZm9sZCApXG4gKiAgZmllbGQtY29udGVudCAgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiAgZmllbGQtdmNoYXIgICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKi9cbmNvbnN0IGhlYWRlckNoYXJSZWdleCA9IC9bXlxcdFxceDIwLVxceDdlXFx4ODAtXFx4ZmZdL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJzXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSAoY2hhcmFjdGVycykge1xuICByZXR1cm4gIWhlYWRlckNoYXJSZWdleC50ZXN0KGNoYXJhY3RlcnMpXG59XG5cbi8vIFBhcnNlZCBhY2NvcmRpbmdseSB0byBSRkMgOTExMFxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTAjZmllbGQuY29udGVudC1yYW5nZVxuZnVuY3Rpb24gcGFyc2VSYW5nZUhlYWRlciAocmFuZ2UpIHtcbiAgaWYgKHJhbmdlID09IG51bGwgfHwgcmFuZ2UgPT09ICcnKSByZXR1cm4geyBzdGFydDogMCwgZW5kOiBudWxsLCBzaXplOiBudWxsIH1cblxuICBjb25zdCBtID0gcmFuZ2UgPyByYW5nZS5tYXRjaCgvXmJ5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKyk/JC8pIDogbnVsbFxuICByZXR1cm4gbVxuICAgID8ge1xuICAgICAgICBzdGFydDogcGFyc2VJbnQobVsxXSksXG4gICAgICAgIGVuZDogbVsyXSA/IHBhcnNlSW50KG1bMl0pIDogbnVsbCxcbiAgICAgICAgc2l6ZTogbVszXSA/IHBhcnNlSW50KG1bM10pIDogbnVsbFxuICAgICAgfVxuICAgIDogbnVsbFxufVxuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lciAob2JqLCBuYW1lLCBsaXN0ZW5lcikge1xuICBjb25zdCBsaXN0ZW5lcnMgPSAob2JqW2tMaXN0ZW5lcnNdID8/PSBbXSlcbiAgbGlzdGVuZXJzLnB1c2goW25hbWUsIGxpc3RlbmVyXSlcbiAgb2JqLm9uKG5hbWUsIGxpc3RlbmVyKVxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyAob2JqKSB7XG4gIGZvciAoY29uc3QgW25hbWUsIGxpc3RlbmVyXSBvZiBvYmpba0xpc3RlbmVyc10gPz8gW10pIHtcbiAgICBvYmoucmVtb3ZlTGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpXG4gIH1cbiAgb2JqW2tMaXN0ZW5lcnNdID0gbnVsbFxufVxuXG5mdW5jdGlvbiBlcnJvclJlcXVlc3QgKGNsaWVudCwgcmVxdWVzdCwgZXJyKSB7XG4gIHRyeSB7XG4gICAgcmVxdWVzdC5vbkVycm9yKGVycilcbiAgICBhc3NlcnQocmVxdWVzdC5hYm9ydGVkKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjbGllbnQuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxuY29uc3Qga0VudW1lcmFibGVQcm9wZXJ0eSA9IE9iamVjdC5jcmVhdGUobnVsbClcbmtFbnVtZXJhYmxlUHJvcGVydHkuZW51bWVyYWJsZSA9IHRydWVcblxuY29uc3Qgbm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlID0ge1xuICBkZWxldGU6ICdERUxFVEUnLFxuICBERUxFVEU6ICdERUxFVEUnLFxuICBnZXQ6ICdHRVQnLFxuICBHRVQ6ICdHRVQnLFxuICBoZWFkOiAnSEVBRCcsXG4gIEhFQUQ6ICdIRUFEJyxcbiAgb3B0aW9uczogJ09QVElPTlMnLFxuICBPUFRJT05TOiAnT1BUSU9OUycsXG4gIHBvc3Q6ICdQT1NUJyxcbiAgUE9TVDogJ1BPU1QnLFxuICBwdXQ6ICdQVVQnLFxuICBQVVQ6ICdQVVQnXG59XG5cbmNvbnN0IG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzID0ge1xuICAuLi5ub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UsXG4gIHBhdGNoOiAncGF0Y2gnLFxuICBQQVRDSDogJ1BBVENIJ1xufVxuXG4vLyBOb3RlOiBvYmplY3QgcHJvdG90eXBlcyBzaG91bGQgbm90IGJlIGFibGUgdG8gYmUgcmVmZXJlbmNlZC4gZS5nLiBgT2JqZWN0I2hhc093blByb3BlcnR5YC5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UsIG51bGwpXG5PYmplY3Quc2V0UHJvdG90eXBlT2Yobm9ybWFsaXplZE1ldGhvZFJlY29yZHMsIG51bGwpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBub3AsXG4gIGlzRGlzdHVyYmVkLFxuICBpc0Vycm9yZWQsXG4gIGlzUmVhZGFibGUsXG4gIHRvVVNWU3RyaW5nLFxuICBpc1VTVlN0cmluZyxcbiAgaXNCbG9iTGlrZSxcbiAgcGFyc2VPcmlnaW4sXG4gIHBhcnNlVVJMLFxuICBnZXRTZXJ2ZXJOYW1lLFxuICBpc1N0cmVhbSxcbiAgaXNJdGVyYWJsZSxcbiAgaXNBc3luY0l0ZXJhYmxlLFxuICBpc0Rlc3Ryb3llZCxcbiAgaGVhZGVyTmFtZVRvU3RyaW5nLFxuICBidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lLFxuICBhZGRMaXN0ZW5lcixcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzLFxuICBlcnJvclJlcXVlc3QsXG4gIHBhcnNlUmF3SGVhZGVycyxcbiAgcGFyc2VIZWFkZXJzLFxuICBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQsXG4gIGRlc3Ryb3ksXG4gIGJvZHlMZW5ndGgsXG4gIGRlZXBDbG9uZSxcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICBpc0J1ZmZlcixcbiAgdmFsaWRhdGVIYW5kbGVyLFxuICBnZXRTb2NrZXRJbmZvLFxuICBpc0Zvcm1EYXRhTGlrZSxcbiAgYnVpbGRVUkwsXG4gIGFkZEFib3J0TGlzdGVuZXIsXG4gIGlzVmFsaWRIVFRQVG9rZW4sXG4gIGlzVmFsaWRIZWFkZXJWYWx1ZSxcbiAgaXNUb2tlbkNoYXJDb2RlLFxuICBwYXJzZVJhbmdlSGVhZGVyLFxuICBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UsXG4gIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzLFxuICBpc1ZhbGlkUG9ydCxcbiAgaXNIdHRwT3JIdHRwc1ByZWZpeGVkLFxuICBub2RlTWFqb3IsXG4gIG5vZGVNaW5vcixcbiAgc2FmZUhUVFBNZXRob2RzOiBbJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnVFJBQ0UnXSxcbiAgd3JhcFJlcXVlc3RCb2R5XG59XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImtEZXN0cm95ZWQiLCJrQm9keVVzZWQiLCJrTGlzdGVuZXJzIiwia0JvZHkiLCJJbmNvbWluZ01lc3NhZ2UiLCJzdHJlYW0iLCJuZXQiLCJCbG9iIiwibm9kZVV0aWwiLCJzdHJpbmdpZnkiLCJFdmVudEVtaXR0ZXIiLCJFRSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQiLCJ0cmVlIiwibm9kZU1ham9yIiwibm9kZU1pbm9yIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsInNwbGl0IiwibWFwIiwidiIsIk51bWJlciIsIkJvZHlBc3luY0l0ZXJhYmxlIiwiYm9keSIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ3cmFwUmVxdWVzdEJvZHkiLCJpc1N0cmVhbSIsImJvZHlMZW5ndGgiLCJvbiIsInJlYWRhYmxlRGlkUmVhZCIsInByb3RvdHlwZSIsImNhbGwiLCJwaXBlVG8iLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImlzSXRlcmFibGUiLCJub3AiLCJvYmoiLCJwaXBlIiwiaXNCbG9iTGlrZSIsIm9iamVjdCIsInNUYWciLCJ0b1N0cmluZ1RhZyIsImFycmF5QnVmZmVyIiwiYnVpbGRVUkwiLCJ1cmwiLCJxdWVyeVBhcmFtcyIsImluY2x1ZGVzIiwiRXJyb3IiLCJzdHJpbmdpZmllZCIsImlzVmFsaWRQb3J0IiwicG9ydCIsInZhbHVlIiwicGFyc2VJbnQiLCJpc0h0dHBPckh0dHBzUHJlZml4ZWQiLCJwYXJzZVVSTCIsIlVSTCIsIm9yaWdpbiIsInByb3RvY29sIiwicGF0aCIsInBhdGhuYW1lIiwiaG9zdG5hbWUiLCJzZWFyY2giLCJsZW5ndGgiLCJzbGljZSIsInBhcnNlT3JpZ2luIiwiaGFzaCIsImdldEhvc3RuYW1lIiwiaG9zdCIsImlkeCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJnZXRTZXJ2ZXJOYW1lIiwic3RyaWN0RXF1YWwiLCJzZXJ2ZXJuYW1lIiwiaXNJUCIsImRlZXBDbG9uZSIsIkpTT04iLCJwYXJzZSIsImlzQXN5bmNJdGVyYWJsZSIsIml0ZXJhdG9yIiwic3RhdGUiLCJfcmVhZGFibGVTdGF0ZSIsIm9iamVjdE1vZGUiLCJlbmRlZCIsImlzRmluaXRlIiwic2l6ZSIsImlzQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImlzRGVzdHJveWVkIiwiZGVzdHJveWVkIiwiZGVzdHJveSIsImVyciIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwic29ja2V0IiwicXVldWVNaWNyb3Rhc2siLCJlbWl0IiwiS0VFUEFMSVZFX1RJTUVPVVRfRVhQUiIsInBhcnNlS2VlcEFsaXZlVGltZW91dCIsInZhbCIsIm0iLCJ0b1N0cmluZyIsIm1hdGNoIiwiaGVhZGVyTmFtZVRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJsb29rdXAiLCJidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lIiwicGFyc2VIZWFkZXJzIiwiaGVhZGVycyIsInVuZGVmaW5lZCIsImkiLCJrZXkiLCJwdXNoIiwiaGVhZGVyc1ZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwieCIsIkJ1ZmZlciIsImZyb20iLCJwYXJzZVJhd0hlYWRlcnMiLCJsZW4iLCJyZXQiLCJoYXNDb250ZW50TGVuZ3RoIiwiY29udGVudERpc3Bvc2l0aW9uSWR4Iiwia0xlbiIsIm4iLCJidWZmZXIiLCJVaW50OEFycmF5IiwidmFsaWRhdGVIYW5kbGVyIiwiaGFuZGxlciIsIm1ldGhvZCIsInVwZ3JhZGUiLCJvbkNvbm5lY3QiLCJvbkVycm9yIiwib25Cb2R5U2VudCIsIm9uVXBncmFkZSIsIm9uSGVhZGVycyIsIm9uRGF0YSIsIm9uQ29tcGxldGUiLCJpc0Rpc3R1cmJlZCIsImlzRXJyb3JlZCIsImlzUmVhZGFibGUiLCJnZXRTb2NrZXRJbmZvIiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZVBvcnQiLCJyZW1vdGVGYW1pbHkiLCJ0aW1lb3V0IiwiYnl0ZXNXcml0dGVuIiwiYnl0ZXNSZWFkIiwiUmVhZGFibGVTdHJlYW1Gcm9tIiwiaXRlcmFibGUiLCJSZWFkYWJsZVN0cmVhbSIsInN0YXJ0IiwicHVsbCIsImNvbnRyb2xsZXIiLCJkb25lIiwibmV4dCIsImNsb3NlIiwiYnlvYlJlcXVlc3QiLCJyZXNwb25kIiwiYnVmIiwiZW5xdWV1ZSIsImRlc2lyZWRTaXplIiwiY2FuY2VsIiwicmVhc29uIiwicmV0dXJuIiwidHlwZSIsImlzRm9ybURhdGFMaWtlIiwiYXBwZW5kIiwiZGVsZXRlIiwiZ2V0IiwiZ2V0QWxsIiwiaGFzIiwic2V0IiwiYWRkQWJvcnRMaXN0ZW5lciIsInNpZ25hbCIsImxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsImhhc1RvV2VsbEZvcm1lZCIsIlN0cmluZyIsInRvV2VsbEZvcm1lZCIsImhhc0lzV2VsbEZvcm1lZCIsImlzV2VsbEZvcm1lZCIsInRvVVNWU3RyaW5nIiwiaXNVU1ZTdHJpbmciLCJpc1Rva2VuQ2hhckNvZGUiLCJjIiwiaXNWYWxpZEhUVFBUb2tlbiIsImNoYXJhY3RlcnMiLCJjaGFyQ29kZUF0IiwiaGVhZGVyQ2hhclJlZ2V4IiwiaXNWYWxpZEhlYWRlclZhbHVlIiwidGVzdCIsInBhcnNlUmFuZ2VIZWFkZXIiLCJyYW5nZSIsImVuZCIsIm5hbWUiLCJsaXN0ZW5lcnMiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlcnJvclJlcXVlc3QiLCJjbGllbnQiLCJyZXF1ZXN0IiwiYWJvcnRlZCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJjcmVhdGUiLCJlbnVtZXJhYmxlIiwibm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlIiwiREVMRVRFIiwiR0VUIiwiaGVhZCIsIkhFQUQiLCJvcHRpb25zIiwiT1BUSU9OUyIsInBvc3QiLCJQT1NUIiwicHV0IiwiUFVUIiwibm9ybWFsaXplZE1ldGhvZFJlY29yZHMiLCJwYXRjaCIsIlBBVENIIiwic2V0UHJvdG90eXBlT2YiLCJtb2R1bGUiLCJleHBvcnRzIiwic2FmZUhUVFBNZXRob2RzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/agent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\");\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kMaxRedirections = Symbol('maxRedirections');\nconst kOnDrain = Symbol('onDrain');\nconst kFactory = Symbol('factory');\nconst kOptions = Symbol('options');\nfunction defaultFactory(origin, opts) {\n    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\nclass Agent extends DispatcherBase {\n    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}){\n        super();\n        if (typeof factory !== 'function') {\n            throw new InvalidArgumentError('factory must be a function.');\n        }\n        if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n            throw new InvalidArgumentError('connect must be a function or an object');\n        }\n        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n            throw new InvalidArgumentError('maxRedirections must be a positive number');\n        }\n        if (connect && typeof connect !== 'function') {\n            connect = {\n                ...connect\n            };\n        }\n        this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [\n            createRedirectInterceptor({\n                maxRedirections\n            })\n        ];\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kMaxRedirections] = maxRedirections;\n        this[kFactory] = factory;\n        this[kClients] = new Map();\n        this[kOnDrain] = (origin, targets)=>{\n            this.emit('drain', origin, [\n                this,\n                ...targets\n            ]);\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            this.emit('connect', origin, [\n                this,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            this.emit('disconnect', origin, [\n                this,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            this.emit('connectionError', origin, [\n                this,\n                ...targets\n            ], err);\n        };\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const client of this[kClients].values()){\n            ret += client[kRunning];\n        }\n        return ret;\n    }\n    [kDispatch](opts, handler) {\n        let key;\n        if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n            key = String(opts.origin);\n        } else {\n            throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');\n        }\n        let dispatcher = this[kClients].get(key);\n        if (!dispatcher) {\n            dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n            // This introduces a tiny memory leak, as dispatchers are never removed from the map.\n            // TODO(mcollina): remove te timer when the client/pool do not have any more\n            // active connections.\n            this[kClients].set(key, dispatcher);\n        }\n        return dispatcher.dispatch(opts, handler);\n    }\n    async [kClose]() {\n        const closePromises = [];\n        for (const client of this[kClients].values()){\n            closePromises.push(client.close());\n        }\n        this[kClients].clear();\n        await Promise.all(closePromises);\n    }\n    async [kDestroy](err) {\n        const destroyPromises = [];\n        for (const client of this[kClients].values()){\n            destroyPromises.push(client.destroy(err));\n        }\n        this[kClients].clear();\n        await Promise.all(destroyPromises);\n    }\n}\nmodule.exports = Agent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxvQkFBb0IsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxzRUFBZ0I7QUFDekQsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDLHdFQUFpQjtBQUNwRyxNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDLHdGQUFtQjtBQUNsRCxNQUFNUSxPQUFPUixtQkFBT0EsQ0FBQyxrRUFBUTtBQUM3QixNQUFNUyxTQUFTVCxtQkFBT0EsQ0FBQyxzRUFBVTtBQUNqQyxNQUFNVSxPQUFPVixtQkFBT0EsQ0FBQyxrRUFBYztBQUNuQyxNQUFNVyw0QkFBNEJYLG1CQUFPQSxDQUFDLGdIQUFxQztBQUUvRSxNQUFNWSxhQUFhQyxPQUFPO0FBQzFCLE1BQU1DLGdCQUFnQkQsT0FBTztBQUM3QixNQUFNRSxxQkFBcUJGLE9BQU87QUFDbEMsTUFBTUcsbUJBQW1CSCxPQUFPO0FBQ2hDLE1BQU1JLFdBQVdKLE9BQU87QUFDeEIsTUFBTUssV0FBV0wsT0FBTztBQUN4QixNQUFNTSxXQUFXTixPQUFPO0FBRXhCLFNBQVNPLGVBQWdCQyxNQUFNLEVBQUVDLElBQUk7SUFDbkMsT0FBT0EsUUFBUUEsS0FBS0MsV0FBVyxLQUFLLElBQ2hDLElBQUlkLE9BQU9ZLFFBQVFDLFFBQ25CLElBQUlkLEtBQUthLFFBQVFDO0FBQ3ZCO0FBRUEsTUFBTUUsY0FBY2pCO0lBQ2xCLFlBQWEsRUFBRWtCLFVBQVVMLGNBQWMsRUFBRU0sa0JBQWtCLENBQUMsRUFBRUMsT0FBTyxFQUFFLEdBQUdDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUN4RixLQUFLO1FBRUwsSUFBSSxPQUFPSCxZQUFZLFlBQVk7WUFDakMsTUFBTSxJQUFJMUIscUJBQXFC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bUI7WUFFakQscUZBQXFGO1lBQ3JGLDRFQUE0RTtZQUM1RSxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDZCxTQUFTLENBQUNpRCxHQUFHLENBQUNOLEtBQUtHO1FBQzFCO1FBRUEsT0FBT0EsV0FBV0ksUUFBUSxDQUFDN0IsTUFBTXFCO0lBQ25DO0lBRUEsTUFBTSxDQUFDeEMsT0FBTyxHQUFJO1FBQ2hCLE1BQU1pRCxnQkFBZ0IsRUFBRTtRQUN4QixLQUFLLE1BQU1YLFVBQVUsSUFBSSxDQUFDeEMsU0FBUyxDQUFDeUMsTUFBTSxHQUFJO1lBQzVDVSxjQUFjQyxJQUFJLENBQUNaLE9BQU9hLEtBQUs7UUFDakM7UUFDQSxJQUFJLENBQUNyRCxTQUFTLENBQUNzRCxLQUFLO1FBRXBCLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ0w7SUFDcEI7SUFFQSxNQUFNLENBQUNoRCxTQUFTLENBQUVtQyxHQUFHLEVBQUU7UUFDckIsTUFBTW1CLGtCQUFrQixFQUFFO1FBQzFCLEtBQUssTUFBTWpCLFVBQVUsSUFBSSxDQUFDeEMsU0FBUyxDQUFDeUMsTUFBTSxHQUFJO1lBQzVDZ0IsZ0JBQWdCTCxJQUFJLENBQUNaLE9BQU9rQixPQUFPLENBQUNwQjtRQUN0QztRQUNBLElBQUksQ0FBQ3RDLFNBQVMsQ0FBQ3NELEtBQUs7UUFFcEIsTUFBTUMsUUFBUUMsR0FBRyxDQUFDQztJQUNwQjtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBR3JDIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGFnZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IGtDbGllbnRzLCBrUnVubmluZywga0Nsb3NlLCBrRGVzdHJveSwga0Rpc3BhdGNoLCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4uL2ludGVyY2VwdG9yL3JlZGlyZWN0LWludGVyY2VwdG9yJylcblxuY29uc3Qga09uQ29ubmVjdCA9IFN5bWJvbCgnb25Db25uZWN0JylcbmNvbnN0IGtPbkRpc2Nvbm5lY3QgPSBTeW1ib2woJ29uRGlzY29ubmVjdCcpXG5jb25zdCBrT25Db25uZWN0aW9uRXJyb3IgPSBTeW1ib2woJ29uQ29ubmVjdGlvbkVycm9yJylcbmNvbnN0IGtNYXhSZWRpcmVjdGlvbnMgPSBTeW1ib2woJ21heFJlZGlyZWN0aW9ucycpXG5jb25zdCBrT25EcmFpbiA9IFN5bWJvbCgnb25EcmFpbicpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpXG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgb3B0cy5jb25uZWN0aW9ucyA9PT0gMVxuICAgID8gbmV3IENsaWVudChvcmlnaW4sIG9wdHMpXG4gICAgOiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNsYXNzIEFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAoeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIG1heFJlZGlyZWN0aW9ucyA9IDAsIGNvbm5lY3QsIC4uLm9wdGlvbnMgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlZGlyZWN0aW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IHsgLi4uY29ubmVjdCB9XG4gICAgfVxuXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzPy5BZ2VudCAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuaW50ZXJjZXB0b3JzLkFnZW50KVxuICAgICAgPyBvcHRpb25zLmludGVyY2VwdG9ycy5BZ2VudFxuICAgICAgOiBbY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvcih7IG1heFJlZGlyZWN0aW9ucyB9KV1cblxuICAgIHRoaXNba09wdGlvbnNdID0geyAuLi51dGlsLmRlZXBDbG9uZShvcHRpb25zKSwgY29ubmVjdCB9XG4gICAgdGhpc1trT3B0aW9uc10uaW50ZXJjZXB0b3JzID0gb3B0aW9ucy5pbnRlcmNlcHRvcnNcbiAgICAgID8geyAuLi5vcHRpb25zLmludGVyY2VwdG9ycyB9XG4gICAgICA6IHVuZGVmaW5lZFxuICAgIHRoaXNba01heFJlZGlyZWN0aW9uc10gPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcbiAgICB0aGlzW2tDbGllbnRzXSA9IG5ldyBNYXAoKVxuXG4gICAgdGhpc1trT25EcmFpbl0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uRGlzY29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIGxldCByZXQgPSAwXG4gICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIHJldCArPSBjbGllbnRba1J1bm5pbmddXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgbGV0IGtleVxuICAgIGlmIChvcHRzLm9yaWdpbiAmJiAodHlwZW9mIG9wdHMub3JpZ2luID09PSAnc3RyaW5nJyB8fCBvcHRzLm9yaWdpbiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgIGtleSA9IFN0cmluZyhvcHRzLm9yaWdpbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLm9yaWdpbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBVUkwuJylcbiAgICB9XG5cbiAgICBsZXQgZGlzcGF0Y2hlciA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcHRzLm9yaWdpbiwgdGhpc1trT3B0aW9uc10pXG4gICAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXSlcbiAgICAgICAgLm9uKCdjb25uZWN0JywgdGhpc1trT25Db25uZWN0XSlcbiAgICAgICAgLm9uKCdkaXNjb25uZWN0JywgdGhpc1trT25EaXNjb25uZWN0XSlcbiAgICAgICAgLm9uKCdjb25uZWN0aW9uRXJyb3InLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pXG5cbiAgICAgIC8vIFRoaXMgaW50cm9kdWNlcyBhIHRpbnkgbWVtb3J5IGxlYWssIGFzIGRpc3BhdGNoZXJzIGFyZSBuZXZlciByZW1vdmVkIGZyb20gdGhlIG1hcC5cbiAgICAgIC8vIFRPRE8obWNvbGxpbmEpOiByZW1vdmUgdGUgdGltZXIgd2hlbiB0aGUgY2xpZW50L3Bvb2wgZG8gbm90IGhhdmUgYW55IG1vcmVcbiAgICAgIC8vIGFjdGl2ZSBjb25uZWN0aW9ucy5cbiAgICAgIHRoaXNba0NsaWVudHNdLnNldChrZXksIGRpc3BhdGNoZXIpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3BhdGNoZXIuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBjb25zdCBjbG9zZVByb21pc2VzID0gW11cbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgY2xvc2VQcm9taXNlcy5wdXNoKGNsaWVudC5jbG9zZSgpKVxuICAgIH1cbiAgICB0aGlzW2tDbGllbnRzXS5jbGVhcigpXG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChjbG9zZVByb21pc2VzKVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgY29uc3QgZGVzdHJveVByb21pc2VzID0gW11cbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgZGVzdHJveVByb21pc2VzLnB1c2goY2xpZW50LmRlc3Ryb3koZXJyKSlcbiAgICB9XG4gICAgdGhpc1trQ2xpZW50c10uY2xlYXIoKVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVzdHJveVByb21pc2VzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnRcbiJdLCJuYW1lcyI6WyJJbnZhbGlkQXJndW1lbnRFcnJvciIsInJlcXVpcmUiLCJrQ2xpZW50cyIsImtSdW5uaW5nIiwia0Nsb3NlIiwia0Rlc3Ryb3kiLCJrRGlzcGF0Y2giLCJrSW50ZXJjZXB0b3JzIiwiRGlzcGF0Y2hlckJhc2UiLCJQb29sIiwiQ2xpZW50IiwidXRpbCIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IiLCJrT25Db25uZWN0IiwiU3ltYm9sIiwia09uRGlzY29ubmVjdCIsImtPbkNvbm5lY3Rpb25FcnJvciIsImtNYXhSZWRpcmVjdGlvbnMiLCJrT25EcmFpbiIsImtGYWN0b3J5Iiwia09wdGlvbnMiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIm9wdHMiLCJjb25uZWN0aW9ucyIsIkFnZW50IiwiZmFjdG9yeSIsIm1heFJlZGlyZWN0aW9ucyIsImNvbm5lY3QiLCJvcHRpb25zIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJjZXB0b3JzIiwiQXJyYXkiLCJpc0FycmF5IiwiZGVlcENsb25lIiwidW5kZWZpbmVkIiwiTWFwIiwidGFyZ2V0cyIsImVtaXQiLCJlcnIiLCJyZXQiLCJjbGllbnQiLCJ2YWx1ZXMiLCJoYW5kbGVyIiwia2V5IiwiVVJMIiwiU3RyaW5nIiwiZGlzcGF0Y2hlciIsImdldCIsIm9uIiwic2V0IiwiZGlzcGF0Y2giLCJjbG9zZVByb21pc2VzIiwicHVzaCIsImNsb3NlIiwiY2xlYXIiLCJQcm9taXNlIiwiYWxsIiwiZGVzdHJveVByb21pc2VzIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/balanced-pool.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { BalancedPoolMissingUpstreamError, InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { parseOrigin } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst kFactory = Symbol('factory');\nconst kOptions = Symbol('options');\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');\nconst kCurrentWeight = Symbol('kCurrentWeight');\nconst kIndex = Symbol('kIndex');\nconst kWeight = Symbol('kWeight');\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer');\nconst kErrorPenalty = Symbol('kErrorPenalty');\nfunction getGreatestCommonDivisor(a, b) {\n    if (b === 0) return a;\n    return getGreatestCommonDivisor(b, a % b);\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass BalancedPool extends PoolBase {\n    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}){\n        super();\n        this[kOptions] = opts;\n        this[kIndex] = -1;\n        this[kCurrentWeight] = 0;\n        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n        if (!Array.isArray(upstreams)) {\n            upstreams = [\n                upstreams\n            ];\n        }\n        if (typeof factory !== 'function') {\n            throw new InvalidArgumentError('factory must be a function.');\n        }\n        this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];\n        this[kFactory] = factory;\n        for (const upstream of upstreams){\n            this.addUpstream(upstream);\n        }\n        this._updateBalancedPoolStats();\n    }\n    addUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        if (this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n            return this;\n        }\n        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n        this[kAddClient](pool);\n        pool.on('connect', ()=>{\n            pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n        });\n        pool.on('connectionError', ()=>{\n            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n            this._updateBalancedPoolStats();\n        });\n        pool.on('disconnect', (...args)=>{\n            const err = args[2];\n            if (err && err.code === 'UND_ERR_SOCKET') {\n                // decrease the weight of the pool.\n                pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n                this._updateBalancedPoolStats();\n            }\n        });\n        for (const client of this[kClients]){\n            client[kWeight] = this[kMaxWeightPerServer];\n        }\n        this._updateBalancedPoolStats();\n        return this;\n    }\n    _updateBalancedPoolStats() {\n        this[kGreatestCommonDivisor] = this[kClients].map((p)=>p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n    }\n    removeUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        const pool = this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n        if (pool) {\n            this[kRemoveClient](pool);\n        }\n        return this;\n    }\n    get upstreams() {\n        return this[kClients].filter((dispatcher)=>dispatcher.closed !== true && dispatcher.destroyed !== true).map((p)=>p[kUrl].origin);\n    }\n    [kGetDispatcher]() {\n        // We validate that pools is greater than 0,\n        // otherwise we would have to wait until an upstream\n        // is added, which might never happen.\n        if (this[kClients].length === 0) {\n            throw new BalancedPoolMissingUpstreamError();\n        }\n        const dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n        if (!dispatcher) {\n            return;\n        }\n        const allClientsBusy = this[kClients].map((pool)=>pool[kNeedDrain]).reduce((a, b)=>a && b, true);\n        if (allClientsBusy) {\n            return;\n        }\n        let counter = 0;\n        let maxWeightIndex = this[kClients].findIndex((pool)=>!pool[kNeedDrain]);\n        while(counter++ < this[kClients].length){\n            this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n            const pool = this[kClients][this[kIndex]];\n            // find pool index with the largest weight\n            if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n                maxWeightIndex = this[kIndex];\n            }\n            // decrease the current weight every `this[kClients].length`.\n            if (this[kIndex] === 0) {\n                // Set the current weight to the next lower weight.\n                this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n                if (this[kCurrentWeight] <= 0) {\n                    this[kCurrentWeight] = this[kMaxWeightPerServer];\n                }\n            }\n            if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n                return pool;\n            }\n        }\n        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n        this[kIndex] = maxWeightIndex;\n        return this[kClients][maxWeightIndex];\n    }\n}\nmodule.exports = BalancedPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLGdDQUFnQyxFQUNoQ0Msb0JBQW9CLEVBQ3JCLEdBQUdDLG1CQUFPQSxDQUFDLHNFQUFnQjtBQUM1QixNQUFNLEVBQ0pDLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsYUFBYSxFQUNiQyxjQUFjLEVBQ2YsR0FBR04sbUJBQU9BLENBQUMsNEVBQWE7QUFDekIsTUFBTU8sT0FBT1AsbUJBQU9BLENBQUMsa0VBQVE7QUFDN0IsTUFBTSxFQUFFUSxJQUFJLEVBQUVDLGFBQWEsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQyx3RUFBaUI7QUFDekQsTUFBTSxFQUFFVSxXQUFXLEVBQUUsR0FBR1YsbUJBQU9BLENBQUMsa0VBQWM7QUFDOUMsTUFBTVcsV0FBV0MsT0FBTztBQUV4QixNQUFNQyxXQUFXRCxPQUFPO0FBQ3hCLE1BQU1FLHlCQUF5QkYsT0FBTztBQUN0QyxNQUFNRyxpQkFBaUJILE9BQU87QUFDOUIsTUFBTUksU0FBU0osT0FBTztBQUN0QixNQUFNSyxVQUFVTCxPQUFPO0FBQ3ZCLE1BQU1NLHNCQUFzQk4sT0FBTztBQUNuQyxNQUFNTyxnQkFBZ0JQLE9BQU87QUFFN0IsU0FBU1EseUJBQTBCQyxDQUFDLEVBQUVDLENBQUM7SUFDckMsSUFBSUEsTUFBTSxHQUFHLE9BQU9EO0lBQ3BCLE9BQU9ELHlCQUF5QkUsR0FBR0QsSUFBSUM7QUFDekM7QUFFQSxTQUFTQyxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ25DLE9BQU8sSUFBSWxCLEtBQUtpQixRQUFRQztBQUMxQjtBQUVBLE1BQU1DLHFCQUFxQnpCO0lBQ3pCLFlBQWEwQixZQUFZLEVBQUUsRUFBRSxFQUFFQyxVQUFVTCxjQUFjLEVBQUUsR0FBR0UsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3ZFLEtBQUs7UUFFTCxJQUFJLENBQUNaLFNBQVMsR0FBR1k7UUFDakIsSUFBSSxDQUFDVCxPQUFPLEdBQUcsQ0FBQztRQUNoQixJQUFJLENBQUNELGVBQWUsR0FBRztRQUV2QixJQUFJLENBQUNHLG9CQUFvQixHQUFHLElBQUksQ0FBQ0wsU0FBUyxDQUFDZ0Isa0JBQWtCLElBQUk7UUFDakUsSUFBSSxDQUFDVixjQUFjLEdBQUcsSUFBSSxDQUFDTixTQUFTLENBQUNpQixZQUFZLElBQUk7UUFFckQsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNMLFlBQVk7WUFDN0JBLFlBQVk7Z0JBQUNBO2FBQVU7UUFDekI7UUFFQSxJQUFJLE9BQU9DLFlBQVksWUFBWTtZQUNqQyxNQUFNLElBQUk3QixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNVLGNBQWMsR0FBR2dCLEtBQUtRLFlBQVksRUFBRVAsZ0JBQWdCSyxNQUFNQyxPQUFPLENBQUNQLEtBQUtRLFlBQVksQ0FBQ1AsWUFBWSxJQUNqR0QsS0FBS1EsWUFBWSxDQUFDUCxZQUFZLEdBQzlCLEVBQUU7UUFDTixJQUFJLENBQUNmLFNBQVMsR0FBR2lCO1FBRWpCLEtBQUssTUFBTU0sWUFBWVAsVUFBVztZQUNoQyxJQUFJLENBQUNRLFdBQVcsQ0FBQ0Q7UUFDbkI7UUFDQSxJQUFJLENBQUNFLHdCQUF3QjtJQUMvQjtJQUVBRCxZQUFhRCxRQUFRLEVBQUU7UUFDckIsTUFBTUcsaUJBQWlCM0IsWUFBWXdCLFVBQVVWLE1BQU07UUFFbkQsSUFBSSxJQUFJLENBQUN0QixTQUFTLENBQUNvQyxJQUFJLENBQUMsQ0FBQ0MsT0FDdkJBLElBQUksQ0FBQy9CLEtBQUssQ0FBQ2dCLE1BQU0sS0FBS2Esa0JBQ3RCRSxLQUFLQyxNQUFNLEtBQUssUUFDaEJELEtBQUtFLFNBQVMsS0FBSyxPQUNqQjtZQUNGLE9BQU8sSUFBSTtRQUNiO1FBQ0EsTUFBTUYsT0FBTyxJQUFJLENBQUM1QixTQUFTLENBQUMwQixnQkFBZ0JLLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDOUIsU0FBUztRQUU1RSxJQUFJLENBQUNULFdBQVcsQ0FBQ21DO1FBQ2pCQSxLQUFLSyxFQUFFLENBQUMsV0FBVztZQUNqQkwsSUFBSSxDQUFDdEIsUUFBUSxHQUFHNEIsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQzVCLG9CQUFvQixFQUFFcUIsSUFBSSxDQUFDdEIsUUFBUSxHQUFHLElBQUksQ0FBQ0UsY0FBYztRQUN6RjtRQUVBb0IsS0FBS0ssRUFBRSxDQUFDLG1CQUFtQjtZQUN6QkwsSUFBSSxDQUFDdEIsUUFBUSxHQUFHNEIsS0FBS0UsR0FBRyxDQUFDLEdBQUdSLElBQUksQ0FBQ3RCLFFBQVEsR0FBRyxJQUFJLENBQUNFLGNBQWM7WUFDL0QsSUFBSSxDQUFDaUIsd0JBQXdCO1FBQy9CO1FBRUFHLEtBQUtLLEVBQUUsQ0FBQyxjQUFjLENBQUMsR0FBR0k7WUFDeEIsTUFBTUMsTUFBTUQsSUFBSSxDQUFDLEVBQUU7WUFDbkIsSUFBSUMsT0FBT0EsSUFBSUMsSUFBSSxLQUFLLGtCQUFrQjtnQkFDeEMsbUNBQW1DO2dCQUNuQ1gsSUFBSSxDQUFDdEIsUUFBUSxHQUFHNEIsS0FBS0UsR0FBRyxDQUFDLEdBQUdSLElBQUksQ0FBQ3RCLFFBQVEsR0FBRyxJQUFJLENBQUNFLGNBQWM7Z0JBQy9ELElBQUksQ0FBQ2lCLHdCQUF3QjtZQUMvQjtRQUNGO1FBRUEsS0FBSyxNQUFNZSxVQUFVLElBQUksQ0FBQ2pELFNBQVMsQ0FBRTtZQUNuQ2lELE1BQU0sQ0FBQ2xDLFFBQVEsR0FBRyxJQUFJLENBQUNDLG9CQUFvQjtRQUM3QztRQUVBLElBQUksQ0FBQ2tCLHdCQUF3QjtRQUU3QixPQUFPLElBQUk7SUFDYjtJQUVBQSwyQkFBNEI7UUFDMUIsSUFBSSxDQUFDdEIsdUJBQXVCLEdBQUcsSUFBSSxDQUFDWixTQUFTLENBQUNrRCxHQUFHLENBQUNDLENBQUFBLElBQUtBLENBQUMsQ0FBQ3BDLFFBQVEsRUFBRXFDLE1BQU0sQ0FBQ2xDLDBCQUEwQjtJQUN0RztJQUVBbUMsZUFBZ0JyQixRQUFRLEVBQUU7UUFDeEIsTUFBTUcsaUJBQWlCM0IsWUFBWXdCLFVBQVVWLE1BQU07UUFFbkQsTUFBTWUsT0FBTyxJQUFJLENBQUNyQyxTQUFTLENBQUNvQyxJQUFJLENBQUMsQ0FBQ0MsT0FDaENBLElBQUksQ0FBQy9CLEtBQUssQ0FBQ2dCLE1BQU0sS0FBS2Esa0JBQ3RCRSxLQUFLQyxNQUFNLEtBQUssUUFDaEJELEtBQUtFLFNBQVMsS0FBSztRQUdyQixJQUFJRixNQUFNO1lBQ1IsSUFBSSxDQUFDbEMsY0FBYyxDQUFDa0M7UUFDdEI7UUFFQSxPQUFPLElBQUk7SUFDYjtJQUVBLElBQUlaLFlBQWE7UUFDZixPQUFPLElBQUksQ0FBQ3pCLFNBQVMsQ0FDbEJzRCxNQUFNLENBQUNDLENBQUFBLGFBQWNBLFdBQVdqQixNQUFNLEtBQUssUUFBUWlCLFdBQVdoQixTQUFTLEtBQUssTUFDNUVXLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxDQUFDLENBQUM3QyxLQUFLLENBQUNnQixNQUFNO0lBQzlCO0lBRUEsQ0FBQ2xCLGVBQWUsR0FBSTtRQUNsQiw0Q0FBNEM7UUFDNUMsb0RBQW9EO1FBQ3BELHNDQUFzQztRQUN0QyxJQUFJLElBQUksQ0FBQ0osU0FBUyxDQUFDd0QsTUFBTSxLQUFLLEdBQUc7WUFDL0IsTUFBTSxJQUFJNUQ7UUFDWjtRQUVBLE1BQU0yRCxhQUFhLElBQUksQ0FBQ3ZELFNBQVMsQ0FBQ29DLElBQUksQ0FBQ21CLENBQUFBLGFBQ3JDLENBQUNBLFVBQVUsQ0FBQ3RELFdBQVcsSUFDdkJzRCxXQUFXakIsTUFBTSxLQUFLLFFBQ3RCaUIsV0FBV2hCLFNBQVMsS0FBSztRQUczQixJQUFJLENBQUNnQixZQUFZO1lBQ2Y7UUFDRjtRQUVBLE1BQU1FLGlCQUFpQixJQUFJLENBQUN6RCxTQUFTLENBQUNrRCxHQUFHLENBQUNiLENBQUFBLE9BQVFBLElBQUksQ0FBQ3BDLFdBQVcsRUFBRW1ELE1BQU0sQ0FBQyxDQUFDakMsR0FBR0MsSUFBTUQsS0FBS0MsR0FBRztRQUU3RixJQUFJcUMsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJQyxVQUFVO1FBRWQsSUFBSUMsaUJBQWlCLElBQUksQ0FBQzNELFNBQVMsQ0FBQzRELFNBQVMsQ0FBQ3ZCLENBQUFBLE9BQVEsQ0FBQ0EsSUFBSSxDQUFDcEMsV0FBVztRQUV2RSxNQUFPeUQsWUFBWSxJQUFJLENBQUMxRCxTQUFTLENBQUN3RCxNQUFNLENBQUU7WUFDeEMsSUFBSSxDQUFDMUMsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDQSxPQUFPLEdBQUcsS0FBSyxJQUFJLENBQUNkLFNBQVMsQ0FBQ3dELE1BQU07WUFDekQsTUFBTW5CLE9BQU8sSUFBSSxDQUFDckMsU0FBUyxDQUFDLElBQUksQ0FBQ2MsT0FBTyxDQUFDO1lBRXpDLDBDQUEwQztZQUMxQyxJQUFJdUIsSUFBSSxDQUFDdEIsUUFBUSxHQUFHLElBQUksQ0FBQ2YsU0FBUyxDQUFDMkQsZUFBZSxDQUFDNUMsUUFBUSxJQUFJLENBQUNzQixJQUFJLENBQUNwQyxXQUFXLEVBQUU7Z0JBQ2hGMEQsaUJBQWlCLElBQUksQ0FBQzdDLE9BQU87WUFDL0I7WUFFQSw2REFBNkQ7WUFDN0QsSUFBSSxJQUFJLENBQUNBLE9BQU8sS0FBSyxHQUFHO2dCQUN0QixtREFBbUQ7Z0JBQ25ELElBQUksQ0FBQ0QsZUFBZSxHQUFHLElBQUksQ0FBQ0EsZUFBZSxHQUFHLElBQUksQ0FBQ0QsdUJBQXVCO2dCQUUxRSxJQUFJLElBQUksQ0FBQ0MsZUFBZSxJQUFJLEdBQUc7b0JBQzdCLElBQUksQ0FBQ0EsZUFBZSxHQUFHLElBQUksQ0FBQ0csb0JBQW9CO2dCQUNsRDtZQUNGO1lBQ0EsSUFBSXFCLElBQUksQ0FBQ3RCLFFBQVEsSUFBSSxJQUFJLENBQUNGLGVBQWUsSUFBSyxDQUFDd0IsSUFBSSxDQUFDcEMsV0FBVyxFQUFHO2dCQUNoRSxPQUFPb0M7WUFDVDtRQUNGO1FBRUEsSUFBSSxDQUFDeEIsZUFBZSxHQUFHLElBQUksQ0FBQ2IsU0FBUyxDQUFDMkQsZUFBZSxDQUFDNUMsUUFBUTtRQUM5RCxJQUFJLENBQUNELE9BQU8sR0FBRzZDO1FBQ2YsT0FBTyxJQUFJLENBQUMzRCxTQUFTLENBQUMyRCxlQUFlO0lBQ3ZDO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHdEMiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcYmFsYW5jZWQtcG9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga1JlbW92ZUNsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn0gPSByZXF1aXJlKCcuL3Bvb2wtYmFzZScpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IHsga1VybCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgcGFyc2VPcmlnaW4gfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5cbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtHcmVhdGVzdENvbW1vbkRpdmlzb3IgPSBTeW1ib2woJ2tHcmVhdGVzdENvbW1vbkRpdmlzb3InKVxuY29uc3Qga0N1cnJlbnRXZWlnaHQgPSBTeW1ib2woJ2tDdXJyZW50V2VpZ2h0JylcbmNvbnN0IGtJbmRleCA9IFN5bWJvbCgna0luZGV4JylcbmNvbnN0IGtXZWlnaHQgPSBTeW1ib2woJ2tXZWlnaHQnKVxuY29uc3Qga01heFdlaWdodFBlclNlcnZlciA9IFN5bWJvbCgna01heFdlaWdodFBlclNlcnZlcicpXG5jb25zdCBrRXJyb3JQZW5hbHR5ID0gU3ltYm9sKCdrRXJyb3JQZW5hbHR5JylcblxuZnVuY3Rpb24gZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yIChhLCBiKSB7XG4gIGlmIChiID09PSAwKSByZXR1cm4gYVxuICByZXR1cm4gZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yKGIsIGEgJSBiKVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNsYXNzIEJhbGFuY2VkUG9vbCBleHRlbmRzIFBvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IgKHVwc3RyZWFtcyA9IFtdLCB7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgLi4ub3B0cyB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tPcHRpb25zXSA9IG9wdHNcbiAgICB0aGlzW2tJbmRleF0gPSAtMVxuICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gMFxuXG4gICAgdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXSA9IHRoaXNba09wdGlvbnNdLm1heFdlaWdodFBlclNlcnZlciB8fCAxMDBcbiAgICB0aGlzW2tFcnJvclBlbmFsdHldID0gdGhpc1trT3B0aW9uc10uZXJyb3JQZW5hbHR5IHx8IDE1XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodXBzdHJlYW1zKSkge1xuICAgICAgdXBzdHJlYW1zID0gW3Vwc3RyZWFtc11cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0cy5pbnRlcmNlcHRvcnM/LkJhbGFuY2VkUG9vbCAmJiBBcnJheS5pc0FycmF5KG9wdHMuaW50ZXJjZXB0b3JzLkJhbGFuY2VkUG9vbClcbiAgICAgID8gb3B0cy5pbnRlcmNlcHRvcnMuQmFsYW5jZWRQb29sXG4gICAgICA6IFtdXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG5cbiAgICBmb3IgKGNvbnN0IHVwc3RyZWFtIG9mIHVwc3RyZWFtcykge1xuICAgICAgdGhpcy5hZGRVcHN0cmVhbSh1cHN0cmVhbSlcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICB9XG5cbiAgYWRkVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBpZiAodGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgY29uc3QgcG9vbCA9IHRoaXNba0ZhY3RvcnldKHVwc3RyZWFtT3JpZ2luLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzW2tPcHRpb25zXSkpXG5cbiAgICB0aGlzW2tBZGRDbGllbnRdKHBvb2wpXG4gICAgcG9vbC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1pbih0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdLCBwb29sW2tXZWlnaHRdICsgdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICB9KVxuXG4gICAgcG9vbC5vbignY29ubmVjdGlvbkVycm9yJywgKCkgPT4ge1xuICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgIH0pXG5cbiAgICBwb29sLm9uKCdkaXNjb25uZWN0JywgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGFyZ3NbMl1cbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdVTkRfRVJSX1NPQ0tFVCcpIHtcbiAgICAgICAgLy8gZGVjcmVhc2UgdGhlIHdlaWdodCBvZiB0aGUgcG9vbC5cbiAgICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICBjbGllbnRba1dlaWdodF0gPSB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cyAoKSB7XG4gICAgdGhpc1trR3JlYXRlc3RDb21tb25EaXZpc29yXSA9IHRoaXNba0NsaWVudHNdLm1hcChwID0+IHBba1dlaWdodF0pLnJlZHVjZShnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IsIDApXG4gIH1cblxuICByZW1vdmVVcHN0cmVhbSAodXBzdHJlYW0pIHtcbiAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW5cblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXS5maW5kKChwb29sKSA9PiAoXG4gICAgICBwb29sW2tVcmxdLm9yaWdpbiA9PT0gdXBzdHJlYW1PcmlnaW4gJiZcbiAgICAgIHBvb2wuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBwb29sLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAocG9vbCkge1xuICAgICAgdGhpc1trUmVtb3ZlQ2xpZW50XShwb29sKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgdXBzdHJlYW1zICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11cbiAgICAgIC5maWx0ZXIoZGlzcGF0Y2hlciA9PiBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJiBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZSlcbiAgICAgIC5tYXAoKHApID0+IHBba1VybF0ub3JpZ2luKVxuICB9XG5cbiAgW2tHZXREaXNwYXRjaGVyXSAoKSB7XG4gICAgLy8gV2UgdmFsaWRhdGUgdGhhdCBwb29scyBpcyBncmVhdGVyIHRoYW4gMCxcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byB3YWl0IHVudGlsIGFuIHVwc3RyZWFtXG4gICAgLy8gaXMgYWRkZWQsIHdoaWNoIG1pZ2h0IG5ldmVyIGhhcHBlbi5cbiAgICBpZiAodGhpc1trQ2xpZW50c10ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5maW5kKGRpc3BhdGNoZXIgPT4gKFxuICAgICAgIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiZcbiAgICAgIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFsbENsaWVudHNCdXN5ID0gdGhpc1trQ2xpZW50c10ubWFwKHBvb2wgPT4gcG9vbFtrTmVlZERyYWluXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG5cbiAgICBpZiAoYWxsQ2xpZW50c0J1c3kpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBjb3VudGVyID0gMFxuXG4gICAgbGV0IG1heFdlaWdodEluZGV4ID0gdGhpc1trQ2xpZW50c10uZmluZEluZGV4KHBvb2wgPT4gIXBvb2xba05lZWREcmFpbl0pXG5cbiAgICB3aGlsZSAoY291bnRlcisrIDwgdGhpc1trQ2xpZW50c10ubGVuZ3RoKSB7XG4gICAgICB0aGlzW2tJbmRleF0gPSAodGhpc1trSW5kZXhdICsgMSkgJSB0aGlzW2tDbGllbnRzXS5sZW5ndGhcbiAgICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXVt0aGlzW2tJbmRleF1dXG5cbiAgICAgIC8vIGZpbmQgcG9vbCBpbmRleCB3aXRoIHRoZSBsYXJnZXN0IHdlaWdodFxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF0gJiYgIXBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgbWF4V2VpZ2h0SW5kZXggPSB0aGlzW2tJbmRleF1cbiAgICAgIH1cblxuICAgICAgLy8gZGVjcmVhc2UgdGhlIGN1cnJlbnQgd2VpZ2h0IGV2ZXJ5IGB0aGlzW2tDbGllbnRzXS5sZW5ndGhgLlxuICAgICAgaWYgKHRoaXNba0luZGV4XSA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgd2VpZ2h0IHRvIHRoZSBuZXh0IGxvd2VyIHdlaWdodC5cbiAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAtIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl1cblxuICAgICAgICBpZiAodGhpc1trQ3VycmVudFdlaWdodF0gPD0gMCkge1xuICAgICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9vbFtrV2VpZ2h0XSA+PSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAmJiAoIXBvb2xba05lZWREcmFpbl0pKSB7XG4gICAgICAgIHJldHVybiBwb29sXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF1cbiAgICB0aGlzW2tJbmRleF0gPSBtYXhXZWlnaHRJbmRleFxuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VkUG9vbFxuIl0sIm5hbWVzIjpbIkJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJyZXF1aXJlIiwiUG9vbEJhc2UiLCJrQ2xpZW50cyIsImtOZWVkRHJhaW4iLCJrQWRkQ2xpZW50Iiwia1JlbW92ZUNsaWVudCIsImtHZXREaXNwYXRjaGVyIiwiUG9vbCIsImtVcmwiLCJrSW50ZXJjZXB0b3JzIiwicGFyc2VPcmlnaW4iLCJrRmFjdG9yeSIsIlN5bWJvbCIsImtPcHRpb25zIiwia0dyZWF0ZXN0Q29tbW9uRGl2aXNvciIsImtDdXJyZW50V2VpZ2h0Iiwia0luZGV4Iiwia1dlaWdodCIsImtNYXhXZWlnaHRQZXJTZXJ2ZXIiLCJrRXJyb3JQZW5hbHR5IiwiZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yIiwiYSIsImIiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIm9wdHMiLCJCYWxhbmNlZFBvb2wiLCJ1cHN0cmVhbXMiLCJmYWN0b3J5IiwibWF4V2VpZ2h0UGVyU2VydmVyIiwiZXJyb3JQZW5hbHR5IiwiQXJyYXkiLCJpc0FycmF5IiwiaW50ZXJjZXB0b3JzIiwidXBzdHJlYW0iLCJhZGRVcHN0cmVhbSIsIl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cyIsInVwc3RyZWFtT3JpZ2luIiwiZmluZCIsInBvb2wiLCJjbG9zZWQiLCJkZXN0cm95ZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJvbiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJhcmdzIiwiZXJyIiwiY29kZSIsImNsaWVudCIsIm1hcCIsInAiLCJyZWR1Y2UiLCJyZW1vdmVVcHN0cmVhbSIsImZpbHRlciIsImRpc3BhdGNoZXIiLCJsZW5ndGgiLCJhbGxDbGllbnRzQnVzeSIsImNvdW50ZXIiLCJtYXhXZWlnaHRJbmRleCIsImZpbmRJbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* global WebAssembly */ const assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst timers = __webpack_require__(/*! ../util/timers.js */ \"(ssr)/./node_modules/undici/lib/util/timers.js\");\nconst { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, RequestAbortedError, HeadersTimeoutError, HeadersOverflowError, SocketError, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError } = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { kUrl, kReset, kClient, kParser, kBlocking, kRunning, kPending, kSize, kWriting, kQueue, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kMaxRequests, kCounter, kMaxResponseSize, kOnError, kResume, kHTTPContext } = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst constants = __webpack_require__(/*! ../llhttp/constants.js */ \"(ssr)/./node_modules/undici/lib/llhttp/constants.js\");\nconst EMPTY_BUF = Buffer.alloc(0);\nconst FastBuffer = Buffer[Symbol.species];\nconst addListener = util.addListener;\nconst removeAllListeners = util.removeAllListeners;\nlet extractBody;\nasync function lazyllhttp() {\n    const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined;\n    let mod;\n    try {\n        mod = await WebAssembly.compile(__webpack_require__(/*! ../llhttp/llhttp_simd-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"));\n    } catch (e) {\n        /* istanbul ignore next */ // We could check if the error was caused by the simd option not\n        // being enabled, but the occurring of this other error\n        // * https://github.com/emscripten-core/emscripten/issues/11495\n        // got me to remove that check to avoid breaking Node 12.\n        mod = await WebAssembly.compile(llhttpWasmData || __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\"));\n    }\n    return await WebAssembly.instantiate(mod, {\n        env: {\n            /* eslint-disable camelcase */ wasm_on_url: (p, at, len)=>{\n                /* istanbul ignore next */ return 0;\n            },\n            wasm_on_status: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_begin: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageBegin() || 0;\n            },\n            wasm_on_header_field: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_header_value: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n            },\n            wasm_on_body: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_complete: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageComplete() || 0;\n            }\n        }\n    });\n}\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n    constructor(client, socket, { exports }){\n        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n        this.llhttp = exports;\n        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n        this.client = client;\n        this.socket = socket;\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.statusCode = null;\n        this.statusText = '';\n        this.upgrade = false;\n        this.headers = [];\n        this.headersSize = 0;\n        this.headersMaxSize = client[kMaxHeadersSize];\n        this.shouldKeepAlive = false;\n        this.paused = false;\n        this.resume = this.resume.bind(this);\n        this.bytesRead = 0;\n        this.keepAlive = '';\n        this.contentLength = '';\n        this.connection = '';\n        this.maxResponseSize = client[kMaxResponseSize];\n    }\n    setTimeout(value, type) {\n        this.timeoutType = type;\n        if (value !== this.timeoutValue) {\n            timers.clearTimeout(this.timeout);\n            if (value) {\n                this.timeout = timers.setTimeout(onParserTimeout, value, this);\n                // istanbul ignore else: only for jest\n                if (this.timeout.unref) {\n                    this.timeout.unref();\n                }\n            } else {\n                this.timeout = null;\n            }\n            this.timeoutValue = value;\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n    }\n    resume() {\n        if (this.socket.destroyed || !this.paused) {\n            return;\n        }\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_resume(this.ptr);\n        assert(this.timeoutType === TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        this.paused = false;\n        this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n        this.readMore();\n    }\n    readMore() {\n        while(!this.paused && this.ptr){\n            const chunk = this.socket.read();\n            if (chunk === null) {\n                break;\n            }\n            this.execute(chunk);\n        }\n    }\n    execute(data) {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        assert(!this.paused);\n        const { socket, llhttp } = this;\n        if (data.length > currentBufferSize) {\n            if (currentBufferPtr) {\n                llhttp.free(currentBufferPtr);\n            }\n            currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n            currentBufferPtr = llhttp.malloc(currentBufferSize);\n        }\n        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n        // Call `execute` on the wasm parser.\n        // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n        // and finally the length of bytes to parse.\n        // The return value is an error code or `constants.ERROR.OK`.\n        try {\n            let ret;\n            try {\n                currentBufferRef = data;\n                currentParser = this;\n                ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n            /* eslint-disable-next-line no-useless-catch */ } catch (err) {\n                /* istanbul ignore next: difficult to make a test case for */ throw err;\n            } finally{\n                currentParser = null;\n                currentBufferRef = null;\n            }\n            const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n            if (ret === constants.ERROR.PAUSED_UPGRADE) {\n                this.onUpgrade(data.slice(offset));\n            } else if (ret === constants.ERROR.PAUSED) {\n                this.paused = true;\n                socket.unshift(data.slice(offset));\n            } else if (ret !== constants.ERROR.OK) {\n                const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n                let message = '';\n                /* istanbul ignore else: difficult to make a test case for */ if (ptr) {\n                    const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n                    message = 'Response does not match the HTTP/1.1 protocol (' + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ')';\n                }\n                throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n            }\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n    }\n    destroy() {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_free(this.ptr);\n        this.ptr = null;\n        timers.clearTimeout(this.timeout);\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.paused = false;\n    }\n    onStatus(buf) {\n        this.statusText = buf.toString();\n    }\n    onMessageBegin() {\n        const { socket, client } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        if (!request) {\n            return -1;\n        }\n        request.onResponseStarted();\n    }\n    onHeaderField(buf) {\n        const len = this.headers.length;\n        if ((len & 1) === 0) {\n            this.headers.push(buf);\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        this.trackHeader(buf.length);\n    }\n    onHeaderValue(buf) {\n        let len = this.headers.length;\n        if ((len & 1) === 1) {\n            this.headers.push(buf);\n            len += 1;\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        const key = this.headers[len - 2];\n        if (key.length === 10) {\n            const headerName = util.bufferToLowerCasedHeaderName(key);\n            if (headerName === 'keep-alive') {\n                this.keepAlive += buf.toString();\n            } else if (headerName === 'connection') {\n                this.connection += buf.toString();\n            }\n        } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n            this.contentLength += buf.toString();\n        }\n        this.trackHeader(buf.length);\n    }\n    trackHeader(len) {\n        this.headersSize += len;\n        if (this.headersSize >= this.headersMaxSize) {\n            util.destroy(this.socket, new HeadersOverflowError());\n        }\n    }\n    onUpgrade(head) {\n        const { upgrade, client, socket, headers, statusCode } = this;\n        assert(upgrade);\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(!socket.destroyed);\n        assert(socket === client[kSocket]);\n        assert(!this.paused);\n        assert(request.upgrade || request.method === 'CONNECT');\n        this.statusCode = null;\n        this.statusText = '';\n        this.shouldKeepAlive = null;\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        socket.unshift(head);\n        socket[kParser].destroy();\n        socket[kParser] = null;\n        socket[kClient] = null;\n        socket[kError] = null;\n        removeAllListeners(socket);\n        client[kSocket] = null;\n        client[kHTTPContext] = null; // TODO (fix): This is hacky...\n        client[kQueue][client[kRunningIdx]++] = null;\n        client.emit('disconnect', client[kUrl], [\n            client\n        ], new InformationalError('upgrade'));\n        try {\n            request.onUpgrade(statusCode, headers, socket);\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n        client[kResume]();\n    }\n    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n        const { client, socket, headers, statusText } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        /* istanbul ignore next: difficult to make a test case for */ if (!request) {\n            return -1;\n        }\n        assert(!this.upgrade);\n        assert(this.statusCode < 200);\n        if (statusCode === 100) {\n            util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n            return -1;\n        }\n        /* this can only happen if server is misbehaving */ if (upgrade && !request.upgrade) {\n            util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n            return -1;\n        }\n        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n        this.statusCode = statusCode;\n        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.\n        request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive';\n        if (this.statusCode >= 200) {\n            const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n            this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        if (request.method === 'CONNECT') {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        if (upgrade) {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (this.shouldKeepAlive && client[kPipelining]) {\n            const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n            if (keepAliveTimeout != null) {\n                const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n                if (timeout <= 0) {\n                    socket[kReset] = true;\n                } else {\n                    client[kKeepAliveTimeoutValue] = timeout;\n                }\n            } else {\n                client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n            }\n        } else {\n            // Stop more requests from being dispatched.\n            socket[kReset] = true;\n        }\n        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n        if (request.aborted) {\n            return -1;\n        }\n        if (request.method === 'HEAD') {\n            return 1;\n        }\n        if (statusCode < 200) {\n            return 1;\n        }\n        if (socket[kBlocking]) {\n            socket[kBlocking] = false;\n            client[kResume]();\n        }\n        return pause ? constants.ERROR.PAUSED : 0;\n    }\n    onBody(buf) {\n        const { client, socket, statusCode, maxResponseSize } = this;\n        if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        assert(statusCode >= 200);\n        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n            util.destroy(socket, new ResponseExceededMaxSizeError());\n            return -1;\n        }\n        this.bytesRead += buf.length;\n        if (request.onData(buf) === false) {\n            return constants.ERROR.PAUSED;\n        }\n    }\n    onMessageComplete() {\n        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;\n        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n            return -1;\n        }\n        if (upgrade) {\n            return;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(statusCode >= 100);\n        this.statusCode = null;\n        this.statusText = '';\n        this.bytesRead = 0;\n        this.contentLength = '';\n        this.keepAlive = '';\n        this.connection = '';\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (statusCode < 200) {\n            return;\n        }\n        /* istanbul ignore next: should be handled by llhttp? */ if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n            util.destroy(socket, new ResponseContentLengthMismatchError());\n            return -1;\n        }\n        request.onComplete(headers);\n        client[kQueue][client[kRunningIdx]++] = null;\n        if (socket[kWriting]) {\n            assert.strictEqual(client[kRunning], 0);\n            // Response completed before request.\n            util.destroy(socket, new InformationalError('reset'));\n            return constants.ERROR.PAUSED;\n        } else if (!shouldKeepAlive) {\n            util.destroy(socket, new InformationalError('reset'));\n            return constants.ERROR.PAUSED;\n        } else if (socket[kReset] && client[kRunning] === 0) {\n            // Destroy socket once all requests have completed.\n            // The request at the tail of the pipeline is the one\n            // that requested reset and no further requests should\n            // have been queued since then.\n            util.destroy(socket, new InformationalError('reset'));\n            return constants.ERROR.PAUSED;\n        } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n            // We must wait a full event loop cycle to reuse this socket to make sure\n            // that non-spec compliant servers are not closing the connection even if they\n            // said they won't.\n            setImmediate(()=>client[kResume]());\n        } else {\n            client[kResume]();\n        }\n    }\n}\nfunction onParserTimeout(parser) {\n    const { socket, timeoutType, client } = parser;\n    /* istanbul ignore else */ if (timeoutType === TIMEOUT_HEADERS) {\n        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n            assert(!parser.paused, 'cannot be paused while waiting for headers');\n            util.destroy(socket, new HeadersTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_BODY) {\n        if (!parser.paused) {\n            util.destroy(socket, new BodyTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_IDLE) {\n        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n        util.destroy(socket, new InformationalError('socket idle timeout'));\n    }\n}\nasync function connectH1(client, socket) {\n    client[kSocket] = socket;\n    if (!llhttpInstance) {\n        llhttpInstance = await llhttpPromise;\n        llhttpPromise = null;\n    }\n    socket[kNoRef] = false;\n    socket[kWriting] = false;\n    socket[kReset] = false;\n    socket[kBlocking] = false;\n    socket[kParser] = new Parser(client, socket, llhttpInstance);\n    addListener(socket, 'error', function(err) {\n        const parser = this[kParser];\n        assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n        // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n        // to the user.\n        if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so for as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n        this[kError] = err;\n        this[kClient][kOnError](err);\n    });\n    addListener(socket, 'readable', function() {\n        const parser = this[kParser];\n        if (parser) {\n            parser.readMore();\n        }\n    });\n    addListener(socket, 'end', function() {\n        const parser = this[kParser];\n        if (parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n        util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n    });\n    addListener(socket, 'close', function() {\n        const client = this[kClient];\n        const parser = this[kParser];\n        if (parser) {\n            if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n                // We treat all incoming data so far as a valid response.\n                parser.onMessageComplete();\n            }\n            this[kParser].destroy();\n            this[kParser] = null;\n        }\n        const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n        client[kSocket] = null;\n        client[kHTTPContext] = null; // TODO (fix): This is hacky...\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            // Fail entire queue.\n            const requests = client[kQueue].splice(client[kRunningIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                util.errorRequest(client, request, err);\n            }\n        } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n            // Fail head of pipeline.\n            const request = client[kQueue][client[kRunningIdx]];\n            client[kQueue][client[kRunningIdx]++] = null;\n            util.errorRequest(client, request, err);\n        }\n        client[kPendingIdx] = client[kRunningIdx];\n        assert(client[kRunning] === 0);\n        client.emit('disconnect', client[kUrl], [\n            client\n        ], err);\n        client[kResume]();\n    });\n    let closed = false;\n    socket.on('close', ()=>{\n        closed = true;\n    });\n    return {\n        version: 'h1',\n        defaultPipelining: 1,\n        write (...args) {\n            return writeH1(client, ...args);\n        },\n        resume () {\n            resumeH1(client);\n        },\n        destroy (err, callback) {\n            if (closed) {\n                queueMicrotask(callback);\n            } else {\n                socket.destroy(err).on('close', callback);\n            }\n        },\n        get destroyed () {\n            return socket.destroyed;\n        },\n        busy (request) {\n            if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n                return true;\n            }\n            if (request) {\n                if (client[kRunning] > 0 && !request.idempotent) {\n                    // Non-idempotent request cannot be retried.\n                    // Ensure that no other requests are inflight and\n                    // could cause failure.\n                    return true;\n                }\n                if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n                    // Don't dispatch an upgrade until all preceding requests have completed.\n                    // A misbehaving server might upgrade the connection before all pipelined\n                    // request has completed.\n                    return true;\n                }\n                if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n                    // Request with stream or iterator body can error while other requests\n                    // are inflight and indirectly error those as well.\n                    // Ensure this doesn't happen by waiting for inflight\n                    // to complete before dispatching.\n                    // Request with stream or iterator body cannot be retried.\n                    // Ensure that no other requests are inflight and\n                    // could cause failure.\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n}\nfunction resumeH1(client) {\n    const socket = client[kSocket];\n    if (socket && !socket.destroyed) {\n        if (client[kSize] === 0) {\n            if (!socket[kNoRef] && socket.unref) {\n                socket.unref();\n                socket[kNoRef] = true;\n            }\n        } else if (socket[kNoRef] && socket.ref) {\n            socket.ref();\n            socket[kNoRef] = false;\n        }\n        if (client[kSize] === 0) {\n            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n                socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n            }\n        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n                const request = client[kQueue][client[kRunningIdx]];\n                const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n                socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n            }\n        }\n    }\n}\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n    return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT';\n}\nfunction writeH1(client, request) {\n    const { method, path, host, upgrade, blocking, reset } = request;\n    let { body, headers, contentLength } = request;\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n    if (util.isFormDataLike(body)) {\n        if (!extractBody) {\n            extractBody = (__webpack_require__(/*! ../web/fetch/body.js */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\").extractBody);\n        }\n        const [bodyStream, contentType] = extractBody(body);\n        if (request.contentType == null) {\n            headers.push('content-type', contentType);\n        }\n        body = bodyStream.stream;\n        contentLength = bodyStream.length;\n    } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n        headers.push('content-type', body.type);\n    }\n    if (body && typeof body.read === 'function') {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    const bodyLength = util.bodyLength(body);\n    contentLength = bodyLength ?? contentLength;\n    if (contentLength === null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 && !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            util.errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    const socket = client[kSocket];\n    const abort = (err)=>{\n        if (request.aborted || request.completed) {\n            return;\n        }\n        util.errorRequest(client, request, err || new RequestAbortedError());\n        util.destroy(body);\n        util.destroy(socket, new InformationalError('aborted'));\n    };\n    try {\n        request.onConnect(abort);\n    } catch (err) {\n        util.errorRequest(client, request, err);\n    }\n    if (request.aborted) {\n        return false;\n    }\n    if (method === 'HEAD') {\n        // https://github.com/mcollina/undici/issues/258\n        // Close after a HEAD request to interop with misbehaving servers\n        // that may send a body in the response.\n        socket[kReset] = true;\n    }\n    if (upgrade || method === 'CONNECT') {\n        // On CONNECT or upgrade, block pipeline from dispatching further\n        // requests on this connection.\n        socket[kReset] = true;\n    }\n    if (reset != null) {\n        socket[kReset] = reset;\n    }\n    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n        socket[kReset] = true;\n    }\n    if (blocking) {\n        socket[kBlocking] = true;\n    }\n    let header = `${method} ${path} HTTP/1.1\\r\\n`;\n    if (typeof host === 'string') {\n        header += `host: ${host}\\r\\n`;\n    } else {\n        header += client[kHostHeader];\n    }\n    if (upgrade) {\n        header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n    } else if (client[kPipelining] && !socket[kReset]) {\n        header += 'connection: keep-alive\\r\\n';\n    } else {\n        header += 'connection: close\\r\\n';\n    }\n    if (Array.isArray(headers)) {\n        for(let n = 0; n < headers.length; n += 2){\n            const key = headers[n + 0];\n            const val = headers[n + 1];\n            if (Array.isArray(val)) {\n                for(let i = 0; i < val.length; i++){\n                    header += `${key}: ${val[i]}\\r\\n`;\n                }\n            } else {\n                header += `${key}: ${val}\\r\\n`;\n            }\n        }\n    }\n    if (channels.sendHeaders.hasSubscribers) {\n        channels.sendHeaders.publish({\n            request,\n            headers: header,\n            socket\n        });\n    }\n    /* istanbul ignore else: assertion */ if (!body || bodyLength === 0) {\n        writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);\n    } else if (util.isBuffer(body)) {\n        writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);\n    } else if (util.isBlobLike(body)) {\n        if (typeof body.stream === 'function') {\n            writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);\n        } else {\n            writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);\n        }\n    } else if (util.isStream(body)) {\n        writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);\n    } else if (util.isIterable(body)) {\n        writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);\n    } else {\n        assert(false);\n    }\n    return true;\n}\nfunction writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n    assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n    let finished = false;\n    const writer = new AsyncWriter({\n        abort,\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    const onData = function(chunk) {\n        if (finished) {\n            return;\n        }\n        try {\n            if (!writer.write(chunk) && this.pause) {\n                this.pause();\n            }\n        } catch (err) {\n            util.destroy(this, err);\n        }\n    };\n    const onDrain = function() {\n        if (finished) {\n            return;\n        }\n        if (body.resume) {\n            body.resume();\n        }\n    };\n    const onClose = function() {\n        // 'close' might be emitted *before* 'error' for\n        // broken streams. Wait a tick to avoid this case.\n        queueMicrotask(()=>{\n            // It's only safe to remove 'error' listener after\n            // 'close'.\n            body.removeListener('error', onFinished);\n        });\n        if (!finished) {\n            const err = new RequestAbortedError();\n            queueMicrotask(()=>onFinished(err));\n        }\n    };\n    const onFinished = function(err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n        socket.off('drain', onDrain).off('error', onFinished);\n        body.removeListener('data', onData).removeListener('end', onFinished).removeListener('close', onClose);\n        if (!err) {\n            try {\n                writer.end();\n            } catch (er) {\n                err = er;\n            }\n        }\n        writer.destroy(err);\n        if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n            util.destroy(body, err);\n        } else {\n            util.destroy(body);\n        }\n    };\n    body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onClose);\n    if (body.resume) {\n        body.resume();\n    }\n    socket.on('drain', onDrain).on('error', onFinished);\n    if (body.errorEmitted ?? body.errored) {\n        setImmediate(()=>onFinished(body.errored));\n    } else if (body.endEmitted ?? body.readableEnded) {\n        setImmediate(()=>onFinished(null));\n    }\n    if (body.closeEmitted ?? body.closed) {\n        setImmediate(onClose);\n    }\n}\nfunction writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n    try {\n        if (!body) {\n            if (contentLength === 0) {\n                socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n            } else {\n                assert(contentLength === null, 'no body must not have content length');\n                socket.write(`${header}\\r\\n`, 'latin1');\n            }\n        } else if (util.isBuffer(body)) {\n            assert(contentLength === body.byteLength, 'buffer body must have content length');\n            socket.cork();\n            socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n            socket.write(body);\n            socket.uncork();\n            request.onBodySent(body);\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n        }\n        request.onRequestSent();\n        client[kResume]();\n    } catch (err) {\n        abort(err);\n    }\n}\nasync function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n    assert(contentLength === body.size, 'blob body must have content length');\n    try {\n        if (contentLength != null && contentLength !== body.size) {\n            throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n        socket.write(buffer);\n        socket.uncork();\n        request.onBodySent(buffer);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        client[kResume]();\n    } catch (err) {\n        abort(err);\n    }\n}\nasync function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n    assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n    let callback = null;\n    function onDrain() {\n        if (callback) {\n            const cb = callback;\n            callback = null;\n            cb();\n        }\n    }\n    const waitForDrain = ()=>new Promise((resolve, reject)=>{\n            assert(callback === null);\n            if (socket[kError]) {\n                reject(socket[kError]);\n            } else {\n                callback = resolve;\n            }\n        });\n    socket.on('close', onDrain).on('drain', onDrain);\n    const writer = new AsyncWriter({\n        abort,\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    try {\n        // It's up to the user to somehow abort the async iterable.\n        for await (const chunk of body){\n            if (socket[kError]) {\n                throw socket[kError];\n            }\n            if (!writer.write(chunk)) {\n                await waitForDrain();\n            }\n        }\n        writer.end();\n    } catch (err) {\n        writer.destroy(err);\n    } finally{\n        socket.off('close', onDrain).off('drain', onDrain);\n    }\n}\nclass AsyncWriter {\n    constructor({ abort, socket, request, contentLength, client, expectsPayload, header }){\n        this.socket = socket;\n        this.request = request;\n        this.contentLength = contentLength;\n        this.client = client;\n        this.bytesWritten = 0;\n        this.expectsPayload = expectsPayload;\n        this.header = header;\n        this.abort = abort;\n        socket[kWriting] = true;\n    }\n    write(chunk) {\n        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return false;\n        }\n        const len = Buffer.byteLength(chunk);\n        if (!len) {\n            return true;\n        }\n        // We should defer writing chunks.\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            }\n            process.emitWarning(new RequestContentLengthMismatchError());\n        }\n        socket.cork();\n        if (bytesWritten === 0) {\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n            if (contentLength === null) {\n                socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1');\n            } else {\n                socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n            }\n        }\n        if (contentLength === null) {\n            socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1');\n        }\n        this.bytesWritten += len;\n        const ret = socket.write(chunk);\n        socket.uncork();\n        request.onBodySent(chunk);\n        if (!ret) {\n            if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n                // istanbul ignore else: only for jest\n                if (socket[kParser].timeout.refresh) {\n                    socket[kParser].timeout.refresh();\n                }\n            }\n        }\n        return ret;\n    }\n    end() {\n        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;\n        request.onRequestSent();\n        socket[kWriting] = false;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return;\n        }\n        if (bytesWritten === 0) {\n            if (expectsPayload) {\n                // https://tools.ietf.org/html/rfc7230#section-3.3.2\n                // A user agent SHOULD send a Content-Length in a request message when\n                // no Transfer-Encoding is sent and the request method defines a meaning\n                // for an enclosed payload body.\n                socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n            } else {\n                socket.write(`${header}\\r\\n`, 'latin1');\n            }\n        } else if (contentLength === null) {\n            socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1');\n        }\n        if (contentLength !== null && bytesWritten !== contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            } else {\n                process.emitWarning(new RequestContentLengthMismatchError());\n            }\n        }\n        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n            // istanbul ignore else: only for jest\n            if (socket[kParser].timeout.refresh) {\n                socket[kParser].timeout.refresh();\n            }\n        }\n        client[kResume]();\n    }\n    destroy(err) {\n        const { socket, client, abort } = this;\n        socket[kWriting] = false;\n        if (err) {\n            assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n            abort(err);\n        }\n    }\n}\nmodule.exports = connectH1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLHNCQUFzQixHQUV0QixNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxxRUFBaUI7QUFDdEMsTUFBTSxFQUFFRSxRQUFRLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsbUZBQXdCO0FBQ3JELE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDLHlFQUFtQjtBQUMxQyxNQUFNLEVBQ0pJLGlDQUFpQyxFQUNqQ0Msa0NBQWtDLEVBQ2xDQyxtQkFBbUIsRUFDbkJDLG1CQUFtQixFQUNuQkMsb0JBQW9CLEVBQ3BCQyxXQUFXLEVBQ1hDLGtCQUFrQixFQUNsQkMsZ0JBQWdCLEVBQ2hCQyxlQUFlLEVBQ2ZDLDRCQUE0QixFQUM3QixHQUFHYixtQkFBT0EsQ0FBQyx5RUFBbUI7QUFDL0IsTUFBTSxFQUNKYyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxPQUFPLEVBQ1BDLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsd0JBQXdCLEVBQ3hCQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxNQUFNLEVBQ05DLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxzQkFBc0IsRUFDdEJDLGVBQWUsRUFDZkMsb0JBQW9CLEVBQ3BCQywwQkFBMEIsRUFDMUJDLGVBQWUsRUFDZkMsWUFBWSxFQUNaQyxvQkFBb0IsRUFDcEJDLFlBQVksRUFDWkMsUUFBUSxFQUNSQyxnQkFBZ0IsRUFDaEJDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxZQUFZLEVBQ2IsR0FBRzVDLG1CQUFPQSxDQUFDLDJFQUFvQjtBQUVoQyxNQUFNNkMsWUFBWTdDLG1CQUFPQSxDQUFDLG1GQUF3QjtBQUNsRCxNQUFNOEMsWUFBWUMsT0FBT0MsS0FBSyxDQUFDO0FBQy9CLE1BQU1DLGFBQWFGLE1BQU0sQ0FBQ0csT0FBT0MsT0FBTyxDQUFDO0FBQ3pDLE1BQU1DLGNBQWNuRCxLQUFLbUQsV0FBVztBQUNwQyxNQUFNQyxxQkFBcUJwRCxLQUFLb0Qsa0JBQWtCO0FBRWxELElBQUlDO0FBRUosZUFBZUM7SUFDYixNQUFNQyxpQkFBaUJDLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYyxHQUFHM0QsbUJBQU9BLENBQUMsdUZBQTBCLElBQUk0RDtJQUUxRixJQUFJQztJQUNKLElBQUk7UUFDRkEsTUFBTSxNQUFNQyxZQUFZQyxPQUFPLENBQUMvRCxtQkFBT0EsQ0FBQyxpR0FBK0I7SUFDekUsRUFBRSxPQUFPZ0UsR0FBRztRQUNWLHdCQUF3QixHQUV4QixnRUFBZ0U7UUFDaEUsdURBQXVEO1FBQ3ZELCtEQUErRDtRQUMvRCx5REFBeUQ7UUFDekRILE1BQU0sTUFBTUMsWUFBWUMsT0FBTyxDQUFDUCxrQkFBa0J4RCxtQkFBT0EsQ0FBQyx1RkFBMEI7SUFDdEY7SUFFQSxPQUFPLE1BQU04RCxZQUFZRyxXQUFXLENBQUNKLEtBQUs7UUFDeENILEtBQUs7WUFDSCw0QkFBNEIsR0FFNUJRLGFBQWEsQ0FBQ0MsR0FBR0MsSUFBSUM7Z0JBQ25CLHdCQUF3QixHQUN4QixPQUFPO1lBQ1Q7WUFDQUMsZ0JBQWdCLENBQUNILEdBQUdDLElBQUlDO2dCQUN0QnRFLE9BQU93RSxXQUFXLENBQUNDLGNBQWNDLEdBQUcsRUFBRU47Z0JBQ3RDLE1BQU1PLFFBQVFOLEtBQUtPLG1CQUFtQkMsaUJBQWlCQyxVQUFVO2dCQUNqRSxPQUFPTCxjQUFjTSxRQUFRLENBQUMsSUFBSTdCLFdBQVcyQixpQkFBaUJHLE1BQU0sRUFBRUwsT0FBT0wsU0FBUztZQUN4RjtZQUNBVyx1QkFBdUIsQ0FBQ2I7Z0JBQ3RCcEUsT0FBT3dFLFdBQVcsQ0FBQ0MsY0FBY0MsR0FBRyxFQUFFTjtnQkFDdEMsT0FBT0ssY0FBY1MsY0FBYyxNQUFNO1lBQzNDO1lBQ0FDLHNCQUFzQixDQUFDZixHQUFHQyxJQUFJQztnQkFDNUJ0RSxPQUFPd0UsV0FBVyxDQUFDQyxjQUFjQyxHQUFHLEVBQUVOO2dCQUN0QyxNQUFNTyxRQUFRTixLQUFLTyxtQkFBbUJDLGlCQUFpQkMsVUFBVTtnQkFDakUsT0FBT0wsY0FBY1csYUFBYSxDQUFDLElBQUlsQyxXQUFXMkIsaUJBQWlCRyxNQUFNLEVBQUVMLE9BQU9MLFNBQVM7WUFDN0Y7WUFDQWUsc0JBQXNCLENBQUNqQixHQUFHQyxJQUFJQztnQkFDNUJ0RSxPQUFPd0UsV0FBVyxDQUFDQyxjQUFjQyxHQUFHLEVBQUVOO2dCQUN0QyxNQUFNTyxRQUFRTixLQUFLTyxtQkFBbUJDLGlCQUFpQkMsVUFBVTtnQkFDakUsT0FBT0wsY0FBY2EsYUFBYSxDQUFDLElBQUlwQyxXQUFXMkIsaUJBQWlCRyxNQUFNLEVBQUVMLE9BQU9MLFNBQVM7WUFDN0Y7WUFDQWlCLDBCQUEwQixDQUFDbkIsR0FBR29CLFlBQVlDLFNBQVNDO2dCQUNqRDFGLE9BQU93RSxXQUFXLENBQUNDLGNBQWNDLEdBQUcsRUFBRU47Z0JBQ3RDLE9BQU9LLGNBQWNrQixpQkFBaUIsQ0FBQ0gsWUFBWUksUUFBUUgsVUFBVUcsUUFBUUYscUJBQXFCO1lBQ3BHO1lBQ0FHLGNBQWMsQ0FBQ3pCLEdBQUdDLElBQUlDO2dCQUNwQnRFLE9BQU93RSxXQUFXLENBQUNDLGNBQWNDLEdBQUcsRUFBRU47Z0JBQ3RDLE1BQU1PLFFBQVFOLEtBQUtPLG1CQUFtQkMsaUJBQWlCQyxVQUFVO2dCQUNqRSxPQUFPTCxjQUFjcUIsTUFBTSxDQUFDLElBQUk1QyxXQUFXMkIsaUJBQWlCRyxNQUFNLEVBQUVMLE9BQU9MLFNBQVM7WUFDdEY7WUFDQXlCLDBCQUEwQixDQUFDM0I7Z0JBQ3pCcEUsT0FBT3dFLFdBQVcsQ0FBQ0MsY0FBY0MsR0FBRyxFQUFFTjtnQkFDdEMsT0FBT0ssY0FBY3VCLGlCQUFpQixNQUFNO1lBQzlDO1FBR0Y7SUFDRjtBQUNGO0FBRUEsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLGdCQUFnQjFDO0FBQ3BCMEMsY0FBY0MsS0FBSztBQUVuQixJQUFJMUIsZ0JBQWdCO0FBQ3BCLElBQUlJLG1CQUFtQjtBQUN2QixJQUFJdUIsb0JBQW9CO0FBQ3hCLElBQUl4QixtQkFBbUI7QUFFdkIsTUFBTXlCLGtCQUFrQjtBQUN4QixNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLGVBQWU7QUFFckIsTUFBTUM7SUFDSixZQUFhQyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxFQUFFQyxPQUFPLEVBQUUsQ0FBRTtRQUN4QzNHLE9BQU80RyxPQUFPQyxRQUFRLENBQUNKLE1BQU0sQ0FBQ3ZFLGdCQUFnQixLQUFLdUUsTUFBTSxDQUFDdkUsZ0JBQWdCLEdBQUc7UUFFN0UsSUFBSSxDQUFDNEUsTUFBTSxHQUFHSDtRQUNkLElBQUksQ0FBQ2pDLEdBQUcsR0FBRyxJQUFJLENBQUNvQyxNQUFNLENBQUNDLFlBQVksQ0FBQ2pFLFVBQVVrRSxJQUFJLENBQUNDLFFBQVE7UUFDM0QsSUFBSSxDQUFDUixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUSxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUM1QixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDNkIsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQzVCLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQzZCLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsY0FBYyxHQUFHZixNQUFNLENBQUN2RSxnQkFBZ0I7UUFDN0MsSUFBSSxDQUFDd0QsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQytCLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUVuQyxJQUFJLENBQUNDLFNBQVMsR0FBRztRQUVqQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGVBQWUsR0FBR3ZCLE1BQU0sQ0FBQy9ELGlCQUFpQjtJQUNqRDtJQUVBdUYsV0FBWUMsS0FBSyxFQUFFQyxJQUFJLEVBQUU7UUFDdkIsSUFBSSxDQUFDZixXQUFXLEdBQUdlO1FBQ25CLElBQUlELFVBQVUsSUFBSSxDQUFDZixZQUFZLEVBQUU7WUFDL0IvRyxPQUFPZ0ksWUFBWSxDQUFDLElBQUksQ0FBQ2xCLE9BQU87WUFDaEMsSUFBSWdCLE9BQU87Z0JBQ1QsSUFBSSxDQUFDaEIsT0FBTyxHQUFHOUcsT0FBTzZILFVBQVUsQ0FBQ0ksaUJBQWlCSCxPQUFPLElBQUk7Z0JBQzdELHNDQUFzQztnQkFDdEMsSUFBSSxJQUFJLENBQUNoQixPQUFPLENBQUNvQixLQUFLLEVBQUU7b0JBQ3RCLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ29CLEtBQUs7Z0JBQ3BCO1lBQ0YsT0FBTztnQkFDTCxJQUFJLENBQUNwQixPQUFPLEdBQUc7WUFDakI7WUFDQSxJQUFJLENBQUNDLFlBQVksR0FBR2U7UUFDdEIsT0FBTyxJQUFJLElBQUksQ0FBQ2hCLE9BQU8sRUFBRTtZQUN2QixzQ0FBc0M7WUFDdEMsSUFBSSxJQUFJLENBQUNBLE9BQU8sQ0FBQ3FCLE9BQU8sRUFBRTtnQkFDeEIsSUFBSSxDQUFDckIsT0FBTyxDQUFDcUIsT0FBTztZQUN0QjtRQUNGO0lBQ0Y7SUFFQWIsU0FBVTtRQUNSLElBQUksSUFBSSxDQUFDaEIsTUFBTSxDQUFDOEIsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDZixNQUFNLEVBQUU7WUFDekM7UUFDRjtRQUVBekgsT0FBTyxJQUFJLENBQUMwRSxHQUFHLElBQUk7UUFDbkIxRSxPQUFPeUUsaUJBQWlCO1FBRXhCLElBQUksQ0FBQ3FDLE1BQU0sQ0FBQzJCLGFBQWEsQ0FBQyxJQUFJLENBQUMvRCxHQUFHO1FBRWxDMUUsT0FBTyxJQUFJLENBQUNvSCxXQUFXLEtBQUtkO1FBQzVCLElBQUksSUFBSSxDQUFDWSxPQUFPLEVBQUU7WUFDaEIsc0NBQXNDO1lBQ3RDLElBQUksSUFBSSxDQUFDQSxPQUFPLENBQUNxQixPQUFPLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQ3FCLE9BQU87WUFDdEI7UUFDRjtRQUVBLElBQUksQ0FBQ2QsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDaUIsT0FBTyxDQUFDLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQ2lDLElBQUksTUFBTTVGLFlBQVcsZ0JBQWdCO1FBQzlELElBQUksQ0FBQzZGLFFBQVE7SUFDZjtJQUVBQSxXQUFZO1FBQ1YsTUFBTyxDQUFDLElBQUksQ0FBQ25CLE1BQU0sSUFBSSxJQUFJLENBQUMvQyxHQUFHLENBQUU7WUFDL0IsTUFBTW1FLFFBQVEsSUFBSSxDQUFDbkMsTUFBTSxDQUFDaUMsSUFBSTtZQUM5QixJQUFJRSxVQUFVLE1BQU07Z0JBQ2xCO1lBQ0Y7WUFDQSxJQUFJLENBQUNILE9BQU8sQ0FBQ0c7UUFDZjtJQUNGO0lBRUFILFFBQVNJLElBQUksRUFBRTtRQUNiOUksT0FBTyxJQUFJLENBQUMwRSxHQUFHLElBQUk7UUFDbkIxRSxPQUFPeUUsaUJBQWlCO1FBQ3hCekUsT0FBTyxDQUFDLElBQUksQ0FBQ3lILE1BQU07UUFFbkIsTUFBTSxFQUFFZixNQUFNLEVBQUVJLE1BQU0sRUFBRSxHQUFHLElBQUk7UUFFL0IsSUFBSWdDLEtBQUtDLE1BQU0sR0FBRzNDLG1CQUFtQjtZQUNuQyxJQUFJeEIsa0JBQWtCO2dCQUNwQmtDLE9BQU9rQyxJQUFJLENBQUNwRTtZQUNkO1lBQ0F3QixvQkFBb0I2QyxLQUFLQyxJQUFJLENBQUNKLEtBQUtDLE1BQU0sR0FBRyxRQUFRO1lBQ3BEbkUsbUJBQW1Ca0MsT0FBT3FDLE1BQU0sQ0FBQy9DO1FBQ25DO1FBRUEsSUFBSWdELFdBQVd0QyxPQUFPdUMsTUFBTSxDQUFDckUsTUFBTSxFQUFFSixrQkFBa0J3QixtQkFBbUJrRCxHQUFHLENBQUNSO1FBRTlFLHFDQUFxQztRQUNyQyx3RkFBd0Y7UUFDeEYsNENBQTRDO1FBQzVDLDZEQUE2RDtRQUM3RCxJQUFJO1lBQ0YsSUFBSVM7WUFFSixJQUFJO2dCQUNGMUUsbUJBQW1CaUU7Z0JBQ25CckUsZ0JBQWdCLElBQUk7Z0JBQ3BCOEUsTUFBTXpDLE9BQU8wQyxjQUFjLENBQUMsSUFBSSxDQUFDOUUsR0FBRyxFQUFFRSxrQkFBa0JrRSxLQUFLQyxNQUFNO1lBQ25FLDZDQUE2QyxHQUMvQyxFQUFFLE9BQU9VLEtBQUs7Z0JBQ1osMkRBQTJELEdBQzNELE1BQU1BO1lBQ1IsU0FBVTtnQkFDUmhGLGdCQUFnQjtnQkFDaEJJLG1CQUFtQjtZQUNyQjtZQUVBLE1BQU02RSxTQUFTNUMsT0FBTzZDLG9CQUFvQixDQUFDLElBQUksQ0FBQ2pGLEdBQUcsSUFBSUU7WUFFdkQsSUFBSTJFLFFBQVF6RyxVQUFVOEcsS0FBSyxDQUFDQyxjQUFjLEVBQUU7Z0JBQzFDLElBQUksQ0FBQ0MsU0FBUyxDQUFDaEIsS0FBS2lCLEtBQUssQ0FBQ0w7WUFDNUIsT0FBTyxJQUFJSCxRQUFRekcsVUFBVThHLEtBQUssQ0FBQ0ksTUFBTSxFQUFFO2dCQUN6QyxJQUFJLENBQUN2QyxNQUFNLEdBQUc7Z0JBQ2RmLE9BQU91RCxPQUFPLENBQUNuQixLQUFLaUIsS0FBSyxDQUFDTDtZQUM1QixPQUFPLElBQUlILFFBQVF6RyxVQUFVOEcsS0FBSyxDQUFDTSxFQUFFLEVBQUU7Z0JBQ3JDLE1BQU14RixNQUFNb0MsT0FBT3FELHVCQUF1QixDQUFDLElBQUksQ0FBQ3pGLEdBQUc7Z0JBQ25ELElBQUkwRixVQUFVO2dCQUNkLDJEQUEyRCxHQUMzRCxJQUFJMUYsS0FBSztvQkFDUCxNQUFNSixNQUFNLElBQUk4RSxXQUFXdEMsT0FBT3VDLE1BQU0sQ0FBQ3JFLE1BQU0sRUFBRU4sS0FBSzJGLE9BQU8sQ0FBQztvQkFDOURELFVBQ0Usb0RBQ0FwSCxPQUFPc0gsSUFBSSxDQUFDeEQsT0FBT3VDLE1BQU0sQ0FBQ3JFLE1BQU0sRUFBRU4sS0FBS0osS0FBS2lHLFFBQVEsS0FDcEQ7Z0JBQ0o7Z0JBQ0EsTUFBTSxJQUFJMUosZ0JBQWdCdUosU0FBU3RILFVBQVU4RyxLQUFLLENBQUNMLElBQUksRUFBRVQsS0FBS2lCLEtBQUssQ0FBQ0w7WUFDdEU7UUFDRixFQUFFLE9BQU9ELEtBQUs7WUFDWnZKLEtBQUtzSyxPQUFPLENBQUM5RCxRQUFRK0M7UUFDdkI7SUFDRjtJQUVBZSxVQUFXO1FBQ1R4SyxPQUFPLElBQUksQ0FBQzBFLEdBQUcsSUFBSTtRQUNuQjFFLE9BQU95RSxpQkFBaUI7UUFFeEIsSUFBSSxDQUFDcUMsTUFBTSxDQUFDMkQsV0FBVyxDQUFDLElBQUksQ0FBQy9GLEdBQUc7UUFDaEMsSUFBSSxDQUFDQSxHQUFHLEdBQUc7UUFFWHRFLE9BQU9nSSxZQUFZLENBQUMsSUFBSSxDQUFDbEIsT0FBTztRQUNoQyxJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBRW5CLElBQUksQ0FBQ0ssTUFBTSxHQUFHO0lBQ2hCO0lBRUExQyxTQUFVMkYsR0FBRyxFQUFFO1FBQ2IsSUFBSSxDQUFDckQsVUFBVSxHQUFHcUQsSUFBSUgsUUFBUTtJQUNoQztJQUVBckYsaUJBQWtCO1FBQ2hCLE1BQU0sRUFBRXdCLE1BQU0sRUFBRUQsTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUUvQiwyREFBMkQsR0FDM0QsSUFBSUMsT0FBTzhCLFNBQVMsRUFBRTtZQUNwQixPQUFPLENBQUM7UUFDVjtRQUVBLE1BQU1tQyxVQUFVbEUsTUFBTSxDQUFDakYsT0FBTyxDQUFDaUYsTUFBTSxDQUFDNUUsWUFBWSxDQUFDO1FBQ25ELElBQUksQ0FBQzhJLFNBQVM7WUFDWixPQUFPLENBQUM7UUFDVjtRQUNBQSxRQUFRQyxpQkFBaUI7SUFDM0I7SUFFQXhGLGNBQWVzRixHQUFHLEVBQUU7UUFDbEIsTUFBTXBHLE1BQU0sSUFBSSxDQUFDZ0QsT0FBTyxDQUFDeUIsTUFBTTtRQUUvQixJQUFJLENBQUN6RSxNQUFNLE9BQU8sR0FBRztZQUNuQixJQUFJLENBQUNnRCxPQUFPLENBQUN1RCxJQUFJLENBQUNIO1FBQ3BCLE9BQU87WUFDTCxJQUFJLENBQUNwRCxPQUFPLENBQUNoRCxNQUFNLEVBQUUsR0FBR3RCLE9BQU84SCxNQUFNLENBQUM7Z0JBQUMsSUFBSSxDQUFDeEQsT0FBTyxDQUFDaEQsTUFBTSxFQUFFO2dCQUFFb0c7YUFBSTtRQUNwRTtRQUVBLElBQUksQ0FBQ0ssV0FBVyxDQUFDTCxJQUFJM0IsTUFBTTtJQUM3QjtJQUVBekQsY0FBZW9GLEdBQUcsRUFBRTtRQUNsQixJQUFJcEcsTUFBTSxJQUFJLENBQUNnRCxPQUFPLENBQUN5QixNQUFNO1FBRTdCLElBQUksQ0FBQ3pFLE1BQU0sT0FBTyxHQUFHO1lBQ25CLElBQUksQ0FBQ2dELE9BQU8sQ0FBQ3VELElBQUksQ0FBQ0g7WUFDbEJwRyxPQUFPO1FBQ1QsT0FBTztZQUNMLElBQUksQ0FBQ2dELE9BQU8sQ0FBQ2hELE1BQU0sRUFBRSxHQUFHdEIsT0FBTzhILE1BQU0sQ0FBQztnQkFBQyxJQUFJLENBQUN4RCxPQUFPLENBQUNoRCxNQUFNLEVBQUU7Z0JBQUVvRzthQUFJO1FBQ3BFO1FBRUEsTUFBTU0sTUFBTSxJQUFJLENBQUMxRCxPQUFPLENBQUNoRCxNQUFNLEVBQUU7UUFDakMsSUFBSTBHLElBQUlqQyxNQUFNLEtBQUssSUFBSTtZQUNyQixNQUFNa0MsYUFBYS9LLEtBQUtnTCw0QkFBNEIsQ0FBQ0Y7WUFDckQsSUFBSUMsZUFBZSxjQUFjO2dCQUMvQixJQUFJLENBQUNwRCxTQUFTLElBQUk2QyxJQUFJSCxRQUFRO1lBQ2hDLE9BQU8sSUFBSVUsZUFBZSxjQUFjO2dCQUN0QyxJQUFJLENBQUNsRCxVQUFVLElBQUkyQyxJQUFJSCxRQUFRO1lBQ2pDO1FBQ0YsT0FBTyxJQUFJUyxJQUFJakMsTUFBTSxLQUFLLE1BQU03SSxLQUFLZ0wsNEJBQTRCLENBQUNGLFNBQVMsa0JBQWtCO1lBQzNGLElBQUksQ0FBQ2xELGFBQWEsSUFBSTRDLElBQUlILFFBQVE7UUFDcEM7UUFFQSxJQUFJLENBQUNRLFdBQVcsQ0FBQ0wsSUFBSTNCLE1BQU07SUFDN0I7SUFFQWdDLFlBQWF6RyxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDaUQsV0FBVyxJQUFJakQ7UUFDcEIsSUFBSSxJQUFJLENBQUNpRCxXQUFXLElBQUksSUFBSSxDQUFDQyxjQUFjLEVBQUU7WUFDM0N0SCxLQUFLc0ssT0FBTyxDQUFDLElBQUksQ0FBQzlELE1BQU0sRUFBRSxJQUFJakc7UUFDaEM7SUFDRjtJQUVBcUosVUFBV3FCLElBQUksRUFBRTtRQUNmLE1BQU0sRUFBRTFGLE9BQU8sRUFBRWdCLE1BQU0sRUFBRUMsTUFBTSxFQUFFWSxPQUFPLEVBQUU5QixVQUFVLEVBQUUsR0FBRyxJQUFJO1FBRTdEeEYsT0FBT3lGO1FBRVAsTUFBTWtGLFVBQVVsRSxNQUFNLENBQUNqRixPQUFPLENBQUNpRixNQUFNLENBQUM1RSxZQUFZLENBQUM7UUFDbkQ3QixPQUFPMks7UUFFUDNLLE9BQU8sQ0FBQzBHLE9BQU84QixTQUFTO1FBQ3hCeEksT0FBTzBHLFdBQVdELE1BQU0sQ0FBQ3pFLFFBQVE7UUFDakNoQyxPQUFPLENBQUMsSUFBSSxDQUFDeUgsTUFBTTtRQUNuQnpILE9BQU8ySyxRQUFRbEYsT0FBTyxJQUFJa0YsUUFBUVMsTUFBTSxLQUFLO1FBRTdDLElBQUksQ0FBQzVGLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUM2QixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDM0IsZUFBZSxHQUFHO1FBRXZCMUYsT0FBTyxJQUFJLENBQUNzSCxPQUFPLENBQUN5QixNQUFNLEdBQUcsTUFBTTtRQUNuQyxJQUFJLENBQUN6QixPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUVuQmIsT0FBT3VELE9BQU8sQ0FBQ2tCO1FBRWZ6RSxNQUFNLENBQUN4RixRQUFRLENBQUNzSixPQUFPO1FBQ3ZCOUQsTUFBTSxDQUFDeEYsUUFBUSxHQUFHO1FBRWxCd0YsTUFBTSxDQUFDekYsUUFBUSxHQUFHO1FBQ2xCeUYsTUFBTSxDQUFDNUUsT0FBTyxHQUFHO1FBRWpCd0IsbUJBQW1Cb0Q7UUFFbkJELE1BQU0sQ0FBQ3pFLFFBQVEsR0FBRztRQUNsQnlFLE1BQU0sQ0FBQzVELGFBQWEsR0FBRyxNQUFLLCtCQUErQjtRQUMzRDRELE1BQU0sQ0FBQ2pGLE9BQU8sQ0FBQ2lGLE1BQU0sQ0FBQzVFLFlBQVksR0FBRyxHQUFHO1FBQ3hDNEUsT0FBTzRFLElBQUksQ0FBQyxjQUFjNUUsTUFBTSxDQUFDMUYsS0FBSyxFQUFFO1lBQUMwRjtTQUFPLEVBQUUsSUFBSTlGLG1CQUFtQjtRQUV6RSxJQUFJO1lBQ0ZnSyxRQUFRYixTQUFTLENBQUN0RSxZQUFZOEIsU0FBU1o7UUFDekMsRUFBRSxPQUFPK0MsS0FBSztZQUNadkosS0FBS3NLLE9BQU8sQ0FBQzlELFFBQVErQztRQUN2QjtRQUVBaEQsTUFBTSxDQUFDN0QsUUFBUTtJQUNqQjtJQUVBK0Msa0JBQW1CSCxVQUFVLEVBQUVDLE9BQU8sRUFBRUMsZUFBZSxFQUFFO1FBQ3ZELE1BQU0sRUFBRWUsTUFBTSxFQUFFQyxNQUFNLEVBQUVZLE9BQU8sRUFBRUQsVUFBVSxFQUFFLEdBQUcsSUFBSTtRQUVwRCwyREFBMkQsR0FDM0QsSUFBSVgsT0FBTzhCLFNBQVMsRUFBRTtZQUNwQixPQUFPLENBQUM7UUFDVjtRQUVBLE1BQU1tQyxVQUFVbEUsTUFBTSxDQUFDakYsT0FBTyxDQUFDaUYsTUFBTSxDQUFDNUUsWUFBWSxDQUFDO1FBRW5ELDJEQUEyRCxHQUMzRCxJQUFJLENBQUM4SSxTQUFTO1lBQ1osT0FBTyxDQUFDO1FBQ1Y7UUFFQTNLLE9BQU8sQ0FBQyxJQUFJLENBQUN5RixPQUFPO1FBQ3BCekYsT0FBTyxJQUFJLENBQUN3RixVQUFVLEdBQUc7UUFFekIsSUFBSUEsZUFBZSxLQUFLO1lBQ3RCdEYsS0FBS3NLLE9BQU8sQ0FBQzlELFFBQVEsSUFBSWhHLFlBQVksZ0JBQWdCUixLQUFLb0wsYUFBYSxDQUFDNUU7WUFDeEUsT0FBTyxDQUFDO1FBQ1Y7UUFFQSxpREFBaUQsR0FDakQsSUFBSWpCLFdBQVcsQ0FBQ2tGLFFBQVFsRixPQUFPLEVBQUU7WUFDL0J2RixLQUFLc0ssT0FBTyxDQUFDOUQsUUFBUSxJQUFJaEcsWUFBWSxlQUFlUixLQUFLb0wsYUFBYSxDQUFDNUU7WUFDdkUsT0FBTyxDQUFDO1FBQ1Y7UUFFQTFHLE9BQU93RSxXQUFXLENBQUMsSUFBSSxDQUFDNEMsV0FBVyxFQUFFZjtRQUVyQyxJQUFJLENBQUNiLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRSxlQUFlLEdBQ2xCQSxtQkFDQSxpRUFBaUU7UUFDaEVpRixRQUFRUyxNQUFNLEtBQUssVUFBVSxDQUFDMUUsTUFBTSxDQUFDMUYsT0FBTyxJQUFJLElBQUksQ0FBQytHLFVBQVUsQ0FBQ3dELFdBQVcsT0FBTztRQUdyRixJQUFJLElBQUksQ0FBQy9GLFVBQVUsSUFBSSxLQUFLO1lBQzFCLE1BQU1nRyxjQUFjYixRQUFRYSxXQUFXLElBQUksT0FDdkNiLFFBQVFhLFdBQVcsR0FDbkIvRSxNQUFNLENBQUNuRSxhQUFhO1lBQ3hCLElBQUksQ0FBQzJGLFVBQVUsQ0FBQ3VELGFBQWFsRjtRQUMvQixPQUFPLElBQUksSUFBSSxDQUFDWSxPQUFPLEVBQUU7WUFDdkIsc0NBQXNDO1lBQ3RDLElBQUksSUFBSSxDQUFDQSxPQUFPLENBQUNxQixPQUFPLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQ3FCLE9BQU87WUFDdEI7UUFDRjtRQUVBLElBQUlvQyxRQUFRUyxNQUFNLEtBQUssV0FBVztZQUNoQ3BMLE9BQU95RyxNQUFNLENBQUNyRixTQUFTLEtBQUs7WUFDNUIsSUFBSSxDQUFDcUUsT0FBTyxHQUFHO1lBQ2YsT0FBTztRQUNUO1FBRUEsSUFBSUEsU0FBUztZQUNYekYsT0FBT3lHLE1BQU0sQ0FBQ3JGLFNBQVMsS0FBSztZQUM1QixJQUFJLENBQUNxRSxPQUFPLEdBQUc7WUFDZixPQUFPO1FBQ1Q7UUFFQXpGLE9BQU8sSUFBSSxDQUFDc0gsT0FBTyxDQUFDeUIsTUFBTSxHQUFHLE1BQU07UUFDbkMsSUFBSSxDQUFDekIsT0FBTyxHQUFHLEVBQUU7UUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFFbkIsSUFBSSxJQUFJLENBQUM3QixlQUFlLElBQUllLE1BQU0sQ0FBQzFFLFlBQVksRUFBRTtZQUMvQyxNQUFNMEosbUJBQW1CLElBQUksQ0FBQzVELFNBQVMsR0FBRzNILEtBQUt3TCxxQkFBcUIsQ0FBQyxJQUFJLENBQUM3RCxTQUFTLElBQUk7WUFFdkYsSUFBSTRELG9CQUFvQixNQUFNO2dCQUM1QixNQUFNdkUsVUFBVStCLEtBQUswQyxHQUFHLENBQ3RCRixtQkFBbUJoRixNQUFNLENBQUNyRSwyQkFBMkIsRUFDckRxRSxNQUFNLENBQUN0RSxxQkFBcUI7Z0JBRTlCLElBQUkrRSxXQUFXLEdBQUc7b0JBQ2hCUixNQUFNLENBQUMxRixPQUFPLEdBQUc7Z0JBQ25CLE9BQU87b0JBQ0x5RixNQUFNLENBQUN4RSx1QkFBdUIsR0FBR2lGO2dCQUNuQztZQUNGLE9BQU87Z0JBQ0xULE1BQU0sQ0FBQ3hFLHVCQUF1QixHQUFHd0UsTUFBTSxDQUFDL0UseUJBQXlCO1lBQ25FO1FBQ0YsT0FBTztZQUNMLDRDQUE0QztZQUM1Q2dGLE1BQU0sQ0FBQzFGLE9BQU8sR0FBRztRQUNuQjtRQUVBLE1BQU00SyxRQUFRakIsUUFBUWtCLFNBQVMsQ0FBQ3JHLFlBQVk4QixTQUFTLElBQUksQ0FBQ0ksTUFBTSxFQUFFTCxnQkFBZ0I7UUFFbEYsSUFBSXNELFFBQVFtQixPQUFPLEVBQUU7WUFDbkIsT0FBTyxDQUFDO1FBQ1Y7UUFFQSxJQUFJbkIsUUFBUVMsTUFBTSxLQUFLLFFBQVE7WUFDN0IsT0FBTztRQUNUO1FBRUEsSUFBSTVGLGFBQWEsS0FBSztZQUNwQixPQUFPO1FBQ1Q7UUFFQSxJQUFJa0IsTUFBTSxDQUFDdkYsVUFBVSxFQUFFO1lBQ3JCdUYsTUFBTSxDQUFDdkYsVUFBVSxHQUFHO1lBQ3BCc0YsTUFBTSxDQUFDN0QsUUFBUTtRQUNqQjtRQUVBLE9BQU9nSixRQUFROUksVUFBVThHLEtBQUssQ0FBQ0ksTUFBTSxHQUFHO0lBQzFDO0lBRUFsRSxPQUFRNEUsR0FBRyxFQUFFO1FBQ1gsTUFBTSxFQUFFakUsTUFBTSxFQUFFQyxNQUFNLEVBQUVsQixVQUFVLEVBQUV3QyxlQUFlLEVBQUUsR0FBRyxJQUFJO1FBRTVELElBQUl0QixPQUFPOEIsU0FBUyxFQUFFO1lBQ3BCLE9BQU8sQ0FBQztRQUNWO1FBRUEsTUFBTW1DLFVBQVVsRSxNQUFNLENBQUNqRixPQUFPLENBQUNpRixNQUFNLENBQUM1RSxZQUFZLENBQUM7UUFDbkQ3QixPQUFPMks7UUFFUDNLLE9BQU93RSxXQUFXLENBQUMsSUFBSSxDQUFDNEMsV0FBVyxFQUFFZDtRQUNyQyxJQUFJLElBQUksQ0FBQ1ksT0FBTyxFQUFFO1lBQ2hCLHNDQUFzQztZQUN0QyxJQUFJLElBQUksQ0FBQ0EsT0FBTyxDQUFDcUIsT0FBTyxFQUFFO2dCQUN4QixJQUFJLENBQUNyQixPQUFPLENBQUNxQixPQUFPO1lBQ3RCO1FBQ0Y7UUFFQXZJLE9BQU93RixjQUFjO1FBRXJCLElBQUl3QyxrQkFBa0IsQ0FBQyxLQUFLLElBQUksQ0FBQ0osU0FBUyxHQUFHOEMsSUFBSTNCLE1BQU0sR0FBR2YsaUJBQWlCO1lBQ3pFOUgsS0FBS3NLLE9BQU8sQ0FBQzlELFFBQVEsSUFBSTVGO1lBQ3pCLE9BQU8sQ0FBQztRQUNWO1FBRUEsSUFBSSxDQUFDOEcsU0FBUyxJQUFJOEMsSUFBSTNCLE1BQU07UUFFNUIsSUFBSTRCLFFBQVFvQixNQUFNLENBQUNyQixTQUFTLE9BQU87WUFDakMsT0FBTzVILFVBQVU4RyxLQUFLLENBQUNJLE1BQU07UUFDL0I7SUFDRjtJQUVBaEUsb0JBQXFCO1FBQ25CLE1BQU0sRUFBRVMsTUFBTSxFQUFFQyxNQUFNLEVBQUVsQixVQUFVLEVBQUVDLE9BQU8sRUFBRTZCLE9BQU8sRUFBRVEsYUFBYSxFQUFFRixTQUFTLEVBQUVsQyxlQUFlLEVBQUUsR0FBRyxJQUFJO1FBRXhHLElBQUlnQixPQUFPOEIsU0FBUyxJQUFLLEVBQUNoRCxjQUFjRSxlQUFjLEdBQUk7WUFDeEQsT0FBTyxDQUFDO1FBQ1Y7UUFFQSxJQUFJRCxTQUFTO1lBQ1g7UUFDRjtRQUVBLE1BQU1rRixVQUFVbEUsTUFBTSxDQUFDakYsT0FBTyxDQUFDaUYsTUFBTSxDQUFDNUUsWUFBWSxDQUFDO1FBQ25EN0IsT0FBTzJLO1FBRVAzSyxPQUFPd0YsY0FBYztRQUVyQixJQUFJLENBQUNBLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUM2QixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDTyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDRSxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRCxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDRSxVQUFVLEdBQUc7UUFFbEIvSCxPQUFPLElBQUksQ0FBQ3NILE9BQU8sQ0FBQ3lCLE1BQU0sR0FBRyxNQUFNO1FBQ25DLElBQUksQ0FBQ3pCLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBRW5CLElBQUkvQixhQUFhLEtBQUs7WUFDcEI7UUFDRjtRQUVBLHNEQUFzRCxHQUN0RCxJQUFJbUYsUUFBUVMsTUFBTSxLQUFLLFVBQVV0RCxpQkFBaUJGLGNBQWNvRSxTQUFTbEUsZUFBZSxLQUFLO1lBQzNGNUgsS0FBS3NLLE9BQU8sQ0FBQzlELFFBQVEsSUFBSXBHO1lBQ3pCLE9BQU8sQ0FBQztRQUNWO1FBRUFxSyxRQUFRc0IsVUFBVSxDQUFDM0U7UUFFbkJiLE1BQU0sQ0FBQ2pGLE9BQU8sQ0FBQ2lGLE1BQU0sQ0FBQzVFLFlBQVksR0FBRyxHQUFHO1FBRXhDLElBQUk2RSxNQUFNLENBQUNuRixTQUFTLEVBQUU7WUFDcEJ2QixPQUFPd0UsV0FBVyxDQUFDaUMsTUFBTSxDQUFDckYsU0FBUyxFQUFFO1lBQ3JDLHFDQUFxQztZQUNyQ2xCLEtBQUtzSyxPQUFPLENBQUM5RCxRQUFRLElBQUkvRixtQkFBbUI7WUFDNUMsT0FBT21DLFVBQVU4RyxLQUFLLENBQUNJLE1BQU07UUFDL0IsT0FBTyxJQUFJLENBQUN0RSxpQkFBaUI7WUFDM0J4RixLQUFLc0ssT0FBTyxDQUFDOUQsUUFBUSxJQUFJL0YsbUJBQW1CO1lBQzVDLE9BQU9tQyxVQUFVOEcsS0FBSyxDQUFDSSxNQUFNO1FBQy9CLE9BQU8sSUFBSXRELE1BQU0sQ0FBQzFGLE9BQU8sSUFBSXlGLE1BQU0sQ0FBQ3JGLFNBQVMsS0FBSyxHQUFHO1lBQ25ELG1EQUFtRDtZQUNuRCxxREFBcUQ7WUFDckQsc0RBQXNEO1lBQ3RELCtCQUErQjtZQUMvQmxCLEtBQUtzSyxPQUFPLENBQUM5RCxRQUFRLElBQUkvRixtQkFBbUI7WUFDNUMsT0FBT21DLFVBQVU4RyxLQUFLLENBQUNJLE1BQU07UUFDL0IsT0FBTyxJQUFJdkQsTUFBTSxDQUFDMUUsWUFBWSxJQUFJLFFBQVEwRSxNQUFNLENBQUMxRSxZQUFZLEtBQUssR0FBRztZQUNuRSx5RUFBeUU7WUFDekUsOEVBQThFO1lBQzlFLG1CQUFtQjtZQUNuQm1LLGFBQWEsSUFBTXpGLE1BQU0sQ0FBQzdELFFBQVE7UUFDcEMsT0FBTztZQUNMNkQsTUFBTSxDQUFDN0QsUUFBUTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQSxTQUFTeUYsZ0JBQWlCOEQsTUFBTTtJQUM5QixNQUFNLEVBQUV6RixNQUFNLEVBQUVVLFdBQVcsRUFBRVgsTUFBTSxFQUFFLEdBQUcwRjtJQUV4Qyx3QkFBd0IsR0FDeEIsSUFBSS9FLGdCQUFnQmYsaUJBQWlCO1FBQ25DLElBQUksQ0FBQ0ssTUFBTSxDQUFDbkYsU0FBUyxJQUFJbUYsT0FBTzBGLGlCQUFpQixJQUFJM0YsTUFBTSxDQUFDckYsU0FBUyxHQUFHLEdBQUc7WUFDekVwQixPQUFPLENBQUNtTSxPQUFPMUUsTUFBTSxFQUFFO1lBQ3ZCdkgsS0FBS3NLLE9BQU8sQ0FBQzlELFFBQVEsSUFBSWxHO1FBQzNCO0lBQ0YsT0FBTyxJQUFJNEcsZ0JBQWdCZCxjQUFjO1FBQ3ZDLElBQUksQ0FBQzZGLE9BQU8xRSxNQUFNLEVBQUU7WUFDbEJ2SCxLQUFLc0ssT0FBTyxDQUFDOUQsUUFBUSxJQUFJOUY7UUFDM0I7SUFDRixPQUFPLElBQUl3RyxnQkFBZ0JiLGNBQWM7UUFDdkN2RyxPQUFPeUcsTUFBTSxDQUFDckYsU0FBUyxLQUFLLEtBQUtxRixNQUFNLENBQUN4RSx1QkFBdUI7UUFDL0QvQixLQUFLc0ssT0FBTyxDQUFDOUQsUUFBUSxJQUFJL0YsbUJBQW1CO0lBQzlDO0FBQ0Y7QUFFQSxlQUFlMEwsVUFBVzVGLE1BQU0sRUFBRUMsTUFBTTtJQUN0Q0QsTUFBTSxDQUFDekUsUUFBUSxHQUFHMEU7SUFFbEIsSUFBSSxDQUFDVCxnQkFBZ0I7UUFDbkJBLGlCQUFpQixNQUFNQztRQUN2QkEsZ0JBQWdCO0lBQ2xCO0lBRUFRLE1BQU0sQ0FBQ2pGLE9BQU8sR0FBRztJQUNqQmlGLE1BQU0sQ0FBQ25GLFNBQVMsR0FBRztJQUNuQm1GLE1BQU0sQ0FBQzFGLE9BQU8sR0FBRztJQUNqQjBGLE1BQU0sQ0FBQ3ZGLFVBQVUsR0FBRztJQUNwQnVGLE1BQU0sQ0FBQ3hGLFFBQVEsR0FBRyxJQUFJc0YsT0FBT0MsUUFBUUMsUUFBUVQ7SUFFN0M1QyxZQUFZcUQsUUFBUSxTQUFTLFNBQVUrQyxHQUFHO1FBQ3hDLE1BQU0wQyxTQUFTLElBQUksQ0FBQ2pMLFFBQVE7UUFFNUJsQixPQUFPeUosSUFBSTZDLElBQUksS0FBSztRQUVwQiwrRUFBK0U7UUFDL0UsZUFBZTtRQUNmLElBQUk3QyxJQUFJNkMsSUFBSSxLQUFLLGdCQUFnQkgsT0FBTzNHLFVBQVUsSUFBSSxDQUFDMkcsT0FBT3pHLGVBQWUsRUFBRTtZQUM3RSx5REFBeUQ7WUFDekR5RyxPQUFPbkcsaUJBQWlCO1lBQ3hCO1FBQ0Y7UUFFQSxJQUFJLENBQUNsRSxPQUFPLEdBQUcySDtRQUVmLElBQUksQ0FBQ3hJLFFBQVEsQ0FBQzBCLFNBQVMsQ0FBQzhHO0lBQzFCO0lBQ0FwRyxZQUFZcUQsUUFBUSxZQUFZO1FBQzlCLE1BQU15RixTQUFTLElBQUksQ0FBQ2pMLFFBQVE7UUFFNUIsSUFBSWlMLFFBQVE7WUFDVkEsT0FBT3ZELFFBQVE7UUFDakI7SUFDRjtJQUNBdkYsWUFBWXFELFFBQVEsT0FBTztRQUN6QixNQUFNeUYsU0FBUyxJQUFJLENBQUNqTCxRQUFRO1FBRTVCLElBQUlpTCxPQUFPM0csVUFBVSxJQUFJLENBQUMyRyxPQUFPekcsZUFBZSxFQUFFO1lBQ2hELHlEQUF5RDtZQUN6RHlHLE9BQU9uRyxpQkFBaUI7WUFDeEI7UUFDRjtRQUVBOUYsS0FBS3NLLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSTlKLFlBQVkscUJBQXFCUixLQUFLb0wsYUFBYSxDQUFDLElBQUk7SUFDakY7SUFDQWpJLFlBQVlxRCxRQUFRLFNBQVM7UUFDM0IsTUFBTUQsU0FBUyxJQUFJLENBQUN4RixRQUFRO1FBQzVCLE1BQU1rTCxTQUFTLElBQUksQ0FBQ2pMLFFBQVE7UUFFNUIsSUFBSWlMLFFBQVE7WUFDVixJQUFJLENBQUMsSUFBSSxDQUFDckssT0FBTyxJQUFJcUssT0FBTzNHLFVBQVUsSUFBSSxDQUFDMkcsT0FBT3pHLGVBQWUsRUFBRTtnQkFDakUseURBQXlEO2dCQUN6RHlHLE9BQU9uRyxpQkFBaUI7WUFDMUI7WUFFQSxJQUFJLENBQUM5RSxRQUFRLENBQUNzSixPQUFPO1lBQ3JCLElBQUksQ0FBQ3RKLFFBQVEsR0FBRztRQUNsQjtRQUVBLE1BQU11SSxNQUFNLElBQUksQ0FBQzNILE9BQU8sSUFBSSxJQUFJcEIsWUFBWSxVQUFVUixLQUFLb0wsYUFBYSxDQUFDLElBQUk7UUFFN0U3RSxNQUFNLENBQUN6RSxRQUFRLEdBQUc7UUFDbEJ5RSxNQUFNLENBQUM1RCxhQUFhLEdBQUcsTUFBSywrQkFBK0I7UUFFM0QsSUFBSTRELE9BQU8rQixTQUFTLEVBQUU7WUFDcEJ4SSxPQUFPeUcsTUFBTSxDQUFDcEYsU0FBUyxLQUFLO1lBRTVCLHFCQUFxQjtZQUNyQixNQUFNa0wsV0FBVzlGLE1BQU0sQ0FBQ2pGLE9BQU8sQ0FBQ2dMLE1BQU0sQ0FBQy9GLE1BQU0sQ0FBQzVFLFlBQVk7WUFDMUQsSUFBSyxJQUFJNEssSUFBSSxHQUFHQSxJQUFJRixTQUFTeEQsTUFBTSxFQUFFMEQsSUFBSztnQkFDeEMsTUFBTTlCLFVBQVU0QixRQUFRLENBQUNFLEVBQUU7Z0JBQzNCdk0sS0FBS3dNLFlBQVksQ0FBQ2pHLFFBQVFrRSxTQUFTbEI7WUFDckM7UUFDRixPQUFPLElBQUloRCxNQUFNLENBQUNyRixTQUFTLEdBQUcsS0FBS3FJLElBQUk2QyxJQUFJLEtBQUssZ0JBQWdCO1lBQzlELHlCQUF5QjtZQUN6QixNQUFNM0IsVUFBVWxFLE1BQU0sQ0FBQ2pGLE9BQU8sQ0FBQ2lGLE1BQU0sQ0FBQzVFLFlBQVksQ0FBQztZQUNuRDRFLE1BQU0sQ0FBQ2pGLE9BQU8sQ0FBQ2lGLE1BQU0sQ0FBQzVFLFlBQVksR0FBRyxHQUFHO1lBRXhDM0IsS0FBS3dNLFlBQVksQ0FBQ2pHLFFBQVFrRSxTQUFTbEI7UUFDckM7UUFFQWhELE1BQU0sQ0FBQzdFLFlBQVksR0FBRzZFLE1BQU0sQ0FBQzVFLFlBQVk7UUFFekM3QixPQUFPeUcsTUFBTSxDQUFDckYsU0FBUyxLQUFLO1FBRTVCcUYsT0FBTzRFLElBQUksQ0FBQyxjQUFjNUUsTUFBTSxDQUFDMUYsS0FBSyxFQUFFO1lBQUMwRjtTQUFPLEVBQUVnRDtRQUVsRGhELE1BQU0sQ0FBQzdELFFBQVE7SUFDakI7SUFFQSxJQUFJK0osU0FBUztJQUNiakcsT0FBT2tHLEVBQUUsQ0FBQyxTQUFTO1FBQ2pCRCxTQUFTO0lBQ1g7SUFFQSxPQUFPO1FBQ0xFLFNBQVM7UUFDVEMsbUJBQW1CO1FBQ25CQyxPQUFPLEdBQUdDLElBQUk7WUFDWixPQUFPQyxRQUFReEcsV0FBV3VHO1FBQzVCO1FBQ0F0RjtZQUNFd0YsU0FBU3pHO1FBQ1g7UUFDQStELFNBQVNmLEdBQUcsRUFBRTBELFFBQVE7WUFDcEIsSUFBSVIsUUFBUTtnQkFDVlMsZUFBZUQ7WUFDakIsT0FBTztnQkFDTHpHLE9BQU84RCxPQUFPLENBQUNmLEtBQUttRCxFQUFFLENBQUMsU0FBU087WUFDbEM7UUFDRjtRQUNBLElBQUkzRSxhQUFhO1lBQ2YsT0FBTzlCLE9BQU84QixTQUFTO1FBQ3pCO1FBQ0E2RSxNQUFNMUMsT0FBTztZQUNYLElBQUlqRSxNQUFNLENBQUNuRixTQUFTLElBQUltRixNQUFNLENBQUMxRixPQUFPLElBQUkwRixNQUFNLENBQUN2RixVQUFVLEVBQUU7Z0JBQzNELE9BQU87WUFDVDtZQUVBLElBQUl3SixTQUFTO2dCQUNYLElBQUlsRSxNQUFNLENBQUNyRixTQUFTLEdBQUcsS0FBSyxDQUFDdUosUUFBUTJDLFVBQVUsRUFBRTtvQkFDL0MsNENBQTRDO29CQUM1QyxpREFBaUQ7b0JBQ2pELHVCQUF1QjtvQkFDdkIsT0FBTztnQkFDVDtnQkFFQSxJQUFJN0csTUFBTSxDQUFDckYsU0FBUyxHQUFHLEtBQU11SixDQUFBQSxRQUFRbEYsT0FBTyxJQUFJa0YsUUFBUVMsTUFBTSxLQUFLLFNBQVEsR0FBSTtvQkFDN0UseUVBQXlFO29CQUN6RSx5RUFBeUU7b0JBQ3pFLHlCQUF5QjtvQkFDekIsT0FBTztnQkFDVDtnQkFFQSxJQUFJM0UsTUFBTSxDQUFDckYsU0FBUyxHQUFHLEtBQUtsQixLQUFLcU4sVUFBVSxDQUFDNUMsUUFBUTZDLElBQUksTUFBTSxLQUMzRHROLENBQUFBLEtBQUt1TixRQUFRLENBQUM5QyxRQUFRNkMsSUFBSSxLQUFLdE4sS0FBS3dOLGVBQWUsQ0FBQy9DLFFBQVE2QyxJQUFJLEtBQUt0TixLQUFLeU4sY0FBYyxDQUFDaEQsUUFBUTZDLElBQUksSUFBSTtvQkFDMUcsc0VBQXNFO29CQUN0RSxtREFBbUQ7b0JBQ25ELHFEQUFxRDtvQkFDckQsa0NBQWtDO29CQUVsQywwREFBMEQ7b0JBQzFELGlEQUFpRDtvQkFDakQsdUJBQXVCO29CQUN2QixPQUFPO2dCQUNUO1lBQ0Y7WUFFQSxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBRUEsU0FBU04sU0FBVXpHLE1BQU07SUFDdkIsTUFBTUMsU0FBU0QsTUFBTSxDQUFDekUsUUFBUTtJQUU5QixJQUFJMEUsVUFBVSxDQUFDQSxPQUFPOEIsU0FBUyxFQUFFO1FBQy9CLElBQUkvQixNQUFNLENBQUNuRixNQUFNLEtBQUssR0FBRztZQUN2QixJQUFJLENBQUNvRixNQUFNLENBQUNqRixPQUFPLElBQUlpRixPQUFPNEIsS0FBSyxFQUFFO2dCQUNuQzVCLE9BQU80QixLQUFLO2dCQUNaNUIsTUFBTSxDQUFDakYsT0FBTyxHQUFHO1lBQ25CO1FBQ0YsT0FBTyxJQUFJaUYsTUFBTSxDQUFDakYsT0FBTyxJQUFJaUYsT0FBT2tILEdBQUcsRUFBRTtZQUN2Q2xILE9BQU9rSCxHQUFHO1lBQ1ZsSCxNQUFNLENBQUNqRixPQUFPLEdBQUc7UUFDbkI7UUFFQSxJQUFJZ0YsTUFBTSxDQUFDbkYsTUFBTSxLQUFLLEdBQUc7WUFDdkIsSUFBSW9GLE1BQU0sQ0FBQ3hGLFFBQVEsQ0FBQ2tHLFdBQVcsS0FBS2IsY0FBYztnQkFDaERHLE1BQU0sQ0FBQ3hGLFFBQVEsQ0FBQytHLFVBQVUsQ0FBQ3hCLE1BQU0sQ0FBQ3hFLHVCQUF1QixFQUFFc0U7WUFDN0Q7UUFDRixPQUFPLElBQUlFLE1BQU0sQ0FBQ3JGLFNBQVMsR0FBRyxLQUFLc0YsTUFBTSxDQUFDeEYsUUFBUSxDQUFDc0UsVUFBVSxHQUFHLEtBQUs7WUFDbkUsSUFBSWtCLE1BQU0sQ0FBQ3hGLFFBQVEsQ0FBQ2tHLFdBQVcsS0FBS2YsaUJBQWlCO2dCQUNuRCxNQUFNc0UsVUFBVWxFLE1BQU0sQ0FBQ2pGLE9BQU8sQ0FBQ2lGLE1BQU0sQ0FBQzVFLFlBQVksQ0FBQztnQkFDbkQsTUFBTWdNLGlCQUFpQmxELFFBQVFrRCxjQUFjLElBQUksT0FDN0NsRCxRQUFRa0QsY0FBYyxHQUN0QnBILE1BQU0sQ0FBQ3BFLGdCQUFnQjtnQkFDM0JxRSxNQUFNLENBQUN4RixRQUFRLENBQUMrRyxVQUFVLENBQUM0RixnQkFBZ0J4SDtZQUM3QztRQUNGO0lBQ0Y7QUFDRjtBQUVBLHVEQUF1RDtBQUN2RCxTQUFTeUgsd0JBQXlCMUMsTUFBTTtJQUN0QyxPQUFPQSxXQUFXLFNBQVNBLFdBQVcsVUFBVUEsV0FBVyxhQUFhQSxXQUFXLFdBQVdBLFdBQVc7QUFDM0c7QUFFQSxTQUFTNkIsUUFBU3hHLE1BQU0sRUFBRWtFLE9BQU87SUFDL0IsTUFBTSxFQUFFUyxNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLElBQUksRUFBRXZJLE9BQU8sRUFBRXdJLFFBQVEsRUFBRUMsS0FBSyxFQUFFLEdBQUd2RDtJQUV6RCxJQUFJLEVBQUU2QyxJQUFJLEVBQUVsRyxPQUFPLEVBQUVRLGFBQWEsRUFBRSxHQUFHNkM7SUFFdkMsb0RBQW9EO0lBQ3BELG9EQUFvRDtJQUNwRCxvREFBb0Q7SUFFcEQsb0RBQW9EO0lBQ3BELGlEQUFpRDtJQUNqRCwrQ0FBK0M7SUFDL0MsOENBQThDO0lBRTlDLE1BQU13RCxpQkFDSi9DLFdBQVcsU0FDWEEsV0FBVyxVQUNYQSxXQUFXO0lBR2IsSUFBSWxMLEtBQUt5TixjQUFjLENBQUNILE9BQU87UUFDN0IsSUFBSSxDQUFDakssYUFBYTtZQUNoQkEsY0FBY3RELGtIQUEyQztRQUMzRDtRQUVBLE1BQU0sQ0FBQ21PLFlBQVlDLFlBQVksR0FBRzlLLFlBQVlpSztRQUM5QyxJQUFJN0MsUUFBUTBELFdBQVcsSUFBSSxNQUFNO1lBQy9CL0csUUFBUXVELElBQUksQ0FBQyxnQkFBZ0J3RDtRQUMvQjtRQUNBYixPQUFPWSxXQUFXRSxNQUFNO1FBQ3hCeEcsZ0JBQWdCc0csV0FBV3JGLE1BQU07SUFDbkMsT0FBTyxJQUFJN0ksS0FBS3FPLFVBQVUsQ0FBQ2YsU0FBUzdDLFFBQVEwRCxXQUFXLElBQUksUUFBUWIsS0FBS3JGLElBQUksRUFBRTtRQUM1RWIsUUFBUXVELElBQUksQ0FBQyxnQkFBZ0IyQyxLQUFLckYsSUFBSTtJQUN4QztJQUVBLElBQUlxRixRQUFRLE9BQU9BLEtBQUs3RSxJQUFJLEtBQUssWUFBWTtRQUMzQywwQ0FBMEM7UUFDMUM2RSxLQUFLN0UsSUFBSSxDQUFDO0lBQ1o7SUFFQSxNQUFNNEUsYUFBYXJOLEtBQUtxTixVQUFVLENBQUNDO0lBRW5DMUYsZ0JBQWdCeUYsY0FBY3pGO0lBRTlCLElBQUlBLGtCQUFrQixNQUFNO1FBQzFCQSxnQkFBZ0I2QyxRQUFRN0MsYUFBYTtJQUN2QztJQUVBLElBQUlBLGtCQUFrQixLQUFLLENBQUNxRyxnQkFBZ0I7UUFDMUMsb0RBQW9EO1FBQ3BELGtFQUFrRTtRQUNsRSxxRUFBcUU7UUFDckUsMkNBQTJDO1FBRTNDckcsZ0JBQWdCO0lBQ2xCO0lBRUEsK0NBQStDO0lBQy9DLHNGQUFzRjtJQUN0RixJQUFJZ0csd0JBQXdCMUMsV0FBV3RELGdCQUFnQixLQUFLNkMsUUFBUTdDLGFBQWEsS0FBSyxRQUFRNkMsUUFBUTdDLGFBQWEsS0FBS0EsZUFBZTtRQUNySSxJQUFJckIsTUFBTSxDQUFDbEUscUJBQXFCLEVBQUU7WUFDaENyQyxLQUFLd00sWUFBWSxDQUFDakcsUUFBUWtFLFNBQVMsSUFBSXRLO1lBQ3ZDLE9BQU87UUFDVDtRQUVBcUQsUUFBUThLLFdBQVcsQ0FBQyxJQUFJbk87SUFDMUI7SUFFQSxNQUFNcUcsU0FBU0QsTUFBTSxDQUFDekUsUUFBUTtJQUU5QixNQUFNeU0sUUFBUSxDQUFDaEY7UUFDYixJQUFJa0IsUUFBUW1CLE9BQU8sSUFBSW5CLFFBQVErRCxTQUFTLEVBQUU7WUFDeEM7UUFDRjtRQUVBeE8sS0FBS3dNLFlBQVksQ0FBQ2pHLFFBQVFrRSxTQUFTbEIsT0FBTyxJQUFJbEo7UUFFOUNMLEtBQUtzSyxPQUFPLENBQUNnRDtRQUNidE4sS0FBS3NLLE9BQU8sQ0FBQzlELFFBQVEsSUFBSS9GLG1CQUFtQjtJQUM5QztJQUVBLElBQUk7UUFDRmdLLFFBQVFnRSxTQUFTLENBQUNGO0lBQ3BCLEVBQUUsT0FBT2hGLEtBQUs7UUFDWnZKLEtBQUt3TSxZQUFZLENBQUNqRyxRQUFRa0UsU0FBU2xCO0lBQ3JDO0lBRUEsSUFBSWtCLFFBQVFtQixPQUFPLEVBQUU7UUFDbkIsT0FBTztJQUNUO0lBRUEsSUFBSVYsV0FBVyxRQUFRO1FBQ3JCLGdEQUFnRDtRQUNoRCxpRUFBaUU7UUFDakUsd0NBQXdDO1FBRXhDMUUsTUFBTSxDQUFDMUYsT0FBTyxHQUFHO0lBQ25CO0lBRUEsSUFBSXlFLFdBQVcyRixXQUFXLFdBQVc7UUFDbkMsaUVBQWlFO1FBQ2pFLCtCQUErQjtRQUUvQjFFLE1BQU0sQ0FBQzFGLE9BQU8sR0FBRztJQUNuQjtJQUVBLElBQUlrTixTQUFTLE1BQU07UUFDakJ4SCxNQUFNLENBQUMxRixPQUFPLEdBQUdrTjtJQUNuQjtJQUVBLElBQUl6SCxNQUFNLENBQUNqRSxhQUFhLElBQUlrRSxNQUFNLENBQUNqRSxTQUFTLE1BQU1nRSxNQUFNLENBQUNqRSxhQUFhLEVBQUU7UUFDdEVrRSxNQUFNLENBQUMxRixPQUFPLEdBQUc7SUFDbkI7SUFFQSxJQUFJaU4sVUFBVTtRQUNadkgsTUFBTSxDQUFDdkYsVUFBVSxHQUFHO0lBQ3RCO0lBRUEsSUFBSXlOLFNBQVMsR0FBR3hELE9BQU8sQ0FBQyxFQUFFMkMsS0FBSyxhQUFhLENBQUM7SUFFN0MsSUFBSSxPQUFPQyxTQUFTLFVBQVU7UUFDNUJZLFVBQVUsQ0FBQyxNQUFNLEVBQUVaLEtBQUssSUFBSSxDQUFDO0lBQy9CLE9BQU87UUFDTFksVUFBVW5JLE1BQU0sQ0FBQzlFLFlBQVk7SUFDL0I7SUFFQSxJQUFJOEQsU0FBUztRQUNYbUosVUFBVSxDQUFDLGdDQUFnQyxFQUFFbkosUUFBUSxJQUFJLENBQUM7SUFDNUQsT0FBTyxJQUFJZ0IsTUFBTSxDQUFDMUUsWUFBWSxJQUFJLENBQUMyRSxNQUFNLENBQUMxRixPQUFPLEVBQUU7UUFDakQ0TixVQUFVO0lBQ1osT0FBTztRQUNMQSxVQUFVO0lBQ1o7SUFFQSxJQUFJQyxNQUFNQyxPQUFPLENBQUN4SCxVQUFVO1FBQzFCLElBQUssSUFBSXlILElBQUksR0FBR0EsSUFBSXpILFFBQVF5QixNQUFNLEVBQUVnRyxLQUFLLEVBQUc7WUFDMUMsTUFBTS9ELE1BQU0xRCxPQUFPLENBQUN5SCxJQUFJLEVBQUU7WUFDMUIsTUFBTUMsTUFBTTFILE9BQU8sQ0FBQ3lILElBQUksRUFBRTtZQUUxQixJQUFJRixNQUFNQyxPQUFPLENBQUNFLE1BQU07Z0JBQ3RCLElBQUssSUFBSXZDLElBQUksR0FBR0EsSUFBSXVDLElBQUlqRyxNQUFNLEVBQUUwRCxJQUFLO29CQUNuQ21DLFVBQVUsR0FBRzVELElBQUksRUFBRSxFQUFFZ0UsR0FBRyxDQUFDdkMsRUFBRSxDQUFDLElBQUksQ0FBQztnQkFDbkM7WUFDRixPQUFPO2dCQUNMbUMsVUFBVSxHQUFHNUQsSUFBSSxFQUFFLEVBQUVnRSxJQUFJLElBQUksQ0FBQztZQUNoQztRQUNGO0lBQ0Y7SUFFQSxJQUFJN08sU0FBUzhPLFdBQVcsQ0FBQ0MsY0FBYyxFQUFFO1FBQ3ZDL08sU0FBUzhPLFdBQVcsQ0FBQ0UsT0FBTyxDQUFDO1lBQUV4RTtZQUFTckQsU0FBU3NIO1lBQVFsSTtRQUFPO0lBQ2xFO0lBRUEsbUNBQW1DLEdBQ25DLElBQUksQ0FBQzhHLFFBQVFELGVBQWUsR0FBRztRQUM3QjZCLFlBQVlYLE9BQU8sTUFBTWhJLFFBQVFrRSxTQUFTakUsUUFBUW9CLGVBQWU4RyxRQUFRVDtJQUMzRSxPQUFPLElBQUlqTyxLQUFLbVAsUUFBUSxDQUFDN0IsT0FBTztRQUM5QjRCLFlBQVlYLE9BQU9qQixNQUFNL0csUUFBUWtFLFNBQVNqRSxRQUFRb0IsZUFBZThHLFFBQVFUO0lBQzNFLE9BQU8sSUFBSWpPLEtBQUtxTyxVQUFVLENBQUNmLE9BQU87UUFDaEMsSUFBSSxPQUFPQSxLQUFLYyxNQUFNLEtBQUssWUFBWTtZQUNyQ2dCLGNBQWNiLE9BQU9qQixLQUFLYyxNQUFNLElBQUk3SCxRQUFRa0UsU0FBU2pFLFFBQVFvQixlQUFlOEcsUUFBUVQ7UUFDdEYsT0FBTztZQUNMb0IsVUFBVWQsT0FBT2pCLE1BQU0vRyxRQUFRa0UsU0FBU2pFLFFBQVFvQixlQUFlOEcsUUFBUVQ7UUFDekU7SUFDRixPQUFPLElBQUlqTyxLQUFLdU4sUUFBUSxDQUFDRCxPQUFPO1FBQzlCZ0MsWUFBWWYsT0FBT2pCLE1BQU0vRyxRQUFRa0UsU0FBU2pFLFFBQVFvQixlQUFlOEcsUUFBUVQ7SUFDM0UsT0FBTyxJQUFJak8sS0FBS3VQLFVBQVUsQ0FBQ2pDLE9BQU87UUFDaEM4QixjQUFjYixPQUFPakIsTUFBTS9HLFFBQVFrRSxTQUFTakUsUUFBUW9CLGVBQWU4RyxRQUFRVDtJQUM3RSxPQUFPO1FBQ0xuTyxPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTd1AsWUFBYWYsS0FBSyxFQUFFakIsSUFBSSxFQUFFL0csTUFBTSxFQUFFa0UsT0FBTyxFQUFFakUsTUFBTSxFQUFFb0IsYUFBYSxFQUFFOEcsTUFBTSxFQUFFVCxjQUFjO0lBQy9Gbk8sT0FBTzhILGtCQUFrQixLQUFLckIsTUFBTSxDQUFDckYsU0FBUyxLQUFLLEdBQUc7SUFFdEQsSUFBSXNPLFdBQVc7SUFFZixNQUFNQyxTQUFTLElBQUlDLFlBQVk7UUFBRW5CO1FBQU8vSDtRQUFRaUU7UUFBUzdDO1FBQWVyQjtRQUFRMEg7UUFBZ0JTO0lBQU87SUFFdkcsTUFBTTdDLFNBQVMsU0FBVWxELEtBQUs7UUFDNUIsSUFBSTZHLFVBQVU7WUFDWjtRQUNGO1FBRUEsSUFBSTtZQUNGLElBQUksQ0FBQ0MsT0FBTzVDLEtBQUssQ0FBQ2xFLFVBQVUsSUFBSSxDQUFDK0MsS0FBSyxFQUFFO2dCQUN0QyxJQUFJLENBQUNBLEtBQUs7WUFDWjtRQUNGLEVBQUUsT0FBT25DLEtBQUs7WUFDWnZKLEtBQUtzSyxPQUFPLENBQUMsSUFBSSxFQUFFZjtRQUNyQjtJQUNGO0lBQ0EsTUFBTW9HLFVBQVU7UUFDZCxJQUFJSCxVQUFVO1lBQ1o7UUFDRjtRQUVBLElBQUlsQyxLQUFLOUYsTUFBTSxFQUFFO1lBQ2Y4RixLQUFLOUYsTUFBTTtRQUNiO0lBQ0Y7SUFDQSxNQUFNb0ksVUFBVTtRQUNkLGdEQUFnRDtRQUNoRCxrREFBa0Q7UUFDbEQxQyxlQUFlO1lBQ2Isa0RBQWtEO1lBQ2xELFdBQVc7WUFDWEksS0FBS3VDLGNBQWMsQ0FBQyxTQUFTQztRQUMvQjtRQUVBLElBQUksQ0FBQ04sVUFBVTtZQUNiLE1BQU1qRyxNQUFNLElBQUlsSjtZQUNoQjZNLGVBQWUsSUFBTTRDLFdBQVd2RztRQUNsQztJQUNGO0lBQ0EsTUFBTXVHLGFBQWEsU0FBVXZHLEdBQUc7UUFDOUIsSUFBSWlHLFVBQVU7WUFDWjtRQUNGO1FBRUFBLFdBQVc7UUFFWDFQLE9BQU8wRyxPQUFPOEIsU0FBUyxJQUFLOUIsTUFBTSxDQUFDbkYsU0FBUyxJQUFJa0YsTUFBTSxDQUFDckYsU0FBUyxJQUFJO1FBRXBFc0YsT0FDR3VKLEdBQUcsQ0FBQyxTQUFTSixTQUNiSSxHQUFHLENBQUMsU0FBU0Q7UUFFaEJ4QyxLQUNHdUMsY0FBYyxDQUFDLFFBQVFoRSxRQUN2QmdFLGNBQWMsQ0FBQyxPQUFPQyxZQUN0QkQsY0FBYyxDQUFDLFNBQVNEO1FBRTNCLElBQUksQ0FBQ3JHLEtBQUs7WUFDUixJQUFJO2dCQUNGa0csT0FBT08sR0FBRztZQUNaLEVBQUUsT0FBT0MsSUFBSTtnQkFDWDFHLE1BQU0wRztZQUNSO1FBQ0Y7UUFFQVIsT0FBT25GLE9BQU8sQ0FBQ2Y7UUFFZixJQUFJQSxPQUFRQSxDQUFBQSxJQUFJNkMsSUFBSSxLQUFLLGtCQUFrQjdDLElBQUlXLE9BQU8sS0FBSyxPQUFNLEdBQUk7WUFDbkVsSyxLQUFLc0ssT0FBTyxDQUFDZ0QsTUFBTS9EO1FBQ3JCLE9BQU87WUFDTHZKLEtBQUtzSyxPQUFPLENBQUNnRDtRQUNmO0lBQ0Y7SUFFQUEsS0FDR1osRUFBRSxDQUFDLFFBQVFiLFFBQ1hhLEVBQUUsQ0FBQyxPQUFPb0QsWUFDVnBELEVBQUUsQ0FBQyxTQUFTb0QsWUFDWnBELEVBQUUsQ0FBQyxTQUFTa0Q7SUFFZixJQUFJdEMsS0FBSzlGLE1BQU0sRUFBRTtRQUNmOEYsS0FBSzlGLE1BQU07SUFDYjtJQUVBaEIsT0FDR2tHLEVBQUUsQ0FBQyxTQUFTaUQsU0FDWmpELEVBQUUsQ0FBQyxTQUFTb0Q7SUFFZixJQUFJeEMsS0FBSzRDLFlBQVksSUFBSTVDLEtBQUs2QyxPQUFPLEVBQUU7UUFDckNuRSxhQUFhLElBQU04RCxXQUFXeEMsS0FBSzZDLE9BQU87SUFDNUMsT0FBTyxJQUFJN0MsS0FBSzhDLFVBQVUsSUFBSTlDLEtBQUsrQyxhQUFhLEVBQUU7UUFDaERyRSxhQUFhLElBQU04RCxXQUFXO0lBQ2hDO0lBRUEsSUFBSXhDLEtBQUtnRCxZQUFZLElBQUloRCxLQUFLYixNQUFNLEVBQUU7UUFDcENULGFBQWE0RDtJQUNmO0FBQ0Y7QUFFQSxTQUFTVixZQUFhWCxLQUFLLEVBQUVqQixJQUFJLEVBQUUvRyxNQUFNLEVBQUVrRSxPQUFPLEVBQUVqRSxNQUFNLEVBQUVvQixhQUFhLEVBQUU4RyxNQUFNLEVBQUVULGNBQWM7SUFDL0YsSUFBSTtRQUNGLElBQUksQ0FBQ1gsTUFBTTtZQUNULElBQUkxRixrQkFBa0IsR0FBRztnQkFDdkJwQixPQUFPcUcsS0FBSyxDQUFDLEdBQUc2QixPQUFPLHlCQUF5QixDQUFDLEVBQUU7WUFDckQsT0FBTztnQkFDTDVPLE9BQU84SCxrQkFBa0IsTUFBTTtnQkFDL0JwQixPQUFPcUcsS0FBSyxDQUFDLEdBQUc2QixPQUFPLElBQUksQ0FBQyxFQUFFO1lBQ2hDO1FBQ0YsT0FBTyxJQUFJMU8sS0FBS21QLFFBQVEsQ0FBQzdCLE9BQU87WUFDOUJ4TixPQUFPOEgsa0JBQWtCMEYsS0FBS2lELFVBQVUsRUFBRTtZQUUxQy9KLE9BQU9nSyxJQUFJO1lBQ1hoSyxPQUFPcUcsS0FBSyxDQUFDLEdBQUc2QixPQUFPLGdCQUFnQixFQUFFOUcsY0FBYyxRQUFRLENBQUMsRUFBRTtZQUNsRXBCLE9BQU9xRyxLQUFLLENBQUNTO1lBQ2I5RyxPQUFPaUssTUFBTTtZQUNiaEcsUUFBUWlHLFVBQVUsQ0FBQ3BEO1lBRW5CLElBQUksQ0FBQ1csZ0JBQWdCO2dCQUNuQnpILE1BQU0sQ0FBQzFGLE9BQU8sR0FBRztZQUNuQjtRQUNGO1FBQ0EySixRQUFRa0csYUFBYTtRQUVyQnBLLE1BQU0sQ0FBQzdELFFBQVE7SUFDakIsRUFBRSxPQUFPNkcsS0FBSztRQUNaZ0YsTUFBTWhGO0lBQ1I7QUFDRjtBQUVBLGVBQWU4RixVQUFXZCxLQUFLLEVBQUVqQixJQUFJLEVBQUUvRyxNQUFNLEVBQUVrRSxPQUFPLEVBQUVqRSxNQUFNLEVBQUVvQixhQUFhLEVBQUU4RyxNQUFNLEVBQUVULGNBQWM7SUFDbkduTyxPQUFPOEgsa0JBQWtCMEYsS0FBS3NELElBQUksRUFBRTtJQUVwQyxJQUFJO1FBQ0YsSUFBSWhKLGlCQUFpQixRQUFRQSxrQkFBa0IwRixLQUFLc0QsSUFBSSxFQUFFO1lBQ3hELE1BQU0sSUFBSXpRO1FBQ1o7UUFFQSxNQUFNMkUsU0FBU2hDLE9BQU9zSCxJQUFJLENBQUMsTUFBTWtELEtBQUt1RCxXQUFXO1FBRWpEckssT0FBT2dLLElBQUk7UUFDWGhLLE9BQU9xRyxLQUFLLENBQUMsR0FBRzZCLE9BQU8sZ0JBQWdCLEVBQUU5RyxjQUFjLFFBQVEsQ0FBQyxFQUFFO1FBQ2xFcEIsT0FBT3FHLEtBQUssQ0FBQy9IO1FBQ2IwQixPQUFPaUssTUFBTTtRQUViaEcsUUFBUWlHLFVBQVUsQ0FBQzVMO1FBQ25CMkYsUUFBUWtHLGFBQWE7UUFFckIsSUFBSSxDQUFDMUMsZ0JBQWdCO1lBQ25CekgsTUFBTSxDQUFDMUYsT0FBTyxHQUFHO1FBQ25CO1FBRUF5RixNQUFNLENBQUM3RCxRQUFRO0lBQ2pCLEVBQUUsT0FBTzZHLEtBQUs7UUFDWmdGLE1BQU1oRjtJQUNSO0FBQ0Y7QUFFQSxlQUFlNkYsY0FBZWIsS0FBSyxFQUFFakIsSUFBSSxFQUFFL0csTUFBTSxFQUFFa0UsT0FBTyxFQUFFakUsTUFBTSxFQUFFb0IsYUFBYSxFQUFFOEcsTUFBTSxFQUFFVCxjQUFjO0lBQ3ZHbk8sT0FBTzhILGtCQUFrQixLQUFLckIsTUFBTSxDQUFDckYsU0FBUyxLQUFLLEdBQUc7SUFFdEQsSUFBSStMLFdBQVc7SUFDZixTQUFTMEM7UUFDUCxJQUFJMUMsVUFBVTtZQUNaLE1BQU02RCxLQUFLN0Q7WUFDWEEsV0FBVztZQUNYNkQ7UUFDRjtJQUNGO0lBRUEsTUFBTUMsZUFBZSxJQUFNLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDL0NwUixPQUFPbU4sYUFBYTtZQUVwQixJQUFJekcsTUFBTSxDQUFDNUUsT0FBTyxFQUFFO2dCQUNsQnNQLE9BQU8xSyxNQUFNLENBQUM1RSxPQUFPO1lBQ3ZCLE9BQU87Z0JBQ0xxTCxXQUFXZ0U7WUFDYjtRQUNGO0lBRUF6SyxPQUNHa0csRUFBRSxDQUFDLFNBQVNpRCxTQUNaakQsRUFBRSxDQUFDLFNBQVNpRDtJQUVmLE1BQU1GLFNBQVMsSUFBSUMsWUFBWTtRQUFFbkI7UUFBTy9IO1FBQVFpRTtRQUFTN0M7UUFBZXJCO1FBQVEwSDtRQUFnQlM7SUFBTztJQUN2RyxJQUFJO1FBQ0YsMkRBQTJEO1FBQzNELFdBQVcsTUFBTS9GLFNBQVMyRSxLQUFNO1lBQzlCLElBQUk5RyxNQUFNLENBQUM1RSxPQUFPLEVBQUU7Z0JBQ2xCLE1BQU00RSxNQUFNLENBQUM1RSxPQUFPO1lBQ3RCO1lBRUEsSUFBSSxDQUFDNk4sT0FBTzVDLEtBQUssQ0FBQ2xFLFFBQVE7Z0JBQ3hCLE1BQU1vSTtZQUNSO1FBQ0Y7UUFFQXRCLE9BQU9PLEdBQUc7SUFDWixFQUFFLE9BQU96RyxLQUFLO1FBQ1prRyxPQUFPbkYsT0FBTyxDQUFDZjtJQUNqQixTQUFVO1FBQ1IvQyxPQUNHdUosR0FBRyxDQUFDLFNBQVNKLFNBQ2JJLEdBQUcsQ0FBQyxTQUFTSjtJQUNsQjtBQUNGO0FBRUEsTUFBTUQ7SUFDSixZQUFhLEVBQUVuQixLQUFLLEVBQUUvSCxNQUFNLEVBQUVpRSxPQUFPLEVBQUU3QyxhQUFhLEVBQUVyQixNQUFNLEVBQUUwSCxjQUFjLEVBQUVTLE1BQU0sRUFBRSxDQUFFO1FBQ3RGLElBQUksQ0FBQ2xJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNpRSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDN0MsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUNyQixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEssWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ2xELGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDUyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDSCxLQUFLLEdBQUdBO1FBRWIvSCxNQUFNLENBQUNuRixTQUFTLEdBQUc7SUFDckI7SUFFQXdMLE1BQU9sRSxLQUFLLEVBQUU7UUFDWixNQUFNLEVBQUVuQyxNQUFNLEVBQUVpRSxPQUFPLEVBQUU3QyxhQUFhLEVBQUVyQixNQUFNLEVBQUU0SyxZQUFZLEVBQUVsRCxjQUFjLEVBQUVTLE1BQU0sRUFBRSxHQUFHLElBQUk7UUFFN0YsSUFBSWxJLE1BQU0sQ0FBQzVFLE9BQU8sRUFBRTtZQUNsQixNQUFNNEUsTUFBTSxDQUFDNUUsT0FBTztRQUN0QjtRQUVBLElBQUk0RSxPQUFPOEIsU0FBUyxFQUFFO1lBQ3BCLE9BQU87UUFDVDtRQUVBLE1BQU1sRSxNQUFNdEIsT0FBT3lOLFVBQVUsQ0FBQzVIO1FBQzlCLElBQUksQ0FBQ3ZFLEtBQUs7WUFDUixPQUFPO1FBQ1Q7UUFFQSxrQ0FBa0M7UUFDbEMsSUFBSXdELGtCQUFrQixRQUFRdUosZUFBZS9NLE1BQU13RCxlQUFlO1lBQ2hFLElBQUlyQixNQUFNLENBQUNsRSxxQkFBcUIsRUFBRTtnQkFDaEMsTUFBTSxJQUFJbEM7WUFDWjtZQUVBcUQsUUFBUThLLFdBQVcsQ0FBQyxJQUFJbk87UUFDMUI7UUFFQXFHLE9BQU9nSyxJQUFJO1FBRVgsSUFBSVcsaUJBQWlCLEdBQUc7WUFDdEIsSUFBSSxDQUFDbEQsZ0JBQWdCO2dCQUNuQnpILE1BQU0sQ0FBQzFGLE9BQU8sR0FBRztZQUNuQjtZQUVBLElBQUk4RyxrQkFBa0IsTUFBTTtnQkFDMUJwQixPQUFPcUcsS0FBSyxDQUFDLEdBQUc2QixPQUFPLDhCQUE4QixDQUFDLEVBQUU7WUFDMUQsT0FBTztnQkFDTGxJLE9BQU9xRyxLQUFLLENBQUMsR0FBRzZCLE9BQU8sZ0JBQWdCLEVBQUU5RyxjQUFjLFFBQVEsQ0FBQyxFQUFFO1lBQ3BFO1FBQ0Y7UUFFQSxJQUFJQSxrQkFBa0IsTUFBTTtZQUMxQnBCLE9BQU9xRyxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUV6SSxJQUFJaUcsUUFBUSxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUU7UUFDOUM7UUFFQSxJQUFJLENBQUM4RyxZQUFZLElBQUkvTTtRQUVyQixNQUFNaUYsTUFBTTdDLE9BQU9xRyxLQUFLLENBQUNsRTtRQUV6Qm5DLE9BQU9pSyxNQUFNO1FBRWJoRyxRQUFRaUcsVUFBVSxDQUFDL0g7UUFFbkIsSUFBSSxDQUFDVSxLQUFLO1lBQ1IsSUFBSTdDLE1BQU0sQ0FBQ3hGLFFBQVEsQ0FBQ2dHLE9BQU8sSUFBSVIsTUFBTSxDQUFDeEYsUUFBUSxDQUFDa0csV0FBVyxLQUFLZixpQkFBaUI7Z0JBQzlFLHNDQUFzQztnQkFDdEMsSUFBSUssTUFBTSxDQUFDeEYsUUFBUSxDQUFDZ0csT0FBTyxDQUFDcUIsT0FBTyxFQUFFO29CQUNuQzdCLE1BQU0sQ0FBQ3hGLFFBQVEsQ0FBQ2dHLE9BQU8sQ0FBQ3FCLE9BQU87Z0JBQ2pDO1lBQ0Y7UUFDRjtRQUVBLE9BQU9nQjtJQUNUO0lBRUEyRyxNQUFPO1FBQ0wsTUFBTSxFQUFFeEosTUFBTSxFQUFFb0IsYUFBYSxFQUFFckIsTUFBTSxFQUFFNEssWUFBWSxFQUFFbEQsY0FBYyxFQUFFUyxNQUFNLEVBQUVqRSxPQUFPLEVBQUUsR0FBRyxJQUFJO1FBQzdGQSxRQUFRa0csYUFBYTtRQUVyQm5LLE1BQU0sQ0FBQ25GLFNBQVMsR0FBRztRQUVuQixJQUFJbUYsTUFBTSxDQUFDNUUsT0FBTyxFQUFFO1lBQ2xCLE1BQU00RSxNQUFNLENBQUM1RSxPQUFPO1FBQ3RCO1FBRUEsSUFBSTRFLE9BQU84QixTQUFTLEVBQUU7WUFDcEI7UUFDRjtRQUVBLElBQUk2SSxpQkFBaUIsR0FBRztZQUN0QixJQUFJbEQsZ0JBQWdCO2dCQUNsQixvREFBb0Q7Z0JBQ3BELHNFQUFzRTtnQkFDdEUsd0VBQXdFO2dCQUN4RSxnQ0FBZ0M7Z0JBRWhDekgsT0FBT3FHLEtBQUssQ0FBQyxHQUFHNkIsT0FBTyx5QkFBeUIsQ0FBQyxFQUFFO1lBQ3JELE9BQU87Z0JBQ0xsSSxPQUFPcUcsS0FBSyxDQUFDLEdBQUc2QixPQUFPLElBQUksQ0FBQyxFQUFFO1lBQ2hDO1FBQ0YsT0FBTyxJQUFJOUcsa0JBQWtCLE1BQU07WUFDakNwQixPQUFPcUcsS0FBSyxDQUFDLGlCQUFpQjtRQUNoQztRQUVBLElBQUlqRixrQkFBa0IsUUFBUXVKLGlCQUFpQnZKLGVBQWU7WUFDNUQsSUFBSXJCLE1BQU0sQ0FBQ2xFLHFCQUFxQixFQUFFO2dCQUNoQyxNQUFNLElBQUlsQztZQUNaLE9BQU87Z0JBQ0xxRCxRQUFROEssV0FBVyxDQUFDLElBQUluTztZQUMxQjtRQUNGO1FBRUEsSUFBSXFHLE1BQU0sQ0FBQ3hGLFFBQVEsQ0FBQ2dHLE9BQU8sSUFBSVIsTUFBTSxDQUFDeEYsUUFBUSxDQUFDa0csV0FBVyxLQUFLZixpQkFBaUI7WUFDOUUsc0NBQXNDO1lBQ3RDLElBQUlLLE1BQU0sQ0FBQ3hGLFFBQVEsQ0FBQ2dHLE9BQU8sQ0FBQ3FCLE9BQU8sRUFBRTtnQkFDbkM3QixNQUFNLENBQUN4RixRQUFRLENBQUNnRyxPQUFPLENBQUNxQixPQUFPO1lBQ2pDO1FBQ0Y7UUFFQTlCLE1BQU0sQ0FBQzdELFFBQVE7SUFDakI7SUFFQTRILFFBQVNmLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRS9DLE1BQU0sRUFBRUQsTUFBTSxFQUFFZ0ksS0FBSyxFQUFFLEdBQUcsSUFBSTtRQUV0Qy9ILE1BQU0sQ0FBQ25GLFNBQVMsR0FBRztRQUVuQixJQUFJa0ksS0FBSztZQUNQekosT0FBT3lHLE1BQU0sQ0FBQ3JGLFNBQVMsSUFBSSxHQUFHO1lBQzlCcU4sTUFBTWhGO1FBQ1I7SUFDRjtBQUNGO0FBRUE2SCxPQUFPM0ssT0FBTyxHQUFHMEYiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcY2xpZW50LWgxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiBnbG9iYWwgV2ViQXNzZW1ibHkgKi9cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbC5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IHRpbWVycyA9IHJlcXVpcmUoJy4uL3V0aWwvdGltZXJzLmpzJylcbmNvbnN0IHtcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBIZWFkZXJzVGltZW91dEVycm9yLFxuICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgU29ja2V0RXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgQm9keVRpbWVvdXRFcnJvcixcbiAgSFRUUFBhcnNlckVycm9yLFxuICBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrUmVzZXQsXG4gIGtDbGllbnQsXG4gIGtQYXJzZXIsXG4gIGtCbG9ja2luZyxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrU2l6ZSxcbiAga1dyaXRpbmcsXG4gIGtRdWV1ZSxcbiAga05vUmVmLFxuICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQsXG4gIGtIb3N0SGVhZGVyLFxuICBrUGVuZGluZ0lkeCxcbiAga1J1bm5pbmdJZHgsXG4gIGtFcnJvcixcbiAga1BpcGVsaW5pbmcsXG4gIGtTb2NrZXQsXG4gIGtLZWVwQWxpdmVUaW1lb3V0VmFsdWUsXG4gIGtNYXhIZWFkZXJzU2l6ZSxcbiAga0tlZXBBbGl2ZU1heFRpbWVvdXQsXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkLFxuICBrSGVhZGVyc1RpbWVvdXQsXG4gIGtCb2R5VGltZW91dCxcbiAga1N0cmljdENvbnRlbnRMZW5ndGgsXG4gIGtNYXhSZXF1ZXN0cyxcbiAga0NvdW50ZXIsXG4gIGtNYXhSZXNwb25zZVNpemUsXG4gIGtPbkVycm9yLFxuICBrUmVzdW1lLFxuICBrSFRUUENvbnRleHRcbn0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMuanMnKVxuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9sbGh0dHAvY29uc3RhbnRzLmpzJylcbmNvbnN0IEVNUFRZX0JVRiA9IEJ1ZmZlci5hbGxvYygwKVxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc11cbmNvbnN0IGFkZExpc3RlbmVyID0gdXRpbC5hZGRMaXN0ZW5lclxuY29uc3QgcmVtb3ZlQWxsTGlzdGVuZXJzID0gdXRpbC5yZW1vdmVBbGxMaXN0ZW5lcnNcblxubGV0IGV4dHJhY3RCb2R5XG5cbmFzeW5jIGZ1bmN0aW9uIGxhenlsbGh0dHAgKCkge1xuICBjb25zdCBsbGh0dHBXYXNtRGF0YSA9IHByb2Nlc3MuZW52LkpFU1RfV09SS0VSX0lEID8gcmVxdWlyZSgnLi4vbGxodHRwL2xsaHR0cC13YXNtLmpzJykgOiB1bmRlZmluZWRcblxuICBsZXQgbW9kXG4gIHRyeSB7XG4gICAgbW9kID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShyZXF1aXJlKCcuLi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcycpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgIC8vIFdlIGNvdWxkIGNoZWNrIGlmIHRoZSBlcnJvciB3YXMgY2F1c2VkIGJ5IHRoZSBzaW1kIG9wdGlvbiBub3RcbiAgICAvLyBiZWluZyBlbmFibGVkLCBidXQgdGhlIG9jY3VycmluZyBvZiB0aGlzIG90aGVyIGVycm9yXG4gICAgLy8gKiBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vaXNzdWVzLzExNDk1XG4gICAgLy8gZ290IG1lIHRvIHJlbW92ZSB0aGF0IGNoZWNrIHRvIGF2b2lkIGJyZWFraW5nIE5vZGUgMTIuXG4gICAgbW9kID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShsbGh0dHBXYXNtRGF0YSB8fCByZXF1aXJlKCcuLi9sbGh0dHAvbGxodHRwLXdhc20uanMnKSlcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2QsIHtcbiAgICBlbnY6IHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuXG4gICAgICB3YXNtX29uX3VybDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX3N0YXR1czogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vblN0YXR1cyhuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX21lc3NhZ2VfYmVnaW46IChwKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQmVnaW4oKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9oZWFkZXJfZmllbGQ6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJGaWVsZChuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2hlYWRlcl92YWx1ZTogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlclZhbHVlKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25faGVhZGVyc19jb21wbGV0ZTogKHAsIHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyc0NvbXBsZXRlKHN0YXR1c0NvZGUsIEJvb2xlYW4odXBncmFkZSksIEJvb2xlYW4oc2hvdWxkS2VlcEFsaXZlKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fYm9keTogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkJvZHkobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9tZXNzYWdlX2NvbXBsZXRlOiAocCkgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKCkgfHwgMFxuICAgICAgfVxuXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIH1cbiAgfSlcbn1cblxubGV0IGxsaHR0cEluc3RhbmNlID0gbnVsbFxubGV0IGxsaHR0cFByb21pc2UgPSBsYXp5bGxodHRwKClcbmxsaHR0cFByb21pc2UuY2F0Y2goKVxuXG5sZXQgY3VycmVudFBhcnNlciA9IG51bGxcbmxldCBjdXJyZW50QnVmZmVyUmVmID0gbnVsbFxubGV0IGN1cnJlbnRCdWZmZXJTaXplID0gMFxubGV0IGN1cnJlbnRCdWZmZXJQdHIgPSBudWxsXG5cbmNvbnN0IFRJTUVPVVRfSEVBREVSUyA9IDFcbmNvbnN0IFRJTUVPVVRfQk9EWSA9IDJcbmNvbnN0IFRJTUVPVVRfSURMRSA9IDNcblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IgKGNsaWVudCwgc29ja2V0LCB7IGV4cG9ydHMgfSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV0pICYmIGNsaWVudFtrTWF4SGVhZGVyc1NpemVdID4gMClcblxuICAgIHRoaXMubGxodHRwID0gZXhwb3J0c1xuICAgIHRoaXMucHRyID0gdGhpcy5sbGh0dHAubGxodHRwX2FsbG9jKGNvbnN0YW50cy5UWVBFLlJFU1BPTlNFKVxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLnVwZ3JhZGUgPSBmYWxzZVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcbiAgICB0aGlzLmhlYWRlcnNNYXhTaXplID0gY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV1cbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IGZhbHNlXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMucmVzdW1lID0gdGhpcy5yZXN1bWUuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5ieXRlc1JlYWQgPSAwXG5cbiAgICB0aGlzLmtlZXBBbGl2ZSA9ICcnXG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuICAgIHRoaXMubWF4UmVzcG9uc2VTaXplID0gY2xpZW50W2tNYXhSZXNwb25zZVNpemVdXG4gIH1cblxuICBzZXRUaW1lb3V0ICh2YWx1ZSwgdHlwZSkge1xuICAgIHRoaXMudGltZW91dFR5cGUgPSB0eXBlXG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLnRpbWVvdXRWYWx1ZSkge1xuICAgICAgdGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZXJzLnNldFRpbWVvdXQob25QYXJzZXJUaW1lb3V0LCB2YWx1ZSwgdGhpcylcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgICAgaWYgKHRoaXMudGltZW91dC51bnJlZikge1xuICAgICAgICAgIHRoaXMudGltZW91dC51bnJlZigpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZW91dFZhbHVlID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzdW1lICgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQuZGVzdHJveWVkIHx8ICF0aGlzLnBhdXNlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcblxuICAgIHRoaXMubGxodHRwLmxsaHR0cF9yZXN1bWUodGhpcy5wdHIpXG5cbiAgICBhc3NlcnQodGhpcy50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKVxuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICB0aGlzLmV4ZWN1dGUodGhpcy5zb2NrZXQucmVhZCgpIHx8IEVNUFRZX0JVRikgLy8gRmx1c2ggcGFyc2VyLlxuICAgIHRoaXMucmVhZE1vcmUoKVxuICB9XG5cbiAgcmVhZE1vcmUgKCkge1xuICAgIHdoaWxlICghdGhpcy5wYXVzZWQgJiYgdGhpcy5wdHIpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5zb2NrZXQucmVhZCgpXG4gICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZShjaHVuaylcbiAgICB9XG4gIH1cblxuICBleGVjdXRlIChkYXRhKSB7XG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuXG4gICAgY29uc3QgeyBzb2NrZXQsIGxsaHR0cCB9ID0gdGhpc1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gY3VycmVudEJ1ZmZlclNpemUpIHtcbiAgICAgIGlmIChjdXJyZW50QnVmZmVyUHRyKSB7XG4gICAgICAgIGxsaHR0cC5mcmVlKGN1cnJlbnRCdWZmZXJQdHIpXG4gICAgICB9XG4gICAgICBjdXJyZW50QnVmZmVyU2l6ZSA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDQwOTYpICogNDA5NlxuICAgICAgY3VycmVudEJ1ZmZlclB0ciA9IGxsaHR0cC5tYWxsb2MoY3VycmVudEJ1ZmZlclNpemUpXG4gICAgfVxuXG4gICAgbmV3IFVpbnQ4QXJyYXkobGxodHRwLm1lbW9yeS5idWZmZXIsIGN1cnJlbnRCdWZmZXJQdHIsIGN1cnJlbnRCdWZmZXJTaXplKS5zZXQoZGF0YSlcblxuICAgIC8vIENhbGwgYGV4ZWN1dGVgIG9uIHRoZSB3YXNtIHBhcnNlci5cbiAgICAvLyBXZSBwYXNzIHRoZSBgbGxodHRwX3BhcnNlcmAgcG9pbnRlciBhZGRyZXNzLCB0aGUgcG9pbnRlciBhZGRyZXNzIG9mIGJ1ZmZlciB2aWV3IGRhdGEsXG4gICAgLy8gYW5kIGZpbmFsbHkgdGhlIGxlbmd0aCBvZiBieXRlcyB0byBwYXJzZS5cbiAgICAvLyBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIGVycm9yIGNvZGUgb3IgYGNvbnN0YW50cy5FUlJPUi5PS2AuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXRcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IGRhdGFcbiAgICAgICAgY3VycmVudFBhcnNlciA9IHRoaXNcbiAgICAgICAgcmV0ID0gbGxodHRwLmxsaHR0cF9leGVjdXRlKHRoaXMucHRyLCBjdXJyZW50QnVmZmVyUHRyLCBkYXRhLmxlbmd0aClcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2F0Y2ggKi9cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFBhcnNlciA9IG51bGxcbiAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gbGxodHRwLmxsaHR0cF9nZXRfZXJyb3JfcG9zKHRoaXMucHRyKSAtIGN1cnJlbnRCdWZmZXJQdHJcblxuICAgICAgaWYgKHJldCA9PT0gY29uc3RhbnRzLkVSUk9SLlBBVVNFRF9VUEdSQURFKSB7XG4gICAgICAgIHRoaXMub25VcGdyYWRlKGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH0gZWxzZSBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEKSB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZVxuICAgICAgICBzb2NrZXQudW5zaGlmdChkYXRhLnNsaWNlKG9mZnNldCkpXG4gICAgICB9IGVsc2UgaWYgKHJldCAhPT0gY29uc3RhbnRzLkVSUk9SLk9LKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IGxsaHR0cC5sbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbih0aGlzLnB0cilcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJ1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgICAgIGlmIChwdHIpIHtcbiAgICAgICAgICBjb25zdCBsZW4gPSBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgcHRyKS5pbmRleE9mKDApXG4gICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAnUmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggdGhlIEhUVFAvMS4xIHByb3RvY29sICgnICtcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIsIGxlbikudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAnKSdcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgSFRUUFBhcnNlckVycm9yKG1lc3NhZ2UsIGNvbnN0YW50cy5FUlJPUltyZXRdLCBkYXRhLnNsaWNlKG9mZnNldCkpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcblxuICAgIHRoaXMubGxodHRwLmxsaHR0cF9mcmVlKHRoaXMucHRyKVxuICAgIHRoaXMucHRyID0gbnVsbFxuXG4gICAgdGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgIHRoaXMudGltZW91dFZhbHVlID0gbnVsbFxuICAgIHRoaXMudGltZW91dFR5cGUgPSBudWxsXG5cbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gIH1cblxuICBvblN0YXR1cyAoYnVmKSB7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gYnVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIG9uTWVzc2FnZUJlZ2luICgpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50IH0gPSB0aGlzXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJlcXVlc3Qub25SZXNwb25zZVN0YXJ0ZWQoKVxuICB9XG5cbiAgb25IZWFkZXJGaWVsZCAoYnVmKSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aFxuXG4gICAgaWYgKChsZW4gJiAxKSA9PT0gMCkge1xuICAgICAgdGhpcy5oZWFkZXJzLnB1c2goYnVmKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbGVuIC0gMV0gPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlcnNbbGVuIC0gMV0sIGJ1Zl0pXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKVxuICB9XG5cbiAgb25IZWFkZXJWYWx1ZSAoYnVmKSB7XG4gICAgbGV0IGxlbiA9IHRoaXMuaGVhZGVycy5sZW5ndGhcblxuICAgIGlmICgobGVuICYgMSkgPT09IDEpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5wdXNoKGJ1ZilcbiAgICAgIGxlbiArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tsZW4gLSAxXSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyc1tsZW4gLSAxXSwgYnVmXSlcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSB0aGlzLmhlYWRlcnNbbGVuIC0gMl1cbiAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIGNvbnN0IGhlYWRlck5hbWUgPSB1dGlsLmJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUoa2V5KVxuICAgICAgaWYgKGhlYWRlck5hbWUgPT09ICdrZWVwLWFsaXZlJykge1xuICAgICAgICB0aGlzLmtlZXBBbGl2ZSArPSBidWYudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAnY29ubmVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uICs9IGJ1Zi50b1N0cmluZygpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxNCAmJiB1dGlsLmJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUoa2V5KSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKVxuICB9XG5cbiAgdHJhY2tIZWFkZXIgKGxlbikge1xuICAgIHRoaXMuaGVhZGVyc1NpemUgKz0gbGVuXG4gICAgaWYgKHRoaXMuaGVhZGVyc1NpemUgPj0gdGhpcy5oZWFkZXJzTWF4U2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMuc29ja2V0LCBuZXcgSGVhZGVyc092ZXJmbG93RXJyb3IoKSlcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKGhlYWQpIHtcbiAgICBjb25zdCB7IHVwZ3JhZGUsIGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNDb2RlIH0gPSB0aGlzXG5cbiAgICBhc3NlcnQodXBncmFkZSlcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGFzc2VydChyZXF1ZXN0KVxuXG4gICAgYXNzZXJ0KCFzb2NrZXQuZGVzdHJveWVkKVxuICAgIGFzc2VydChzb2NrZXQgPT09IGNsaWVudFtrU29ja2V0XSlcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuICAgIGFzc2VydChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gbnVsbFxuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIHNvY2tldC51bnNoaWZ0KGhlYWQpXG5cbiAgICBzb2NrZXRba1BhcnNlcl0uZGVzdHJveSgpXG4gICAgc29ja2V0W2tQYXJzZXJdID0gbnVsbFxuXG4gICAgc29ja2V0W2tDbGllbnRdID0gbnVsbFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKHNvY2tldClcblxuICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgICBjbGllbnRba0hUVFBDb250ZXh0XSA9IG51bGwgLy8gVE9ETyAoZml4KTogVGhpcyBpcyBoYWNreS4uLlxuICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG4gICAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCd1cGdyYWRlJykpXG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdC5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgZXJyKVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH1cblxuICBvbkhlYWRlcnNDb21wbGV0ZSAoc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgaGVhZGVycywgc3RhdHVzVGV4dCB9ID0gdGhpc1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGFzc2VydCghdGhpcy51cGdyYWRlKVxuICAgIGFzc2VydCh0aGlzLnN0YXR1c0NvZGUgPCAyMDApXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMTAwKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCByZXNwb25zZScsIHV0aWwuZ2V0U29ja2V0SW5mbyhzb2NrZXQpKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIC8qIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHNlcnZlciBpcyBtaXNiZWhhdmluZyAqL1xuICAgIGlmICh1cGdyYWRlICYmICFyZXF1ZXN0LnVwZ3JhZGUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBTb2NrZXRFcnJvcignYmFkIHVwZ3JhZGUnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy50aW1lb3V0VHlwZSwgVElNRU9VVF9IRUFERVJTKVxuXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gKFxuICAgICAgc2hvdWxkS2VlcEFsaXZlIHx8XG4gICAgICAvLyBPdmVycmlkZSBsbGh0dHAgdmFsdWUgd2hpY2ggZG9lcyBub3QgYWxsb3cga2VlcEFsaXZlIGZvciBIRUFELlxuICAgICAgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgJiYgIXNvY2tldFtrUmVzZXRdICYmIHRoaXMuY29ubmVjdGlvbi50b0xvd2VyQ2FzZSgpID09PSAna2VlcC1hbGl2ZScpXG4gICAgKVxuXG4gICAgaWYgKHRoaXMuc3RhdHVzQ29kZSA+PSAyMDApIHtcbiAgICAgIGNvbnN0IGJvZHlUaW1lb3V0ID0gcmVxdWVzdC5ib2R5VGltZW91dCAhPSBudWxsXG4gICAgICAgID8gcmVxdWVzdC5ib2R5VGltZW91dFxuICAgICAgICA6IGNsaWVudFtrQm9keVRpbWVvdXRdXG4gICAgICB0aGlzLnNldFRpbWVvdXQoYm9keVRpbWVvdXQsIFRJTUVPVVRfQk9EWSlcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKVxuICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZVxuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDEpXG4gICAgICB0aGlzLnVwZ3JhZGUgPSB0cnVlXG4gICAgICByZXR1cm4gMlxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmhlYWRlcnMubGVuZ3RoICUgMiA9PT0gMClcbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG5cbiAgICBpZiAodGhpcy5zaG91bGRLZWVwQWxpdmUgJiYgY2xpZW50W2tQaXBlbGluaW5nXSkge1xuICAgICAgY29uc3Qga2VlcEFsaXZlVGltZW91dCA9IHRoaXMua2VlcEFsaXZlID8gdXRpbC5wYXJzZUtlZXBBbGl2ZVRpbWVvdXQodGhpcy5rZWVwQWxpdmUpIDogbnVsbFxuXG4gICAgICBpZiAoa2VlcEFsaXZlVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBNYXRoLm1pbihcbiAgICAgICAgICBrZWVwQWxpdmVUaW1lb3V0IC0gY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXSxcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZU1heFRpbWVvdXRdXG4gICAgICAgIClcbiAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRpbWVvdXRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdID0gY2xpZW50W2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RvcCBtb3JlIHJlcXVlc3RzIGZyb20gYmVpbmcgZGlzcGF0Y2hlZC5cbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHBhdXNlID0gcmVxdWVzdC5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgdGhpcy5yZXN1bWUsIHN0YXR1c1RleHQpID09PSBmYWxzZVxuXG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFtrQmxvY2tpbmddKSB7XG4gICAgICBzb2NrZXRba0Jsb2NraW5nXSA9IGZhbHNlXG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cblxuICAgIHJldHVybiBwYXVzZSA/IGNvbnN0YW50cy5FUlJPUi5QQVVTRUQgOiAwXG4gIH1cblxuICBvbkJvZHkgKGJ1Zikge1xuICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIHN0YXR1c0NvZGUsIG1heFJlc3BvbnNlU2l6ZSB9ID0gdGhpc1xuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGFzc2VydChyZXF1ZXN0KVxuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRoaXMudGltZW91dFR5cGUsIFRJTUVPVVRfQk9EWSlcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAyMDApXG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplID4gLTEgJiYgdGhpcy5ieXRlc1JlYWQgKyBidWYubGVuZ3RoID4gbWF4UmVzcG9uc2VTaXplKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcigpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgdGhpcy5ieXRlc1JlYWQgKz0gYnVmLmxlbmd0aFxuXG4gICAgaWYgKHJlcXVlc3Qub25EYXRhKGJ1ZikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH1cbiAgfVxuXG4gIG9uTWVzc2FnZUNvbXBsZXRlICgpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlLCB1cGdyYWRlLCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoLCBieXRlc1JlYWQsIHNob3VsZEtlZXBBbGl2ZSB9ID0gdGhpc1xuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQgJiYgKCFzdGF0dXNDb2RlIHx8IHNob3VsZEtlZXBBbGl2ZSkpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydChzdGF0dXNDb2RlID49IDEwMClcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuYnl0ZXNSZWFkID0gMFxuICAgIHRoaXMuY29udGVudExlbmd0aCA9ICcnXG4gICAgdGhpcy5rZWVwQWxpdmUgPSAnJ1xuICAgIHRoaXMuY29ubmVjdGlvbiA9ICcnXG5cbiAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgYmUgaGFuZGxlZCBieSBsbGh0dHA/ICovXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiYgY29udGVudExlbmd0aCAmJiBieXRlc1JlYWQgIT09IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHJlcXVlc3Qub25Db21wbGV0ZShoZWFkZXJzKVxuXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGlmIChzb2NrZXRba1dyaXRpbmddKSB7XG4gICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY2xpZW50W2tSdW5uaW5nXSwgMClcbiAgICAgIC8vIFJlc3BvbnNlIGNvbXBsZXRlZCBiZWZvcmUgcmVxdWVzdC5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoIXNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmIChzb2NrZXRba1Jlc2V0XSAmJiBjbGllbnRba1J1bm5pbmddID09PSAwKSB7XG4gICAgICAvLyBEZXN0cm95IHNvY2tldCBvbmNlIGFsbCByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGF0IHRoZSB0YWlsIG9mIHRoZSBwaXBlbGluZSBpcyB0aGUgb25lXG4gICAgICAvLyB0aGF0IHJlcXVlc3RlZCByZXNldCBhbmQgbm8gZnVydGhlciByZXF1ZXN0cyBzaG91bGRcbiAgICAgIC8vIGhhdmUgYmVlbiBxdWV1ZWQgc2luY2UgdGhlbi5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSA9PSBudWxsIHx8IGNsaWVudFtrUGlwZWxpbmluZ10gPT09IDEpIHtcbiAgICAgIC8vIFdlIG11c3Qgd2FpdCBhIGZ1bGwgZXZlbnQgbG9vcCBjeWNsZSB0byByZXVzZSB0aGlzIHNvY2tldCB0byBtYWtlIHN1cmVcbiAgICAgIC8vIHRoYXQgbm9uLXNwZWMgY29tcGxpYW50IHNlcnZlcnMgYXJlIG5vdCBjbG9zaW5nIHRoZSBjb25uZWN0aW9uIGV2ZW4gaWYgdGhleVxuICAgICAgLy8gc2FpZCB0aGV5IHdvbid0LlxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNsaWVudFtrUmVzdW1lXSgpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblBhcnNlclRpbWVvdXQgKHBhcnNlcikge1xuICBjb25zdCB7IHNvY2tldCwgdGltZW91dFR5cGUsIGNsaWVudCB9ID0gcGFyc2VyXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICBpZiAoIXNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0LndyaXRhYmxlTmVlZERyYWluIHx8IGNsaWVudFtrUnVubmluZ10gPiAxKSB7XG4gICAgICBhc3NlcnQoIXBhcnNlci5wYXVzZWQsICdjYW5ub3QgYmUgcGF1c2VkIHdoaWxlIHdhaXRpbmcgZm9yIGhlYWRlcnMnKVxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEhlYWRlcnNUaW1lb3V0RXJyb3IoKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfQk9EWSkge1xuICAgIGlmICghcGFyc2VyLnBhdXNlZCkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEJvZHlUaW1lb3V0RXJyb3IoKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfSURMRSkge1xuICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwICYmIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSlcbiAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdzb2NrZXQgaWRsZSB0aW1lb3V0JykpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdEgxIChjbGllbnQsIHNvY2tldCkge1xuICBjbGllbnRba1NvY2tldF0gPSBzb2NrZXRcblxuICBpZiAoIWxsaHR0cEluc3RhbmNlKSB7XG4gICAgbGxodHRwSW5zdGFuY2UgPSBhd2FpdCBsbGh0dHBQcm9taXNlXG4gICAgbGxodHRwUHJvbWlzZSA9IG51bGxcbiAgfVxuXG4gIHNvY2tldFtrTm9SZWZdID0gZmFsc2VcbiAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG4gIHNvY2tldFtrUmVzZXRdID0gZmFsc2VcbiAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICBzb2NrZXRba1BhcnNlcl0gPSBuZXcgUGFyc2VyKGNsaWVudCwgc29ja2V0LCBsbGh0dHBJbnN0YW5jZSlcblxuICBhZGRMaXN0ZW5lcihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzW2tQYXJzZXJdXG5cbiAgICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICAgIC8vIE9uIE1hYyBPUywgd2UgZ2V0IGFuIEVDT05OUkVTRVQgZXZlbiBpZiB0aGVyZSBpcyBhIGZ1bGwgYm9keSB0byBiZSBmb3J3YXJkZWRcbiAgICAvLyB0byB0aGUgdXNlci5cbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFQ09OTlJFU0VUJyAmJiBwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZm9yIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpc1trRXJyb3JdID0gZXJyXG5cbiAgICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG4gIH0pXG4gIGFkZExpc3RlbmVyKHNvY2tldCwgJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXNba1BhcnNlcl1cblxuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgIHBhcnNlci5yZWFkTW9yZSgpXG4gICAgfVxuICB9KVxuICBhZGRMaXN0ZW5lcihzb2NrZXQsICdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gICAgaWYgKHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmYXIgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG4gIH0pXG4gIGFkZExpc3RlbmVyKHNvY2tldCwgJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudF1cbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzW2tQYXJzZXJdXG5cbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICBpZiAoIXRoaXNba0Vycm9yXSAmJiBwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmYXIgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICAgIH1cblxuICAgICAgdGhpc1trUGFyc2VyXS5kZXN0cm95KClcbiAgICAgIHRoaXNba1BhcnNlcl0gPSBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgZXJyID0gdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcignY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXMpKVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICAgIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbCAvLyBUT0RPIChmaXgpOiBUaGlzIGlzIGhhY2t5Li4uXG5cbiAgICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApXG5cbiAgICAgIC8vIEZhaWwgZW50aXJlIHF1ZXVlLlxuICAgICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nKSB7XG4gICAgICAvLyBGYWlsIGhlYWQgb2YgcGlwZWxpbmUuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG5cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cblxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSlcblxuICBsZXQgY2xvc2VkID0gZmFsc2VcbiAgc29ja2V0Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnaDEnLFxuICAgIGRlZmF1bHRQaXBlbGluaW5nOiAxLFxuICAgIHdyaXRlICguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gd3JpdGVIMShjbGllbnQsIC4uLmFyZ3MpXG4gICAgfSxcbiAgICByZXN1bWUgKCkge1xuICAgICAgcmVzdW1lSDEoY2xpZW50KVxuICAgIH0sXG4gICAgZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvY2tldC5kZXN0cm95KGVycikub24oJ2Nsb3NlJywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICAgIHJldHVybiBzb2NrZXQuZGVzdHJveWVkXG4gICAgfSxcbiAgICBidXN5IChyZXF1ZXN0KSB7XG4gICAgICBpZiAoc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba1Jlc2V0XSB8fCBzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgIXJlcXVlc3QuaWRlbXBvdGVudCkge1xuICAgICAgICAgIC8vIE5vbi1pZGVtcG90ZW50IHJlcXVlc3QgY2Fubm90IGJlIHJldHJpZWQuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgICAgIC8vIGNvdWxkIGNhdXNlIGZhaWx1cmUuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAocmVxdWVzdC51cGdyYWRlIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGlzcGF0Y2ggYW4gdXBncmFkZSB1bnRpbCBhbGwgcHJlY2VkaW5nIHJlcXVlc3RzIGhhdmUgY29tcGxldGVkLlxuICAgICAgICAgIC8vIEEgbWlzYmVoYXZpbmcgc2VydmVyIG1pZ2h0IHVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gYmVmb3JlIGFsbCBwaXBlbGluZWRcbiAgICAgICAgICAvLyByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiB1dGlsLmJvZHlMZW5ndGgocmVxdWVzdC5ib2R5KSAhPT0gMCAmJlxuICAgICAgICAgICh1dGlsLmlzU3RyZWFtKHJlcXVlc3QuYm9keSkgfHwgdXRpbC5pc0FzeW5jSXRlcmFibGUocmVxdWVzdC5ib2R5KSB8fCB1dGlsLmlzRm9ybURhdGFMaWtlKHJlcXVlc3QuYm9keSkpKSB7XG4gICAgICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbiBlcnJvciB3aGlsZSBvdGhlciByZXF1ZXN0c1xuICAgICAgICAgIC8vIGFyZSBpbmZsaWdodCBhbmQgaW5kaXJlY3RseSBlcnJvciB0aG9zZSBhcyB3ZWxsLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGRvZXNuJ3QgaGFwcGVuIGJ5IHdhaXRpbmcgZm9yIGluZmxpZ2h0XG4gICAgICAgICAgLy8gdG8gY29tcGxldGUgYmVmb3JlIGRpc3BhdGNoaW5nLlxuXG4gICAgICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIG90aGVyIHJlcXVlc3RzIGFyZSBpbmZsaWdodCBhbmRcbiAgICAgICAgICAvLyBjb3VsZCBjYXVzZSBmYWlsdXJlLlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZUgxIChjbGllbnQpIHtcbiAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgaWYgKHNvY2tldCAmJiAhc29ja2V0LmRlc3Ryb3llZCkge1xuICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICBpZiAoIXNvY2tldFtrTm9SZWZdICYmIHNvY2tldC51bnJlZikge1xuICAgICAgICBzb2NrZXQudW5yZWYoKVxuICAgICAgICBzb2NrZXRba05vUmVmXSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvY2tldFtrTm9SZWZdICYmIHNvY2tldC5yZWYpIHtcbiAgICAgIHNvY2tldC5yZWYoKVxuICAgICAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0lETEUpIHtcbiAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdLCBUSU1FT1VUX0lETEUpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBzb2NrZXRba1BhcnNlcl0uc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSAhPT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgICAgICBjb25zdCBoZWFkZXJzVGltZW91dCA9IHJlcXVlc3QuaGVhZGVyc1RpbWVvdXQgIT0gbnVsbFxuICAgICAgICAgID8gcmVxdWVzdC5oZWFkZXJzVGltZW91dFxuICAgICAgICAgIDogY2xpZW50W2tIZWFkZXJzVGltZW91dF1cbiAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoaGVhZGVyc1RpbWVvdXQsIFRJTUVPVVRfSEVBREVSUylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuZnVuY3Rpb24gc2hvdWxkU2VuZENvbnRlbnRMZW5ndGggKG1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kICE9PSAnR0VUJyAmJiBtZXRob2QgIT09ICdIRUFEJyAmJiBtZXRob2QgIT09ICdPUFRJT05TJyAmJiBtZXRob2QgIT09ICdUUkFDRScgJiYgbWV0aG9kICE9PSAnQ09OTkVDVCdcbn1cblxuZnVuY3Rpb24gd3JpdGVIMSAoY2xpZW50LCByZXF1ZXN0KSB7XG4gIGNvbnN0IHsgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBibG9ja2luZywgcmVzZXQgfSA9IHJlcXVlc3RcblxuICBsZXQgeyBib2R5LCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoIH0gPSByZXF1ZXN0XG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4yXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjVcblxuICAvLyBTZW5kaW5nIGEgcGF5bG9hZCBib2R5IG9uIGEgcmVxdWVzdCB0aGF0IGRvZXMgbm90XG4gIC8vIGV4cGVjdCBpdCBjYW4gY2F1c2UgdW5kZWZpbmVkIGJlaGF2aW9yIG9uIHNvbWVcbiAgLy8gc2VydmVycyBhbmQgY29ycnVwdCBjb25uZWN0aW9uIHN0YXRlLiBEbyBub3RcbiAgLy8gcmUtdXNlIHRoZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIHJlcXVlc3RzLlxuXG4gIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gKFxuICAgIG1ldGhvZCA9PT0gJ1BVVCcgfHxcbiAgICBtZXRob2QgPT09ICdQT1NUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BBVENIJ1xuICApXG5cbiAgaWYgKHV0aWwuaXNGb3JtRGF0YUxpa2UoYm9keSkpIHtcbiAgICBpZiAoIWV4dHJhY3RCb2R5KSB7XG4gICAgICBleHRyYWN0Qm9keSA9IHJlcXVpcmUoJy4uL3dlYi9mZXRjaC9ib2R5LmpzJykuZXh0cmFjdEJvZHlcbiAgICB9XG5cbiAgICBjb25zdCBbYm9keVN0cmVhbSwgY29udGVudFR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSlcbiAgICBpZiAocmVxdWVzdC5jb250ZW50VHlwZSA9PSBudWxsKSB7XG4gICAgICBoZWFkZXJzLnB1c2goJ2NvbnRlbnQtdHlwZScsIGNvbnRlbnRUeXBlKVxuICAgIH1cbiAgICBib2R5ID0gYm9keVN0cmVhbS5zdHJlYW1cbiAgICBjb250ZW50TGVuZ3RoID0gYm9keVN0cmVhbS5sZW5ndGhcbiAgfSBlbHNlIGlmICh1dGlsLmlzQmxvYkxpa2UoYm9keSkgJiYgcmVxdWVzdC5jb250ZW50VHlwZSA9PSBudWxsICYmIGJvZHkudHlwZSkge1xuICAgIGhlYWRlcnMucHVzaCgnY29udGVudC10eXBlJywgYm9keS50eXBlKVxuICB9XG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRyeSB0byByZWFkIEVPRiBpbiBvcmRlciB0byBnZXQgbGVuZ3RoLlxuICAgIGJvZHkucmVhZCgwKVxuICB9XG5cbiAgY29uc3QgYm9keUxlbmd0aCA9IHV0aWwuYm9keUxlbmd0aChib2R5KVxuXG4gIGNvbnRlbnRMZW5ndGggPSBib2R5TGVuZ3RoID8/IGNvbnRlbnRMZW5ndGhcblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgIGNvbnRlbnRMZW5ndGggPSByZXF1ZXN0LmNvbnRlbnRMZW5ndGhcbiAgfVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09PSAwICYmICFleHBlY3RzUGF5bG9hZCkge1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIE5PVCBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkIHdoZW5cbiAgICAvLyB0aGUgcmVxdWVzdCBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYSBwYXlsb2FkIGJvZHkgYW5kIHRoZSBtZXRob2RcbiAgICAvLyBzZW1hbnRpY3MgZG8gbm90IGFudGljaXBhdGUgc3VjaCBhIGJvZHkuXG5cbiAgICBjb250ZW50TGVuZ3RoID0gbnVsbFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwNDZcbiAgLy8gQSB1c2VyIGFnZW50IG1heSBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIHdpdGggMCB2YWx1ZSwgdGhpcyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgaWYgKHNob3VsZFNlbmRDb250ZW50TGVuZ3RoKG1ldGhvZCkgJiYgY29udGVudExlbmd0aCA+IDAgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBudWxsICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gY29udGVudExlbmd0aCkge1xuICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICB9XG5cbiAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgY29uc3QgYWJvcnQgPSAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCB8fCByZXF1ZXN0LmNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcblxuICAgIHV0aWwuZGVzdHJveShib2R5KVxuICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ2Fib3J0ZWQnKSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVxdWVzdC5vbkNvbm5lY3QoYWJvcnQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21jb2xsaW5hL3VuZGljaS9pc3N1ZXMvMjU4XG4gICAgLy8gQ2xvc2UgYWZ0ZXIgYSBIRUFEIHJlcXVlc3QgdG8gaW50ZXJvcCB3aXRoIG1pc2JlaGF2aW5nIHNlcnZlcnNcbiAgICAvLyB0aGF0IG1heSBzZW5kIGEgYm9keSBpbiB0aGUgcmVzcG9uc2UuXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgLy8gT24gQ09OTkVDVCBvciB1cGdyYWRlLCBibG9jayBwaXBlbGluZSBmcm9tIGRpc3BhdGNoaW5nIGZ1cnRoZXJcbiAgICAvLyByZXF1ZXN0cyBvbiB0aGlzIGNvbm5lY3Rpb24uXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmIChyZXNldCAhPSBudWxsKSB7XG4gICAgc29ja2V0W2tSZXNldF0gPSByZXNldFxuICB9XG5cbiAgaWYgKGNsaWVudFtrTWF4UmVxdWVzdHNdICYmIHNvY2tldFtrQ291bnRlcl0rKyA+PSBjbGllbnRba01heFJlcXVlc3RzXSkge1xuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGJsb2NraW5nKSB7XG4gICAgc29ja2V0W2tCbG9ja2luZ10gPSB0cnVlXG4gIH1cblxuICBsZXQgaGVhZGVyID0gYCR7bWV0aG9kfSAke3BhdGh9IEhUVFAvMS4xXFxyXFxuYFxuXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBoZWFkZXIgKz0gYGhvc3Q6ICR7aG9zdH1cXHJcXG5gXG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9IGNsaWVudFtrSG9zdEhlYWRlcl1cbiAgfVxuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgaGVhZGVyICs9IGBjb25uZWN0aW9uOiB1cGdyYWRlXFxyXFxudXBncmFkZTogJHt1cGdyYWRlfVxcclxcbmBcbiAgfSBlbHNlIGlmIChjbGllbnRba1BpcGVsaW5pbmddICYmICFzb2NrZXRba1Jlc2V0XSkge1xuICAgIGhlYWRlciArPSAnY29ubmVjdGlvbjoga2VlcC1hbGl2ZVxcclxcbidcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIgKz0gJ2Nvbm5lY3Rpb246IGNsb3NlXFxyXFxuJ1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNbbiArIDBdXG4gICAgICBjb25zdCB2YWwgPSBoZWFkZXJzW24gKyAxXVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGVhZGVyICs9IGAke2tleX06ICR7dmFsW2ldfVxcclxcbmBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyICs9IGAke2tleX06ICR7dmFsfVxcclxcbmBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY2hhbm5lbHMuc2VuZEhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5zZW5kSGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdCwgaGVhZGVyczogaGVhZGVyLCBzb2NrZXQgfSlcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBhc3NlcnRpb24gKi9cbiAgaWYgKCFib2R5IHx8IGJvZHlMZW5ndGggPT09IDApIHtcbiAgICB3cml0ZUJ1ZmZlcihhYm9ydCwgbnVsbCwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgIHdyaXRlQnVmZmVyKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIGlmICh1dGlsLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3cml0ZUl0ZXJhYmxlKGFib3J0LCBib2R5LnN0cmVhbSgpLCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVCbG9iKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgICB9XG4gIH0gZWxzZSBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgIHdyaXRlU3RyZWFtKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIGlmICh1dGlsLmlzSXRlcmFibGUoYm9keSkpIHtcbiAgICB3cml0ZUl0ZXJhYmxlKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmVhbSAoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICBsZXQgZmluaXNoZWQgPSBmYWxzZVxuXG4gIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KVxuXG4gIGNvbnN0IG9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSAmJiB0aGlzLnBhdXNlKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChib2R5LnJlc3VtZSkge1xuICAgICAgYm9keS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuICBjb25zdCBvbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vICdjbG9zZScgbWlnaHQgYmUgZW1pdHRlZCAqYmVmb3JlKiAnZXJyb3InIGZvclxuICAgIC8vIGJyb2tlbiBzdHJlYW1zLiBXYWl0IGEgdGljayB0byBhdm9pZCB0aGlzIGNhc2UuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gSXQncyBvbmx5IHNhZmUgdG8gcmVtb3ZlICdlcnJvcicgbGlzdGVuZXIgYWZ0ZXJcbiAgICAgIC8vICdjbG9zZScuXG4gICAgICBib2R5LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgfSlcblxuICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IG9uRmluaXNoZWQoZXJyKSlcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25GaW5pc2hlZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZpbmlzaGVkID0gdHJ1ZVxuXG4gICAgYXNzZXJ0KHNvY2tldC5kZXN0cm95ZWQgfHwgKHNvY2tldFtrV3JpdGluZ10gJiYgY2xpZW50W2tSdW5uaW5nXSA8PSAxKSlcblxuICAgIHNvY2tldFxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgICAgLm9mZignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gICAgYm9keVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG5cbiAgICBpZiAoIWVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd3JpdGVyLmVuZCgpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBlcnIgPSBlclxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlci5kZXN0cm95KGVycilcblxuICAgIGlmIChlcnIgJiYgKGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJyB8fCBlcnIubWVzc2FnZSAhPT0gJ3Jlc2V0JykpIHtcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuZGVzdHJveShib2R5KVxuICAgIH1cbiAgfVxuXG4gIGJvZHlcbiAgICAub24oJ2RhdGEnLCBvbkRhdGEpXG4gICAgLm9uKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgIC5vbignZXJyb3InLCBvbkZpbmlzaGVkKVxuICAgIC5vbignY2xvc2UnLCBvbkNsb3NlKVxuXG4gIGlmIChib2R5LnJlc3VtZSkge1xuICAgIGJvZHkucmVzdW1lKClcbiAgfVxuXG4gIHNvY2tldFxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuICAgIC5vbignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gIGlmIChib2R5LmVycm9yRW1pdHRlZCA/PyBib2R5LmVycm9yZWQpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gb25GaW5pc2hlZChib2R5LmVycm9yZWQpKVxuICB9IGVsc2UgaWYgKGJvZHkuZW5kRW1pdHRlZCA/PyBib2R5LnJlYWRhYmxlRW5kZWQpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gb25GaW5pc2hlZChudWxsKSlcbiAgfVxuXG4gIGlmIChib2R5LmNsb3NlRW1pdHRlZCA/PyBib2R5LmNsb3NlZCkge1xuICAgIHNldEltbWVkaWF0ZShvbkNsb3NlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBudWxsLCAnbm8gYm9keSBtdXN0IG5vdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LmJ5dGVMZW5ndGgsICdidWZmZXIgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gICAgICBzb2NrZXQuY29yaygpXG4gICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICBzb2NrZXQud3JpdGUoYm9keSlcbiAgICAgIHNvY2tldC51bmNvcmsoKVxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGJvZHkpXG5cbiAgICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSlcblxuICAgIHNvY2tldC5jb3JrKClcbiAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgc29ja2V0LndyaXRlKGJ1ZmZlcilcbiAgICBzb2NrZXQudW5jb3JrKClcblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChidWZmZXIpXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUl0ZXJhYmxlIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIHNvY2tldFxuICAgIC5vbignY2xvc2UnLCBvbkRyYWluKVxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuXG4gIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KVxuICB0cnkge1xuICAgIC8vIEl0J3MgdXAgdG8gdGhlIHVzZXIgdG8gc29tZWhvdyBhYm9ydCB0aGUgYXN5bmMgaXRlcmFibGUuXG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICAgIH1cblxuICAgICAgaWYgKCF3cml0ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLmVuZCgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHdyaXRlci5kZXN0cm95KGVycilcbiAgfSBmaW5hbGx5IHtcbiAgICBzb2NrZXRcbiAgICAgIC5vZmYoJ2Nsb3NlJywgb25EcmFpbilcbiAgICAgIC5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgfVxufVxuXG5jbGFzcyBBc3luY1dyaXRlciB7XG4gIGNvbnN0cnVjdG9yICh7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aFxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwXG4gICAgdGhpcy5leHBlY3RzUGF5bG9hZCA9IGV4cGVjdHNQYXlsb2FkXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSB0cnVlXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gV2Ugc2hvdWxkIGRlZmVyIHdyaXRpbmcgY2h1bmtzLlxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiArIGxlbiA+IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICB9XG5cbiAgICBzb2NrZXQuY29yaygpXG5cbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfXRyYW5zZmVyLWVuY29kaW5nOiBjaHVua2VkXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIHNvY2tldC53cml0ZShgXFxyXFxuJHtsZW4udG9TdHJpbmcoMTYpfVxcclxcbmAsICdsYXRpbjEnKVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGxlblxuXG4gICAgY29uc3QgcmV0ID0gc29ja2V0LndyaXRlKGNodW5rKVxuXG4gICAgc29ja2V0LnVuY29yaygpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0ICYmIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBlbmQgKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciwgcmVxdWVzdCB9ID0gdGhpc1xuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgaWYgKGV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAgICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBzZW5kIGEgQ29udGVudC1MZW5ndGggaW4gYSByZXF1ZXN0IG1lc3NhZ2Ugd2hlblxuICAgICAgICAvLyBubyBUcmFuc2Zlci1FbmNvZGluZyBpcyBzZW50IGFuZCB0aGUgcmVxdWVzdCBtZXRob2QgZGVmaW5lcyBhIG1lYW5pbmdcbiAgICAgICAgLy8gZm9yIGFuIGVuY2xvc2VkIHBheWxvYWQgYm9keS5cblxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAwXFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgc29ja2V0LndyaXRlKCdcXHJcXG4wXFxyXFxuXFxyXFxuJywgJ2xhdGluMScpXG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50LCBhYm9ydCB9ID0gdGhpc1xuXG4gICAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA8PSAxLCAncGlwZWxpbmUgc2hvdWxkIG9ubHkgY29udGFpbiB0aGlzIHJlcXVlc3QnKVxuICAgICAgYWJvcnQoZXJyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3RIMVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJ1dGlsIiwiY2hhbm5lbHMiLCJ0aW1lcnMiLCJSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IiLCJSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIkhlYWRlcnNUaW1lb3V0RXJyb3IiLCJIZWFkZXJzT3ZlcmZsb3dFcnJvciIsIlNvY2tldEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiQm9keVRpbWVvdXRFcnJvciIsIkhUVFBQYXJzZXJFcnJvciIsIlJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IiLCJrVXJsIiwia1Jlc2V0Iiwia0NsaWVudCIsImtQYXJzZXIiLCJrQmxvY2tpbmciLCJrUnVubmluZyIsImtQZW5kaW5nIiwia1NpemUiLCJrV3JpdGluZyIsImtRdWV1ZSIsImtOb1JlZiIsImtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCIsImtIb3N0SGVhZGVyIiwia1BlbmRpbmdJZHgiLCJrUnVubmluZ0lkeCIsImtFcnJvciIsImtQaXBlbGluaW5nIiwia1NvY2tldCIsImtLZWVwQWxpdmVUaW1lb3V0VmFsdWUiLCJrTWF4SGVhZGVyc1NpemUiLCJrS2VlcEFsaXZlTWF4VGltZW91dCIsImtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwia0hlYWRlcnNUaW1lb3V0Iiwia0JvZHlUaW1lb3V0Iiwia1N0cmljdENvbnRlbnRMZW5ndGgiLCJrTWF4UmVxdWVzdHMiLCJrQ291bnRlciIsImtNYXhSZXNwb25zZVNpemUiLCJrT25FcnJvciIsImtSZXN1bWUiLCJrSFRUUENvbnRleHQiLCJjb25zdGFudHMiLCJFTVBUWV9CVUYiLCJCdWZmZXIiLCJhbGxvYyIsIkZhc3RCdWZmZXIiLCJTeW1ib2wiLCJzcGVjaWVzIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJleHRyYWN0Qm9keSIsImxhenlsbGh0dHAiLCJsbGh0dHBXYXNtRGF0YSIsInByb2Nlc3MiLCJlbnYiLCJKRVNUX1dPUktFUl9JRCIsInVuZGVmaW5lZCIsIm1vZCIsIldlYkFzc2VtYmx5IiwiY29tcGlsZSIsImUiLCJpbnN0YW50aWF0ZSIsIndhc21fb25fdXJsIiwicCIsImF0IiwibGVuIiwid2FzbV9vbl9zdGF0dXMiLCJzdHJpY3RFcXVhbCIsImN1cnJlbnRQYXJzZXIiLCJwdHIiLCJzdGFydCIsImN1cnJlbnRCdWZmZXJQdHIiLCJjdXJyZW50QnVmZmVyUmVmIiwiYnl0ZU9mZnNldCIsIm9uU3RhdHVzIiwiYnVmZmVyIiwid2FzbV9vbl9tZXNzYWdlX2JlZ2luIiwib25NZXNzYWdlQmVnaW4iLCJ3YXNtX29uX2hlYWRlcl9maWVsZCIsIm9uSGVhZGVyRmllbGQiLCJ3YXNtX29uX2hlYWRlcl92YWx1ZSIsIm9uSGVhZGVyVmFsdWUiLCJ3YXNtX29uX2hlYWRlcnNfY29tcGxldGUiLCJzdGF0dXNDb2RlIiwidXBncmFkZSIsInNob3VsZEtlZXBBbGl2ZSIsIm9uSGVhZGVyc0NvbXBsZXRlIiwiQm9vbGVhbiIsIndhc21fb25fYm9keSIsIm9uQm9keSIsIndhc21fb25fbWVzc2FnZV9jb21wbGV0ZSIsIm9uTWVzc2FnZUNvbXBsZXRlIiwibGxodHRwSW5zdGFuY2UiLCJsbGh0dHBQcm9taXNlIiwiY2F0Y2giLCJjdXJyZW50QnVmZmVyU2l6ZSIsIlRJTUVPVVRfSEVBREVSUyIsIlRJTUVPVVRfQk9EWSIsIlRJTUVPVVRfSURMRSIsIlBhcnNlciIsImNsaWVudCIsInNvY2tldCIsImV4cG9ydHMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImxsaHR0cCIsImxsaHR0cF9hbGxvYyIsIlRZUEUiLCJSRVNQT05TRSIsInRpbWVvdXQiLCJ0aW1lb3V0VmFsdWUiLCJ0aW1lb3V0VHlwZSIsInN0YXR1c1RleHQiLCJoZWFkZXJzIiwiaGVhZGVyc1NpemUiLCJoZWFkZXJzTWF4U2l6ZSIsInBhdXNlZCIsInJlc3VtZSIsImJpbmQiLCJieXRlc1JlYWQiLCJrZWVwQWxpdmUiLCJjb250ZW50TGVuZ3RoIiwiY29ubmVjdGlvbiIsIm1heFJlc3BvbnNlU2l6ZSIsInNldFRpbWVvdXQiLCJ2YWx1ZSIsInR5cGUiLCJjbGVhclRpbWVvdXQiLCJvblBhcnNlclRpbWVvdXQiLCJ1bnJlZiIsInJlZnJlc2giLCJkZXN0cm95ZWQiLCJsbGh0dHBfcmVzdW1lIiwiZXhlY3V0ZSIsInJlYWQiLCJyZWFkTW9yZSIsImNodW5rIiwiZGF0YSIsImxlbmd0aCIsImZyZWUiLCJNYXRoIiwiY2VpbCIsIm1hbGxvYyIsIlVpbnQ4QXJyYXkiLCJtZW1vcnkiLCJzZXQiLCJyZXQiLCJsbGh0dHBfZXhlY3V0ZSIsImVyciIsIm9mZnNldCIsImxsaHR0cF9nZXRfZXJyb3JfcG9zIiwiRVJST1IiLCJQQVVTRURfVVBHUkFERSIsIm9uVXBncmFkZSIsInNsaWNlIiwiUEFVU0VEIiwidW5zaGlmdCIsIk9LIiwibGxodHRwX2dldF9lcnJvcl9yZWFzb24iLCJtZXNzYWdlIiwiaW5kZXhPZiIsImZyb20iLCJ0b1N0cmluZyIsImRlc3Ryb3kiLCJsbGh0dHBfZnJlZSIsImJ1ZiIsInJlcXVlc3QiLCJvblJlc3BvbnNlU3RhcnRlZCIsInB1c2giLCJjb25jYXQiLCJ0cmFja0hlYWRlciIsImtleSIsImhlYWRlck5hbWUiLCJidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lIiwiaGVhZCIsIm1ldGhvZCIsImVtaXQiLCJnZXRTb2NrZXRJbmZvIiwidG9Mb3dlckNhc2UiLCJib2R5VGltZW91dCIsImtlZXBBbGl2ZVRpbWVvdXQiLCJwYXJzZUtlZXBBbGl2ZVRpbWVvdXQiLCJtaW4iLCJwYXVzZSIsIm9uSGVhZGVycyIsImFib3J0ZWQiLCJvbkRhdGEiLCJwYXJzZUludCIsIm9uQ29tcGxldGUiLCJzZXRJbW1lZGlhdGUiLCJwYXJzZXIiLCJ3cml0YWJsZU5lZWREcmFpbiIsImNvbm5lY3RIMSIsImNvZGUiLCJyZXF1ZXN0cyIsInNwbGljZSIsImkiLCJlcnJvclJlcXVlc3QiLCJjbG9zZWQiLCJvbiIsInZlcnNpb24iLCJkZWZhdWx0UGlwZWxpbmluZyIsIndyaXRlIiwiYXJncyIsIndyaXRlSDEiLCJyZXN1bWVIMSIsImNhbGxiYWNrIiwicXVldWVNaWNyb3Rhc2siLCJidXN5IiwiaWRlbXBvdGVudCIsImJvZHlMZW5ndGgiLCJib2R5IiwiaXNTdHJlYW0iLCJpc0FzeW5jSXRlcmFibGUiLCJpc0Zvcm1EYXRhTGlrZSIsInJlZiIsImhlYWRlcnNUaW1lb3V0Iiwic2hvdWxkU2VuZENvbnRlbnRMZW5ndGgiLCJwYXRoIiwiaG9zdCIsImJsb2NraW5nIiwicmVzZXQiLCJleHBlY3RzUGF5bG9hZCIsImJvZHlTdHJlYW0iLCJjb250ZW50VHlwZSIsInN0cmVhbSIsImlzQmxvYkxpa2UiLCJlbWl0V2FybmluZyIsImFib3J0IiwiY29tcGxldGVkIiwib25Db25uZWN0IiwiaGVhZGVyIiwiQXJyYXkiLCJpc0FycmF5IiwibiIsInZhbCIsInNlbmRIZWFkZXJzIiwiaGFzU3Vic2NyaWJlcnMiLCJwdWJsaXNoIiwid3JpdGVCdWZmZXIiLCJpc0J1ZmZlciIsIndyaXRlSXRlcmFibGUiLCJ3cml0ZUJsb2IiLCJ3cml0ZVN0cmVhbSIsImlzSXRlcmFibGUiLCJmaW5pc2hlZCIsIndyaXRlciIsIkFzeW5jV3JpdGVyIiwib25EcmFpbiIsIm9uQ2xvc2UiLCJyZW1vdmVMaXN0ZW5lciIsIm9uRmluaXNoZWQiLCJvZmYiLCJlbmQiLCJlciIsImVycm9yRW1pdHRlZCIsImVycm9yZWQiLCJlbmRFbWl0dGVkIiwicmVhZGFibGVFbmRlZCIsImNsb3NlRW1pdHRlZCIsImJ5dGVMZW5ndGgiLCJjb3JrIiwidW5jb3JrIiwib25Cb2R5U2VudCIsIm9uUmVxdWVzdFNlbnQiLCJzaXplIiwiYXJyYXlCdWZmZXIiLCJjYiIsIndhaXRGb3JEcmFpbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYnl0ZXNXcml0dGVuIiwibW9kdWxlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h2.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { RequestContentLengthMismatchError, RequestAbortedError, SocketError, InformationalError } = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { kUrl, kReset, kClient, kRunning, kPending, kQueue, kPendingIdx, kRunningIdx, kError, kSocket, kStrictContentLength, kOnError, kMaxConcurrentStreams, kHTTP2Session, kResume } = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst kOpenStreams = Symbol('open streams');\n// Experimental\nlet h2ExperimentalWarned = false;\n/** @type {import('http2')} */ let http2;\ntry {\n    http2 = __webpack_require__(/*! node:http2 */ \"node:http2\");\n} catch  {\n    // @ts-ignore\n    http2 = {\n        constants: {}\n    };\n}\nconst { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;\nfunction parseH2Headers(headers) {\n    const result = [];\n    for (const [name, value] of Object.entries(headers)){\n        // h2 may concat the header value by array\n        // e.g. Set-Cookie\n        if (Array.isArray(value)) {\n            for (const subvalue of value){\n                // we need to provide each header value of header name\n                // because the headers handler expect name-value pair\n                result.push(Buffer.from(name), Buffer.from(subvalue));\n            }\n        } else {\n            result.push(Buffer.from(name), Buffer.from(value));\n        }\n    }\n    return result;\n}\nasync function connectH2(client, socket) {\n    client[kSocket] = socket;\n    if (!h2ExperimentalWarned) {\n        h2ExperimentalWarned = true;\n        process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n            code: 'UNDICI-H2'\n        });\n    }\n    const session = http2.connect(client[kUrl], {\n        createConnection: ()=>socket,\n        peerMaxConcurrentStreams: client[kMaxConcurrentStreams]\n    });\n    session[kOpenStreams] = 0;\n    session[kClient] = client;\n    session[kSocket] = socket;\n    util.addListener(session, 'error', onHttp2SessionError);\n    util.addListener(session, 'frameError', onHttp2FrameError);\n    util.addListener(session, 'end', onHttp2SessionEnd);\n    util.addListener(session, 'goaway', onHTTP2GoAway);\n    util.addListener(session, 'close', function() {\n        const { [kClient]: client } = this;\n        const { [kSocket]: socket } = client;\n        const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket));\n        client[kHTTP2Session] = null;\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            // Fail entire queue.\n            const requests = client[kQueue].splice(client[kRunningIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                util.errorRequest(client, request, err);\n            }\n        }\n    });\n    session.unref();\n    client[kHTTP2Session] = session;\n    socket[kHTTP2Session] = session;\n    util.addListener(socket, 'error', function(err) {\n        assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n        this[kError] = err;\n        this[kClient][kOnError](err);\n    });\n    util.addListener(socket, 'end', function() {\n        util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n    });\n    util.addListener(socket, 'close', function() {\n        const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n        client[kSocket] = null;\n        if (this[kHTTP2Session] != null) {\n            this[kHTTP2Session].destroy(err);\n        }\n        client[kPendingIdx] = client[kRunningIdx];\n        assert(client[kRunning] === 0);\n        client.emit('disconnect', client[kUrl], [\n            client\n        ], err);\n        client[kResume]();\n    });\n    let closed = false;\n    socket.on('close', ()=>{\n        closed = true;\n    });\n    return {\n        version: 'h2',\n        defaultPipelining: Infinity,\n        write (...args) {\n            // TODO (fix): return\n            writeH2(client, ...args);\n        },\n        resume () {},\n        destroy (err, callback) {\n            if (closed) {\n                queueMicrotask(callback);\n            } else {\n                // Destroying the socket will trigger the session close\n                socket.destroy(err).on('close', callback);\n            }\n        },\n        get destroyed () {\n            return socket.destroyed;\n        },\n        busy () {\n            return false;\n        }\n    };\n}\nfunction onHttp2SessionError(err) {\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n    this[kSocket][kError] = err;\n    this[kClient][kOnError](err);\n}\nfunction onHttp2FrameError(type, code, id) {\n    if (id === 0) {\n        const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n        this[kSocket][kError] = err;\n        this[kClient][kOnError](err);\n    }\n}\nfunction onHttp2SessionEnd() {\n    const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]));\n    this.destroy(err);\n    util.destroy(this[kSocket], err);\n}\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n */ function onHTTP2GoAway(code) {\n    const err = new RequestAbortedError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`);\n    // We need to trigger the close cycle right away\n    // We need to destroy the session and the socket\n    // Requests should be failed with the error after the current one is handled\n    this[kSocket][kError] = err;\n    this[kClient][kOnError](err);\n    this.unref();\n    util.destroy(this[kSocket], err);\n}\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n    return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT';\n}\nfunction writeH2(client, request) {\n    const session = client[kHTTP2Session];\n    const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;\n    if (upgrade) {\n        util.errorRequest(client, request, new Error('Upgrade not supported for H2'));\n        return false;\n    }\n    if (request.aborted) {\n        return false;\n    }\n    const headers = {};\n    for(let n = 0; n < reqHeaders.length; n += 2){\n        const key = reqHeaders[n + 0];\n        const val = reqHeaders[n + 1];\n        if (Array.isArray(val)) {\n            for(let i = 0; i < val.length; i++){\n                if (headers[key]) {\n                    headers[key] += `,${val[i]}`;\n                } else {\n                    headers[key] = val[i];\n                }\n            }\n        } else {\n            headers[key] = val;\n        }\n    }\n    /** @type {import('node:http2').ClientHttp2Stream} */ let stream;\n    const { hostname, port } = client[kUrl];\n    headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`;\n    headers[HTTP2_HEADER_METHOD] = method;\n    const abort = (err)=>{\n        if (request.aborted || request.completed) {\n            return;\n        }\n        err = err || new RequestAbortedError();\n        util.errorRequest(client, request, err);\n        if (stream != null) {\n            util.destroy(stream, err);\n        }\n        // We do not destroy the socket as we can continue using the session\n        // the stream get's destroyed and the session remains to create new streams\n        util.destroy(body, err);\n    };\n    try {\n        // We are already connected, streams are pending.\n        // We can call on connect, and wait for abort\n        request.onConnect(abort);\n    } catch (err) {\n        util.errorRequest(client, request, err);\n    }\n    if (method === 'CONNECT') {\n        session.ref();\n        // We are already connected, streams are pending, first request\n        // will create a new stream. We trigger a request to create the stream and wait until\n        // `ready` event is triggered\n        // We disabled endStream to allow the user to write to the stream\n        stream = session.request(headers, {\n            endStream: false,\n            signal\n        });\n        if (stream.id && !stream.pending) {\n            request.onUpgrade(null, null, stream);\n            ++session[kOpenStreams];\n        } else {\n            stream.once('ready', ()=>{\n                request.onUpgrade(null, null, stream);\n                ++session[kOpenStreams];\n            });\n        }\n        stream.once('close', ()=>{\n            session[kOpenStreams] -= 1;\n            if (session[kOpenStreams] === 0) session.unref();\n        });\n        return true;\n    }\n    // https://tools.ietf.org/html/rfc7540#section-8.3\n    // :path and :scheme headers must be omitted when sending CONNECT\n    headers[HTTP2_HEADER_PATH] = path;\n    headers[HTTP2_HEADER_SCHEME] = 'https';\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n    if (body && typeof body.read === 'function') {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    let contentLength = util.bodyLength(body);\n    if (contentLength == null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 || !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            util.errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    if (contentLength != null) {\n        assert(body, 'no body must not have content length');\n        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;\n    }\n    session.ref();\n    const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null;\n    if (expectContinue) {\n        headers[HTTP2_HEADER_EXPECT] = '100-continue';\n        stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        stream.once('continue', writeBodyH2);\n    } else {\n        stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        writeBodyH2();\n    }\n    // Increment counter as we have new streams open\n    ++session[kOpenStreams];\n    stream.once('response', (headers)=>{\n        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;\n        request.onResponseStarted();\n        // Due to the stream nature, it is possible we face a race condition\n        // where the stream has been assigned, but the request has been aborted\n        // the request remains in-flight and headers hasn't been received yet\n        // for those scenarios, best effort is to destroy the stream immediately\n        // as there's no value to keep it open.\n        if (request.aborted) {\n            const err = new RequestAbortedError();\n            util.errorRequest(client, request, err);\n            util.destroy(stream, err);\n            return;\n        }\n        if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n            stream.pause();\n        }\n        stream.on('data', (chunk)=>{\n            if (request.onData(chunk) === false) {\n                stream.pause();\n            }\n        });\n    });\n    stream.once('end', ()=>{\n        // When state is null, it means we haven't consumed body and the stream still do not have\n        // a state.\n        // Present specially when using pipeline or stream\n        if (stream.state?.state == null || stream.state.state < 6) {\n            request.onComplete([]);\n            return;\n        }\n        // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n        // It does not have sense to continue working with the stream as we do not\n        // have yet RST_STREAM support on client-side\n        if (session[kOpenStreams] === 0) {\n            session.unref();\n        }\n        abort(new InformationalError('HTTP/2: stream half-closed (remote)'));\n    });\n    stream.once('close', ()=>{\n        session[kOpenStreams] -= 1;\n        if (session[kOpenStreams] === 0) {\n            session.unref();\n        }\n    });\n    stream.once('error', function(err) {\n        abort(err);\n    });\n    stream.once('frameError', (type, code)=>{\n        abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`));\n    });\n    // stream.on('aborted', () => {\n    //   // TODO(HTTP/2): Support aborted\n    // })\n    // stream.on('timeout', () => {\n    //   // TODO(HTTP/2): Support timeout\n    // })\n    // stream.on('push', headers => {\n    //   // TODO(HTTP/2): Support push\n    // })\n    // stream.on('trailers', headers => {\n    //   // TODO(HTTP/2): Support trailers\n    // })\n    return true;\n    function writeBodyH2() {\n        /* istanbul ignore else: assertion */ if (!body || contentLength === 0) {\n            writeBuffer(abort, stream, null, client, request, client[kSocket], contentLength, expectsPayload);\n        } else if (util.isBuffer(body)) {\n            writeBuffer(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n        } else if (util.isBlobLike(body)) {\n            if (typeof body.stream === 'function') {\n                writeIterable(abort, stream, body.stream(), client, request, client[kSocket], contentLength, expectsPayload);\n            } else {\n                writeBlob(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n            }\n        } else if (util.isStream(body)) {\n            writeStream(abort, client[kSocket], expectsPayload, stream, body, client, request, contentLength);\n        } else if (util.isIterable(body)) {\n            writeIterable(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n        } else {\n            assert(false);\n        }\n    }\n}\nfunction writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n    try {\n        if (body != null && util.isBuffer(body)) {\n            assert(contentLength === body.byteLength, 'buffer body must have content length');\n            h2stream.cork();\n            h2stream.write(body);\n            h2stream.uncork();\n            h2stream.end();\n            request.onBodySent(body);\n        }\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        request.onRequestSent();\n        client[kResume]();\n    } catch (error) {\n        abort(error);\n    }\n}\nfunction writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n    assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n    // For HTTP/2, is enough to pipe the stream\n    const pipe = pipeline(body, h2stream, (err)=>{\n        if (err) {\n            util.destroy(pipe, err);\n            abort(err);\n        } else {\n            util.removeAllListeners(pipe);\n            request.onRequestSent();\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n            client[kResume]();\n        }\n    });\n    util.addListener(pipe, 'data', onPipeData);\n    function onPipeData(chunk) {\n        request.onBodySent(chunk);\n    }\n}\nasync function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n    assert(contentLength === body.size, 'blob body must have content length');\n    try {\n        if (contentLength != null && contentLength !== body.size) {\n            throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        h2stream.cork();\n        h2stream.write(buffer);\n        h2stream.uncork();\n        h2stream.end();\n        request.onBodySent(buffer);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        client[kResume]();\n    } catch (err) {\n        abort(err);\n    }\n}\nasync function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n    assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n    let callback = null;\n    function onDrain() {\n        if (callback) {\n            const cb = callback;\n            callback = null;\n            cb();\n        }\n    }\n    const waitForDrain = ()=>new Promise((resolve, reject)=>{\n            assert(callback === null);\n            if (socket[kError]) {\n                reject(socket[kError]);\n            } else {\n                callback = resolve;\n            }\n        });\n    h2stream.on('close', onDrain).on('drain', onDrain);\n    try {\n        // It's up to the user to somehow abort the async iterable.\n        for await (const chunk of body){\n            if (socket[kError]) {\n                throw socket[kError];\n            }\n            const res = h2stream.write(chunk);\n            request.onBodySent(chunk);\n            if (!res) {\n                await waitForDrain();\n            }\n        }\n        h2stream.end();\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        client[kResume]();\n    } catch (err) {\n        abort(err);\n    } finally{\n        h2stream.off('close', onDrain).off('drain', onDrain);\n    }\n}\nmodule.exports = connectH2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3BDLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDLGdDQUFhO0FBQzFDLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDLHFFQUFpQjtBQUN0QyxNQUFNLEVBQ0pHLGlDQUFpQyxFQUNqQ0MsbUJBQW1CLEVBQ25CQyxXQUFXLEVBQ1hDLGtCQUFrQixFQUNuQixHQUFHTixtQkFBT0EsQ0FBQyx5RUFBbUI7QUFDL0IsTUFBTSxFQUNKTyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsTUFBTSxFQUNOQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsTUFBTSxFQUNOQyxPQUFPLEVBQ1BDLG9CQUFvQixFQUNwQkMsUUFBUSxFQUNSQyxxQkFBcUIsRUFDckJDLGFBQWEsRUFDYkMsT0FBTyxFQUNSLEdBQUdyQixtQkFBT0EsQ0FBQywyRUFBb0I7QUFFaEMsTUFBTXNCLGVBQWVDLE9BQU87QUFFNUIsZUFBZTtBQUNmLElBQUlDLHVCQUF1QjtBQUUzQiw0QkFBNEIsR0FDNUIsSUFBSUM7QUFDSixJQUFJO0lBQ0ZBLFFBQVF6QixtQkFBT0EsQ0FBQyw4QkFBWTtBQUM5QixFQUFFLE9BQU07SUFDTixhQUFhO0lBQ2J5QixRQUFRO1FBQUVDLFdBQVcsQ0FBQztJQUFFO0FBQzFCO0FBRUEsTUFBTSxFQUNKQSxXQUFXLEVBQ1RDLHNCQUFzQixFQUN0QkMsbUJBQW1CLEVBQ25CQyxpQkFBaUIsRUFDakJDLG1CQUFtQixFQUNuQkMsMkJBQTJCLEVBQzNCQyxtQkFBbUIsRUFDbkJDLG1CQUFtQixFQUNwQixFQUNGLEdBQUdSO0FBRUosU0FBU1MsZUFBZ0JDLE9BQU87SUFDOUIsTUFBTUMsU0FBUyxFQUFFO0lBRWpCLEtBQUss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QUUsQ0FBQyxTQUFTNkU7SUFFZixJQUFJO1FBQ0YsMkRBQTJEO1FBQzNELFdBQVcsTUFBTTFCLFNBQVNwQyxLQUFNO1lBQzlCLElBQUl6QyxNQUFNLENBQUNsQyxPQUFPLEVBQUU7Z0JBQ2xCLE1BQU1rQyxNQUFNLENBQUNsQyxPQUFPO1lBQ3RCO1lBRUEsTUFBTStJLE1BQU1wQixTQUFTM0QsS0FBSyxDQUFDK0M7WUFDM0J6RCxRQUFRMEUsVUFBVSxDQUFDakI7WUFDbkIsSUFBSSxDQUFDZ0MsS0FBSztnQkFDUixNQUFNSjtZQUNSO1FBQ0Y7UUFFQWhCLFNBQVNJLEdBQUc7UUFFWnpFLFFBQVEyRSxhQUFhO1FBRXJCLElBQUksQ0FBQy9CLGdCQUFnQjtZQUNuQmhFLE1BQU0sQ0FBQ3pDLE9BQU8sR0FBRztRQUNuQjtRQUVBd0MsTUFBTSxDQUFDM0IsUUFBUTtJQUNqQixFQUFFLE9BQU95QyxLQUFLO1FBQ1oyQyxNQUFNM0M7SUFDUixTQUFVO1FBQ1I0RSxTQUNHcUIsR0FBRyxDQUFDLFNBQVNQLFNBQ2JPLEdBQUcsQ0FBQyxTQUFTUDtJQUNsQjtBQUNGO0FBRUFRLE9BQU9DLE9BQU8sR0FBR2xIIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGNsaWVudC1oMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbC5qcycpXG5jb25zdCB7XG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgU29ja2V0RXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzLmpzJylcbmNvbnN0IHtcbiAga1VybCxcbiAga1Jlc2V0LFxuICBrQ2xpZW50LFxuICBrUnVubmluZyxcbiAga1BlbmRpbmcsXG4gIGtRdWV1ZSxcbiAga1BlbmRpbmdJZHgsXG4gIGtSdW5uaW5nSWR4LFxuICBrRXJyb3IsXG4gIGtTb2NrZXQsXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICBrT25FcnJvcixcbiAga01heENvbmN1cnJlbnRTdHJlYW1zLFxuICBrSFRUUDJTZXNzaW9uLFxuICBrUmVzdW1lXG59ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzLmpzJylcblxuY29uc3Qga09wZW5TdHJlYW1zID0gU3ltYm9sKCdvcGVuIHN0cmVhbXMnKVxuXG4vLyBFeHBlcmltZW50YWxcbmxldCBoMkV4cGVyaW1lbnRhbFdhcm5lZCA9IGZhbHNlXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdodHRwMicpfSAqL1xubGV0IGh0dHAyXG50cnkge1xuICBodHRwMiA9IHJlcXVpcmUoJ25vZGU6aHR0cDInKVxufSBjYXRjaCB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaHR0cDIgPSB7IGNvbnN0YW50czoge30gfVxufVxuXG5jb25zdCB7XG4gIGNvbnN0YW50czoge1xuICAgIEhUVFAyX0hFQURFUl9BVVRIT1JJVFksXG4gICAgSFRUUDJfSEVBREVSX01FVEhPRCxcbiAgICBIVFRQMl9IRUFERVJfUEFUSCxcbiAgICBIVFRQMl9IRUFERVJfU0NIRU1FLFxuICAgIEhUVFAyX0hFQURFUl9DT05URU5UX0xFTkdUSCxcbiAgICBIVFRQMl9IRUFERVJfRVhQRUNULFxuICAgIEhUVFAyX0hFQURFUl9TVEFUVVNcbiAgfVxufSA9IGh0dHAyXG5cbmZ1bmN0aW9uIHBhcnNlSDJIZWFkZXJzIChoZWFkZXJzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdXG5cbiAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgLy8gaDIgbWF5IGNvbmNhdCB0aGUgaGVhZGVyIHZhbHVlIGJ5IGFycmF5XG4gICAgLy8gZS5nLiBTZXQtQ29va2llXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IHN1YnZhbHVlIG9mIHZhbHVlKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcHJvdmlkZSBlYWNoIGhlYWRlciB2YWx1ZSBvZiBoZWFkZXIgbmFtZVxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBoZWFkZXJzIGhhbmRsZXIgZXhwZWN0IG5hbWUtdmFsdWUgcGFpclxuICAgICAgICByZXN1bHQucHVzaChCdWZmZXIuZnJvbShuYW1lKSwgQnVmZmVyLmZyb20oc3VidmFsdWUpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChCdWZmZXIuZnJvbShuYW1lKSwgQnVmZmVyLmZyb20odmFsdWUpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdEgyIChjbGllbnQsIHNvY2tldCkge1xuICBjbGllbnRba1NvY2tldF0gPSBzb2NrZXRcblxuICBpZiAoIWgyRXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgaDJFeHBlcmltZW50YWxXYXJuZWQgPSB0cnVlXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZygnSDIgc3VwcG9ydCBpcyBleHBlcmltZW50YWwsIGV4cGVjdCB0aGVtIHRvIGNoYW5nZSBhdCBhbnkgdGltZS4nLCB7XG4gICAgICBjb2RlOiAnVU5ESUNJLUgyJ1xuICAgIH0pXG4gIH1cblxuICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChjbGllbnRba1VybF0sIHtcbiAgICBjcmVhdGVDb25uZWN0aW9uOiAoKSA9PiBzb2NrZXQsXG4gICAgcGVlck1heENvbmN1cnJlbnRTdHJlYW1zOiBjbGllbnRba01heENvbmN1cnJlbnRTdHJlYW1zXVxuICB9KVxuXG4gIHNlc3Npb25ba09wZW5TdHJlYW1zXSA9IDBcbiAgc2Vzc2lvbltrQ2xpZW50XSA9IGNsaWVudFxuICBzZXNzaW9uW2tTb2NrZXRdID0gc29ja2V0XG5cbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnZXJyb3InLCBvbkh0dHAyU2Vzc2lvbkVycm9yKVxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdmcmFtZUVycm9yJywgb25IdHRwMkZyYW1lRXJyb3IpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2VuZCcsIG9uSHR0cDJTZXNzaW9uRW5kKVxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdnb2F3YXknLCBvbkhUVFAyR29Bd2F5KVxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB7IFtrQ2xpZW50XTogY2xpZW50IH0gPSB0aGlzXG4gICAgY29uc3QgeyBba1NvY2tldF06IHNvY2tldCB9ID0gY2xpZW50XG5cbiAgICBjb25zdCBlcnIgPSB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gfHwgdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcignY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpXG5cbiAgICBjbGllbnRba0hUVFAyU2Vzc2lvbl0gPSBudWxsXG5cbiAgICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApXG5cbiAgICAgIC8vIEZhaWwgZW50aXJlIHF1ZXVlLlxuICAgICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBzZXNzaW9uLnVucmVmKClcblxuICBjbGllbnRba0hUVFAyU2Vzc2lvbl0gPSBzZXNzaW9uXG4gIHNvY2tldFtrSFRUUDJTZXNzaW9uXSA9IHNlc3Npb25cblxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIGFzc2VydChlcnIuY29kZSAhPT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKVxuXG4gICAgdGhpc1trRXJyb3JdID0gZXJyXG5cbiAgICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG4gIH0pXG5cbiAgdXRpbC5hZGRMaXN0ZW5lcihzb2NrZXQsICdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdXRpbC5kZXN0cm95KHRoaXMsIG5ldyBTb2NrZXRFcnJvcignb3RoZXIgc2lkZSBjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpKVxuICB9KVxuXG4gIHV0aWwuYWRkTGlzdGVuZXIoc29ja2V0LCAnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZXJyID0gdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcignY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXMpKVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuXG4gICAgaWYgKHRoaXNba0hUVFAyU2Vzc2lvbl0gIT0gbnVsbCkge1xuICAgICAgdGhpc1trSFRUUDJTZXNzaW9uXS5kZXN0cm95KGVycilcbiAgICB9XG5cbiAgICBjbGllbnRba1BlbmRpbmdJZHhdID0gY2xpZW50W2tSdW5uaW5nSWR4XVxuXG4gICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG5cbiAgICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0pXG5cbiAgbGV0IGNsb3NlZCA9IGZhbHNlXG4gIHNvY2tldC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgY2xvc2VkID0gdHJ1ZVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogJ2gyJyxcbiAgICBkZWZhdWx0UGlwZWxpbmluZzogSW5maW5pdHksXG4gICAgd3JpdGUgKC4uLmFyZ3MpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IHJldHVyblxuICAgICAgd3JpdGVIMihjbGllbnQsIC4uLmFyZ3MpXG4gICAgfSxcbiAgICByZXN1bWUgKCkge1xuXG4gICAgfSxcbiAgICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVzdHJveWluZyB0aGUgc29ja2V0IHdpbGwgdHJpZ2dlciB0aGUgc2Vzc2lvbiBjbG9zZVxuICAgICAgICBzb2NrZXQuZGVzdHJveShlcnIpLm9uKCdjbG9zZScsIGNhbGxiYWNrKVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgICByZXR1cm4gc29ja2V0LmRlc3Ryb3llZFxuICAgIH0sXG4gICAgYnVzeSAoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FcnJvciAoZXJyKSB7XG4gIGFzc2VydChlcnIuY29kZSAhPT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKVxuXG4gIHRoaXNba1NvY2tldF1ba0Vycm9yXSA9IGVyclxuICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJGcmFtZUVycm9yICh0eXBlLCBjb2RlLCBpZCkge1xuICBpZiAoaWQgPT09IDApIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgSW5mb3JtYXRpb25hbEVycm9yKGBIVFRQLzI6IFwiZnJhbWVFcnJvclwiIHJlY2VpdmVkIC0gdHlwZSAke3R5cGV9LCBjb2RlICR7Y29kZX1gKVxuICAgIHRoaXNba1NvY2tldF1ba0Vycm9yXSA9IGVyclxuICAgIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU2Vzc2lvbkVuZCAoKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBTb2NrZXRFcnJvcignb3RoZXIgc2lkZSBjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpc1trU29ja2V0XSkpXG4gIHRoaXMuZGVzdHJveShlcnIpXG4gIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLCBlcnIpXG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgcm9vdCBjYXVzZSBvZiAjMzAxMVxuICogV2UgbmVlZCB0byBoYW5kbGUgR09BV0FZIGZyYW1lcyBwcm9wZXJseSwgYW5kIHRyaWdnZXIgdGhlIHNlc3Npb24gY2xvc2VcbiAqIGFsb25nIHdpdGggdGhlIHNvY2tldCByaWdodCBhd2F5XG4gKi9cbmZ1bmN0aW9uIG9uSFRUUDJHb0F3YXkgKGNvZGUpIHtcbiAgY29uc3QgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoYEhUVFAvMjogXCJHT0FXQVlcIiBmcmFtZSByZWNlaXZlZCB3aXRoIGNvZGUgJHtjb2RlfWApXG5cbiAgLy8gV2UgbmVlZCB0byB0cmlnZ2VyIHRoZSBjbG9zZSBjeWNsZSByaWdodCBhd2F5XG4gIC8vIFdlIG5lZWQgdG8gZGVzdHJveSB0aGUgc2Vzc2lvbiBhbmQgdGhlIHNvY2tldFxuICAvLyBSZXF1ZXN0cyBzaG91bGQgYmUgZmFpbGVkIHdpdGggdGhlIGVycm9yIGFmdGVyIHRoZSBjdXJyZW50IG9uZSBpcyBoYW5kbGVkXG4gIHRoaXNba1NvY2tldF1ba0Vycm9yXSA9IGVyclxuICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG5cbiAgdGhpcy51bnJlZigpXG5cbiAgdXRpbC5kZXN0cm95KHRoaXNba1NvY2tldF0sIGVycilcbn1cblxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuZnVuY3Rpb24gc2hvdWxkU2VuZENvbnRlbnRMZW5ndGggKG1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kICE9PSAnR0VUJyAmJiBtZXRob2QgIT09ICdIRUFEJyAmJiBtZXRob2QgIT09ICdPUFRJT05TJyAmJiBtZXRob2QgIT09ICdUUkFDRScgJiYgbWV0aG9kICE9PSAnQ09OTkVDVCdcbn1cblxuZnVuY3Rpb24gd3JpdGVIMiAoY2xpZW50LCByZXF1ZXN0KSB7XG4gIGNvbnN0IHNlc3Npb24gPSBjbGllbnRba0hUVFAyU2Vzc2lvbl1cbiAgY29uc3QgeyBib2R5LCBtZXRob2QsIHBhdGgsIGhvc3QsIHVwZ3JhZGUsIGV4cGVjdENvbnRpbnVlLCBzaWduYWwsIGhlYWRlcnM6IHJlcUhlYWRlcnMgfSA9IHJlcXVlc3RcblxuICBpZiAodXBncmFkZSkge1xuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IEVycm9yKCdVcGdyYWRlIG5vdCBzdXBwb3J0ZWQgZm9yIEgyJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBoZWFkZXJzID0ge31cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCByZXFIZWFkZXJzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gcmVxSGVhZGVyc1tuICsgMF1cbiAgICBjb25zdCB2YWwgPSByZXFIZWFkZXJzW24gKyAxXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhlYWRlcnNba2V5XSkge1xuICAgICAgICAgIGhlYWRlcnNba2V5XSArPSBgLCR7dmFsW2ldfWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWxbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWxcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge2ltcG9ydCgnbm9kZTpodHRwMicpLkNsaWVudEh0dHAyU3RyZWFtfSAqL1xuICBsZXQgc3RyZWFtXG5cbiAgY29uc3QgeyBob3N0bmFtZSwgcG9ydCB9ID0gY2xpZW50W2tVcmxdXG5cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQVVUSE9SSVRZXSA9IGhvc3QgfHwgYCR7aG9zdG5hbWV9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfWBcbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9IG1ldGhvZFxuXG4gIGNvbnN0IGFib3J0ID0gKGVycikgPT4ge1xuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQgfHwgcmVxdWVzdC5jb21wbGV0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGVyciA9IGVyciB8fCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG5cbiAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcblxuICAgIGlmIChzdHJlYW0gIT0gbnVsbCkge1xuICAgICAgdXRpbC5kZXN0cm95KHN0cmVhbSwgZXJyKVxuICAgIH1cblxuICAgIC8vIFdlIGRvIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgYXMgd2UgY2FuIGNvbnRpbnVlIHVzaW5nIHRoZSBzZXNzaW9uXG4gICAgLy8gdGhlIHN0cmVhbSBnZXQncyBkZXN0cm95ZWQgYW5kIHRoZSBzZXNzaW9uIHJlbWFpbnMgdG8gY3JlYXRlIG5ldyBzdHJlYW1zXG4gICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gV2UgYXJlIGFscmVhZHkgY29ubmVjdGVkLCBzdHJlYW1zIGFyZSBwZW5kaW5nLlxuICAgIC8vIFdlIGNhbiBjYWxsIG9uIGNvbm5lY3QsIGFuZCB3YWl0IGZvciBhYm9ydFxuICAgIHJlcXVlc3Qub25Db25uZWN0KGFib3J0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgIHNlc3Npb24ucmVmKClcbiAgICAvLyBXZSBhcmUgYWxyZWFkeSBjb25uZWN0ZWQsIHN0cmVhbXMgYXJlIHBlbmRpbmcsIGZpcnN0IHJlcXVlc3RcbiAgICAvLyB3aWxsIGNyZWF0ZSBhIG5ldyBzdHJlYW0uIFdlIHRyaWdnZXIgYSByZXF1ZXN0IHRvIGNyZWF0ZSB0aGUgc3RyZWFtIGFuZCB3YWl0IHVudGlsXG4gICAgLy8gYHJlYWR5YCBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAvLyBXZSBkaXNhYmxlZCBlbmRTdHJlYW0gdG8gYWxsb3cgdGhlIHVzZXIgdG8gd3JpdGUgdG8gdGhlIHN0cmVhbVxuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogZmFsc2UsIHNpZ25hbCB9KVxuXG4gICAgaWYgKHN0cmVhbS5pZCAmJiAhc3RyZWFtLnBlbmRpbmcpIHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICsrc2Vzc2lvbltrT3BlblN0cmVhbXNdXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5vbmNlKCdyZWFkeScsICgpID0+IHtcbiAgICAgICAgcmVxdWVzdC5vblVwZ3JhZGUobnVsbCwgbnVsbCwgc3RyZWFtKVxuICAgICAgICArK3Nlc3Npb25ba09wZW5TdHJlYW1zXVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICBzZXNzaW9uW2tPcGVuU3RyZWFtc10gLT0gMVxuICAgICAgaWYgKHNlc3Npb25ba09wZW5TdHJlYW1zXSA9PT0gMCkgc2Vzc2lvbi51bnJlZigpXG4gICAgfSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzU0MCNzZWN0aW9uLTguM1xuICAvLyA6cGF0aCBhbmQgOnNjaGVtZSBoZWFkZXJzIG11c3QgYmUgb21pdHRlZCB3aGVuIHNlbmRpbmcgQ09OTkVDVFxuXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX1BBVEhdID0gcGF0aFxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9TQ0hFTUVdID0gJ2h0dHBzJ1xuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjFcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMlxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy41XG5cbiAgLy8gU2VuZGluZyBhIHBheWxvYWQgYm9keSBvbiBhIHJlcXVlc3QgdGhhdCBkb2VzIG5vdFxuICAvLyBleHBlY3QgaXQgY2FuIGNhdXNlIHVuZGVmaW5lZCBiZWhhdmlvciBvbiBzb21lXG4gIC8vIHNlcnZlcnMgYW5kIGNvcnJ1cHQgY29ubmVjdGlvbiBzdGF0ZS4gRG8gbm90XG4gIC8vIHJlLXVzZSB0aGUgY29ubmVjdGlvbiBmb3IgZnVydGhlciByZXF1ZXN0cy5cblxuICBjb25zdCBleHBlY3RzUGF5bG9hZCA9IChcbiAgICBtZXRob2QgPT09ICdQVVQnIHx8XG4gICAgbWV0aG9kID09PSAnUE9TVCcgfHxcbiAgICBtZXRob2QgPT09ICdQQVRDSCdcbiAgKVxuXG4gIGlmIChib2R5ICYmIHR5cGVvZiBib2R5LnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUcnkgdG8gcmVhZCBFT0YgaW4gb3JkZXIgdG8gZ2V0IGxlbmd0aC5cbiAgICBib2R5LnJlYWQoMClcbiAgfVxuXG4gIGxldCBjb250ZW50TGVuZ3RoID0gdXRpbC5ib2R5TGVuZ3RoKGJvZHkpXG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT0gbnVsbCkge1xuICAgIGNvbnRlbnRMZW5ndGggPSByZXF1ZXN0LmNvbnRlbnRMZW5ndGhcbiAgfVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09PSAwIHx8ICFleHBlY3RzUGF5bG9hZCkge1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIE5PVCBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkIHdoZW5cbiAgICAvLyB0aGUgcmVxdWVzdCBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYSBwYXlsb2FkIGJvZHkgYW5kIHRoZSBtZXRob2RcbiAgICAvLyBzZW1hbnRpY3MgZG8gbm90IGFudGljaXBhdGUgc3VjaCBhIGJvZHkuXG5cbiAgICBjb250ZW50TGVuZ3RoID0gbnVsbFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwNDZcbiAgLy8gQSB1c2VyIGFnZW50IG1heSBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIHdpdGggMCB2YWx1ZSwgdGhpcyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgaWYgKHNob3VsZFNlbmRDb250ZW50TGVuZ3RoKG1ldGhvZCkgJiYgY29udGVudExlbmd0aCA+IDAgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9IG51bGwgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KGJvZHksICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IGAke2NvbnRlbnRMZW5ndGh9YFxuICB9XG5cbiAgc2Vzc2lvbi5yZWYoKVxuXG4gIGNvbnN0IHNob3VsZEVuZFN0cmVhbSA9IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnSEVBRCcgfHwgYm9keSA9PT0gbnVsbFxuICBpZiAoZXhwZWN0Q29udGludWUpIHtcbiAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9FWFBFQ1RdID0gJzEwMC1jb250aW51ZSdcbiAgICBzdHJlYW0gPSBzZXNzaW9uLnJlcXVlc3QoaGVhZGVycywgeyBlbmRTdHJlYW06IHNob3VsZEVuZFN0cmVhbSwgc2lnbmFsIH0pXG5cbiAgICBzdHJlYW0ub25jZSgnY29udGludWUnLCB3cml0ZUJvZHlIMilcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBzZXNzaW9uLnJlcXVlc3QoaGVhZGVycywge1xuICAgICAgZW5kU3RyZWFtOiBzaG91bGRFbmRTdHJlYW0sXG4gICAgICBzaWduYWxcbiAgICB9KVxuICAgIHdyaXRlQm9keUgyKClcbiAgfVxuXG4gIC8vIEluY3JlbWVudCBjb3VudGVyIGFzIHdlIGhhdmUgbmV3IHN0cmVhbXMgb3BlblxuICArK3Nlc3Npb25ba09wZW5TdHJlYW1zXVxuXG4gIHN0cmVhbS5vbmNlKCdyZXNwb25zZScsIGhlYWRlcnMgPT4ge1xuICAgIGNvbnN0IHsgW0hUVFAyX0hFQURFUl9TVEFUVVNdOiBzdGF0dXNDb2RlLCAuLi5yZWFsSGVhZGVycyB9ID0gaGVhZGVyc1xuICAgIHJlcXVlc3Qub25SZXNwb25zZVN0YXJ0ZWQoKVxuXG4gICAgLy8gRHVlIHRvIHRoZSBzdHJlYW0gbmF0dXJlLCBpdCBpcyBwb3NzaWJsZSB3ZSBmYWNlIGEgcmFjZSBjb25kaXRpb25cbiAgICAvLyB3aGVyZSB0aGUgc3RyZWFtIGhhcyBiZWVuIGFzc2lnbmVkLCBidXQgdGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZFxuICAgIC8vIHRoZSByZXF1ZXN0IHJlbWFpbnMgaW4tZmxpZ2h0IGFuZCBoZWFkZXJzIGhhc24ndCBiZWVuIHJlY2VpdmVkIHlldFxuICAgIC8vIGZvciB0aG9zZSBzY2VuYXJpb3MsIGJlc3QgZWZmb3J0IGlzIHRvIGRlc3Ryb3kgdGhlIHN0cmVhbSBpbW1lZGlhdGVseVxuICAgIC8vIGFzIHRoZXJlJ3Mgbm8gdmFsdWUgdG8ga2VlcCBpdCBvcGVuLlxuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgICAgdXRpbC5kZXN0cm95KHN0cmVhbSwgZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3Qub25IZWFkZXJzKE51bWJlcihzdGF0dXNDb2RlKSwgcGFyc2VIMkhlYWRlcnMocmVhbEhlYWRlcnMpLCBzdHJlYW0ucmVzdW1lLmJpbmQoc3RyZWFtKSwgJycpID09PSBmYWxzZSkge1xuICAgICAgc3RyZWFtLnBhdXNlKClcbiAgICB9XG5cbiAgICBzdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0Lm9uRGF0YShjaHVuaykgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmVhbS5wYXVzZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZW5kJywgKCkgPT4ge1xuICAgIC8vIFdoZW4gc3RhdGUgaXMgbnVsbCwgaXQgbWVhbnMgd2UgaGF2ZW4ndCBjb25zdW1lZCBib2R5IGFuZCB0aGUgc3RyZWFtIHN0aWxsIGRvIG5vdCBoYXZlXG4gICAgLy8gYSBzdGF0ZS5cbiAgICAvLyBQcmVzZW50IHNwZWNpYWxseSB3aGVuIHVzaW5nIHBpcGVsaW5lIG9yIHN0cmVhbVxuICAgIGlmIChzdHJlYW0uc3RhdGU/LnN0YXRlID09IG51bGwgfHwgc3RyZWFtLnN0YXRlLnN0YXRlIDwgNikge1xuICAgICAgcmVxdWVzdC5vbkNvbXBsZXRlKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gU3RyZWFtIGlzIGNsb3NlZCBvciBoYWxmLWNsb3NlZC1yZW1vdGUgKDYpLCBkZWNyZW1lbnQgY291bnRlciBhbmQgY2xlYW51cFxuICAgIC8vIEl0IGRvZXMgbm90IGhhdmUgc2Vuc2UgdG8gY29udGludWUgd29ya2luZyB3aXRoIHRoZSBzdHJlYW0gYXMgd2UgZG8gbm90XG4gICAgLy8gaGF2ZSB5ZXQgUlNUX1NUUkVBTSBzdXBwb3J0IG9uIGNsaWVudC1zaWRlXG4gICAgaWYgKHNlc3Npb25ba09wZW5TdHJlYW1zXSA9PT0gMCkge1xuICAgICAgc2Vzc2lvbi51bnJlZigpXG4gICAgfVxuXG4gICAgYWJvcnQobmV3IEluZm9ybWF0aW9uYWxFcnJvcignSFRUUC8yOiBzdHJlYW0gaGFsZi1jbG9zZWQgKHJlbW90ZSknKSlcbiAgfSlcblxuICBzdHJlYW0ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgc2Vzc2lvbltrT3BlblN0cmVhbXNdIC09IDFcbiAgICBpZiAoc2Vzc2lvbltrT3BlblN0cmVhbXNdID09PSAwKSB7XG4gICAgICBzZXNzaW9uLnVucmVmKClcbiAgICB9XG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZnJhbWVFcnJvcicsICh0eXBlLCBjb2RlKSA9PiB7XG4gICAgYWJvcnQobmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHt0eXBlfSwgY29kZSAke2NvZGV9YCkpXG4gIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCdhYm9ydGVkJywgKCkgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCBhYm9ydGVkXG4gIC8vIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCB0aW1lb3V0XG4gIC8vIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCdwdXNoJywgaGVhZGVycyA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3J0IHB1c2hcbiAgLy8gfSlcblxuICAvLyBzdHJlYW0ub24oJ3RyYWlsZXJzJywgaGVhZGVycyA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3J0IHRyYWlsZXJzXG4gIC8vIH0pXG5cbiAgcmV0dXJuIHRydWVcblxuICBmdW5jdGlvbiB3cml0ZUJvZHlIMiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGFzc2VydGlvbiAqL1xuICAgIGlmICghYm9keSB8fCBjb250ZW50TGVuZ3RoID09PSAwKSB7XG4gICAgICB3cml0ZUJ1ZmZlcihcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICB3cml0ZUJ1ZmZlcihcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keS5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd3JpdGVJdGVyYWJsZShcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgYm9keS5zdHJlYW0oKSxcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUJsb2IoXG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgY2xpZW50LFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgd3JpdGVTdHJlYW0oXG4gICAgICAgIGFib3J0LFxuICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkLFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0l0ZXJhYmxlKGJvZHkpKSB7XG4gICAgICB3cml0ZUl0ZXJhYmxlKFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZUJ1ZmZlciAoYWJvcnQsIGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgZXhwZWN0c1BheWxvYWQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoYm9keSAhPSBudWxsICYmIHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LmJ5dGVMZW5ndGgsICdidWZmZXIgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgICAgaDJzdHJlYW0uY29yaygpXG4gICAgICBoMnN0cmVhbS53cml0ZShib2R5KVxuICAgICAgaDJzdHJlYW0udW5jb3JrKClcbiAgICAgIGgyc3RyZWFtLmVuZCgpXG5cbiAgICAgIHJlcXVlc3Qub25Cb2R5U2VudChib2R5KVxuICAgIH1cblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBhYm9ydChlcnJvcilcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmVhbSAoYWJvcnQsIHNvY2tldCwgZXhwZWN0c1BheWxvYWQsIGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ3N0cmVhbSBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWQnKVxuXG4gIC8vIEZvciBIVFRQLzIsIGlzIGVub3VnaCB0byBwaXBlIHRoZSBzdHJlYW1cbiAgY29uc3QgcGlwZSA9IHBpcGVsaW5lKFxuICAgIGJvZHksXG4gICAgaDJzdHJlYW0sXG4gICAgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB1dGlsLmRlc3Ryb3kocGlwZSwgZXJyKVxuICAgICAgICBhYm9ydChlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlsLnJlbW92ZUFsbExpc3RlbmVycyhwaXBlKVxuICAgICAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gICAgICB9XG4gICAgfVxuICApXG5cbiAgdXRpbC5hZGRMaXN0ZW5lcihwaXBlLCAnZGF0YScsIG9uUGlwZURhdGEpXG5cbiAgZnVuY3Rpb24gb25QaXBlRGF0YSAoY2h1bmspIHtcbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iIChhYm9ydCwgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBleHBlY3RzUGF5bG9hZCkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5zaXplLCAnYmxvYiBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgdHJ5IHtcbiAgICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsICYmIGNvbnRlbnRMZW5ndGggIT09IGJvZHkuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpXG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXdhaXQgYm9keS5hcnJheUJ1ZmZlcigpKVxuXG4gICAgaDJzdHJlYW0uY29yaygpXG4gICAgaDJzdHJlYW0ud3JpdGUoYnVmZmVyKVxuICAgIGgyc3RyZWFtLnVuY29yaygpXG4gICAgaDJzdHJlYW0uZW5kKClcblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChidWZmZXIpXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUl0ZXJhYmxlIChhYm9ydCwgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBleHBlY3RzUGF5bG9hZCkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCAhPT0gMCB8fCBjbGllbnRba1J1bm5pbmddID09PSAwLCAnaXRlcmF0b3IgYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICBsZXQgY2FsbGJhY2sgPSBudWxsXG4gIGZ1bmN0aW9uIG9uRHJhaW4gKCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uc3QgY2IgPSBjYWxsYmFja1xuICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICBjYigpXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgd2FpdEZvckRyYWluID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFzc2VydChjYWxsYmFjayA9PT0gbnVsbClcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgcmVqZWN0KHNvY2tldFtrRXJyb3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayA9IHJlc29sdmVcbiAgICB9XG4gIH0pXG5cbiAgaDJzdHJlYW1cbiAgICAub24oJ2Nsb3NlJywgb25EcmFpbilcbiAgICAub24oJ2RyYWluJywgb25EcmFpbilcblxuICB0cnkge1xuICAgIC8vIEl0J3MgdXAgdG8gdGhlIHVzZXIgdG8gc29tZWhvdyBhYm9ydCB0aGUgYXN5bmMgaXRlcmFibGUuXG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzID0gaDJzdHJlYW0ud3JpdGUoY2h1bmspXG4gICAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG4gICAgICBpZiAoIXJlcykge1xuICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKVxuICAgICAgfVxuICAgIH1cblxuICAgIGgyc3RyZWFtLmVuZCgpXG5cbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYWJvcnQoZXJyKVxuICB9IGZpbmFsbHkge1xuICAgIGgyc3RyZWFtXG4gICAgICAub2ZmKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAub2ZmKCdkcmFpbicsIG9uRHJhaW4pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0SDJcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwicGlwZWxpbmUiLCJ1dGlsIiwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIlNvY2tldEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwia1VybCIsImtSZXNldCIsImtDbGllbnQiLCJrUnVubmluZyIsImtQZW5kaW5nIiwia1F1ZXVlIiwia1BlbmRpbmdJZHgiLCJrUnVubmluZ0lkeCIsImtFcnJvciIsImtTb2NrZXQiLCJrU3RyaWN0Q29udGVudExlbmd0aCIsImtPbkVycm9yIiwia01heENvbmN1cnJlbnRTdHJlYW1zIiwia0hUVFAyU2Vzc2lvbiIsImtSZXN1bWUiLCJrT3BlblN0cmVhbXMiLCJTeW1ib2wiLCJoMkV4cGVyaW1lbnRhbFdhcm5lZCIsImh0dHAyIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX0FVVEhPUklUWSIsIkhUVFAyX0hFQURFUl9NRVRIT0QiLCJIVFRQMl9IRUFERVJfUEFUSCIsIkhUVFAyX0hFQURFUl9TQ0hFTUUiLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEgiLCJIVFRQMl9IRUFERVJfRVhQRUNUIiwiSFRUUDJfSEVBREVSX1NUQVRVUyIsInBhcnNlSDJIZWFkZXJzIiwiaGVhZGVycyIsInJlc3VsdCIsIm5hbWUiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJzdWJ2YWx1ZSIsInB1c2giLCJCdWZmZXIiLCJmcm9tIiwiY29ubmVjdEgyIiwiY2xpZW50Iiwic29ja2V0IiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiY29kZSIsInNlc3Npb24iLCJjb25uZWN0IiwiY3JlYXRlQ29ubmVjdGlvbiIsInBlZXJNYXhDb25jdXJyZW50U3RyZWFtcyIsImFkZExpc3RlbmVyIiwib25IdHRwMlNlc3Npb25FcnJvciIsIm9uSHR0cDJGcmFtZUVycm9yIiwib25IdHRwMlNlc3Npb25FbmQiLCJvbkhUVFAyR29Bd2F5IiwiZXJyIiwiZ2V0U29ja2V0SW5mbyIsImRlc3Ryb3llZCIsInJlcXVlc3RzIiwic3BsaWNlIiwiaSIsImxlbmd0aCIsInJlcXVlc3QiLCJlcnJvclJlcXVlc3QiLCJ1bnJlZiIsImRlc3Ryb3kiLCJlbWl0IiwiY2xvc2VkIiwib24iLCJ2ZXJzaW9uIiwiZGVmYXVsdFBpcGVsaW5pbmciLCJJbmZpbml0eSIsIndyaXRlIiwiYXJncyIsIndyaXRlSDIiLCJyZXN1bWUiLCJjYWxsYmFjayIsInF1ZXVlTWljcm90YXNrIiwiYnVzeSIsInR5cGUiLCJpZCIsInNob3VsZFNlbmRDb250ZW50TGVuZ3RoIiwibWV0aG9kIiwiYm9keSIsInBhdGgiLCJob3N0IiwidXBncmFkZSIsImV4cGVjdENvbnRpbnVlIiwic2lnbmFsIiwicmVxSGVhZGVycyIsIkVycm9yIiwiYWJvcnRlZCIsIm4iLCJrZXkiLCJ2YWwiLCJzdHJlYW0iLCJob3N0bmFtZSIsInBvcnQiLCJhYm9ydCIsImNvbXBsZXRlZCIsIm9uQ29ubmVjdCIsInJlZiIsImVuZFN0cmVhbSIsInBlbmRpbmciLCJvblVwZ3JhZGUiLCJvbmNlIiwiZXhwZWN0c1BheWxvYWQiLCJyZWFkIiwiY29udGVudExlbmd0aCIsImJvZHlMZW5ndGgiLCJzaG91bGRFbmRTdHJlYW0iLCJ3cml0ZUJvZHlIMiIsInN0YXR1c0NvZGUiLCJyZWFsSGVhZGVycyIsIm9uUmVzcG9uc2VTdGFydGVkIiwib25IZWFkZXJzIiwiTnVtYmVyIiwiYmluZCIsInBhdXNlIiwiY2h1bmsiLCJvbkRhdGEiLCJzdGF0ZSIsIm9uQ29tcGxldGUiLCJ3cml0ZUJ1ZmZlciIsImlzQnVmZmVyIiwiaXNCbG9iTGlrZSIsIndyaXRlSXRlcmFibGUiLCJ3cml0ZUJsb2IiLCJpc1N0cmVhbSIsIndyaXRlU3RyZWFtIiwiaXNJdGVyYWJsZSIsImgyc3RyZWFtIiwiYnl0ZUxlbmd0aCIsImNvcmsiLCJ1bmNvcmsiLCJlbmQiLCJvbkJvZHlTZW50Iiwib25SZXF1ZXN0U2VudCIsImVycm9yIiwicGlwZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIm9uUGlwZURhdGEiLCJzaXplIiwiYnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJvbkRyYWluIiwiY2IiLCJ3YWl0Rm9yRHJhaW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlcyIsIm9mZiIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// @ts-check\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst net = __webpack_require__(/*! node:net */ \"node:net\");\nconst http = __webpack_require__(/*! node:http */ \"node:http\");\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst Request = __webpack_require__(/*! ../core/request.js */ \"(ssr)/./node_modules/undici/lib/core/request.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst { InvalidArgumentError, InformationalError, ClientDestroyedError } = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ../core/connect.js */ \"(ssr)/./node_modules/undici/lib/core/connect.js\");\nconst { kUrl, kServerName, kClient, kBusy, kConnect, kResuming, kRunning, kPending, kSize, kQueue, kConnected, kConnecting, kNeedDrain, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections, kMaxRequests, kCounter, kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress, kMaxResponseSize, kOnError, kHTTPContext, kMaxConcurrentStreams, kResume } = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst connectH1 = __webpack_require__(/*! ./client-h1.js */ \"(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js\");\nconst connectH2 = __webpack_require__(/*! ./client-h2.js */ \"(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js\");\nlet deprecatedInterceptorWarned = false;\nconst kClosedResolve = Symbol('kClosedResolve');\nfunction getPipelining(client) {\n    return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;\n}\n/**\n * @type {import('../../types/client.js').default}\n */ class Client extends DispatcherBase {\n    /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */ constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls, strictContentLength, maxCachedSessions, maxRedirections, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, // h2\n    maxConcurrentStreams, allowH2 } = {}){\n        super();\n        if (keepAlive !== undefined) {\n            throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n        }\n        if (socketTimeout !== undefined) {\n            throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n        }\n        if (requestTimeout !== undefined) {\n            throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n        }\n        if (idleTimeout !== undefined) {\n            throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n        }\n        if (maxKeepAliveTimeout !== undefined) {\n            throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n        }\n        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n            throw new InvalidArgumentError('invalid maxHeaderSize');\n        }\n        if (socketPath != null && typeof socketPath !== 'string') {\n            throw new InvalidArgumentError('invalid socketPath');\n        }\n        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n            throw new InvalidArgumentError('invalid connectTimeout');\n        }\n        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n            throw new InvalidArgumentError('invalid keepAliveTimeout');\n        }\n        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n            throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n        }\n        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n            throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n        }\n        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n        }\n        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n        }\n        if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n            throw new InvalidArgumentError('connect must be a function or an object');\n        }\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError('maxRedirections must be a positive number');\n        }\n        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n            throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n        }\n        if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n            throw new InvalidArgumentError('localAddress must be valid string IP address');\n        }\n        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n            throw new InvalidArgumentError('maxResponseSize must be a positive number');\n        }\n        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n            throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');\n        }\n        // h2\n        if (allowH2 != null && typeof allowH2 !== 'boolean') {\n            throw new InvalidArgumentError('allowH2 must be a valid boolean value');\n        }\n        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n            throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0');\n        }\n        if (typeof connect !== 'function') {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        if (interceptors?.Client && Array.isArray(interceptors.Client)) {\n            this[kInterceptors] = interceptors.Client;\n            if (!deprecatedInterceptorWarned) {\n                deprecatedInterceptorWarned = true;\n                process.emitWarning('Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.', {\n                    code: 'UNDICI-CLIENT-INTERCEPTOR-DEPRECATED'\n                });\n            }\n        } else {\n            this[kInterceptors] = [\n                createRedirectInterceptor({\n                    maxRedirections\n                })\n            ];\n        }\n        this[kUrl] = util.parseOrigin(url);\n        this[kConnector] = connect;\n        this[kPipelining] = pipelining != null ? pipelining : 1;\n        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;\n        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;\n        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n        this[kServerName] = null;\n        this[kLocalAddress] = localAddress != null ? localAddress : null;\n        this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n        this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n        this[kMaxRedirections] = maxRedirections;\n        this[kMaxRequests] = maxRequestsPerClient;\n        this[kClosedResolve] = null;\n        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n        this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100; // Max peerConcurrentStreams for a Node h2 server\n        this[kHTTPContext] = null;\n        // kQueue is built up of 3 sections separated by\n        // the kRunningIdx and kPendingIdx indices.\n        // |   complete   |   running   |   pending   |\n        //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n        // kRunningIdx points to the first running element.\n        // kPendingIdx points to the first pending element.\n        // This implements a fast queue with an amortized\n        // time of O(1).\n        this[kQueue] = [];\n        this[kRunningIdx] = 0;\n        this[kPendingIdx] = 0;\n        this[kResume] = (sync)=>resume(this, sync);\n        this[kOnError] = (err)=>onError(this, err);\n    }\n    get pipelining() {\n        return this[kPipelining];\n    }\n    set pipelining(value) {\n        this[kPipelining] = value;\n        this[kResume](true);\n    }\n    get [kPending]() {\n        return this[kQueue].length - this[kPendingIdx];\n    }\n    get [kRunning]() {\n        return this[kPendingIdx] - this[kRunningIdx];\n    }\n    get [kSize]() {\n        return this[kQueue].length - this[kRunningIdx];\n    }\n    get [kConnected]() {\n        return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;\n    }\n    get [kBusy]() {\n        return Boolean(this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0);\n    }\n    /* istanbul ignore: only used for test */ [kConnect](cb) {\n        connect(this);\n        this.once('connect', cb);\n    }\n    [kDispatch](opts, handler) {\n        const origin = opts.origin || this[kUrl].origin;\n        const request = new Request(origin, opts, handler);\n        this[kQueue].push(request);\n        if (this[kResuming]) {\n        // Do nothing.\n        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n            // Wait a tick in case stream/iterator is ended in the same tick.\n            this[kResuming] = 1;\n            queueMicrotask(()=>resume(this));\n        } else {\n            this[kResume](true);\n        }\n        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n            this[kNeedDrain] = 2;\n        }\n        return this[kNeedDrain] < 2;\n    }\n    async [kClose]() {\n        // TODO: for H2 we need to gracefully flush the remaining enqueued\n        // request and close each stream.\n        return new Promise((resolve)=>{\n            if (this[kSize]) {\n                this[kClosedResolve] = resolve;\n            } else {\n                resolve(null);\n            }\n        });\n    }\n    async [kDestroy](err) {\n        return new Promise((resolve)=>{\n            const requests = this[kQueue].splice(this[kPendingIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                util.errorRequest(this, request, err);\n            }\n            const callback = ()=>{\n                if (this[kClosedResolve]) {\n                    // TODO (fix): Should we error here with ClientDestroyedError?\n                    this[kClosedResolve]();\n                    this[kClosedResolve] = null;\n                }\n                resolve(null);\n            };\n            if (this[kHTTPContext]) {\n                this[kHTTPContext].destroy(err, callback);\n                this[kHTTPContext] = null;\n            } else {\n                queueMicrotask(callback);\n            }\n            this[kResume]();\n        });\n    }\n}\nconst createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor.js */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\");\nfunction onError(client, err) {\n    if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n        // Error is not caused by running request and not a recoverable\n        // socket error.\n        assert(client[kPendingIdx] === client[kRunningIdx]);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            util.errorRequest(client, request, err);\n        }\n        assert(client[kSize] === 0);\n    }\n}\nasync function connect(client) {\n    assert(!client[kConnecting]);\n    assert(!client[kHTTPContext]);\n    let { host, hostname, protocol, port } = client[kUrl];\n    // Resolve ipv6\n    if (hostname[0] === '[') {\n        const idx = hostname.indexOf(']');\n        assert(idx !== -1);\n        const ip = hostname.substring(1, idx);\n        assert(net.isIP(ip));\n        hostname = ip;\n    }\n    client[kConnecting] = true;\n    if (channels.beforeConnect.hasSubscribers) {\n        channels.beforeConnect.publish({\n            connectParams: {\n                host,\n                hostname,\n                protocol,\n                port,\n                version: client[kHTTPContext]?.version,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            },\n            connector: client[kConnector]\n        });\n    }\n    try {\n        const socket = await new Promise((resolve, reject)=>{\n            client[kConnector]({\n                host,\n                hostname,\n                protocol,\n                port,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            }, (err, socket)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(socket);\n                }\n            });\n        });\n        if (client.destroyed) {\n            util.destroy(socket.on('error', ()=>{}), new ClientDestroyedError());\n            return;\n        }\n        assert(socket);\n        try {\n            client[kHTTPContext] = socket.alpnProtocol === 'h2' ? await connectH2(client, socket) : await connectH1(client, socket);\n        } catch (err) {\n            socket.destroy().on('error', ()=>{});\n            throw err;\n        }\n        client[kConnecting] = false;\n        socket[kCounter] = 0;\n        socket[kMaxRequests] = client[kMaxRequests];\n        socket[kClient] = client;\n        socket[kError] = null;\n        if (channels.connected.hasSubscribers) {\n            channels.connected.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    version: client[kHTTPContext]?.version,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                socket\n            });\n        }\n        client.emit('connect', client[kUrl], [\n            client\n        ]);\n    } catch (err) {\n        if (client.destroyed) {\n            return;\n        }\n        client[kConnecting] = false;\n        if (channels.connectError.hasSubscribers) {\n            channels.connectError.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    version: client[kHTTPContext]?.version,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                error: err\n            });\n        }\n        if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            assert(client[kRunning] === 0);\n            while(client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]){\n                const request = client[kQueue][client[kPendingIdx]++];\n                util.errorRequest(client, request, err);\n            }\n        } else {\n            onError(client, err);\n        }\n        client.emit('connectionError', client[kUrl], [\n            client\n        ], err);\n    }\n    client[kResume]();\n}\nfunction emitDrain(client) {\n    client[kNeedDrain] = 0;\n    client.emit('drain', client[kUrl], [\n        client\n    ]);\n}\nfunction resume(client, sync) {\n    if (client[kResuming] === 2) {\n        return;\n    }\n    client[kResuming] = 2;\n    _resume(client, sync);\n    client[kResuming] = 0;\n    if (client[kRunningIdx] > 256) {\n        client[kQueue].splice(0, client[kRunningIdx]);\n        client[kPendingIdx] -= client[kRunningIdx];\n        client[kRunningIdx] = 0;\n    }\n}\nfunction _resume(client, sync) {\n    while(true){\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            return;\n        }\n        if (client[kClosedResolve] && !client[kSize]) {\n            client[kClosedResolve]();\n            client[kClosedResolve] = null;\n            return;\n        }\n        if (client[kHTTPContext]) {\n            client[kHTTPContext].resume();\n        }\n        if (client[kBusy]) {\n            client[kNeedDrain] = 2;\n        } else if (client[kNeedDrain] === 2) {\n            if (sync) {\n                client[kNeedDrain] = 1;\n                queueMicrotask(()=>emitDrain(client));\n            } else {\n                emitDrain(client);\n            }\n            continue;\n        }\n        if (client[kPending] === 0) {\n            return;\n        }\n        if (client[kRunning] >= (getPipelining(client) || 1)) {\n            return;\n        }\n        const request = client[kQueue][client[kPendingIdx]];\n        if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n            if (client[kRunning] > 0) {\n                return;\n            }\n            client[kServerName] = request.servername;\n            client[kHTTPContext]?.destroy(new InformationalError('servername changed'), ()=>{\n                client[kHTTPContext] = null;\n                resume(client);\n            });\n        }\n        if (client[kConnecting]) {\n            return;\n        }\n        if (!client[kHTTPContext]) {\n            connect(client);\n            return;\n        }\n        if (client[kHTTPContext].destroyed) {\n            return;\n        }\n        if (client[kHTTPContext].busy(request)) {\n            return;\n        }\n        if (!request.aborted && client[kHTTPContext].write(request)) {\n            client[kPendingIdx]++;\n        } else {\n            client[kQueue].splice(client[kPendingIdx], 1);\n        }\n    }\n}\nmodule.exports = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZO0FBRVo7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQywwQkFBVTtBQUM5QixNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQyw0QkFBVztBQUNoQyxNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyxxRUFBaUI7QUFDdEMsTUFBTSxFQUFFSSxRQUFRLEVBQUUsR0FBR0osbUJBQU9BLENBQUMsbUZBQXdCO0FBQ3JELE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLDJFQUFvQjtBQUM1QyxNQUFNTSxpQkFBaUJOLG1CQUFPQSxDQUFDLHdGQUFtQjtBQUNsRCxNQUFNLEVBQ0pPLG9CQUFvQixFQUNwQkMsa0JBQWtCLEVBQ2xCQyxvQkFBb0IsRUFDckIsR0FBR1QsbUJBQU9BLENBQUMseUVBQW1CO0FBQy9CLE1BQU1VLGlCQUFpQlYsbUJBQU9BLENBQUMsMkVBQW9CO0FBQ25ELE1BQU0sRUFDSlcsSUFBSSxFQUNKQyxXQUFXLEVBQ1hDLE9BQU8sRUFDUEMsS0FBSyxFQUNMQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsTUFBTSxFQUNOQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyx3QkFBd0IsRUFDeEJDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLE1BQU0sRUFDTkMsV0FBVyxFQUNYQyxzQkFBc0IsRUFDdEJDLGVBQWUsRUFDZkMsb0JBQW9CLEVBQ3BCQywwQkFBMEIsRUFDMUJDLGVBQWUsRUFDZkMsWUFBWSxFQUNaQyxvQkFBb0IsRUFDcEJDLFVBQVUsRUFDVkMsZ0JBQWdCLEVBQ2hCQyxZQUFZLEVBQ1pDLFFBQVEsRUFDUkMsTUFBTSxFQUNOQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsYUFBYSxF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WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtY2hlY2tcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25vZGU6bmV0JylcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdub2RlOmh0dHAnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbC5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuLi9jb3JlL3JlcXVlc3QuanMnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIENsaWVudERlc3Ryb3llZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL2Nvbm5lY3QuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrU2VydmVyTmFtZSxcbiAga0NsaWVudCxcbiAga0J1c3ksXG4gIGtDb25uZWN0LFxuICBrUmVzdW1pbmcsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1NpemUsXG4gIGtRdWV1ZSxcbiAga0Nvbm5lY3RlZCxcbiAga0Nvbm5lY3RpbmcsXG4gIGtOZWVkRHJhaW4sXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCxcbiAga0hvc3RIZWFkZXIsXG4gIGtQZW5kaW5nSWR4LFxuICBrUnVubmluZ0lkeCxcbiAga0Vycm9yLFxuICBrUGlwZWxpbmluZyxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSxcbiAga01heEhlYWRlcnNTaXplLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dCxcbiAga0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQsXG4gIGtIZWFkZXJzVGltZW91dCxcbiAga0JvZHlUaW1lb3V0LFxuICBrU3RyaWN0Q29udGVudExlbmd0aCxcbiAga0Nvbm5lY3RvcixcbiAga01heFJlZGlyZWN0aW9ucyxcbiAga01heFJlcXVlc3RzLFxuICBrQ291bnRlcixcbiAga0Nsb3NlLFxuICBrRGVzdHJveSxcbiAga0Rpc3BhdGNoLFxuICBrSW50ZXJjZXB0b3JzLFxuICBrTG9jYWxBZGRyZXNzLFxuICBrTWF4UmVzcG9uc2VTaXplLFxuICBrT25FcnJvcixcbiAga0hUVFBDb250ZXh0LFxuICBrTWF4Q29uY3VycmVudFN0cmVhbXMsXG4gIGtSZXN1bWVcbn0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMuanMnKVxuY29uc3QgY29ubmVjdEgxID0gcmVxdWlyZSgnLi9jbGllbnQtaDEuanMnKVxuY29uc3QgY29ubmVjdEgyID0gcmVxdWlyZSgnLi9jbGllbnQtaDIuanMnKVxubGV0IGRlcHJlY2F0ZWRJbnRlcmNlcHRvcldhcm5lZCA9IGZhbHNlXG5cbmNvbnN0IGtDbG9zZWRSZXNvbHZlID0gU3ltYm9sKCdrQ2xvc2VkUmVzb2x2ZScpXG5cbmZ1bmN0aW9uIGdldFBpcGVsaW5pbmcgKGNsaWVudCkge1xuICByZXR1cm4gY2xpZW50W2tQaXBlbGluaW5nXSA/PyBjbGllbnRba0hUVFBDb250ZXh0XT8uZGVmYXVsdFBpcGVsaW5pbmcgPz8gMVxufVxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NsaWVudC5qcycpLmRlZmF1bHR9XG4gKi9cbmNsYXNzIENsaWVudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gdXJsXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jbGllbnQuanMnKS5DbGllbnQuT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHVybCwge1xuICAgIGludGVyY2VwdG9ycyxcbiAgICBtYXhIZWFkZXJTaXplLFxuICAgIGhlYWRlcnNUaW1lb3V0LFxuICAgIHNvY2tldFRpbWVvdXQsXG4gICAgcmVxdWVzdFRpbWVvdXQsXG4gICAgY29ubmVjdFRpbWVvdXQsXG4gICAgYm9keVRpbWVvdXQsXG4gICAgaWRsZVRpbWVvdXQsXG4gICAga2VlcEFsaXZlLFxuICAgIGtlZXBBbGl2ZVRpbWVvdXQsXG4gICAgbWF4S2VlcEFsaXZlVGltZW91dCxcbiAgICBrZWVwQWxpdmVNYXhUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQsXG4gICAgc29ja2V0UGF0aCxcbiAgICBwaXBlbGluaW5nLFxuICAgIHRscyxcbiAgICBzdHJpY3RDb250ZW50TGVuZ3RoLFxuICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgIG1heFJlZGlyZWN0aW9ucyxcbiAgICBjb25uZWN0LFxuICAgIG1heFJlcXVlc3RzUGVyQ2xpZW50LFxuICAgIGxvY2FsQWRkcmVzcyxcbiAgICBtYXhSZXNwb25zZVNpemUsXG4gICAgYXV0b1NlbGVjdEZhbWlseSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQsXG4gICAgLy8gaDJcbiAgICBtYXhDb25jdXJyZW50U3RyZWFtcyxcbiAgICBhbGxvd0gyXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmIChrZWVwQWxpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBrZWVwQWxpdmUsIHVzZSBwaXBlbGluaW5nPTAgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBzb2NrZXRUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCByZXF1ZXN0VGltZW91dCwgdXNlIGhlYWRlcnNUaW1lb3V0ICYgYm9keVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKGlkbGVUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgaWRsZVRpbWVvdXQsIHVzZSBrZWVwQWxpdmVUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChtYXhLZWVwQWxpdmVUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgbWF4S2VlcEFsaXZlVGltZW91dCwgdXNlIGtlZXBBbGl2ZU1heFRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKG1heEhlYWRlclNpemUgIT0gbnVsbCAmJiAhTnVtYmVyLmlzRmluaXRlKG1heEhlYWRlclNpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWF4SGVhZGVyU2l6ZScpXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFBhdGggIT0gbnVsbCAmJiB0eXBlb2Ygc29ja2V0UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBzb2NrZXRQYXRoJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdFRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShjb25uZWN0VGltZW91dCkgfHwgY29ubmVjdFRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbm5lY3RUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoa2VlcEFsaXZlVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGtlZXBBbGl2ZVRpbWVvdXQpIHx8IGtlZXBBbGl2ZVRpbWVvdXQgPD0gMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBrZWVwQWxpdmVUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoa2VlcEFsaXZlTWF4VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGtlZXBBbGl2ZU1heFRpbWVvdXQpIHx8IGtlZXBBbGl2ZU1heFRpbWVvdXQgPD0gMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBrZWVwQWxpdmVNYXhUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoa2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkJylcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIoaGVhZGVyc1RpbWVvdXQpIHx8IGhlYWRlcnNUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVyc1RpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpXG4gICAgfVxuXG4gICAgaWYgKGJvZHlUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGJvZHlUaW1lb3V0KSB8fCBib2R5VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2JvZHlUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKG1heFJlZGlyZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlZGlyZWN0aW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVxdWVzdHNQZXJDbGllbnQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVxdWVzdHNQZXJDbGllbnQpIHx8IG1heFJlcXVlc3RzUGVyQ2xpZW50IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVxdWVzdHNQZXJDbGllbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgaWYgKGxvY2FsQWRkcmVzcyAhPSBudWxsICYmICh0eXBlb2YgbG9jYWxBZGRyZXNzICE9PSAnc3RyaW5nJyB8fCBuZXQuaXNJUChsb2NhbEFkZHJlc3MpID09PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdsb2NhbEFkZHJlc3MgbXVzdCBiZSB2YWxpZCBzdHJpbmcgSVAgYWRkcmVzcycpXG4gICAgfVxuXG4gICAgaWYgKG1heFJlc3BvbnNlU2l6ZSAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXNwb25zZVNpemUpIHx8IG1heFJlc3BvbnNlU2l6ZSA8IC0xKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZXNwb25zZVNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0ICE9IG51bGwgJiZcbiAgICAgICghTnVtYmVyLmlzSW50ZWdlcihhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQpIHx8IGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCA8IC0xKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgLy8gaDJcbiAgICBpZiAoYWxsb3dIMiAhPSBudWxsICYmIHR5cGVvZiBhbGxvd0gyICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYWxsb3dIMiBtdXN0IGJlIGEgdmFsaWQgYm9vbGVhbiB2YWx1ZScpXG4gICAgfVxuXG4gICAgaWYgKG1heENvbmN1cnJlbnRTdHJlYW1zICE9IG51bGwgJiYgKHR5cGVvZiBtYXhDb25jdXJyZW50U3RyZWFtcyAhPT0gJ251bWJlcicgfHwgbWF4Q29uY3VycmVudFN0cmVhbXMgPCAxKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhDb25jdXJyZW50U3RyZWFtcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgZ3JlYXRlciB0aGFuIDAnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgLi4udGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgYWxsb3dIMixcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQsXG4gICAgICAgIC4uLihhdXRvU2VsZWN0RmFtaWx5ID8geyBhdXRvU2VsZWN0RmFtaWx5LCBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgfSA6IHVuZGVmaW5lZCksXG4gICAgICAgIC4uLmNvbm5lY3RcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGludGVyY2VwdG9ycz8uQ2xpZW50ICYmIEFycmF5LmlzQXJyYXkoaW50ZXJjZXB0b3JzLkNsaWVudCkpIHtcbiAgICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBpbnRlcmNlcHRvcnMuQ2xpZW50XG4gICAgICBpZiAoIWRlcHJlY2F0ZWRJbnRlcmNlcHRvcldhcm5lZCkge1xuICAgICAgICBkZXByZWNhdGVkSW50ZXJjZXB0b3JXYXJuZWQgPSB0cnVlXG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ0NsaWVudC5PcHRpb25zI2ludGVyY2VwdG9yIGlzIGRlcHJlY2F0ZWQuIFVzZSBEaXNwYXRjaGVyI2NvbXBvc2UgaW5zdGVhZC4nLCB7XG4gICAgICAgICAgY29kZTogJ1VORElDSS1DTElFTlQtSU5URVJDRVBUT1ItREVQUkVDQVRFRCdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IFtjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yKHsgbWF4UmVkaXJlY3Rpb25zIH0pXVxuICAgIH1cblxuICAgIHRoaXNba1VybF0gPSB1dGlsLnBhcnNlT3JpZ2luKHVybClcbiAgICB0aGlzW2tDb25uZWN0b3JdID0gY29ubmVjdFxuICAgIHRoaXNba1BpcGVsaW5pbmddID0gcGlwZWxpbmluZyAhPSBudWxsID8gcGlwZWxpbmluZyA6IDFcbiAgICB0aGlzW2tNYXhIZWFkZXJzU2l6ZV0gPSBtYXhIZWFkZXJTaXplIHx8IGh0dHAubWF4SGVhZGVyU2l6ZVxuICAgIHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XSA9IGtlZXBBbGl2ZVRpbWVvdXQgPT0gbnVsbCA/IDRlMyA6IGtlZXBBbGl2ZVRpbWVvdXRcbiAgICB0aGlzW2tLZWVwQWxpdmVNYXhUaW1lb3V0XSA9IGtlZXBBbGl2ZU1heFRpbWVvdXQgPT0gbnVsbCA/IDYwMGUzIDoga2VlcEFsaXZlTWF4VGltZW91dFxuICAgIHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRdID0ga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCA9PSBudWxsID8gMmUzIDoga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZFxuICAgIHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aGlzW2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF1cbiAgICB0aGlzW2tTZXJ2ZXJOYW1lXSA9IG51bGxcbiAgICB0aGlzW2tMb2NhbEFkZHJlc3NdID0gbG9jYWxBZGRyZXNzICE9IG51bGwgPyBsb2NhbEFkZHJlc3MgOiBudWxsXG4gICAgdGhpc1trUmVzdW1pbmddID0gMCAvLyAwLCBpZGxlLCAxLCBzY2hlZHVsZWQsIDIgcmVzdW1pbmdcbiAgICB0aGlzW2tOZWVkRHJhaW5dID0gMCAvLyAwLCBpZGxlLCAxLCBzY2hlZHVsZWQsIDIgcmVzdW1pbmdcbiAgICB0aGlzW2tIb3N0SGVhZGVyXSA9IGBob3N0OiAke3RoaXNba1VybF0uaG9zdG5hbWV9JHt0aGlzW2tVcmxdLnBvcnQgPyBgOiR7dGhpc1trVXJsXS5wb3J0fWAgOiAnJ31cXHJcXG5gXG4gICAgdGhpc1trQm9keVRpbWVvdXRdID0gYm9keVRpbWVvdXQgIT0gbnVsbCA/IGJvZHlUaW1lb3V0IDogMzAwZTNcbiAgICB0aGlzW2tIZWFkZXJzVGltZW91dF0gPSBoZWFkZXJzVGltZW91dCAhPSBudWxsID8gaGVhZGVyc1RpbWVvdXQgOiAzMDBlM1xuICAgIHRoaXNba1N0cmljdENvbnRlbnRMZW5ndGhdID0gc3RyaWN0Q29udGVudExlbmd0aCA9PSBudWxsID8gdHJ1ZSA6IHN0cmljdENvbnRlbnRMZW5ndGhcbiAgICB0aGlzW2tNYXhSZWRpcmVjdGlvbnNdID0gbWF4UmVkaXJlY3Rpb25zXG4gICAgdGhpc1trTWF4UmVxdWVzdHNdID0gbWF4UmVxdWVzdHNQZXJDbGllbnRcbiAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICB0aGlzW2tNYXhSZXNwb25zZVNpemVdID0gbWF4UmVzcG9uc2VTaXplID4gLTEgPyBtYXhSZXNwb25zZVNpemUgOiAtMVxuICAgIHRoaXNba01heENvbmN1cnJlbnRTdHJlYW1zXSA9IG1heENvbmN1cnJlbnRTdHJlYW1zICE9IG51bGwgPyBtYXhDb25jdXJyZW50U3RyZWFtcyA6IDEwMCAvLyBNYXggcGVlckNvbmN1cnJlbnRTdHJlYW1zIGZvciBhIE5vZGUgaDIgc2VydmVyXG4gICAgdGhpc1trSFRUUENvbnRleHRdID0gbnVsbFxuXG4gICAgLy8ga1F1ZXVlIGlzIGJ1aWx0IHVwIG9mIDMgc2VjdGlvbnMgc2VwYXJhdGVkIGJ5XG4gICAgLy8gdGhlIGtSdW5uaW5nSWR4IGFuZCBrUGVuZGluZ0lkeCBpbmRpY2VzLlxuICAgIC8vIHwgICBjb21wbGV0ZSAgIHwgICBydW5uaW5nICAgfCAgIHBlbmRpbmcgICB8XG4gICAgLy8gICAgICAgICAgICAgICAgXiBrUnVubmluZ0lkeCBeIGtQZW5kaW5nSWR4IF4ga1F1ZXVlLmxlbmd0aFxuICAgIC8vIGtSdW5uaW5nSWR4IHBvaW50cyB0byB0aGUgZmlyc3QgcnVubmluZyBlbGVtZW50LlxuICAgIC8vIGtQZW5kaW5nSWR4IHBvaW50cyB0byB0aGUgZmlyc3QgcGVuZGluZyBlbGVtZW50LlxuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBhIGZhc3QgcXVldWUgd2l0aCBhbiBhbW9ydGl6ZWRcbiAgICAvLyB0aW1lIG9mIE8oMSkuXG5cbiAgICB0aGlzW2tRdWV1ZV0gPSBbXVxuICAgIHRoaXNba1J1bm5pbmdJZHhdID0gMFxuICAgIHRoaXNba1BlbmRpbmdJZHhdID0gMFxuXG4gICAgdGhpc1trUmVzdW1lXSA9IChzeW5jKSA9PiByZXN1bWUodGhpcywgc3luYylcbiAgICB0aGlzW2tPbkVycm9yXSA9IChlcnIpID0+IG9uRXJyb3IodGhpcywgZXJyKVxuICB9XG5cbiAgZ2V0IHBpcGVsaW5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQaXBlbGluaW5nXVxuICB9XG5cbiAgc2V0IHBpcGVsaW5pbmcgKHZhbHVlKSB7XG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSB2YWx1ZVxuICAgIHRoaXNba1Jlc3VtZV0odHJ1ZSlcbiAgfVxuXG4gIGdldCBba1BlbmRpbmddICgpIHtcbiAgICByZXR1cm4gdGhpc1trUXVldWVdLmxlbmd0aCAtIHRoaXNba1BlbmRpbmdJZHhdXG4gIH1cblxuICBnZXQgW2tSdW5uaW5nXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1BlbmRpbmdJZHhdIC0gdGhpc1trUnVubmluZ0lkeF1cbiAgfVxuXG4gIGdldCBba1NpemVdICgpIHtcbiAgICByZXR1cm4gdGhpc1trUXVldWVdLmxlbmd0aCAtIHRoaXNba1J1bm5pbmdJZHhdXG4gIH1cblxuICBnZXQgW2tDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gISF0aGlzW2tIVFRQQ29udGV4dF0gJiYgIXRoaXNba0Nvbm5lY3RpbmddICYmICF0aGlzW2tIVFRQQ29udGV4dF0uZGVzdHJveWVkXG4gIH1cblxuICBnZXQgW2tCdXN5XSAoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICB0aGlzW2tIVFRQQ29udGV4dF0/LmJ1c3kobnVsbCkgfHxcbiAgICAgICh0aGlzW2tTaXplXSA+PSAoZ2V0UGlwZWxpbmluZyh0aGlzKSB8fCAxKSkgfHxcbiAgICAgIHRoaXNba1BlbmRpbmddID4gMFxuICAgIClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZTogb25seSB1c2VkIGZvciB0ZXN0ICovXG4gIFtrQ29ubmVjdF0gKGNiKSB7XG4gICAgY29ubmVjdCh0aGlzKVxuICAgIHRoaXMub25jZSgnY29ubmVjdCcsIGNiKVxuICB9XG5cbiAgW2tEaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBvcmlnaW4gPSBvcHRzLm9yaWdpbiB8fCB0aGlzW2tVcmxdLm9yaWdpblxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChvcmlnaW4sIG9wdHMsIGhhbmRsZXIpXG5cbiAgICB0aGlzW2tRdWV1ZV0ucHVzaChyZXF1ZXN0KVxuICAgIGlmICh0aGlzW2tSZXN1bWluZ10pIHtcbiAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSBlbHNlIGlmICh1dGlsLmJvZHlMZW5ndGgocmVxdWVzdC5ib2R5KSA9PSBudWxsICYmIHV0aWwuaXNJdGVyYWJsZShyZXF1ZXN0LmJvZHkpKSB7XG4gICAgICAvLyBXYWl0IGEgdGljayBpbiBjYXNlIHN0cmVhbS9pdGVyYXRvciBpcyBlbmRlZCBpbiB0aGUgc2FtZSB0aWNrLlxuICAgICAgdGhpc1trUmVzdW1pbmddID0gMVxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVzdW1lKHRoaXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tSZXN1bWVdKHRydWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1Jlc3VtaW5nXSAmJiB0aGlzW2tOZWVkRHJhaW5dICE9PSAyICYmIHRoaXNba0J1c3ldKSB7XG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gMlxuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2tOZWVkRHJhaW5dIDwgMlxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIC8vIFRPRE86IGZvciBIMiB3ZSBuZWVkIHRvIGdyYWNlZnVsbHkgZmx1c2ggdGhlIHJlbWFpbmluZyBlbnF1ZXVlZFxuICAgIC8vIHJlcXVlc3QgYW5kIGNsb3NlIGVhY2ggc3RyZWFtLlxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKHRoaXNba1NpemVdKSB7XG4gICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gcmVzb2x2ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShudWxsKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpc1trUXVldWVdLnNwbGljZSh0aGlzW2tQZW5kaW5nSWR4XSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KHRoaXMsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzW2tDbG9zZWRSZXNvbHZlXSkge1xuICAgICAgICAgIC8vIFRPRE8gKGZpeCk6IFNob3VsZCB3ZSBlcnJvciBoZXJlIHdpdGggQ2xpZW50RGVzdHJveWVkRXJyb3I/XG4gICAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0oKVxuICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0hUVFBDb250ZXh0XSkge1xuICAgICAgICB0aGlzW2tIVFRQQ29udGV4dF0uZGVzdHJveShlcnIsIGNhbGxiYWNrKVxuICAgICAgICB0aGlzW2tIVFRQQ29udGV4dF0gPSBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjaylcbiAgICAgIH1cblxuICAgICAgdGhpc1trUmVzdW1lXSgpXG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJjZXB0b3IvcmVkaXJlY3QtaW50ZXJjZXB0b3IuanMnKVxuXG5mdW5jdGlvbiBvbkVycm9yIChjbGllbnQsIGVycikge1xuICBpZiAoXG4gICAgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCAmJlxuICAgIGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJyAmJlxuICAgIGVyci5jb2RlICE9PSAnVU5EX0VSUl9TT0NLRVQnXG4gICkge1xuICAgIC8vIEVycm9yIGlzIG5vdCBjYXVzZWQgYnkgcnVubmluZyByZXF1ZXN0IGFuZCBub3QgYSByZWNvdmVyYWJsZVxuICAgIC8vIHNvY2tldCBlcnJvci5cblxuICAgIGFzc2VydChjbGllbnRba1BlbmRpbmdJZHhdID09PSBjbGllbnRba1J1bm5pbmdJZHhdKVxuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgfVxuICAgIGFzc2VydChjbGllbnRba1NpemVdID09PSAwKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QgKGNsaWVudCkge1xuICBhc3NlcnQoIWNsaWVudFtrQ29ubmVjdGluZ10pXG4gIGFzc2VydCghY2xpZW50W2tIVFRQQ29udGV4dF0pXG5cbiAgbGV0IHsgaG9zdCwgaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0IH0gPSBjbGllbnRba1VybF1cblxuICAvLyBSZXNvbHZlIGlwdjZcbiAgaWYgKGhvc3RuYW1lWzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0bmFtZS5pbmRleE9mKCddJylcblxuICAgIGFzc2VydChpZHggIT09IC0xKVxuICAgIGNvbnN0IGlwID0gaG9zdG5hbWUuc3Vic3RyaW5nKDEsIGlkeClcblxuICAgIGFzc2VydChuZXQuaXNJUChpcCkpXG4gICAgaG9zdG5hbWUgPSBpcFxuICB9XG5cbiAgY2xpZW50W2tDb25uZWN0aW5nXSA9IHRydWVcblxuICBpZiAoY2hhbm5lbHMuYmVmb3JlQ29ubmVjdC5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QucHVibGlzaCh7XG4gICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgdmVyc2lvbjogY2xpZW50W2tIVFRQQ29udGV4dF0/LnZlcnNpb24sXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LFxuICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl1cbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzb2NrZXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnRba0Nvbm5lY3Rvcl0oe1xuICAgICAgICBob3N0LFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LCAoZXJyLCBzb2NrZXQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShzb2NrZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHt9KSwgbmV3IENsaWVudERlc3Ryb3llZEVycm9yKCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQoc29ja2V0KVxuXG4gICAgdHJ5IHtcbiAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdID0gc29ja2V0LmFscG5Qcm90b2NvbCA9PT0gJ2gyJ1xuICAgICAgICA/IGF3YWl0IGNvbm5lY3RIMihjbGllbnQsIHNvY2tldClcbiAgICAgICAgOiBhd2FpdCBjb25uZWN0SDEoY2xpZW50LCBzb2NrZXQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzb2NrZXQuZGVzdHJveSgpLm9uKCdlcnJvcicsICgpID0+IHt9KVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgY2xpZW50W2tDb25uZWN0aW5nXSA9IGZhbHNlXG5cbiAgICBzb2NrZXRba0NvdW50ZXJdID0gMFxuICAgIHNvY2tldFtrTWF4UmVxdWVzdHNdID0gY2xpZW50W2tNYXhSZXF1ZXN0c11cbiAgICBzb2NrZXRba0NsaWVudF0gPSBjbGllbnRcbiAgICBzb2NrZXRba0Vycm9yXSA9IG51bGxcblxuICAgIGlmIChjaGFubmVscy5jb25uZWN0ZWQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RlZC5wdWJsaXNoKHtcbiAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgcG9ydCxcbiAgICAgICAgICB2ZXJzaW9uOiBjbGllbnRba0hUVFBDb250ZXh0XT8udmVyc2lvbixcbiAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdLFxuICAgICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdLFxuICAgICAgICBzb2NrZXRcbiAgICAgIH0pXG4gICAgfVxuICAgIGNsaWVudC5lbWl0KCdjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsaWVudFtrQ29ubmVjdGluZ10gPSBmYWxzZVxuXG4gICAgaWYgKGNoYW5uZWxzLmNvbm5lY3RFcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY29ubmVjdEVycm9yLnB1Ymxpc2goe1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgICAgaG9zdCxcbiAgICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICBwb3J0LFxuICAgICAgICAgIHZlcnNpb246IGNsaWVudFtrSFRUUENvbnRleHRdPy52ZXJzaW9uLFxuICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl0sXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGVyci5jb2RlID09PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuICAgICAgd2hpbGUgKGNsaWVudFtrUGVuZGluZ10gPiAwICYmIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF1dLnNlcnZlcm5hbWUgPT09IGNsaWVudFtrU2VydmVyTmFtZV0pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF0rK11cbiAgICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uRXJyb3IoY2xpZW50LCBlcnIpXG4gICAgfVxuXG4gICAgY2xpZW50LmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcbiAgfVxuXG4gIGNsaWVudFtrUmVzdW1lXSgpXG59XG5cbmZ1bmN0aW9uIGVtaXREcmFpbiAoY2xpZW50KSB7XG4gIGNsaWVudFtrTmVlZERyYWluXSA9IDBcbiAgY2xpZW50LmVtaXQoJ2RyYWluJywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSlcbn1cblxuZnVuY3Rpb24gcmVzdW1lIChjbGllbnQsIHN5bmMpIHtcbiAgaWYgKGNsaWVudFtrUmVzdW1pbmddID09PSAyKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjbGllbnRba1Jlc3VtaW5nXSA9IDJcblxuICBfcmVzdW1lKGNsaWVudCwgc3luYylcbiAgY2xpZW50W2tSZXN1bWluZ10gPSAwXG5cbiAgaWYgKGNsaWVudFtrUnVubmluZ0lkeF0gPiAyNTYpIHtcbiAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoMCwgY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICBjbGllbnRba1BlbmRpbmdJZHhdIC09IGNsaWVudFtrUnVubmluZ0lkeF1cbiAgICBjbGllbnRba1J1bm5pbmdJZHhdID0gMFxuICB9XG59XG5cbmZ1bmN0aW9uIF9yZXN1bWUgKGNsaWVudCwgc3luYykge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nXSA9PT0gMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0Nsb3NlZFJlc29sdmVdICYmICFjbGllbnRba1NpemVdKSB7XG4gICAgICBjbGllbnRba0Nsb3NlZFJlc29sdmVdKClcbiAgICAgIGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0gPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tIVFRQQ29udGV4dF0pIHtcbiAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdLnJlc3VtZSgpXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQnVzeV0pIHtcbiAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDJcbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrTmVlZERyYWluXSA9PT0gMikge1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgY2xpZW50W2tOZWVkRHJhaW5dID0gMVxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBlbWl0RHJhaW4oY2xpZW50KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXREcmFpbihjbGllbnQpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1BlbmRpbmddID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+PSAoZ2V0UGlwZWxpbmluZyhjbGllbnQpIHx8IDEpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XV1cblxuICAgIGlmIChjbGllbnRba1VybF0ucHJvdG9jb2wgPT09ICdodHRwczonICYmIGNsaWVudFtrU2VydmVyTmFtZV0gIT09IHJlcXVlc3Quc2VydmVybmFtZSkge1xuICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjbGllbnRba1NlcnZlck5hbWVdID0gcmVxdWVzdC5zZXJ2ZXJuYW1lXG4gICAgICBjbGllbnRba0hUVFBDb250ZXh0XT8uZGVzdHJveShuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdzZXJ2ZXJuYW1lIGNoYW5nZWQnKSwgKCkgPT4ge1xuICAgICAgICBjbGllbnRba0hUVFBDb250ZXh0XSA9IG51bGxcbiAgICAgICAgcmVzdW1lKGNsaWVudClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ29ubmVjdGluZ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghY2xpZW50W2tIVFRQQ29udGV4dF0pIHtcbiAgICAgIGNvbm5lY3QoY2xpZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrSFRUUENvbnRleHRdLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrSFRUUENvbnRleHRdLmJ1c3kocmVxdWVzdCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdC5hYm9ydGVkICYmIGNsaWVudFtrSFRUUENvbnRleHRdLndyaXRlKHJlcXVlc3QpKSB7XG4gICAgICBjbGllbnRba1BlbmRpbmdJZHhdKytcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUGVuZGluZ0lkeF0sIDEpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIm5ldCIsImh0dHAiLCJ1dGlsIiwiY2hhbm5lbHMiLCJSZXF1ZXN0IiwiRGlzcGF0Y2hlckJhc2UiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkluZm9ybWF0aW9uYWxFcnJvciIsIkNsaWVudERlc3Ryb3llZEVycm9yIiwiYnVpbGRDb25uZWN0b3IiLCJrVXJsIiwia1NlcnZlck5hbWUiLCJrQ2xpZW50Iiwia0J1c3kiLCJrQ29ubmVjdCIsImtSZXN1bWluZyIsImtSdW5uaW5nIiwia1BlbmRpbmciLCJrU2l6ZSIsImtRdWV1ZSIsImtDb25uZWN0ZWQiLCJrQ29ubmVjdGluZyIsImtOZWVkRHJhaW4iLCJrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQiLCJrSG9zdEhlYWRlciIsImtQZW5kaW5nSWR4Iiwia1J1bm5pbmdJZHgiLCJrRXJyb3IiLCJrUGlwZWxpbmluZyIsImtLZWVwQWxpdmVUaW1lb3V0VmFsdWUiLCJrTWF4SGVhZGVyc1NpemUiLCJrS2VlcEFsaXZlTWF4VGltZW91dCIsImtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwia0hlYWRlcnNUaW1lb3V0Iiwia0JvZHlUaW1lb3V0Iiwia1N0cmljdENvbnRlbnRMZW5ndGgiLCJrQ29ubmVjdG9yIiwia01heFJlZGlyZWN0aW9ucyIsImtNYXhSZXF1ZXN0cyIsImtDb3VudGVyIiwia0Nsb3NlIiwia0Rlc3Ryb3kiLCJrRGlzcGF0Y2giLCJrSW50ZXJjZXB0b3JzIiwia0xvY2FsQWRkcmVzcyIsImtNYXhSZXNwb25zZVNpemUiLCJrT25FcnJvciIsImtIVFRQQ29udGV4dCIsImtNYXhDb25jdXJyZW50U3RyZWFtcyIsImtSZXN1bWUiLCJjb25uZWN0SDEiLCJjb25uZWN0SDIiLCJkZXByZWNhdGVkSW50ZXJjZXB0b3JXYXJuZWQiLCJrQ2xvc2VkUmVzb2x2ZSIsIlN5bWJvbCIsImdldFBpcGVsaW5pbmciLCJjbGllbnQiLCJkZWZhdWx0UGlwZWxpbmluZyIsIkNsaWVudCIsInVybCIsImludGVyY2VwdG9ycyIsIm1heEhlYWRlclNpemUiLCJoZWFkZXJzVGltZW91dCIsInNvY2tldFRpbWVvdXQiLCJyZXF1ZXN0VGltZW91dCIsImNvbm5lY3RUaW1lb3V0IiwiYm9keVRpbWVvdXQiLCJpZGxlVGltZW91dCIsImtlZXBBbGl2ZSIsImtlZXBBbGl2ZVRpbWVvdXQiLCJtYXhLZWVwQWxpdmVUaW1lb3V0Iiwia2VlcEFsaXZlTWF4VGltZW91dCIsImtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQiLCJzb2NrZXRQYXRoIiwicGlwZWxpbmluZyIsInRscyIsInN0cmljdENvbnRlbnRMZW5ndGgiLCJtYXhDYWNoZWRTZXNzaW9ucyIsIm1heFJlZGlyZWN0aW9ucyIsImNvbm5lY3QiLCJtYXhSZXF1ZXN0c1BlckNsaWVudCIsImxvY2FsQWRkcmVzcyIsIm1heFJlc3BvbnNlU2l6ZSIsImF1dG9TZWxlY3RGYW1pbHkiLCJhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQiLCJtYXhDb25jdXJyZW50U3RyZWFtcyIsImFsbG93SDIiLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImlzSW50ZWdlciIsImlzSVAiLCJ0aW1lb3V0IiwiQXJyYXkiLCJpc0FycmF5IiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiY29kZSIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IiLCJwYXJzZU9yaWdpbiIsImhvc3RuYW1lIiwicG9ydCIsInN5bmMiLCJyZXN1bWUiLCJlcnIiLCJvbkVycm9yIiwidmFsdWUiLCJsZW5ndGgiLCJkZXN0cm95ZWQiLCJCb29sZWFuIiwiYnVzeSIsImNiIiwib25jZSIsIm9wdHMiLCJoYW5kbGVyIiwib3JpZ2luIiwicmVxdWVzdCIsInB1c2giLCJib2R5TGVuZ3RoIiwiYm9keSIsImlzSXRlcmFibGUiLCJxdWV1ZU1pY3JvdGFzayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVxdWVzdHMiLCJzcGxpY2UiLCJpIiwiZXJyb3JSZXF1ZXN0IiwiY2FsbGJhY2siLCJkZXN0cm95IiwiaG9zdCIsInByb3RvY29sIiwiaWR4IiwiaW5kZXhPZiIsImlwIiwic3Vic3RyaW5nIiwiYmVmb3JlQ29ubmVjdCIsImhhc1N1YnNjcmliZXJzIiwicHVibGlzaCIsImNvbm5lY3RQYXJhbXMiLCJ2ZXJzaW9uIiwic2VydmVybmFtZSIsImNvbm5lY3RvciIsInNvY2tldCIsInJlamVjdCIsIm9uIiwiYWxwblByb3RvY29sIiwiY29ubmVjdGVkIiwiZW1pdCIsImNvbm5lY3RFcnJvciIsImVycm9yIiwiZW1pdERyYWluIiwiX3Jlc3VtZSIsImFib3J0ZWQiLCJ3cml0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher-base.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\");\nconst { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst kOnDestroyed = Symbol('onDestroyed');\nconst kOnClosed = Symbol('onClosed');\nconst kInterceptedDispatch = Symbol('Intercepted Dispatch');\nclass DispatcherBase extends Dispatcher {\n    constructor(){\n        super();\n        this[kDestroyed] = false;\n        this[kOnDestroyed] = null;\n        this[kClosed] = false;\n        this[kOnClosed] = [];\n    }\n    get destroyed() {\n        return this[kDestroyed];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get interceptors() {\n        return this[kInterceptors];\n    }\n    set interceptors(newInterceptors) {\n        if (newInterceptors) {\n            for(let i = newInterceptors.length - 1; i >= 0; i--){\n                const interceptor = this[kInterceptors][i];\n                if (typeof interceptor !== 'function') {\n                    throw new InvalidArgumentError('interceptor must be an function');\n                }\n            }\n        }\n        this[kInterceptors] = newInterceptors;\n    }\n    close(callback) {\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.close((err, data)=>{\n                    return err ? reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== 'function') {\n            throw new InvalidArgumentError('invalid callback');\n        }\n        if (this[kDestroyed]) {\n            queueMicrotask(()=>callback(new ClientDestroyedError(), null));\n            return;\n        }\n        if (this[kClosed]) {\n            if (this[kOnClosed]) {\n                this[kOnClosed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        this[kClosed] = true;\n        this[kOnClosed].push(callback);\n        const onClosed = ()=>{\n            const callbacks = this[kOnClosed];\n            this[kOnClosed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kClose]().then(()=>this.destroy()).then(()=>{\n            queueMicrotask(onClosed);\n        });\n    }\n    destroy(err, callback) {\n        if (typeof err === 'function') {\n            callback = err;\n            err = null;\n        }\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.destroy(err, (err, data)=>{\n                    return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== 'function') {\n            throw new InvalidArgumentError('invalid callback');\n        }\n        if (this[kDestroyed]) {\n            if (this[kOnDestroyed]) {\n                this[kOnDestroyed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        if (!err) {\n            err = new ClientDestroyedError();\n        }\n        this[kDestroyed] = true;\n        this[kOnDestroyed] = this[kOnDestroyed] || [];\n        this[kOnDestroyed].push(callback);\n        const onDestroyed = ()=>{\n            const callbacks = this[kOnDestroyed];\n            this[kOnDestroyed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kDestroy](err).then(()=>{\n            queueMicrotask(onDestroyed);\n        });\n    }\n    [kInterceptedDispatch](opts, handler) {\n        if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n            this[kInterceptedDispatch] = this[kDispatch];\n            return this[kDispatch](opts, handler);\n        }\n        let dispatch = this[kDispatch].bind(this);\n        for(let i = this[kInterceptors].length - 1; i >= 0; i--){\n            dispatch = this[kInterceptors][i](dispatch);\n        }\n        this[kInterceptedDispatch] = dispatch;\n        return dispatch(opts, handler);\n    }\n    dispatch(opts, handler) {\n        if (!handler || typeof handler !== 'object') {\n            throw new InvalidArgumentError('handler must be an object');\n        }\n        try {\n            if (!opts || typeof opts !== 'object') {\n                throw new InvalidArgumentError('opts must be an object.');\n            }\n            if (this[kDestroyed] || this[kOnDestroyed]) {\n                throw new ClientDestroyedError();\n            }\n            if (this[kClosed]) {\n                throw new ClientClosedError();\n            }\n            return this[kInterceptedDispatch](opts, handler);\n        } catch (err) {\n            if (typeof handler.onError !== 'function') {\n                throw new InvalidArgumentError('invalid onError method');\n            }\n            handler.onError(err);\n            return false;\n        }\n    }\n}\nmodule.exports = DispatcherBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXItYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDLDhFQUFjO0FBQ3pDLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyxpQkFBaUIsRUFDakJDLG9CQUFvQixFQUNyQixHQUFHSCxtQkFBT0EsQ0FBQyxzRUFBZ0I7QUFDNUIsTUFBTSxFQUFFSSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFLEdBQUdULG1CQUFPQSxDQUFDLHdFQUFpQjtBQUVyRyxNQUFNVSxlQUFlQyxPQUFPO0FBQzVCLE1BQU1DLFlBQVlELE9BQU87QUFDekIsTUFBTUUsdUJBQXVCRixPQUFPO0FBRXBDLE1BQU1HLHVCQUF1QmY7SUFDM0IsYUFBZTtRQUNiLEtBQUs7UUFFTCxJQUFJLENBQUNRLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNHLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNKLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNNLFVBQVUsR0FBRyxFQUFFO0lBQ3RCO0lBRUEsSUFBSUcsWUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDUixXQUFXO0lBQ3pCO0lBRUEsSUFBSVMsU0FBVTtRQUNaLE9BQU8sSUFBSSxDQUFDVixRQUFRO0lBQ3RCO0lBRUEsSUFBSVcsZUFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUNSLGNBQWM7SUFDNUI7SUFFQSxJQUFJUSxhQUFjQyxlQUFlLEVBQUU7UUFDakMsSUFBSUEsaUJBQWlCO1lBQ25CLElBQUssSUFBSUMsSUFBSUQsZ0JBQWdCRSxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxJQUFLO2dCQUNwRCxNQUFNRSxjQUFjLElBQUksQ0FBQ1osY0FBYyxDQUFDVSxFQUFFO2dCQUMxQyxJQUFJLE9BQU9FLGdCQUFnQixZQUFZO29CQUNyQyxNQUFNLElB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QU8sQ0FBQ2I7WUFFaEIsT0FBTztRQUNUO0lBQ0Y7QUFDRjtBQUVBYyxPQUFPQyxPQUFPLEdBQUc3QiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxkaXNwYXRjaGVyLWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXInKVxuY29uc3Qge1xuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBrRGVzdHJveSwga0Nsb3NlLCBrQ2xvc2VkLCBrRGVzdHJveWVkLCBrRGlzcGF0Y2gsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5cbmNvbnN0IGtPbkRlc3Ryb3llZCA9IFN5bWJvbCgnb25EZXN0cm95ZWQnKVxuY29uc3Qga09uQ2xvc2VkID0gU3ltYm9sKCdvbkNsb3NlZCcpXG5jb25zdCBrSW50ZXJjZXB0ZWREaXNwYXRjaCA9IFN5bWJvbCgnSW50ZXJjZXB0ZWQgRGlzcGF0Y2gnKVxuXG5jbGFzcyBEaXNwYXRjaGVyQmFzZSBleHRlbmRzIERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trRGVzdHJveWVkXSA9IGZhbHNlXG4gICAgdGhpc1trT25EZXN0cm95ZWRdID0gbnVsbFxuICAgIHRoaXNba0Nsb3NlZF0gPSBmYWxzZVxuICAgIHRoaXNba09uQ2xvc2VkXSA9IFtdXG4gIH1cblxuICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trRGVzdHJveWVkXVxuICB9XG5cbiAgZ2V0IGNsb3NlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nsb3NlZF1cbiAgfVxuXG4gIGdldCBpbnRlcmNlcHRvcnMgKCkge1xuICAgIHJldHVybiB0aGlzW2tJbnRlcmNlcHRvcnNdXG4gIH1cblxuICBzZXQgaW50ZXJjZXB0b3JzIChuZXdJbnRlcmNlcHRvcnMpIHtcbiAgICBpZiAobmV3SW50ZXJjZXB0b3JzKSB7XG4gICAgICBmb3IgKGxldCBpID0gbmV3SW50ZXJjZXB0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yID0gdGhpc1trSW50ZXJjZXB0b3JzXVtpXVxuICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnRlcmNlcHRvciBtdXN0IGJlIGFuIGZ1bmN0aW9uJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBuZXdJbnRlcmNlcHRvcnNcbiAgfVxuXG4gIGNsb3NlIChjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpLCBudWxsKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICBpZiAodGhpc1trT25DbG9zZWRdKSB7XG4gICAgICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobnVsbCwgbnVsbCkpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzW2tDbG9zZWRdID0gdHJ1ZVxuICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKVxuXG4gICAgY29uc3Qgb25DbG9zZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkNsb3NlZF1cbiAgICAgIHRoaXNba09uQ2xvc2VkXSA9IG51bGxcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXShudWxsLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCBub3QgZXJyb3IuXG4gICAgdGhpc1trQ2xvc2VdKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuZGVzdHJveSgpKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhvbkNsb3NlZClcbiAgICAgIH0pXG4gIH1cblxuICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZXJyXG4gICAgICBlcnIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciBlcnJvciAqLyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRGVzdHJveWVkXSkge1xuICAgICAgaWYgKHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGVyciA9IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpc1trRGVzdHJveWVkXSA9IHRydWVcbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSB0aGlzW2tPbkRlc3Ryb3llZF0gfHwgW11cbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjaylcblxuICAgIGNvbnN0IG9uRGVzdHJveWVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpc1trT25EZXN0cm95ZWRdXG4gICAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG91bGQgbm90IGVycm9yLlxuICAgIHRoaXNba0Rlc3Ryb3ldKGVycikudGhlbigoKSA9PiB7XG4gICAgICBxdWV1ZU1pY3JvdGFzayhvbkRlc3Ryb3llZClcbiAgICB9KVxuICB9XG5cbiAgW2tJbnRlcmNlcHRlZERpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghdGhpc1trSW50ZXJjZXB0b3JzXSB8fCB0aGlzW2tJbnRlcmNlcHRvcnNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0gPSB0aGlzW2tEaXNwYXRjaF1cbiAgICAgIHJldHVybiB0aGlzW2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgICB9XG5cbiAgICBsZXQgZGlzcGF0Y2ggPSB0aGlzW2tEaXNwYXRjaF0uYmluZCh0aGlzKVxuICAgIGZvciAobGV0IGkgPSB0aGlzW2tJbnRlcmNlcHRvcnNdLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBkaXNwYXRjaCA9IHRoaXNba0ludGVyY2VwdG9yc11baV0oZGlzcGF0Y2gpXG4gICAgfVxuICAgIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdID0gZGlzcGF0Y2hcbiAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMgbXVzdCBiZSBhbiBvYmplY3QuJylcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0gfHwgdGhpc1trT25EZXN0cm95ZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnRDbG9zZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXShvcHRzLCBoYW5kbGVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaGFuZGxlci5vbkVycm9yKGVycilcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlckJhc2VcbiJdLCJuYW1lcyI6WyJEaXNwYXRjaGVyIiwicmVxdWlyZSIsIkNsaWVudERlc3Ryb3llZEVycm9yIiwiQ2xpZW50Q2xvc2VkRXJyb3IiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImtEZXN0cm95Iiwia0Nsb3NlIiwia0Nsb3NlZCIsImtEZXN0cm95ZWQiLCJrRGlzcGF0Y2giLCJrSW50ZXJjZXB0b3JzIiwia09uRGVzdHJveWVkIiwiU3ltYm9sIiwia09uQ2xvc2VkIiwia0ludGVyY2VwdGVkRGlzcGF0Y2giLCJEaXNwYXRjaGVyQmFzZSIsImRlc3Ryb3llZCIsImNsb3NlZCIsImludGVyY2VwdG9ycyIsIm5ld0ludGVyY2VwdG9ycyIsImkiLCJsZW5ndGgiLCJpbnRlcmNlcHRvciIsImNsb3NlIiwiY2FsbGJhY2siLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVyciIsImRhdGEiLCJxdWV1ZU1pY3JvdGFzayIsInB1c2giLCJvbkNsb3NlZCIsImNhbGxiYWNrcyIsInRoZW4iLCJkZXN0cm95Iiwib25EZXN0cm95ZWQiLCJvcHRzIiwiaGFuZGxlciIsImRpc3BhdGNoIiwiYmluZCIsIm9uRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = __webpack_require__(/*! node:events */ \"node:events\");\nclass Dispatcher extends EventEmitter {\n    dispatch() {\n        throw new Error('not implemented');\n    }\n    close() {\n        throw new Error('not implemented');\n    }\n    destroy() {\n        throw new Error('not implemented');\n    }\n    compose(...args) {\n        // So we handle [interceptor1, interceptor2] or interceptor1, interceptor2, ...\n        const interceptors = Array.isArray(args[0]) ? args[0] : args;\n        let dispatch = this.dispatch.bind(this);\n        for (const interceptor of interceptors){\n            if (interceptor == null) {\n                continue;\n            }\n            if (typeof interceptor !== 'function') {\n                throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);\n            }\n            dispatch = interceptor(dispatch);\n            if (dispatch == null || typeof dispatch !== 'function' || dispatch.length !== 2) {\n                throw new TypeError('invalid interceptor');\n            }\n        }\n        return new ComposedDispatcher(this, dispatch);\n    }\n}\nclass ComposedDispatcher extends Dispatcher {\n    #dispatcher;\n    #dispatch;\n    constructor(dispatcher, dispatch){\n        super(), this.#dispatcher = null, this.#dispatch = null;\n        this.#dispatcher = dispatcher;\n        this.#dispatch = dispatch;\n    }\n    dispatch(...args) {\n        this.#dispatch(...args);\n    }\n    close(...args) {\n        return this.#dispatcher.close(...args);\n    }\n    destroy(...args) {\n        return this.#dispatcher.destroy(...args);\n    }\n}\nmodule.exports = Dispatcher;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNQSxlQUFlQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUUxQyxNQUFNQyxtQkFBbUJGO0lBQ3ZCRyxXQUFZO1FBQ1YsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUFDLFFBQVM7UUFDUCxNQUFNLElBQUlELE1BQU07SUFDbEI7SUFFQUUsVUFBVztRQUNULE1BQU0sSUFBSUYsTUFBTTtJQUNsQjtJQUVBRyxRQUFTLEdBQUdDLElBQUksRUFBRTtRQUNoQiwrRUFBK0U7UUFDL0UsTUFBTUMsZUFBZUMsTUFBTUMsT0FBTyxDQUFDSCxJQUFJLENBQUMsRUFBRSxJQUFJQSxJQUFJLENBQUMsRUFBRSxHQUFHQTtRQUN4RCxJQUFJTCxXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDUyxJQUFJLENBQUMsSUFBSTtRQUV0QyxLQUFLLE1BQU1DLGVBQWVKLGFBQWM7WUFDdEMsSUFBSUksZUFBZSxNQUFNO2dCQUN2QjtZQUNGO1lBRUEsSUFBSSxPQUFPQSxnQkFBZ0IsWUFBWTtnQkFDckMsTUFBTSxJQUFJQyxVQUFVLENBQUMsZ0RBQWdELEVBQUUsT0FBT0QsYUFBYTtZQUM3RjtZQUVBVixXQUFXVSxZQUFZVjtZQUV2QixJQUFJQSxZQUFZLFFBQVEsT0FBT0EsYUFBYSxjQUFjQSxTQUFTWSxNQUFNLEtBQUssR0FBRztnQkFDL0UsTUFBTSxJQUFJRCxVQUFVO1lBQ3RCO1FBQ0Y7UUFFQSxPQUFPLElBQUlFLG1CQUFtQixJQUFJLEVBQUViO0lBQ3RDO0FBQ0Y7QUFFQSxNQUFNYSwyQkFBMkJkO0lBQy9CLFdBQVcsQ0FBTztJQUNsQixTQUFTLENBQU87SUFFaEIsWUFBYWUsVUFBVSxFQUFFZCxRQUFRLENBQUU7UUFDakMsS0FBSyxTQUpQLFdBQVcsR0FBRyxXQUNkLFNBQVMsR0FBRztRQUlWLElBQUksQ0FBQyxXQUFXLEdBQUdjO1FBQ25CLElBQUksQ0FBQyxTQUFTLEdBQUdkO0lBQ25CO0lBRUFBLFNBQVUsR0FBR0ssSUFBSSxFQUFFO1FBQ2pCLElBQUksQ0FBQyxTQUFTLElBQUlBO0lBQ3BCO0lBRUFILE1BQU8sR0FBR0csSUFBSSxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDSCxLQUFLLElBQUlHO0lBQ25DO0lBRUFGLFFBQVMsR0FBR0UsSUFBSSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQ0YsT0FBTyxJQUFJRTtJQUNyQztBQUNGO0FBRUFVLE9BQU9DLE9BQU8sR0FBR2pCIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGRpc3BhdGNoZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5cbmNsYXNzIERpc3BhdGNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBkaXNwYXRjaCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGNvbXBvc2UgKC4uLmFyZ3MpIHtcbiAgICAvLyBTbyB3ZSBoYW5kbGUgW2ludGVyY2VwdG9yMSwgaW50ZXJjZXB0b3IyXSBvciBpbnRlcmNlcHRvcjEsIGludGVyY2VwdG9yMiwgLi4uXG4gICAgY29uc3QgaW50ZXJjZXB0b3JzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzXG4gICAgbGV0IGRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpXG5cbiAgICBmb3IgKGNvbnN0IGludGVyY2VwdG9yIG9mIGludGVyY2VwdG9ycykge1xuICAgICAgaWYgKGludGVyY2VwdG9yID09IG51bGwpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVyY2VwdG9yLCBleHBlY3RlZCBmdW5jdGlvbiByZWNlaXZlZCAke3R5cGVvZiBpbnRlcmNlcHRvcn1gKVxuICAgICAgfVxuXG4gICAgICBkaXNwYXRjaCA9IGludGVyY2VwdG9yKGRpc3BhdGNoKVxuXG4gICAgICBpZiAoZGlzcGF0Y2ggPT0gbnVsbCB8fCB0eXBlb2YgZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicgfHwgZGlzcGF0Y2gubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaW50ZXJjZXB0b3InKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29tcG9zZWREaXNwYXRjaGVyKHRoaXMsIGRpc3BhdGNoKVxuICB9XG59XG5cbmNsYXNzIENvbXBvc2VkRGlzcGF0Y2hlciBleHRlbmRzIERpc3BhdGNoZXIge1xuICAjZGlzcGF0Y2hlciA9IG51bGxcbiAgI2Rpc3BhdGNoID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChkaXNwYXRjaGVyLCBkaXNwYXRjaCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLiNkaXNwYXRjaGVyID0gZGlzcGF0Y2hlclxuICAgIHRoaXMuI2Rpc3BhdGNoID0gZGlzcGF0Y2hcbiAgfVxuXG4gIGRpc3BhdGNoICguLi5hcmdzKSB7XG4gICAgdGhpcy4jZGlzcGF0Y2goLi4uYXJncylcbiAgfVxuXG4gIGNsb3NlICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rpc3BhdGNoZXIuY2xvc2UoLi4uYXJncylcbiAgfVxuXG4gIGRlc3Ryb3kgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jZGlzcGF0Y2hlci5kZXN0cm95KC4uLmFyZ3MpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyXG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsIkRpc3BhdGNoZXIiLCJkaXNwYXRjaCIsIkVycm9yIiwiY2xvc2UiLCJkZXN0cm95IiwiY29tcG9zZSIsImFyZ3MiLCJpbnRlcmNlcHRvcnMiLCJBcnJheSIsImlzQXJyYXkiLCJiaW5kIiwiaW50ZXJjZXB0b3IiLCJUeXBlRXJyb3IiLCJsZW5ndGgiLCJDb21wb3NlZERpc3BhdGNoZXIiLCJkaXNwYXRjaGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js":
/*!********************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst ProxyAgent = __webpack_require__(/*! ./proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nconst DEFAULT_PORTS = {\n    'http:': 80,\n    'https:': 443\n};\nlet experimentalWarned = false;\nclass EnvHttpProxyAgent extends DispatcherBase {\n    #noProxyValue;\n    #noProxyEntries;\n    #opts;\n    constructor(opts = {}){\n        super(), this.#noProxyValue = null, this.#noProxyEntries = null, this.#opts = null;\n        this.#opts = opts;\n        if (!experimentalWarned) {\n            experimentalWarned = true;\n            process.emitWarning('EnvHttpProxyAgent is experimental, expect them to change at any time.', {\n                code: 'UNDICI-EHPA'\n            });\n        }\n        const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;\n        this[kNoProxyAgent] = new Agent(agentOpts);\n        const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;\n        if (HTTP_PROXY) {\n            this[kHttpProxyAgent] = new ProxyAgent({\n                ...agentOpts,\n                uri: HTTP_PROXY\n            });\n        } else {\n            this[kHttpProxyAgent] = this[kNoProxyAgent];\n        }\n        const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;\n        if (HTTPS_PROXY) {\n            this[kHttpsProxyAgent] = new ProxyAgent({\n                ...agentOpts,\n                uri: HTTPS_PROXY\n            });\n        } else {\n            this[kHttpsProxyAgent] = this[kHttpProxyAgent];\n        }\n        this.#parseNoProxy();\n    }\n    [kDispatch](opts, handler) {\n        const url = new URL(opts.origin);\n        const agent = this.#getProxyAgentForUrl(url);\n        return agent.dispatch(opts, handler);\n    }\n    async [kClose]() {\n        await this[kNoProxyAgent].close();\n        if (!this[kHttpProxyAgent][kClosed]) {\n            await this[kHttpProxyAgent].close();\n        }\n        if (!this[kHttpsProxyAgent][kClosed]) {\n            await this[kHttpsProxyAgent].close();\n        }\n    }\n    async [kDestroy](err) {\n        await this[kNoProxyAgent].destroy(err);\n        if (!this[kHttpProxyAgent][kDestroyed]) {\n            await this[kHttpProxyAgent].destroy(err);\n        }\n        if (!this[kHttpsProxyAgent][kDestroyed]) {\n            await this[kHttpsProxyAgent].destroy(err);\n        }\n    }\n    #getProxyAgentForUrl(url) {\n        let { protocol, host: hostname, port } = url;\n        // Stripping ports in this way instead of using parsedUrl.hostname to make\n        // sure that the brackets around IPv6 addresses are kept.\n        hostname = hostname.replace(/:\\d*$/, '').toLowerCase();\n        port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;\n        if (!this.#shouldProxy(hostname, port)) {\n            return this[kNoProxyAgent];\n        }\n        if (protocol === 'https:') {\n            return this[kHttpsProxyAgent];\n        }\n        return this[kHttpProxyAgent];\n    }\n    #shouldProxy(hostname, port) {\n        if (this.#noProxyChanged) {\n            this.#parseNoProxy();\n        }\n        if (this.#noProxyEntries.length === 0) {\n            return true // Always proxy if NO_PROXY is not set or empty.\n            ;\n        }\n        if (this.#noProxyValue === '*') {\n            return false // Never proxy if wildcard is set.\n            ;\n        }\n        for(let i = 0; i < this.#noProxyEntries.length; i++){\n            const entry = this.#noProxyEntries[i];\n            if (entry.port && entry.port !== port) {\n                continue; // Skip if ports don't match.\n            }\n            if (!/^[.*]/.test(entry.hostname)) {\n                // No wildcards, so don't proxy only if there is not an exact match.\n                if (hostname === entry.hostname) {\n                    return false;\n                }\n            } else {\n                // Don't proxy if the hostname ends with the no_proxy host.\n                if (hostname.endsWith(entry.hostname.replace(/^\\*/, ''))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    #parseNoProxy() {\n        const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;\n        const noProxySplit = noProxyValue.split(/[,\\s]/);\n        const noProxyEntries = [];\n        for(let i = 0; i < noProxySplit.length; i++){\n            const entry = noProxySplit[i];\n            if (!entry) {\n                continue;\n            }\n            const parsed = entry.match(/^(.+):(\\d+)$/);\n            noProxyEntries.push({\n                hostname: (parsed ? parsed[1] : entry).toLowerCase(),\n                port: parsed ? Number.parseInt(parsed[2], 10) : 0\n            });\n        }\n        this.#noProxyValue = noProxyValue;\n        this.#noProxyEntries = noProxyEntries;\n    }\n    get #noProxyChanged() {\n        if (this.#opts.noProxy !== undefined) {\n            return false;\n        }\n        return this.#noProxyValue !== this.#noProxyEnv;\n    }\n    get #noProxyEnv() {\n        return process.env.no_proxy ?? process.env.NO_PROXY ?? '';\n    }\n}\nmodule.exports = EnvHttpProxyAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsaUJBQWlCQyxtQkFBT0EsQ0FBQyx3RkFBbUI7QUFDbEQsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFLEdBQUdSLG1CQUFPQSxDQUFDLHdFQUFpQjtBQUN4SSxNQUFNUyxhQUFhVCxtQkFBT0EsQ0FBQyxnRkFBZTtBQUMxQyxNQUFNVSxRQUFRVixtQkFBT0EsQ0FBQyxvRUFBUztBQUUvQixNQUFNVyxnQkFBZ0I7SUFDcEIsU0FBUztJQUNULFVBQVU7QUFDWjtBQUVBLElBQUlDLHFCQUFxQjtBQUV6QixNQUFNQywwQkFBMEJkO0lBQzlCLGFBQWEsQ0FBTztJQUNwQixlQUFlLENBQU87SUFDdEIsS0FBSyxDQUFPO0lBRVosWUFBYWUsT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUN0QixLQUFLLFNBTFAsYUFBYSxHQUFHLFdBQ2hCLGVBQWUsR0FBRyxXQUNsQixLQUFLLEdBQUc7UUFJTixJQUFJLENBQUMsS0FBSyxHQUFHQTtRQUViLElBQUksQ0FBQ0Ysb0JBQW9CO1lBQ3ZCQSxxQkFBcUI7WUFDckJHLFFBQVFDLFdBQVcsQ0FBQyx5RUFBeUU7Z0JBQzNGQyxNQUFNO1lBQ1I7UUFDRjtRQUVBLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRSxHQUFHQyxXQUFXLEdBQUdQO1FBRXpELElBQUksQ0FBQ1IsY0FBYyxHQUFHLElBQUlJLE1BQU1XO1FBRWhDLE1BQU1DLGFBQWFKLGFBQWFILFFBQVFRLEdBQUcsQ0FBQ0MsVUFBVSxJQUFJVCxRQUFRUSxHQUFHLENBQUNELFVBQVU7UUFDaEYsSUFBSUEsWUFBWTtZQUNkLElBQUksQ0FBQ2YsZ0JBQWdC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QyxLQUFLLENBQUNqQyxPQUFPLEtBQUtxQyxXQUFXO1lBQ3BDLE9BQU87UUFDVDtRQUNBLE9BQU8sSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJLENBQUMsV0FBVztJQUNoRDtJQUVBLElBQUksV0FBVztRQUNiLE9BQU8xQyxRQUFRUSxHQUFHLENBQUNtQyxRQUFRLElBQUkzQyxRQUFRUSxHQUFHLENBQUNvQyxRQUFRLElBQUk7SUFDekQ7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdoRCIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxlbnYtaHR0cC1wcm94eS1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7IGtDbG9zZSwga0Rlc3Ryb3ksIGtDbG9zZWQsIGtEZXN0cm95ZWQsIGtEaXNwYXRjaCwga05vUHJveHlBZ2VudCwga0h0dHBQcm94eUFnZW50LCBrSHR0cHNQcm94eUFnZW50IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vcHJveHktYWdlbnQnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50JylcblxuY29uc3QgREVGQVVMVF9QT1JUUyA9IHtcbiAgJ2h0dHA6JzogODAsXG4gICdodHRwczonOiA0NDNcbn1cblxubGV0IGV4cGVyaW1lbnRhbFdhcm5lZCA9IGZhbHNlXG5cbmNsYXNzIEVudkh0dHBQcm94eUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAjbm9Qcm94eVZhbHVlID0gbnVsbFxuICAjbm9Qcm94eUVudHJpZXMgPSBudWxsXG4gICNvcHRzID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy4jb3B0cyA9IG9wdHNcblxuICAgIGlmICghZXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgICBleHBlcmltZW50YWxXYXJuZWQgPSB0cnVlXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdFbnZIdHRwUHJveHlBZ2VudCBpcyBleHBlcmltZW50YWwsIGV4cGVjdCB0aGVtIHRvIGNoYW5nZSBhdCBhbnkgdGltZS4nLCB7XG4gICAgICAgIGNvZGU6ICdVTkRJQ0ktRUhQQSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgeyBodHRwUHJveHksIGh0dHBzUHJveHksIG5vUHJveHksIC4uLmFnZW50T3B0cyB9ID0gb3B0c1xuXG4gICAgdGhpc1trTm9Qcm94eUFnZW50XSA9IG5ldyBBZ2VudChhZ2VudE9wdHMpXG5cbiAgICBjb25zdCBIVFRQX1BST1hZID0gaHR0cFByb3h5ID8/IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgPz8gcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWVxuICAgIGlmIChIVFRQX1BST1hZKSB7XG4gICAgICB0aGlzW2tIdHRwUHJveHlBZ2VudF0gPSBuZXcgUHJveHlBZ2VudCh7IC4uLmFnZW50T3B0cywgdXJpOiBIVFRQX1BST1hZIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0h0dHBQcm94eUFnZW50XSA9IHRoaXNba05vUHJveHlBZ2VudF1cbiAgICB9XG5cbiAgICBjb25zdCBIVFRQU19QUk9YWSA9IGh0dHBzUHJveHkgPz8gcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgPz8gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFlcbiAgICBpZiAoSFRUUFNfUFJPWFkpIHtcbiAgICAgIHRoaXNba0h0dHBzUHJveHlBZ2VudF0gPSBuZXcgUHJveHlBZ2VudCh7IC4uLmFnZW50T3B0cywgdXJpOiBIVFRQU19QUk9YWSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdID0gdGhpc1trSHR0cFByb3h5QWdlbnRdXG4gICAgfVxuXG4gICAgdGhpcy4jcGFyc2VOb1Byb3h5KClcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChvcHRzLm9yaWdpbilcbiAgICBjb25zdCBhZ2VudCA9IHRoaXMuI2dldFByb3h5QWdlbnRGb3JVcmwodXJsKVxuICAgIHJldHVybiBhZ2VudC5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHRoaXNba05vUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIGlmICghdGhpc1trSHR0cFByb3h5QWdlbnRdW2tDbG9zZWRdKSB7XG4gICAgICBhd2FpdCB0aGlzW2tIdHRwUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIH1cbiAgICBpZiAoIXRoaXNba0h0dHBzUHJveHlBZ2VudF1ba0Nsb3NlZF0pIHtcbiAgICAgIGF3YWl0IHRoaXNba0h0dHBzUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIGF3YWl0IHRoaXNba05vUHJveHlBZ2VudF0uZGVzdHJveShlcnIpXG4gICAgaWYgKCF0aGlzW2tIdHRwUHJveHlBZ2VudF1ba0Rlc3Ryb3llZF0pIHtcbiAgICAgIGF3YWl0IHRoaXNba0h0dHBQcm94eUFnZW50XS5kZXN0cm95KGVycilcbiAgICB9XG4gICAgaWYgKCF0aGlzW2tIdHRwc1Byb3h5QWdlbnRdW2tEZXN0cm95ZWRdKSB7XG4gICAgICBhd2FpdCB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxuXG4gICNnZXRQcm94eUFnZW50Rm9yVXJsICh1cmwpIHtcbiAgICBsZXQgeyBwcm90b2NvbCwgaG9zdDogaG9zdG5hbWUsIHBvcnQgfSA9IHVybFxuXG4gICAgLy8gU3RyaXBwaW5nIHBvcnRzIGluIHRoaXMgd2F5IGluc3RlYWQgb2YgdXNpbmcgcGFyc2VkVXJsLmhvc3RuYW1lIHRvIG1ha2VcbiAgICAvLyBzdXJlIHRoYXQgdGhlIGJyYWNrZXRzIGFyb3VuZCBJUHY2IGFkZHJlc3NlcyBhcmUga2VwdC5cbiAgICBob3N0bmFtZSA9IGhvc3RuYW1lLnJlcGxhY2UoLzpcXGQqJC8sICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgcG9ydCA9IE51bWJlci5wYXJzZUludChwb3J0LCAxMCkgfHwgREVGQVVMVF9QT1JUU1twcm90b2NvbF0gfHwgMFxuICAgIGlmICghdGhpcy4jc2hvdWxkUHJveHkoaG9zdG5hbWUsIHBvcnQpKSB7XG4gICAgICByZXR1cm4gdGhpc1trTm9Qcm94eUFnZW50XVxuICAgIH1cbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICByZXR1cm4gdGhpc1trSHR0cHNQcm94eUFnZW50XVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1trSHR0cFByb3h5QWdlbnRdXG4gIH1cblxuICAjc2hvdWxkUHJveHkgKGhvc3RuYW1lLCBwb3J0KSB7XG4gICAgaWYgKHRoaXMuI25vUHJveHlDaGFuZ2VkKSB7XG4gICAgICB0aGlzLiNwYXJzZU5vUHJveHkoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiNub1Byb3h5RW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlIC8vIEFsd2F5cyBwcm94eSBpZiBOT19QUk9YWSBpcyBub3Qgc2V0IG9yIGVtcHR5LlxuICAgIH1cbiAgICBpZiAodGhpcy4jbm9Qcm94eVZhbHVlID09PSAnKicpIHtcbiAgICAgIHJldHVybiBmYWxzZSAvLyBOZXZlciBwcm94eSBpZiB3aWxkY2FyZCBpcyBzZXQuXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNub1Byb3h5RW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLiNub1Byb3h5RW50cmllc1tpXVxuICAgICAgaWYgKGVudHJ5LnBvcnQgJiYgZW50cnkucG9ydCAhPT0gcG9ydCkge1xuICAgICAgICBjb250aW51ZSAvLyBTa2lwIGlmIHBvcnRzIGRvbid0IG1hdGNoLlxuICAgICAgfVxuICAgICAgaWYgKCEvXlsuKl0vLnRlc3QoZW50cnkuaG9zdG5hbWUpKSB7XG4gICAgICAgIC8vIE5vIHdpbGRjYXJkcywgc28gZG9uJ3QgcHJveHkgb25seSBpZiB0aGVyZSBpcyBub3QgYW4gZXhhY3QgbWF0Y2guXG4gICAgICAgIGlmIChob3N0bmFtZSA9PT0gZW50cnkuaG9zdG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG9uJ3QgcHJveHkgaWYgdGhlIGhvc3RuYW1lIGVuZHMgd2l0aCB0aGUgbm9fcHJveHkgaG9zdC5cbiAgICAgICAgaWYgKGhvc3RuYW1lLmVuZHNXaXRoKGVudHJ5Lmhvc3RuYW1lLnJlcGxhY2UoL15cXCovLCAnJykpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgI3BhcnNlTm9Qcm94eSAoKSB7XG4gICAgY29uc3Qgbm9Qcm94eVZhbHVlID0gdGhpcy4jb3B0cy5ub1Byb3h5ID8/IHRoaXMuI25vUHJveHlFbnZcbiAgICBjb25zdCBub1Byb3h5U3BsaXQgPSBub1Byb3h5VmFsdWUuc3BsaXQoL1ssXFxzXS8pXG4gICAgY29uc3Qgbm9Qcm94eUVudHJpZXMgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub1Byb3h5U3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gbm9Qcm94eVNwbGl0W2ldXG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWQgPSBlbnRyeS5tYXRjaCgvXiguKyk6KFxcZCspJC8pXG4gICAgICBub1Byb3h5RW50cmllcy5wdXNoKHtcbiAgICAgICAgaG9zdG5hbWU6IChwYXJzZWQgPyBwYXJzZWRbMV0gOiBlbnRyeSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcG9ydDogcGFyc2VkID8gTnVtYmVyLnBhcnNlSW50KHBhcnNlZFsyXSwgMTApIDogMFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLiNub1Byb3h5VmFsdWUgPSBub1Byb3h5VmFsdWVcbiAgICB0aGlzLiNub1Byb3h5RW50cmllcyA9IG5vUHJveHlFbnRyaWVzXG4gIH1cblxuICBnZXQgI25vUHJveHlDaGFuZ2VkICgpIHtcbiAgICBpZiAodGhpcy4jb3B0cy5ub1Byb3h5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jbm9Qcm94eVZhbHVlICE9PSB0aGlzLiNub1Byb3h5RW52XG4gIH1cblxuICBnZXQgI25vUHJveHlFbnYgKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ub19wcm94eSA/PyBwcm9jZXNzLmVudi5OT19QUk9YWSA/PyAnJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW52SHR0cFByb3h5QWdlbnRcbiJdLCJuYW1lcyI6WyJEaXNwYXRjaGVyQmFzZSIsInJlcXVpcmUiLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtDbG9zZWQiLCJrRGVzdHJveWVkIiwia0Rpc3BhdGNoIiwia05vUHJveHlBZ2VudCIsImtIdHRwUHJveHlBZ2VudCIsImtIdHRwc1Byb3h5QWdlbnQiLCJQcm94eUFnZW50IiwiQWdlbnQiLCJERUZBVUxUX1BPUlRTIiwiZXhwZXJpbWVudGFsV2FybmVkIiwiRW52SHR0cFByb3h5QWdlbnQiLCJvcHRzIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiY29kZSIsImh0dHBQcm94eSIsImh0dHBzUHJveHkiLCJub1Byb3h5IiwiYWdlbnRPcHRzIiwiSFRUUF9QUk9YWSIsImVudiIsImh0dHBfcHJveHkiLCJ1cmkiLCJIVFRQU19QUk9YWSIsImh0dHBzX3Byb3h5IiwiaGFuZGxlciIsInVybCIsIlVSTCIsIm9yaWdpbiIsImFnZW50IiwiZGlzcGF0Y2giLCJjbG9zZSIsImVyciIsImRlc3Ryb3kiLCJwcm90b2NvbCIsImhvc3QiLCJob3N0bmFtZSIsInBvcnQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJwYXJzZUludCIsImxlbmd0aCIsImkiLCJlbnRyeSIsInRlc3QiLCJlbmRzV2l0aCIsIm5vUHJveHlWYWx1ZSIsIm5vUHJveHlTcGxpdCIsInNwbGl0Iiwibm9Qcm94eUVudHJpZXMiLCJwYXJzZWQiLCJtYXRjaCIsInB1c2giLCJ1bmRlZmluZWQiLCJub19wcm94eSIsIk5PX1BST1hZIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/fixed-queue.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/* eslint-disable */ \n// Extracted from node/lib/internal/fixed_queue.js\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\nclass FixedCircularBuffer {\n    constructor(){\n        this.bottom = 0;\n        this.top = 0;\n        this.list = new Array(kSize);\n        this.next = null;\n    }\n    isEmpty() {\n        return this.top === this.bottom;\n    }\n    isFull() {\n        return (this.top + 1 & kMask) === this.bottom;\n    }\n    push(data) {\n        this.list[this.top] = data;\n        this.top = this.top + 1 & kMask;\n    }\n    shift() {\n        const nextItem = this.list[this.bottom];\n        if (nextItem === undefined) return null;\n        this.list[this.bottom] = undefined;\n        this.bottom = this.bottom + 1 & kMask;\n        return nextItem;\n    }\n}\nmodule.exports = class FixedQueue {\n    constructor(){\n        this.head = this.tail = new FixedCircularBuffer();\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n    push(data) {\n        if (this.head.isFull()) {\n            // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n            // and sets it as the new main queue.\n            this.head = this.head.next = new FixedCircularBuffer();\n        }\n        this.head.push(data);\n    }\n    shift() {\n        const tail = this.tail;\n        const next = tail.shift();\n        if (tail.isEmpty() && tail.next !== null) {\n            // If there is another queue, it forms the new tail.\n            this.tail = tail.next;\n        }\n        return next;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixHQUVsQjtBQUVBLGtEQUFrRDtBQUVsRCw4RUFBOEU7QUFDOUUsTUFBTUEsUUFBUTtBQUNkLE1BQU1DLFFBQVFELFFBQVE7QUFFdEIsc0VBQXNFO0FBQ3RFLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0YsbUVBQW1FO0FBQ25FLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEUsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLEVBQUU7QUFDRiwrREFBK0Q7QUFDL0Qsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pELHlEQUF5RDtBQUN6RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsRUFBRTtBQUNGLG1FQUFtRTtBQUNuRSxvRUFBb0U7QUFDcEUsZ0JBQWdCO0FBQ2hCLEVBQUU7QUFDRiw0REFBNEQ7QUFDNUQsd0VBQXdFO0FBQ3hFLGtDQUFrQztBQUVsQyxNQUFNRTtJQUNKLGFBQWM7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSUMsTUFBTU47UUFDdEIsSUFBSSxDQUFDTyxJQUFJLEdBQUc7SUFDZDtJQUVBQyxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNKLEdBQUcsS0FBSyxJQUFJLENBQUNELE1BQU07SUFDakM7SUFFQU0sU0FBUztRQUNQLE9BQU8sQ0FBQyxJQUFLLENBQUNMLEdBQUcsR0FBRyxJQUFLSCxLQUFJLE1BQU8sSUFBSSxDQUFDRSxNQUFNO0lBQ2pEO0lBRUFPLEtBQUtDLElBQUksRUFBRTtRQUNULElBQUksQ0FBQ04sSUFBSSxDQUFDLElBQUksQ0FBQ0QsR0FBRyxDQUFDLEdBQUdPO1FBQ3RCLElBQUksQ0FBQ1AsR0FBRyxHQUFHLElBQUssQ0FBQ0EsR0FBRyxHQUFHLElBQUtIO0lBQzlCO0lBRUFXLFFBQVE7UUFDTixNQUFNQyxXQUFXLElBQUksQ0FBQ1IsSUFBSSxDQUFDLElBQUksQ0FBQ0YsTUFBTSxDQUFDO1FBQ3ZDLElBQUlVLGFBQWFDLFdBQ2YsT0FBTztRQUNULElBQUksQ0FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQ0YsTUFBTSxDQUFDLEdBQUdXO1FBQ3pCLElBQUksQ0FBQ1gsTUFBTSxHQUFHLElBQUssQ0FBQ0EsTUFBTSxHQUFHLElBQUtGO1FBQ2xDLE9BQU9ZO0lBQ1Q7QUFDRjtBQUVBRSxPQUFPQyxPQUFPLEdBQUcsTUFBTUM7SUFDckIsYUFBYztRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlqQjtJQUM5QjtJQUVBTSxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNVLElBQUksQ0FBQ1YsT0FBTztJQUMxQjtJQUVBRSxLQUFLQyxJQUFJLEVBQUU7UUFDVCxJQUFJLElBQUksQ0FBQ08sSUFBSSxDQUFDVCxNQUFNLElBQUk7WUFDdEIseUVBQXlFO1lBQ3pFLHFDQUFxQztZQUNyQyxJQUFJLENBQUNTLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQ1gsSUFBSSxHQUFHLElBQUlMO1FBQ25DO1FBQ0EsSUFBSSxDQUFDZ0IsSUFBSSxDQUFDUixJQUFJLENBQUNDO0lBQ2pCO0lBRUFDLFFBQVE7UUFDTixNQUFNTyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNWixPQUFPWSxLQUFLUCxLQUFLO1FBQ3ZCLElBQUlPLEtBQUtYLE9BQU8sTUFBTVcsS0FBS1osSUFBSSxLQUFLLE1BQU07WUFDeEMsb0RBQW9EO1lBQ3BELElBQUksQ0FBQ1ksSUFBSSxHQUFHQSxLQUFLWixJQUFJO1FBQ3ZCO1FBQ0EsT0FBT0E7SUFDVDtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGZpeGVkLXF1ZXVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vLyBFeHRyYWN0ZWQgZnJvbSBub2RlL2xpYi9pbnRlcm5hbC9maXhlZF9xdWV1ZS5qc1xuXG4vLyBDdXJyZW50bHkgb3B0aW1hbCBxdWV1ZSBzaXplLCB0ZXN0ZWQgb24gVjggNi4wIC0gNi42LiBNdXN0IGJlIHBvd2VyIG9mIHR3by5cbmNvbnN0IGtTaXplID0gMjA0ODtcbmNvbnN0IGtNYXNrID0ga1NpemUgLSAxO1xuXG4vLyBUaGUgRml4ZWRRdWV1ZSBpcyBpbXBsZW1lbnRlZCBhcyBhIHNpbmdseS1saW5rZWQgbGlzdCBvZiBmaXhlZC1zaXplXG4vLyBjaXJjdWxhciBidWZmZXJzLiBJdCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICBoZWFkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxcbi8vICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2XG4vLyArLS0tLS0tLS0tLS0rIDwtLS0tLVxcICAgICAgICstLS0tLS0tLS0tLSsgPC0tLS0tLVxcICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgXFwtLS0tLSB8ICAgbmV4dCAgICB8ICAgICAgICAgXFwtLS0tLS0tIHwgICBuZXh0ICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICBib3R0b20gLS0+IHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgICAuLi4gICAgfCAgICAgICAgICAgICAgIHwgICAgLi4uICAgIHwgICAgICAgICAgICAgICAgICB8ICAgIC4uLiAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCA8LS0gdG9wICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8IDwtLSB0b3AgIHRvcCAtLT4gfCAgW2VtcHR5XSAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vL1xuLy8gT3IsIGlmIHRoZXJlIGlzIG9ubHkgb25lIGNpcmN1bGFyIGJ1ZmZlciwgaXQgbG9va3Mgc29tZXRoaW5nXG4vLyBsaWtlIGVpdGhlciBvZiB0aGVzZTpcbi8vXG4vLyAgaGVhZCAgIHRhaWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkICAgdGFpbFxuLy8gICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8XG4vLyAgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgICAgIHZcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbbnVsbF0gICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgICAgICAgICB0b3AgLS0+IHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgW2VtcHR5XSAgfCA8LS0gdG9wICAgICAgICAgICAgYm90dG9tIC0tPiB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy9cbi8vIEFkZGluZyBhIHZhbHVlIG1lYW5zIG1vdmluZyBgdG9wYCBmb3J3YXJkIGJ5IG9uZSwgcmVtb3ZpbmcgbWVhbnNcbi8vIG1vdmluZyBgYm90dG9tYCBmb3J3YXJkIGJ5IG9uZS4gQWZ0ZXIgcmVhY2hpbmcgdGhlIGVuZCwgdGhlIHF1ZXVlXG4vLyB3cmFwcyBhcm91bmQuXG4vL1xuLy8gV2hlbiBgdG9wID09PSBib3R0b21gIHRoZSBjdXJyZW50IHF1ZXVlIGlzIGVtcHR5IGFuZCB3aGVuXG4vLyBgdG9wICsgMSA9PT0gYm90dG9tYCBpdCdzIGZ1bGwuIFRoaXMgd2FzdGVzIGEgc2luZ2xlIHNwYWNlIG9mIHN0b3JhZ2Vcbi8vIGJ1dCBhbGxvd3MgbXVjaCBxdWlja2VyIGNoZWNrcy5cblxuY2xhc3MgRml4ZWRDaXJjdWxhckJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYm90dG9tID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG4gICAgdGhpcy5saXN0ID0gbmV3IEFycmF5KGtTaXplKTtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50b3AgPT09IHRoaXMuYm90dG9tO1xuICB9XG5cbiAgaXNGdWxsKCkge1xuICAgIHJldHVybiAoKHRoaXMudG9wICsgMSkgJiBrTWFzaykgPT09IHRoaXMuYm90dG9tO1xuICB9XG5cbiAgcHVzaChkYXRhKSB7XG4gICAgdGhpcy5saXN0W3RoaXMudG9wXSA9IGRhdGE7XG4gICAgdGhpcy50b3AgPSAodGhpcy50b3AgKyAxKSAmIGtNYXNrO1xuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLmxpc3RbdGhpcy5ib3R0b21dO1xuICAgIGlmIChuZXh0SXRlbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5saXN0W3RoaXMuYm90dG9tXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9ICh0aGlzLmJvdHRvbSArIDEpICYga01hc2s7XG4gICAgcmV0dXJuIG5leHRJdGVtO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRml4ZWRRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKCk7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQuaXNFbXB0eSgpO1xuICB9XG5cbiAgcHVzaChkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGVhZC5pc0Z1bGwoKSkge1xuICAgICAgLy8gSGVhZCBpcyBmdWxsOiBDcmVhdGVzIGEgbmV3IHF1ZXVlLCBzZXRzIHRoZSBvbGQgcXVldWUncyBgLm5leHRgIHRvIGl0LFxuICAgICAgLy8gYW5kIHNldHMgaXQgYXMgdGhlIG5ldyBtYWluIHF1ZXVlLlxuICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQgPSBuZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcigpO1xuICAgIH1cbiAgICB0aGlzLmhlYWQucHVzaChkYXRhKTtcbiAgfVxuXG4gIHNoaWZ0KCkge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgY29uc3QgbmV4dCA9IHRhaWwuc2hpZnQoKTtcbiAgICBpZiAodGFpbC5pc0VtcHR5KCkgJiYgdGFpbC5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhbm90aGVyIHF1ZXVlLCBpdCBmb3JtcyB0aGUgbmV3IHRhaWwuXG4gICAgICB0aGlzLnRhaWwgPSB0YWlsLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9XG59O1xuIl0sIm5hbWVzIjpbImtTaXplIiwia01hc2siLCJGaXhlZENpcmN1bGFyQnVmZmVyIiwiYm90dG9tIiwidG9wIiwibGlzdCIsIkFycmF5IiwibmV4dCIsImlzRW1wdHkiLCJpc0Z1bGwiLCJwdXNoIiwiZGF0YSIsInNoaWZ0IiwibmV4dEl0ZW0iLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwiRml4ZWRRdWV1ZSIsImhlYWQiLCJ0YWlsIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst FixedQueue = __webpack_require__(/*! ./fixed-queue */ \"(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\");\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst PoolStats = __webpack_require__(/*! ./pool-stats */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js\");\nconst kClients = Symbol('clients');\nconst kNeedDrain = Symbol('needDrain');\nconst kQueue = Symbol('queue');\nconst kClosedResolve = Symbol('closed resolve');\nconst kOnDrain = Symbol('onDrain');\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kGetDispatcher = Symbol('get dispatcher');\nconst kAddClient = Symbol('add client');\nconst kRemoveClient = Symbol('remove client');\nconst kStats = Symbol('stats');\nclass PoolBase extends DispatcherBase {\n    constructor(){\n        super();\n        this[kQueue] = new FixedQueue();\n        this[kClients] = [];\n        this[kQueued] = 0;\n        const pool = this;\n        this[kOnDrain] = function onDrain(origin, targets) {\n            const queue = pool[kQueue];\n            let needDrain = false;\n            while(!needDrain){\n                const item = queue.shift();\n                if (!item) {\n                    break;\n                }\n                pool[kQueued]--;\n                needDrain = !this.dispatch(item.opts, item.handler);\n            }\n            this[kNeedDrain] = needDrain;\n            if (!this[kNeedDrain] && pool[kNeedDrain]) {\n                pool[kNeedDrain] = false;\n                pool.emit('drain', origin, [\n                    pool,\n                    ...targets\n                ]);\n            }\n            if (pool[kClosedResolve] && queue.isEmpty()) {\n                Promise.all(pool[kClients].map((c)=>c.close())).then(pool[kClosedResolve]);\n            }\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            pool.emit('connect', origin, [\n                pool,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            pool.emit('disconnect', origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            pool.emit('connectionError', origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kStats] = new PoolStats(this);\n    }\n    get [kBusy]() {\n        return this[kNeedDrain];\n    }\n    get [kConnected]() {\n        return this[kClients].filter((client)=>client[kConnected]).length;\n    }\n    get [kFree]() {\n        return this[kClients].filter((client)=>client[kConnected] && !client[kNeedDrain]).length;\n    }\n    get [kPending]() {\n        let ret = this[kQueued];\n        for (const { [kPending]: pending } of this[kClients]){\n            ret += pending;\n        }\n        return ret;\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const { [kRunning]: running } of this[kClients]){\n            ret += running;\n        }\n        return ret;\n    }\n    get [kSize]() {\n        let ret = this[kQueued];\n        for (const { [kSize]: size } of this[kClients]){\n            ret += size;\n        }\n        return ret;\n    }\n    get stats() {\n        return this[kStats];\n    }\n    async [kClose]() {\n        if (this[kQueue].isEmpty()) {\n            return Promise.all(this[kClients].map((c)=>c.close()));\n        } else {\n            return new Promise((resolve)=>{\n                this[kClosedResolve] = resolve;\n            });\n        }\n    }\n    async [kDestroy](err) {\n        while(true){\n            const item = this[kQueue].shift();\n            if (!item) {\n                break;\n            }\n            item.handler.onError(err);\n        }\n        return Promise.all(this[kClients].map((c)=>c.destroy(err)));\n    }\n    [kDispatch](opts, handler) {\n        const dispatcher = this[kGetDispatcher]();\n        if (!dispatcher) {\n            this[kNeedDrain] = true;\n            this[kQueue].push({\n                opts,\n                handler\n            });\n            this[kQueued]++;\n        } else if (!dispatcher.dispatch(opts, handler)) {\n            dispatcher[kNeedDrain] = true;\n            this[kNeedDrain] = !this[kGetDispatcher]();\n        }\n        return !this[kNeedDrain];\n    }\n    [kAddClient](client) {\n        client.on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n        this[kClients].push(client);\n        if (this[kNeedDrain]) {\n            queueMicrotask(()=>{\n                if (this[kNeedDrain]) {\n                    this[kOnDrain](client[kUrl], [\n                        this,\n                        client\n                    ]);\n                }\n            });\n        }\n        return this;\n    }\n    [kRemoveClient](client) {\n        client.close(()=>{\n            const idx = this[kClients].indexOf(client);\n            if (idx !== -1) {\n                this[kClients].splice(idx, 1);\n            }\n        });\n        this[kNeedDrain] = this[kClients].some((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n    }\n}\nmodule.exports = {\n    PoolBase,\n    kClients,\n    kNeedDrain,\n    kAddClient,\n    kRemoveClient,\n    kGetDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGlCQUFpQkMsbUJBQU9BLENBQUMsd0ZBQW1CO0FBQ2xELE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGdGQUFlO0FBQzFDLE1BQU0sRUFBRUUsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR1osbUJBQU9BLENBQUMsd0VBQWlCO0FBQ3JJLE1BQU1hLFlBQVliLG1CQUFPQSxDQUFDLDhFQUFjO0FBRXhDLE1BQU1jLFdBQVdDLE9BQU87QUFDeEIsTUFBTUMsYUFBYUQsT0FBTztBQUMxQixNQUFNRSxTQUFTRixPQUFPO0FBQ3RCLE1BQU1HLGlCQUFpQkgsT0FBTztBQUM5QixNQUFNSSxXQUFXSixPQUFPO0FBQ3hCLE1BQU1LLGFBQWFMLE9BQU87QUFDMUIsTUFBTU0sZ0JBQWdCTixPQUFPO0FBQzdCLE1BQU1PLHFCQUFxQlAsT0FBTztBQUNsQyxNQUFNUSxpQkFBaUJSLE9BQU87QUFDOUIsTUFBTVMsYUFBYVQsT0FBTztBQUMxQixNQUFNVSxnQkFBZ0JWLE9BQU87QUFDN0IsTUFBTVcsU0FBU1gsT0FBTztBQUV0QixNQUFNWSxpQkFBaUI1QjtJQUNyQixhQUFlO1FBQ2IsS0FBSztRQUVMLElBQUksQ0FBQ2tCLE9BQU8sR0FBRyxJQUFJaEI7UUFDbkIsSUFBSSxDQUFDYSxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNSLFFBQVEsR0FBRztRQUVoQixNQUFNc0IsT0FBTyxJQUFJO1FBRWpCLElBQUksQ0FBQ1QsU0FBUyxHQUFHLFNBQVNVLFFBQVNDLE1BQU0sRUFBRUMsT0FBTztZQUNoRCxNQUFNQyxRQUFRSixJQUFJLENBQUNYLE9BQU87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XGRpc3BhdGNoZXJcXHBvb2wtYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCBGaXhlZFF1ZXVlID0gcmVxdWlyZSgnLi9maXhlZC1xdWV1ZScpXG5jb25zdCB7IGtDb25uZWN0ZWQsIGtTaXplLCBrUnVubmluZywga1BlbmRpbmcsIGtRdWV1ZWQsIGtCdXN5LCBrRnJlZSwga1VybCwga0Nsb3NlLCBrRGVzdHJveSwga0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgUG9vbFN0YXRzID0gcmVxdWlyZSgnLi9wb29sLXN0YXRzJylcblxuY29uc3Qga0NsaWVudHMgPSBTeW1ib2woJ2NsaWVudHMnKVxuY29uc3Qga05lZWREcmFpbiA9IFN5bWJvbCgnbmVlZERyYWluJylcbmNvbnN0IGtRdWV1ZSA9IFN5bWJvbCgncXVldWUnKVxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2Nsb3NlZCByZXNvbHZlJylcbmNvbnN0IGtPbkRyYWluID0gU3ltYm9sKCdvbkRyYWluJylcbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrR2V0RGlzcGF0Y2hlciA9IFN5bWJvbCgnZ2V0IGRpc3BhdGNoZXInKVxuY29uc3Qga0FkZENsaWVudCA9IFN5bWJvbCgnYWRkIGNsaWVudCcpXG5jb25zdCBrUmVtb3ZlQ2xpZW50ID0gU3ltYm9sKCdyZW1vdmUgY2xpZW50JylcbmNvbnN0IGtTdGF0cyA9IFN5bWJvbCgnc3RhdHMnKVxuXG5jbGFzcyBQb29sQmFzZSBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba1F1ZXVlXSA9IG5ldyBGaXhlZFF1ZXVlKClcbiAgICB0aGlzW2tDbGllbnRzXSA9IFtdXG4gICAgdGhpc1trUXVldWVkXSA9IDBcblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzXG5cbiAgICB0aGlzW2tPbkRyYWluXSA9IGZ1bmN0aW9uIG9uRHJhaW4gKG9yaWdpbiwgdGFyZ2V0cykge1xuICAgICAgY29uc3QgcXVldWUgPSBwb29sW2tRdWV1ZV1cblxuICAgICAgbGV0IG5lZWREcmFpbiA9IGZhbHNlXG5cbiAgICAgIHdoaWxlICghbmVlZERyYWluKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcG9vbFtrUXVldWVkXS0tXG4gICAgICAgIG5lZWREcmFpbiA9ICF0aGlzLmRpc3BhdGNoKGl0ZW0ub3B0cywgaXRlbS5oYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gbmVlZERyYWluXG5cbiAgICAgIGlmICghdGhpc1trTmVlZERyYWluXSAmJiBwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgIHBvb2xba05lZWREcmFpbl0gPSBmYWxzZVxuICAgICAgICBwb29sLmVtaXQoJ2RyYWluJywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10pXG4gICAgICB9XG5cbiAgICAgIGlmIChwb29sW2tDbG9zZWRSZXNvbHZlXSAmJiBxdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgUHJvbWlzZVxuICAgICAgICAgIC5hbGwocG9vbFtrQ2xpZW50c10ubWFwKGMgPT4gYy5jbG9zZSgpKSlcbiAgICAgICAgICAudGhlbihwb29sW2tDbG9zZWRSZXNvbHZlXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdjb25uZWN0Jywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25EaXNjb25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdkaXNjb25uZWN0Jywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tTdGF0c10gPSBuZXcgUG9vbFN0YXRzKHRoaXMpXG4gIH1cblxuICBnZXQgW2tCdXN5XSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl1cbiAgfVxuXG4gIGdldCBba0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maWx0ZXIoY2xpZW50ID0+IGNsaWVudFtrQ29ubmVjdGVkXSkubGVuZ3RoXG4gIH1cblxuICBnZXQgW2tGcmVlXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdLmZpbHRlcihjbGllbnQgPT4gY2xpZW50W2tDb25uZWN0ZWRdICYmICFjbGllbnRba05lZWREcmFpbl0pLmxlbmd0aFxuICB9XG5cbiAgZ2V0IFtrUGVuZGluZ10gKCkge1xuICAgIGxldCByZXQgPSB0aGlzW2tRdWV1ZWRdXG4gICAgZm9yIChjb25zdCB7IFtrUGVuZGluZ106IHBlbmRpbmcgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHBlbmRpbmdcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIGxldCByZXQgPSAwXG4gICAgZm9yIChjb25zdCB7IFtrUnVubmluZ106IHJ1bm5pbmcgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHJ1bm5pbmdcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IFtrU2l6ZV0gKCkge1xuICAgIGxldCByZXQgPSB0aGlzW2tRdWV1ZWRdXG4gICAgZm9yIChjb25zdCB7IFtrU2l6ZV06IHNpemUgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHNpemVcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IHN0YXRzICgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RhdHNdXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNba1F1ZXVlXS5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoYyA9PiBjLmNsb3NlKCkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trUXVldWVdLnNoaWZ0KClcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaXRlbS5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoYyA9PiBjLmRlc3Ryb3koZXJyKSkpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tHZXREaXNwYXRjaGVyXSgpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSB0cnVlXG4gICAgICB0aGlzW2tRdWV1ZV0ucHVzaCh7IG9wdHMsIGhhbmRsZXIgfSlcbiAgICAgIHRoaXNba1F1ZXVlZF0rK1xuICAgIH0gZWxzZSBpZiAoIWRpc3BhdGNoZXIuZGlzcGF0Y2gob3B0cywgaGFuZGxlcikpIHtcbiAgICAgIGRpc3BhdGNoZXJba05lZWREcmFpbl0gPSB0cnVlXG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gIXRoaXNba0dldERpc3BhdGNoZXJdKClcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXNba05lZWREcmFpbl1cbiAgfVxuXG4gIFtrQWRkQ2xpZW50XSAoY2xpZW50KSB7XG4gICAgY2xpZW50XG4gICAgICAub24oJ2RyYWluJywgdGhpc1trT25EcmFpbl0pXG4gICAgICAub24oJ2Nvbm5lY3QnLCB0aGlzW2tPbkNvbm5lY3RdKVxuICAgICAgLm9uKCdkaXNjb25uZWN0JywgdGhpc1trT25EaXNjb25uZWN0XSlcbiAgICAgIC5vbignY29ubmVjdGlvbkVycm9yJywgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKVxuXG4gICAgdGhpc1trQ2xpZW50c10ucHVzaChjbGllbnQpXG5cbiAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgICAgIHRoaXNba09uRHJhaW5dKGNsaWVudFtrVXJsXSwgW3RoaXMsIGNsaWVudF0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIFtrUmVtb3ZlQ2xpZW50XSAoY2xpZW50KSB7XG4gICAgY2xpZW50LmNsb3NlKCgpID0+IHtcbiAgICAgIGNvbnN0IGlkeCA9IHRoaXNba0NsaWVudHNdLmluZGV4T2YoY2xpZW50KVxuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgdGhpc1trQ2xpZW50c10uc3BsaWNlKGlkeCwgMSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpc1trTmVlZERyYWluXSA9IHRoaXNba0NsaWVudHNdLnNvbWUoZGlzcGF0Y2hlciA9PiAoXG4gICAgICAhZGlzcGF0Y2hlcltrTmVlZERyYWluXSAmJlxuICAgICAgZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIGRpc3BhdGNoZXIuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUG9vbEJhc2UsXG4gIGtDbGllbnRzLFxuICBrTmVlZERyYWluLFxuICBrQWRkQ2xpZW50LFxuICBrUmVtb3ZlQ2xpZW50LFxuICBrR2V0RGlzcGF0Y2hlclxufVxuIl0sIm5hbWVzIjpbIkRpc3BhdGNoZXJCYXNlIiwicmVxdWlyZSIsIkZpeGVkUXVldWUiLCJrQ29ubmVjdGVkIiwia1NpemUiLCJrUnVubmluZyIsImtQZW5kaW5nIiwia1F1ZXVlZCIsImtCdXN5Iiwia0ZyZWUiLCJrVXJsIiwia0Nsb3NlIiwia0Rlc3Ryb3kiLCJrRGlzcGF0Y2giLCJQb29sU3RhdHMiLCJrQ2xpZW50cyIsIlN5bWJvbCIsImtOZWVkRHJhaW4iLCJrUXVldWUiLCJrQ2xvc2VkUmVzb2x2ZSIsImtPbkRyYWluIiwia09uQ29ubmVjdCIsImtPbkRpc2Nvbm5lY3QiLCJrT25Db25uZWN0aW9uRXJyb3IiLCJrR2V0RGlzcGF0Y2hlciIsImtBZGRDbGllbnQiLCJrUmVtb3ZlQ2xpZW50Iiwia1N0YXRzIiwiUG9vbEJhc2UiLCJwb29sIiwib25EcmFpbiIsIm9yaWdpbiIsInRhcmdldHMiLCJxdWV1ZSIsIm5lZWREcmFpbiIsIml0ZW0iLCJzaGlmdCIsImRpc3BhdGNoIiwib3B0cyIsImhhbmRsZXIiLCJlbWl0IiwiaXNFbXB0eSIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJjIiwiY2xvc2UiLCJ0aGVuIiwiZXJyIiwiZmlsdGVyIiwiY2xpZW50IiwibGVuZ3RoIiwicmV0IiwicGVuZGluZyIsInJ1bm5pbmciLCJzaXplIiwic3RhdHMiLCJyZXNvbHZlIiwib25FcnJvciIsImRlc3Ryb3kiLCJkaXNwYXRjaGVyIiwicHVzaCIsIm9uIiwicXVldWVNaWNyb3Rhc2siLCJpZHgiLCJpbmRleE9mIiwic3BsaWNlIiwic29tZSIsImNsb3NlZCIsImRlc3Ryb3llZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-stats.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst kPool = Symbol('pool');\nclass PoolStats {\n    constructor(pool){\n        this[kPool] = pool;\n    }\n    get connected() {\n        return this[kPool][kConnected];\n    }\n    get free() {\n        return this[kPool][kFree];\n    }\n    get pending() {\n        return this[kPool][kPending];\n    }\n    get queued() {\n        return this[kPool][kQueued];\n    }\n    get running() {\n        return this[kPool][kRunning];\n    }\n    get size() {\n        return this[kPool][kSize];\n    }\n}\nmodule.exports = PoolStats;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtc3RhdHMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU0sRUFBRUEsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyx3RUFBaUI7QUFDM0YsTUFBTUMsUUFBUUMsT0FBTztBQUVyQixNQUFNQztJQUNKLFlBQWFDLElBQUksQ0FBRTtRQUNqQixJQUFJLENBQUNILE1BQU0sR0FBR0c7SUFDaEI7SUFFQSxJQUFJQyxZQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ04sV0FBVztJQUNoQztJQUVBLElBQUlXLE9BQVE7UUFDVixPQUFPLElBQUksQ0FBQ0wsTUFBTSxDQUFDUCxNQUFNO0lBQzNCO0lBRUEsSUFBSWEsVUFBVztRQUNiLE9BQU8sSUFBSSxDQUFDTixNQUFNLENBQUNMLFNBQVM7SUFDOUI7SUFFQSxJQUFJWSxTQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNQLE1BQU0sQ0FBQ0osUUFBUTtJQUM3QjtJQUVBLElBQUlZLFVBQVc7UUFDYixPQUFPLElBQUksQ0FBQ1IsTUFBTSxDQUFDSCxTQUFTO0lBQzlCO0lBRUEsSUFBSVksT0FBUTtRQUNWLE9BQU8sSUFBSSxDQUFDVCxNQUFNLENBQUNGLE1BQU07SUFDM0I7QUFDRjtBQUVBWSxPQUFPQyxPQUFPLEdBQUdUIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXHBvb2wtc3RhdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBrRnJlZSwga0Nvbm5lY3RlZCwga1BlbmRpbmcsIGtRdWV1ZWQsIGtSdW5uaW5nLCBrU2l6ZSB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGtQb29sID0gU3ltYm9sKCdwb29sJylcblxuY2xhc3MgUG9vbFN0YXRzIHtcbiAgY29uc3RydWN0b3IgKHBvb2wpIHtcbiAgICB0aGlzW2tQb29sXSA9IHBvb2xcbiAgfVxuXG4gIGdldCBjb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrQ29ubmVjdGVkXVxuICB9XG5cbiAgZ2V0IGZyZWUgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrRnJlZV1cbiAgfVxuXG4gIGdldCBwZW5kaW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1BlbmRpbmddXG4gIH1cblxuICBnZXQgcXVldWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1F1ZXVlZF1cbiAgfVxuXG4gIGdldCBydW5uaW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1J1bm5pbmddXG4gIH1cblxuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tTaXplXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbFN0YXRzXG4iXSwibmFtZXMiOlsia0ZyZWUiLCJrQ29ubmVjdGVkIiwia1BlbmRpbmciLCJrUXVldWVkIiwia1J1bm5pbmciLCJrU2l6ZSIsInJlcXVpcmUiLCJrUG9vbCIsIlN5bWJvbCIsIlBvb2xTdGF0cyIsInBvb2wiLCJjb25uZWN0ZWQiLCJmcmVlIiwicGVuZGluZyIsInF1ZXVlZCIsInJ1bm5pbmciLCJzaXplIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\");\nconst kOptions = Symbol('options');\nconst kConnections = Symbol('connections');\nconst kFactory = Symbol('factory');\nfunction defaultFactory(origin, opts) {\n    return new Client(origin, opts);\n}\nclass Pool extends PoolBase {\n    constructor(origin, { connections, factory = defaultFactory, connect, connectTimeout, tls, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}){\n        super();\n        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n            throw new InvalidArgumentError('invalid connections');\n        }\n        if (typeof factory !== 'function') {\n            throw new InvalidArgumentError('factory must be a function.');\n        }\n        if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n            throw new InvalidArgumentError('connect must be a function or an object');\n        }\n        if (typeof connect !== 'function') {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];\n        this[kConnections] = connections || null;\n        this[kUrl] = util.parseOrigin(origin);\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect,\n            allowH2\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kFactory] = factory;\n    }\n    [kGetDispatcher]() {\n        for (const client of this[kClients]){\n            if (!client[kNeedDrain]) {\n                return client;\n            }\n        }\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n            const dispatcher = this[kFactory](this[kUrl], this[kOptions]);\n            this[kAddClient](dispatcher);\n            return dispatcher;\n        }\n    }\n}\nmodule.exports = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsY0FBYyxFQUNmLEdBQUdDLG1CQUFPQSxDQUFDLDRFQUFhO0FBQ3pCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLHNFQUFVO0FBQ2pDLE1BQU0sRUFDSkUsb0JBQW9CLEVBQ3JCLEdBQUdGLG1CQUFPQSxDQUFDLHNFQUFnQjtBQUM1QixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyxrRUFBYztBQUNuQyxNQUFNLEVBQUVJLElBQUksRUFBRUMsYUFBYSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDLHdFQUFpQjtBQUN6RCxNQUFNTSxpQkFBaUJOLG1CQUFPQSxDQUFDLHdFQUFpQjtBQUVoRCxNQUFNTyxXQUFXQyxPQUFPO0FBQ3hCLE1BQU1DLGVBQWVELE9BQU87QUFDNUIsTUFBTUUsV0FBV0YsT0FBTztBQUV4QixTQUFTRyxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ25DLE9BQU8sSUFBSVosT0FBT1csUUFBUUM7QUFDNUI7QUFFQSxNQUFNQyxhQUFhbkI7SUFDakIsWUFBYWlCLE1BQU0sRUFBRSxFQUNuQkcsV0FBVyxFQUNYQyxVQUFVTCxjQUFjLEVBQ3hCTSxPQUFPLEVBQ1BDLGNBQWMsRUFDZEMsR0FBRyxFQUNIQyxpQkFBaUIsRUFDakJDLFVBQVUsRUFDVkMsZ0JBQWdCLEVBQ2hCQyw4QkFBOEIsRUFDOUJDLE9BQU8sRUFDUCxHQUFHQyxTQUNKLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLO1FBRUwsSUFBSVYsZUFBZSxRQUFTLEVBQUNXLE9BQU9DLFFBQVEsQ0FBQ1osZ0JBQWdCQSxjQUFjLElBQUk7WUFDN0UsTUFBTSxJQUFJYixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9jLFlBQVksWUFBWTtZQUNqQyxNQUFNLElBQUlkLHFCQUFxQjtRQUNqQztRQUVBLElBQUllLFdBQVcsUUFBUSxPQUFPQSxZQUFZLGNBQWMsT0FBT0EsWUFBWSxVQUFVO1lBQ25GLE1BQU0sSUFBSWYscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxPQUFPZSxZQUFZLFlBQVk7WUFDakNBLFVBQVVYLGVBQWU7Z0JBQ3ZCLEdBQUdhLEdBQUc7Z0JBQ05DO2dCQUNBSTtnQkFDQUg7Z0JBQ0FPLFNBQVNWO2dCQUNULEdBQUlJLG1CQUFtQjtvQkFBRUE7b0JBQWtCQztnQkFBK0IsSUFBSU0sU0FBUztnQkFDdkYsR0FBR1osT0FBTztZQUNaO1FBQ0Y7UUFFQSxJQUFJLENBQUNaLGNBQWMsR0FBR29CLFFBQVFLLFlBQVksRUFBRWhCLFFBQVFpQixNQUFNQyxPQUFPLENBQUNQLFFBQVFLLFlBQVksQ0FBQ2hCLElBQUksSUFDdkZXLFFBQVFLLFlBQVksQ0FBQ2hCLElBQUksR0FDekIsRUFBRTtRQUNOLElBQUksQ0FBQ0wsYUFBYSxHQUFHTSxlQUFlO1FBQ3BDLElBQUksQ0FBQ1gsS0FBSyxHQUFHRCxLQUFLOEIsV0FBVyxDQUFDckI7UUFDOUIsSUFBSSxDQUFDTCxTQUFTLEdBQUc7WUFBRSxHQUFHSixLQUFLK0IsU0FBUyxDQUFDVCxRQUFRO1lBQUVSO1lBQVNPO1FBQVE7UUFDaEUsSUFBSSxDQUFDakIsU0FBUyxDQUFDdUIsWUFBWSxHQUFHTCxRQUFRSyxZQUFZLEdBQzlDO1lBQUUsR0FBR0wsUUFBUUssWUFBWTtRQUFDLElBQzFCRDtRQUNKLElBQUksQ0FBQ25CLFNBQVMsR0FBR007SUFDbkI7SUFFQSxDQUFDakIsZUFBZSxHQUFJO1FBQ2xCLEtBQUssTUFBTW9DLFVBQVUsSUFBSSxDQUFDdkMsU0FBUyxDQUFFO1lBQ25DLElBQUksQ0FBQ3VDLE1BQU0sQ0FBQ3RDLFdBQVcsRUFBRTtnQkFDdkIsT0FBT3NDO1lBQ1Q7UUFDRjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUMxQixhQUFhLElBQUksSUFBSSxDQUFDYixTQUFTLENBQUN3QyxNQUFNLEdBQUcsSUFBSSxDQUFDM0IsYUFBYSxFQUFFO1lBQ3JFLE1BQU00QixhQUFhLElBQUksQ0FBQzNCLFNBQVMsQ0FBQyxJQUFJLENBQUNOLEtBQUssRUFBRSxJQUFJLENBQUNHLFNBQVM7WUFDNUQsSUFBSSxDQUFDVCxXQUFXLENBQUN1QztZQUNqQixPQUFPQTtRQUNUO0lBQ0Y7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUd6QiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxwb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn0gPSByZXF1aXJlKCcuL3Bvb2wtYmFzZScpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtVcmwsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdCcpXG5cbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtDb25uZWN0aW9ucyA9IFN5bWJvbCgnY29ubmVjdGlvbnMnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUG9vbCBleHRlbmRzIFBvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIGNvbm5lY3Rpb25zLFxuICAgIGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSxcbiAgICBjb25uZWN0LFxuICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgIHRscyxcbiAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICBzb2NrZXRQYXRoLFxuICAgIGF1dG9TZWxlY3RGYW1pbHksXG4gICAgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0LFxuICAgIGFsbG93SDIsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoY29ubmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShjb25uZWN0aW9ucykgfHwgY29ubmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbm5lY3Rpb25zJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgLi4udGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgYWxsb3dIMixcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQsXG4gICAgICAgIC4uLihhdXRvU2VsZWN0RmFtaWx5ID8geyBhdXRvU2VsZWN0RmFtaWx5LCBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgfSA6IHVuZGVmaW5lZCksXG4gICAgICAgIC4uLmNvbm5lY3RcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzPy5Qb29sICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnRlcmNlcHRvcnMuUG9vbClcbiAgICAgID8gb3B0aW9ucy5pbnRlcmNlcHRvcnMuUG9vbFxuICAgICAgOiBbXVxuICAgIHRoaXNba0Nvbm5lY3Rpb25zXSA9IGNvbm5lY3Rpb25zIHx8IG51bGxcbiAgICB0aGlzW2tVcmxdID0gdXRpbC5wYXJzZU9yaWdpbihvcmlnaW4pXG4gICAgdGhpc1trT3B0aW9uc10gPSB7IC4uLnV0aWwuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0LCBhbGxvd0gyIH1cbiAgICB0aGlzW2tPcHRpb25zXS5pbnRlcmNlcHRvcnMgPSBvcHRpb25zLmludGVyY2VwdG9yc1xuICAgICAgPyB7IC4uLm9wdGlvbnMuaW50ZXJjZXB0b3JzIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gIH1cblxuICBba0dldERpc3BhdGNoZXJdICgpIHtcbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgaWYgKCFjbGllbnRba05lZWREcmFpbl0pIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpc1trQ29ubmVjdGlvbnNdIHx8IHRoaXNba0NsaWVudHNdLmxlbmd0aCA8IHRoaXNba0Nvbm5lY3Rpb25zXSkge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKHRoaXNba1VybF0sIHRoaXNba09wdGlvbnNdKVxuICAgICAgdGhpc1trQWRkQ2xpZW50XShkaXNwYXRjaGVyKVxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sXG4iXSwibmFtZXMiOlsiUG9vbEJhc2UiLCJrQ2xpZW50cyIsImtOZWVkRHJhaW4iLCJrQWRkQ2xpZW50Iiwia0dldERpc3BhdGNoZXIiLCJyZXF1aXJlIiwiQ2xpZW50IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJ1dGlsIiwia1VybCIsImtJbnRlcmNlcHRvcnMiLCJidWlsZENvbm5lY3RvciIsImtPcHRpb25zIiwiU3ltYm9sIiwia0Nvbm5lY3Rpb25zIiwia0ZhY3RvcnkiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIm9wdHMiLCJQb29sIiwiY29ubmVjdGlvbnMiLCJmYWN0b3J5IiwiY29ubmVjdCIsImNvbm5lY3RUaW1lb3V0IiwidGxzIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJzb2NrZXRQYXRoIiwiYXV0b1NlbGVjdEZhbWlseSIsImF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCIsImFsbG93SDIiLCJvcHRpb25zIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0aW1lb3V0IiwidW5kZWZpbmVkIiwiaW50ZXJjZXB0b3JzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyc2VPcmlnaW4iLCJkZWVwQ2xvbmUiLCJjbGllbnQiLCJsZW5ndGgiLCJkaXNwYXRjaGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/proxy-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { URL } = __webpack_require__(/*! node:url */ \"node:url\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\");\nconst kAgent = Symbol('proxy agent');\nconst kClient = Symbol('proxy client');\nconst kProxyHeaders = Symbol('proxy headers');\nconst kRequestTls = Symbol('request tls settings');\nconst kProxyTls = Symbol('proxy tls settings');\nconst kConnectEndpoint = Symbol('connect endpoint function');\nfunction defaultProtocolPort(protocol) {\n    return protocol === 'https:' ? 443 : 80;\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass ProxyAgent extends DispatcherBase {\n    constructor(opts){\n        super();\n        if (!opts || typeof opts === 'object' && !(opts instanceof URL) && !opts.uri) {\n            throw new InvalidArgumentError('Proxy uri is mandatory');\n        }\n        const { clientFactory = defaultFactory } = opts;\n        if (typeof clientFactory !== 'function') {\n            throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.');\n        }\n        const url = this.#getUrl(opts);\n        const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;\n        this[kProxy] = {\n            uri: href,\n            protocol\n        };\n        this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];\n        this[kRequestTls] = opts.requestTls;\n        this[kProxyTls] = opts.proxyTls;\n        this[kProxyHeaders] = opts.headers || {};\n        if (opts.auth && opts.token) {\n            throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token');\n        } else if (opts.auth) {\n            /* @deprecated in favour of opts.token */ this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;\n        } else if (opts.token) {\n            this[kProxyHeaders]['proxy-authorization'] = opts.token;\n        } else if (username && password) {\n            this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`;\n        }\n        const connect = buildConnector({\n            ...opts.proxyTls\n        });\n        this[kConnectEndpoint] = buildConnector({\n            ...opts.requestTls\n        });\n        this[kClient] = clientFactory(url, {\n            connect\n        });\n        this[kAgent] = new Agent({\n            ...opts,\n            connect: async (opts, callback)=>{\n                let requestedPath = opts.host;\n                if (!opts.port) {\n                    requestedPath += `:${defaultProtocolPort(opts.protocol)}`;\n                }\n                try {\n                    const { socket, statusCode } = await this[kClient].connect({\n                        origin,\n                        port,\n                        path: requestedPath,\n                        signal: opts.signal,\n                        headers: {\n                            ...this[kProxyHeaders],\n                            host: opts.host\n                        },\n                        servername: this[kProxyTls]?.servername || proxyHostname\n                    });\n                    if (statusCode !== 200) {\n                        socket.on('error', ()=>{}).destroy();\n                        callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));\n                    }\n                    if (opts.protocol !== 'https:') {\n                        callback(null, socket);\n                        return;\n                    }\n                    let servername;\n                    if (this[kRequestTls]) {\n                        servername = this[kRequestTls].servername;\n                    } else {\n                        servername = opts.servername;\n                    }\n                    this[kConnectEndpoint]({\n                        ...opts,\n                        servername,\n                        httpSocket: socket\n                    }, callback);\n                } catch (err) {\n                    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n                        // Throw a custom error to avoid loop in client.js#connect\n                        callback(new SecureProxyConnectionError(err));\n                    } else {\n                        callback(err);\n                    }\n                }\n            }\n        });\n    }\n    dispatch(opts, handler) {\n        const headers = buildHeaders(opts.headers);\n        throwIfProxyAuthIsSent(headers);\n        if (headers && !('host' in headers) && !('Host' in headers)) {\n            const { host } = new URL(opts.origin);\n            headers.host = host;\n        }\n        return this[kAgent].dispatch({\n            ...opts,\n            headers\n        }, handler);\n    }\n    /**\n   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */ #getUrl(opts) {\n        if (typeof opts === 'string') {\n            return new URL(opts);\n        } else if (opts instanceof URL) {\n            return opts;\n        } else {\n            return new URL(opts.uri);\n        }\n    }\n    async [kClose]() {\n        await this[kAgent].close();\n        await this[kClient].close();\n    }\n    async [kDestroy]() {\n        await this[kAgent].destroy();\n        await this[kClient].destroy();\n    }\n}\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */ function buildHeaders(headers) {\n    // When using undici.fetch, the headers list is stored\n    // as an array.\n    if (Array.isArray(headers)) {\n        /** @type {Record<string, string>} */ const headersPair = {};\n        for(let i = 0; i < headers.length; i += 2){\n            headersPair[headers[i]] = headers[i + 1];\n        }\n        return headersPair;\n    }\n    return headers;\n}\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */ function throwIfProxyAuthIsSent(headers) {\n    const existProxyAuth = headers && Object.keys(headers).find((key)=>key.toLowerCase() === 'proxy-authorization');\n    if (existProxyAuth) {\n        throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor');\n    }\n}\nmodule.exports = ProxyAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Byb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsd0VBQWlCO0FBQzdFLE1BQU0sRUFBRUMsR0FBRyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDLDBCQUFVO0FBQ2xDLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDLG9FQUFTO0FBQy9CLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDLGtFQUFRO0FBQzdCLE1BQU1JLGlCQUFpQkosbUJBQU9BLENBQUMsd0ZBQW1CO0FBQ2xELE1BQU0sRUFBRUssb0JBQW9CLEVBQUVDLG1CQUFtQixFQUFFQywwQkFBMEIsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQyxzRUFBZ0I7QUFDMUcsTUFBTVEsaUJBQWlCUixtQkFBT0EsQ0FBQyx3RUFBaUI7QUFFaEQsTUFBTVMsU0FBU0MsT0FBTztBQUN0QixNQUFNQyxVQUFVRCxPQUFPO0FBQ3ZCLE1BQU1FLGdCQUFnQkYsT0FBTztBQUM3QixNQUFNRyxjQUFjSCxPQUFPO0FBQzNCLE1BQU1JLFlBQVlKLE9BQU87QUFDekIsTUFBTUssbUJBQW1CTCxPQUFPO0FBRWhDLFNBQVNNLG9CQUFxQkMsUUFBUTtJQUNwQyxPQUFPQSxhQUFhLFdBQVcsTUFBTTtBQUN2QztBQUVBLFNBQVNDLGVBQWdCQyxNQUFNLEVBQUVDLElBQUk7SUFDbkMsT0FBTyxJQUFJakIsS0FBS2dCLFFBQVFDO0FBQzFCO0FBRUEsTUFBTUMsbUJBQW1CakI7SUFDdkIsWUFBYWdCLElBQUksQ0FBRTtRQUNqQixLQUFLO1FBRUwsSUFBSSxDQUFDQSxRQUFTLE9BQU9BLFNBQVMsWUFBWSxDQUFFQSxDQUFBQSxnQkFBZ0JuQixHQUFFLEtBQU0sQ0FBQ21CLEtBQUtFLEdBQUcsRUFBRztZQUM5RSxNQUFNLElBQUlqQixxQkFB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Q1QsT0FBTztZQUNMLE9BQU8sSUFBSW5CLElBQUltQixLQUFLRSxHQUFHO1FBQ3pCO0lBQ0Y7SUFFQSxNQUFNLENBQUN6QixPQUFPLEdBQUk7UUFDaEIsTUFBTSxJQUFJLENBQUNZLE9BQU8sQ0FBQ29ELEtBQUs7UUFDeEIsTUFBTSxJQUFJLENBQUNsRCxRQUFRLENBQUNrRCxLQUFLO0lBQzNCO0lBRUEsTUFBTSxDQUFDL0QsU0FBUyxHQUFJO1FBQ2xCLE1BQU0sSUFBSSxDQUFDVyxPQUFPLENBQUM0QyxPQUFPO1FBQzFCLE1BQU0sSUFBSSxDQUFDMUMsUUFBUSxDQUFDMEMsT0FBTztJQUM3QjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU00sYUFBY3ZCLE9BQU87SUFDNUIsc0RBQXNEO0lBQ3RELGVBQWU7SUFDZixJQUFJSixNQUFNQyxPQUFPLENBQUNHLFVBQVU7UUFDMUIsbUNBQW1DLEdBQ25DLE1BQU0wQixjQUFjLENBQUM7UUFFckIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUkzQixRQUFRNEIsTUFBTSxFQUFFRCxLQUFLLEVBQUc7WUFDMUNELFdBQVcsQ0FBQzFCLE9BQU8sQ0FBQzJCLEVBQUUsQ0FBQyxHQUFHM0IsT0FBTyxDQUFDMkIsSUFBSSxFQUFFO1FBQzFDO1FBRUEsT0FBT0Q7SUFDVDtJQUVBLE9BQU8xQjtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVN3Qix1QkFBd0J4QixPQUFPO0lBQ3RDLE1BQU02QixpQkFBaUI3QixXQUFXOEIsT0FBT0MsSUFBSSxDQUFDL0IsU0FDM0NnQyxJQUFJLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsV0FBVyxPQUFPO0lBQ3ZDLElBQUlMLGdCQUFnQjtRQUNsQixNQUFNLElBQUk1RCxxQkFBcUI7SUFDakM7QUFDRjtBQUVBa0UsT0FBT0MsT0FBTyxHQUFHbkQiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxccHJveHktYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga1Byb3h5LCBrQ2xvc2UsIGtEZXN0cm95LCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ25vZGU6dXJsJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudCcpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciwgU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga0FnZW50ID0gU3ltYm9sKCdwcm94eSBhZ2VudCcpXG5jb25zdCBrQ2xpZW50ID0gU3ltYm9sKCdwcm94eSBjbGllbnQnKVxuY29uc3Qga1Byb3h5SGVhZGVycyA9IFN5bWJvbCgncHJveHkgaGVhZGVycycpXG5jb25zdCBrUmVxdWVzdFRscyA9IFN5bWJvbCgncmVxdWVzdCB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga1Byb3h5VGxzID0gU3ltYm9sKCdwcm94eSB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga0Nvbm5lY3RFbmRwb2ludCA9IFN5bWJvbCgnY29ubmVjdCBlbmRwb2ludCBmdW5jdGlvbicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRQcm90b2NvbFBvcnQgKHByb3RvY29sKSB7XG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MFxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNsYXNzIFByb3h5QWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKCFvcHRzIHx8ICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgIShvcHRzIGluc3RhbmNlb2YgVVJMKSAmJiAhb3B0cy51cmkpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5IHVyaSBpcyBtYW5kYXRvcnknKVxuICAgIH1cblxuICAgIGNvbnN0IHsgY2xpZW50RmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5IH0gPSBvcHRzXG4gICAgaWYgKHR5cGVvZiBjbGllbnRGYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5IG9wdHMuY2xpZW50RmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSB0aGlzLiNnZXRVcmwob3B0cylcbiAgICBjb25zdCB7IGhyZWYsIG9yaWdpbiwgcG9ydCwgcHJvdG9jb2wsIHVzZXJuYW1lLCBwYXNzd29yZCwgaG9zdG5hbWU6IHByb3h5SG9zdG5hbWUgfSA9IHVybFxuXG4gICAgdGhpc1trUHJveHldID0geyB1cmk6IGhyZWYsIHByb3RvY29sIH1cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0cy5pbnRlcmNlcHRvcnM/LlByb3h5QWdlbnQgJiYgQXJyYXkuaXNBcnJheShvcHRzLmludGVyY2VwdG9ycy5Qcm94eUFnZW50KVxuICAgICAgPyBvcHRzLmludGVyY2VwdG9ycy5Qcm94eUFnZW50XG4gICAgICA6IFtdXG4gICAgdGhpc1trUmVxdWVzdFRsc10gPSBvcHRzLnJlcXVlc3RUbHNcbiAgICB0aGlzW2tQcm94eVRsc10gPSBvcHRzLnByb3h5VGxzXG4gICAgdGhpc1trUHJveHlIZWFkZXJzXSA9IG9wdHMuaGVhZGVycyB8fCB7fVxuXG4gICAgaWYgKG9wdHMuYXV0aCAmJiBvcHRzLnRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMuYXV0aCBjYW5ub3QgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIG9wdHMudG9rZW4nKVxuICAgIH0gZWxzZSBpZiAob3B0cy5hdXRoKSB7XG4gICAgICAvKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Ygb3B0cy50b2tlbiAqL1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7b3B0cy5hdXRofWBcbiAgICB9IGVsc2UgaWYgKG9wdHMudG9rZW4pIHtcbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IG9wdHMudG9rZW5cbiAgICB9IGVsc2UgaWYgKHVzZXJuYW1lICYmIHBhc3N3b3JkKSB7XG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtCdWZmZXIuZnJvbShgJHtkZWNvZGVVUklDb21wb25lbnQodXNlcm5hbWUpfToke2RlY29kZVVSSUNvbXBvbmVudChwYXNzd29yZCl9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWBcbiAgICB9XG5cbiAgICBjb25zdCBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3IoeyAuLi5vcHRzLnByb3h5VGxzIH0pXG4gICAgdGhpc1trQ29ubmVjdEVuZHBvaW50XSA9IGJ1aWxkQ29ubmVjdG9yKHsgLi4ub3B0cy5yZXF1ZXN0VGxzIH0pXG4gICAgdGhpc1trQ2xpZW50XSA9IGNsaWVudEZhY3RvcnkodXJsLCB7IGNvbm5lY3QgfSlcbiAgICB0aGlzW2tBZ2VudF0gPSBuZXcgQWdlbnQoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGNvbm5lY3Q6IGFzeW5jIChvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgcmVxdWVzdGVkUGF0aCA9IG9wdHMuaG9zdFxuICAgICAgICBpZiAoIW9wdHMucG9ydCkge1xuICAgICAgICAgIHJlcXVlc3RlZFBhdGggKz0gYDoke2RlZmF1bHRQcm90b2NvbFBvcnQob3B0cy5wcm90b2NvbCl9YFxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzb2NrZXQsIHN0YXR1c0NvZGUgfSA9IGF3YWl0IHRoaXNba0NsaWVudF0uY29ubmVjdCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgcGF0aDogcmVxdWVzdGVkUGF0aCxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnRoaXNba1Byb3h5SGVhZGVyc10sXG4gICAgICAgICAgICAgIGhvc3Q6IG9wdHMuaG9zdFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcnZlcm5hbWU6IHRoaXNba1Byb3h5VGxzXT8uc2VydmVybmFtZSB8fCBwcm94eUhvc3RuYW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAoc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge30pLmRlc3Ryb3koKVxuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoYFByb3h5IHJlc3BvbnNlICgke3N0YXR1c0NvZGV9KSAhPT0gMjAwIHdoZW4gSFRUUCBUdW5uZWxpbmdgKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzb2NrZXQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHNlcnZlcm5hbWVcbiAgICAgICAgICBpZiAodGhpc1trUmVxdWVzdFRsc10pIHtcbiAgICAgICAgICAgIHNlcnZlcm5hbWUgPSB0aGlzW2tSZXF1ZXN0VGxzXS5zZXJ2ZXJuYW1lXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcnZlcm5hbWUgPSBvcHRzLnNlcnZlcm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1trQ29ubmVjdEVuZHBvaW50XSh7IC4uLm9wdHMsIHNlcnZlcm5hbWUsIGh0dHBTb2NrZXQ6IHNvY2tldCB9LCBjYWxsYmFjaylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGVycm9yIHRvIGF2b2lkIGxvb3AgaW4gY2xpZW50LmpzI2Nvbm5lY3RcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvcihlcnIpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IGJ1aWxkSGVhZGVycyhvcHRzLmhlYWRlcnMpXG4gICAgdGhyb3dJZlByb3h5QXV0aElzU2VudChoZWFkZXJzKVxuXG4gICAgaWYgKGhlYWRlcnMgJiYgISgnaG9zdCcgaW4gaGVhZGVycykgJiYgISgnSG9zdCcgaW4gaGVhZGVycykpIHtcbiAgICAgIGNvbnN0IHsgaG9zdCB9ID0gbmV3IFVSTChvcHRzLm9yaWdpbilcbiAgICAgIGhlYWRlcnMuaG9zdCA9IGhvc3RcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1trQWdlbnRdLmRpc3BhdGNoKFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9LFxuICAgICAgaGFuZGxlclxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvcHJveHktYWdlbnQnKS5Qcm94eUFnZW50Lk9wdGlvbnMgfCBzdHJpbmcgfCBVUkx9IG9wdHNcbiAgICogQHJldHVybnMge1VSTH1cbiAgICovXG4gICNnZXRVcmwgKG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTChvcHRzKVxuICAgIH0gZWxzZSBpZiAob3B0cyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgcmV0dXJuIG9wdHNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBVUkwob3B0cy51cmkpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpXG4gICAgYXdhaXQgdGhpc1trQ2xpZW50XS5jbG9zZSgpXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uZGVzdHJveSgpXG4gICAgYXdhaXQgdGhpc1trQ2xpZW50XS5kZXN0cm95KClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJzIChoZWFkZXJzKSB7XG4gIC8vIFdoZW4gdXNpbmcgdW5kaWNpLmZldGNoLCB0aGUgaGVhZGVycyBsaXN0IGlzIHN0b3JlZFxuICAvLyBhcyBhbiBhcnJheS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgY29uc3QgaGVhZGVyc1BhaXIgPSB7fVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBoZWFkZXJzUGFpcltoZWFkZXJzW2ldXSA9IGhlYWRlcnNbaSArIDFdXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnNQYWlyXG4gIH1cblxuICByZXR1cm4gaGVhZGVyc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICpcbiAqIFByZXZpb3VzIHZlcnNpb25zIG9mIFByb3h5QWdlbnQgc3VnZ2VzdHMgdGhlIFByb3h5LUF1dGhvcml6YXRpb24gaW4gcmVxdWVzdCBoZWFkZXJzXG4gKiBOZXZlcnRoZWxlc3MsIGl0IHdhcyBjaGFuZ2VkIGFuZCB0byBhdm9pZCBhIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdHkgYnkgZW5kIHVzZXJzXG4gKiB0aGlzIGNoZWNrIHdhcyBjcmVhdGVkLlxuICogSXQgc2hvdWxkIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICovXG5mdW5jdGlvbiB0aHJvd0lmUHJveHlBdXRoSXNTZW50IChoZWFkZXJzKSB7XG4gIGNvbnN0IGV4aXN0UHJveHlBdXRoID0gaGVhZGVycyAmJiBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgIC5maW5kKChrZXkpID0+IGtleS50b0xvd2VyQ2FzZSgpID09PSAncHJveHktYXV0aG9yaXphdGlvbicpXG4gIGlmIChleGlzdFByb3h5QXV0aCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHktQXV0aG9yaXphdGlvbiBzaG91bGQgYmUgc2VudCBpbiBQcm94eUFnZW50IGNvbnN0cnVjdG9yJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3h5QWdlbnRcbiJdLCJuYW1lcyI6WyJrUHJveHkiLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtJbnRlcmNlcHRvcnMiLCJyZXF1aXJlIiwiVVJMIiwiQWdlbnQiLCJQb29sIiwiRGlzcGF0Y2hlckJhc2UiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvciIsImJ1aWxkQ29ubmVjdG9yIiwia0FnZW50IiwiU3ltYm9sIiwia0NsaWVudCIsImtQcm94eUhlYWRlcnMiLCJrUmVxdWVzdFRscyIsImtQcm94eVRscyIsImtDb25uZWN0RW5kcG9pbnQiLCJkZWZhdWx0UHJvdG9jb2xQb3J0IiwicHJvdG9jb2wiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIm9wdHMiLCJQcm94eUFnZW50IiwidXJpIiwiY2xpZW50RmFjdG9yeSIsInVybCIsImhyZWYiLCJwb3J0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImhvc3RuYW1lIiwicHJveHlIb3N0bmFtZSIsImludGVyY2VwdG9ycyIsIkFycmF5IiwiaXNBcnJheSIsInJlcXVlc3RUbHMiLCJwcm94eVRscyIsImhlYWRlcnMiLCJhdXRoIiwidG9rZW4iLCJCdWZmZXIiLCJmcm9tIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9TdHJpbmciLCJjb25uZWN0IiwiY2FsbGJhY2siLCJyZXF1ZXN0ZWRQYXRoIiwiaG9zdCIsInNvY2tldCIsInN0YXR1c0NvZGUiLCJwYXRoIiwic2lnbmFsIiwic2VydmVybmFtZSIsIm9uIiwiZGVzdHJveSIsImh0dHBTb2NrZXQiLCJlcnIiLCJjb2RlIiwiZGlzcGF0Y2giLCJoYW5kbGVyIiwiYnVpbGRIZWFkZXJzIiwidGhyb3dJZlByb3h5QXV0aElzU2VudCIsImNsb3NlIiwiaGVhZGVyc1BhaXIiLCJpIiwibGVuZ3RoIiwiZXhpc3RQcm94eUF1dGgiLCJPYmplY3QiLCJrZXlzIiwiZmluZCIsImtleSIsInRvTG93ZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/retry-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\");\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\");\nclass RetryAgent extends Dispatcher {\n    #agent;\n    #options;\n    constructor(agent, options = {}){\n        super(options), this.#agent = null, this.#options = null;\n        this.#agent = agent;\n        this.#options = options;\n    }\n    dispatch(opts, handler) {\n        const retry = new RetryHandler({\n            ...opts,\n            retryOptions: this.#options\n        }, {\n            dispatch: this.#agent.dispatch.bind(this.#agent),\n            handler\n        });\n        return this.#agent.dispatch(opts, retry);\n    }\n    close() {\n        return this.#agent.close();\n    }\n    destroy() {\n        return this.#agent.destroy();\n    }\n}\nmodule.exports = RetryAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUMsOEVBQWM7QUFDekMsTUFBTUMsZUFBZUQsbUJBQU9BLENBQUMsMEZBQTBCO0FBRXZELE1BQU1FLG1CQUFtQkg7SUFDdkIsTUFBTSxDQUFPO0lBQ2IsUUFBUSxDQUFPO0lBQ2YsWUFBYUksS0FBSyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ2hDLEtBQUssQ0FBQ0EsZUFIUixNQUFNLEdBQUcsV0FDVCxRQUFRLEdBQUc7UUFHVCxJQUFJLENBQUMsTUFBTSxHQUFHRDtRQUNkLElBQUksQ0FBQyxRQUFRLEdBQUdDO0lBQ2xCO0lBRUFDLFNBQVVDLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQ3ZCLE1BQU1DLFFBQVEsSUFBSVAsYUFBYTtZQUM3QixHQUFHSyxJQUFJO1lBQ1BHLGNBQWMsSUFBSSxDQUFDLFFBQVE7UUFDN0IsR0FBRztZQUNESixVQUFVLElBQUksQ0FBQyxNQUFNLENBQUNBLFFBQVEsQ0FBQ0ssSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNO1lBQy9DSDtRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDRixRQUFRLENBQUNDLE1BQU1FO0lBQ3BDO0lBRUFHLFFBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUNBLEtBQUs7SUFDMUI7SUFFQUMsVUFBVztRQUNULE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQ0EsT0FBTztJQUM1QjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxccmV0cnktYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXInKVxuY29uc3QgUmV0cnlIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci9yZXRyeS1oYW5kbGVyJylcblxuY2xhc3MgUmV0cnlBZ2VudCBleHRlbmRzIERpc3BhdGNoZXIge1xuICAjYWdlbnQgPSBudWxsXG4gICNvcHRpb25zID0gbnVsbFxuICBjb25zdHJ1Y3RvciAoYWdlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgdGhpcy4jYWdlbnQgPSBhZ2VudFxuICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IHJldHJ5ID0gbmV3IFJldHJ5SGFuZGxlcih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgcmV0cnlPcHRpb25zOiB0aGlzLiNvcHRpb25zXG4gICAgfSwge1xuICAgICAgZGlzcGF0Y2g6IHRoaXMuI2FnZW50LmRpc3BhdGNoLmJpbmQodGhpcy4jYWdlbnQpLFxuICAgICAgaGFuZGxlclxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuI2FnZW50LmRpc3BhdGNoKG9wdHMsIHJldHJ5KVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIHJldHVybiB0aGlzLiNhZ2VudC5jbG9zZSgpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWdlbnQuZGVzdHJveSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXRyeUFnZW50XG4iXSwibmFtZXMiOlsiRGlzcGF0Y2hlciIsInJlcXVpcmUiLCJSZXRyeUhhbmRsZXIiLCJSZXRyeUFnZW50IiwiYWdlbnQiLCJvcHRpb25zIiwiZGlzcGF0Y2giLCJvcHRzIiwiaGFuZGxlciIsInJldHJ5IiwicmV0cnlPcHRpb25zIiwiYmluZCIsImNsb3NlIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for('undici.globalDispatcher.1');\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst Agent = __webpack_require__(/*! ./dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nif (getGlobalDispatcher() === undefined) {\n    setGlobalDispatcher(new Agent());\n}\nfunction setGlobalDispatcher(agent) {\n    if (!agent || typeof agent.dispatch !== 'function') {\n        throw new InvalidArgumentError('Argument agent must implement Agent');\n    }\n    Object.defineProperty(globalThis, globalDispatcher, {\n        value: agent,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nfunction getGlobalDispatcher() {\n    return globalThis[globalDispatcher];\n}\nmodule.exports = {\n    setGlobalDispatcher,\n    getGlobalDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxtRkFBbUY7QUFDbkYsNERBQTREO0FBQzVELE1BQU1BLG1CQUFtQkMsT0FBT0MsR0FBRyxDQUFDO0FBQ3BDLE1BQU0sRUFBRUMsb0JBQW9CLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMscUVBQWU7QUFDeEQsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsK0VBQW9CO0FBRTFDLElBQUlFLDBCQUEwQkMsV0FBVztJQUN2Q0Msb0JBQW9CLElBQUlIO0FBQzFCO0FBRUEsU0FBU0csb0JBQXFCQyxLQUFLO0lBQ2pDLElBQUksQ0FBQ0EsU0FBUyxPQUFPQSxNQUFNQyxRQUFRLEtBQUssWUFBWTtRQUNsRCxNQUFNLElBQUlQLHFCQUFxQjtJQUNqQztJQUNBUSxPQUFPQyxjQUFjLENBQUNDLFlBQVliLGtCQUFrQjtRQUNsRGMsT0FBT0w7UUFDUE0sVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGNBQWM7SUFDaEI7QUFDRjtBQUVBLFNBQVNYO0lBQ1AsT0FBT08sVUFBVSxDQUFDYixpQkFBaUI7QUFDckM7QUFFQWtCLE9BQU9DLE9BQU8sR0FBRztJQUNmWDtJQUNBRjtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGdsb2JhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gV2UgaW5jbHVkZSBhIHZlcnNpb24gbnVtYmVyIGZvciB0aGUgRGlzcGF0Y2hlciBBUEkuIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcyxcbi8vIHRoaXMgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBpbmNyZWFzZWQgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsRGlzcGF0Y2hlciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxEaXNwYXRjaGVyLjEnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci9hZ2VudCcpXG5cbmlmIChnZXRHbG9iYWxEaXNwYXRjaGVyKCkgPT09IHVuZGVmaW5lZCkge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyKG5ldyBBZ2VudCgpKVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxEaXNwYXRjaGVyIChhZ2VudCkge1xuICBpZiAoIWFnZW50IHx8IHR5cGVvZiBhZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxEaXNwYXRjaGVyLCB7XG4gICAgdmFsdWU6IGFnZW50LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRGlzcGF0Y2hlciAoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbERpc3BhdGNoZXJdXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyLFxuICBnZXRHbG9iYWxEaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsRGlzcGF0Y2hlciIsIlN5bWJvbCIsImZvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicmVxdWlyZSIsIkFnZW50IiwiZ2V0R2xvYmFsRGlzcGF0Y2hlciIsInVuZGVmaW5lZCIsInNldEdsb2JhbERpc3BhdGNoZXIiLCJhZ2VudCIsImRpc3BhdGNoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnbG9iYWxUaGlzIiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/decorator-handler.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/handler/decorator-handler.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = class DecoratorHandler {\n    #handler;\n    constructor(handler){\n        if (typeof handler !== 'object' || handler === null) {\n            throw new TypeError('handler must be an object');\n        }\n        this.#handler = handler;\n    }\n    onConnect(...args) {\n        return this.#handler.onConnect?.(...args);\n    }\n    onError(...args) {\n        return this.#handler.onError?.(...args);\n    }\n    onUpgrade(...args) {\n        return this.#handler.onUpgrade?.(...args);\n    }\n    onResponseStarted(...args) {\n        return this.#handler.onResponseStarted?.(...args);\n    }\n    onHeaders(...args) {\n        return this.#handler.onHeaders?.(...args);\n    }\n    onData(...args) {\n        return this.#handler.onData?.(...args);\n    }\n    onComplete(...args) {\n        return this.#handler.onComplete?.(...args);\n    }\n    onBodySent(...args) {\n        return this.#handler.onBodySent?.(...args);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQixRQUFRO0lBRVIsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLElBQUksT0FBT0EsWUFBWSxZQUFZQSxZQUFZLE1BQU07WUFDbkQsTUFBTSxJQUFJQyxVQUFVO1FBQ3RCO1FBQ0EsSUFBSSxDQUFDLFFBQVEsR0FBR0Q7SUFDbEI7SUFFQUUsVUFBVyxHQUFHQyxJQUFJLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDRCxTQUFTLE1BQU1DO0lBQ3RDO0lBRUFDLFFBQVMsR0FBR0QsSUFBSSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQ0MsT0FBTyxNQUFNRDtJQUNwQztJQUVBRSxVQUFXLEdBQUdGLElBQUksRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUNFLFNBQVMsTUFBTUY7SUFDdEM7SUFFQUcsa0JBQW1CLEdBQUdILElBQUksRUFBRTtRQUMxQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUNHLGlCQUFpQixNQUFNSDtJQUM5QztJQUVBSSxVQUFXLEdBQUdKLElBQUksRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUNJLFNBQVMsTUFBTUo7SUFDdEM7SUFFQUssT0FBUSxHQUFHTCxJQUFJLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUNLLE1BQU0sTUFBTUw7SUFDbkM7SUFFQU0sV0FBWSxHQUFHTixJQUFJLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDTSxVQUFVLE1BQU1OO0lBQ3ZDO0lBRUFPLFdBQVksR0FBR1AsSUFBSSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQ08sVUFBVSxNQUFNUDtJQUN2QztBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXGRlY29yYXRvci1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERlY29yYXRvckhhbmRsZXIge1xuICAjaGFuZGxlclxuXG4gIGNvbnN0cnVjdG9yIChoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0JyB8fCBoYW5kbGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG4gICAgdGhpcy4jaGFuZGxlciA9IGhhbmRsZXJcbiAgfVxuXG4gIG9uQ29ubmVjdCAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uQ29ubmVjdD8uKC4uLmFyZ3MpXG4gIH1cblxuICBvbkVycm9yICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25FcnJvcj8uKC4uLmFyZ3MpXG4gIH1cblxuICBvblVwZ3JhZGUgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vblVwZ3JhZGU/LiguLi5hcmdzKVxuICB9XG5cbiAgb25SZXNwb25zZVN0YXJ0ZWQgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlU3RhcnRlZD8uKC4uLmFyZ3MpXG4gIH1cblxuICBvbkhlYWRlcnMgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkhlYWRlcnM/LiguLi5hcmdzKVxuICB9XG5cbiAgb25EYXRhICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25EYXRhPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkNvbXBsZXRlPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uQm9keVNlbnQgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkJvZHlTZW50Py4oLi4uYXJncylcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJEZWNvcmF0b3JIYW5kbGVyIiwiaGFuZGxlciIsIlR5cGVFcnJvciIsIm9uQ29ubmVjdCIsImFyZ3MiLCJvbkVycm9yIiwib25VcGdyYWRlIiwib25SZXNwb25zZVN0YXJ0ZWQiLCJvbkhlYWRlcnMiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwib25Cb2R5U2VudCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/redirect-handler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/redirect-handler.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst EE = __webpack_require__(/*! node:events */ \"node:events\");\nconst redirectableStatusCodes = [\n    300,\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst kBody = Symbol('body');\nclass BodyAsyncIterable {\n    constructor(body){\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n    }\n    async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], 'disturbed');\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n    }\n}\nclass RedirectHandler {\n    constructor(dispatch, maxRedirections, opts, handler){\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError('maxRedirections must be a positive number');\n        }\n        util.validateHandler(handler, opts.method, opts.upgrade);\n        this.dispatch = dispatch;\n        this.location = null;\n        this.abort = null;\n        this.opts = {\n            ...opts,\n            maxRedirections: 0\n        }; // opts must be a copy\n        this.maxRedirections = maxRedirections;\n        this.handler = handler;\n        this.history = [];\n        this.redirectionLimitReached = false;\n        if (util.isStream(this.opts.body)) {\n            // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n            // so that it can be dispatched again?\n            // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n            if (util.bodyLength(this.opts.body) === 0) {\n                this.opts.body.on('data', function() {\n                    assert(false);\n                });\n            }\n            if (typeof this.opts.body.readableDidRead !== 'boolean') {\n                this.opts.body[kBodyUsed] = false;\n                EE.prototype.on.call(this.opts.body, 'data', function() {\n                    this[kBodyUsed] = true;\n                });\n            }\n        } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n            // TODO (fix): We can't access ReadableStream internal state\n            // to determine whether or not it has been disturbed. This is just\n            // a workaround.\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        } else if (this.opts.body && typeof this.opts.body !== 'string' && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {\n            // TODO: Should we allow re-using iterable if !this.opts.idempotent\n            // or through some other flag?\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        }\n    }\n    onConnect(abort) {\n        this.abort = abort;\n        this.handler.onConnect(abort, {\n            history: this.history\n        });\n    }\n    onUpgrade(statusCode, headers, socket) {\n        this.handler.onUpgrade(statusCode, headers, socket);\n    }\n    onError(error) {\n        this.handler.onError(error);\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);\n        if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {\n            if (this.request) {\n                this.request.abort(new Error('max redirects'));\n            }\n            this.redirectionLimitReached = true;\n            this.abort(new Error('max redirects'));\n            return;\n        }\n        if (this.opts.origin) {\n            this.history.push(new URL(this.opts.path, this.opts.origin));\n        }\n        if (!this.location) {\n            return this.handler.onHeaders(statusCode, headers, resume, statusText);\n        }\n        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));\n        const path = search ? `${pathname}${search}` : pathname;\n        // Remove headers referring to the original URL.\n        // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n        // https://tools.ietf.org/html/rfc7231#section-6.4\n        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);\n        this.opts.path = path;\n        this.opts.origin = origin;\n        this.opts.maxRedirections = 0;\n        this.opts.query = null;\n        // https://tools.ietf.org/html/rfc7231#section-6.4.4\n        // In case of HTTP 303, always replace method to be either HEAD or GET\n        if (statusCode === 303 && this.opts.method !== 'HEAD') {\n            this.opts.method = 'GET';\n            this.opts.body = null;\n        }\n    }\n    onData(chunk) {\n        if (this.location) {\n        /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitly chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */ } else {\n            return this.handler.onData(chunk);\n        }\n    }\n    onComplete(trailers) {\n        if (this.location) {\n            /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed information.\n      */ this.location = null;\n            this.abort = null;\n            this.dispatch(this.opts, this);\n        } else {\n            this.handler.onComplete(trailers);\n        }\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) {\n            this.handler.onBodySent(chunk);\n        }\n    }\n}\nfunction parseLocation(statusCode, headers) {\n    if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n        return null;\n    }\n    for(let i = 0; i < headers.length; i += 2){\n        if (headers[i].length === 8 && util.headerNameToString(headers[i]) === 'location') {\n            return headers[i + 1];\n        }\n    }\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader(header, removeContent, unknownOrigin) {\n    if (header.length === 4) {\n        return util.headerNameToString(header) === 'host';\n    }\n    if (removeContent && util.headerNameToString(header).startsWith('content-')) {\n        return true;\n    }\n    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {\n        const name = util.headerNameToString(header);\n        return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization';\n    }\n    return false;\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders(headers, removeContent, unknownOrigin) {\n    const ret = [];\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n                ret.push(headers[i], headers[i + 1]);\n            }\n        }\n    } else if (headers && typeof headers === 'object') {\n        for (const key of Object.keys(headers)){\n            if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n                ret.push(key, headers[key]);\n            }\n        }\n    } else {\n        assert(headers == null, 'headers must be an object or an array');\n    }\n    return ret;\n}\nmodule.exports = RedirectHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQyxrRUFBYztBQUNuQyxNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyx3RUFBaUI7QUFDL0MsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUMsZ0NBQWE7QUFDcEMsTUFBTSxFQUFFRyxvQkFBb0IsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQyxzRUFBZ0I7QUFDekQsTUFBTUksS0FBS0osbUJBQU9BLENBQUMsZ0NBQWE7QUFFaEMsTUFBTUssMEJBQTBCO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFFOUQsTUFBTUMsUUFBUUMsT0FBTztBQUVyQixNQUFNQztJQUNKLFlBQWFDLElBQUksQ0FBRTtRQUNqQixJQUFJLENBQUNILE1BQU0sR0FBR0c7UUFDZCxJQUFJLENBQUNSLFVBQVUsR0FBRztJQUNwQjtJQUVBLE9BQVEsQ0FBQ00sT0FBT0csYUFBYSxDQUFDLEdBQUk7UUFDaENSLE9BQU8sQ0FBQyxJQUFJLENBQUNELFVBQVUsRUFBRTtRQUN6QixJQUFJLENBQUNBLFVBQVUsR0FBRztRQUNsQixPQUFRLElBQUksQ0FBQ0ssTUFBTTtJQUNyQjtBQUNGO0FBRUEsTUFBTUs7SUFDSixZQUFhQyxRQUFRLEVBQUVDLGVBQWUsRUFBRUMsSUFBSSxFQUFFQyxPQUFPLENBQUU7UUFDckQsSUFBSUYsbUJBQW1CLFFBQVMsRUFBQ0csT0FBT0MsU0FBUyxDQUFDSixvQkFBb0JBLGtCQUFrQixJQUFJO1lBQzFGLE1BQU0sSUFBSVYscUJBQXFCO1FBQ2pDO1FBRUFKLEtBQUttQixlQUFlLENBQUNILFNBQVNELEtBQUtLLE1BQU0sRUFBRUwsS0FBS00sT0FBTztRQUV2RCxJQUFJLENBQUNSLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDUyxRQUFRLEdBQUc7UUFD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Q0FBQzRCLEVBQUUsRUFBRUksZUFBZUMsZ0JBQWdCO2dCQUNqRUcsSUFBSXRCLElBQUksQ0FBQ2QsT0FBTyxDQUFDNEIsRUFBRSxFQUFFNUIsT0FBTyxDQUFDNEIsSUFBSSxFQUFFO1lBQ3JDO1FBQ0Y7SUFDRixPQUFPLElBQUk1QixXQUFXLE9BQU9BLFlBQVksVUFBVTtRQUNqRCxLQUFLLE1BQU11QyxPQUFPQyxPQUFPQyxJQUFJLENBQUN6QyxTQUFVO1lBQ3RDLElBQUksQ0FBQzhCLG1CQUFtQlMsS0FBS1AsZUFBZUMsZ0JBQWdCO2dCQUMxREcsSUFBSXRCLElBQUksQ0FBQ3lCLEtBQUt2QyxPQUFPLENBQUN1QyxJQUFJO1lBQzVCO1FBQ0Y7SUFDRixPQUFPO1FBQ0wzRSxPQUFPb0MsV0FBVyxNQUFNO0lBQzFCO0lBQ0EsT0FBT29DO0FBQ1Q7QUFFQU0sT0FBT0MsT0FBTyxHQUFHdEUiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaGFuZGxlclxccmVkaXJlY3QtaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtCb2R5VXNlZCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuXG5jb25zdCByZWRpcmVjdGFibGVTdGF0dXNDb2RlcyA9IFszMDAsIDMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5jb25zdCBrQm9keSA9IFN5bWJvbCgnYm9keScpXG5cbmNsYXNzIEJvZHlBc3luY0l0ZXJhYmxlIHtcbiAgY29uc3RydWN0b3IgKGJvZHkpIHtcbiAgICB0aGlzW2tCb2R5XSA9IGJvZHlcbiAgICB0aGlzW2tCb2R5VXNlZF0gPSBmYWxzZVxuICB9XG5cbiAgYXN5bmMgKiBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBhc3NlcnQoIXRoaXNba0JvZHlVc2VkXSwgJ2Rpc3R1cmJlZCcpXG4gICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgIHlpZWxkICogdGhpc1trQm9keV1cbiAgfVxufVxuXG5jbGFzcyBSZWRpcmVjdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2gsIG1heFJlZGlyZWN0aW9ucywgb3B0cywgaGFuZGxlcikge1xuICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgdXRpbC52YWxpZGF0ZUhhbmRsZXIoaGFuZGxlciwgb3B0cy5tZXRob2QsIG9wdHMudXBncmFkZSlcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBkaXNwYXRjaFxuICAgIHRoaXMubG9jYXRpb24gPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIG1heFJlZGlyZWN0aW9uczogMCB9IC8vIG9wdHMgbXVzdCBiZSBhIGNvcHlcbiAgICB0aGlzLm1heFJlZGlyZWN0aW9ucyA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmhpc3RvcnkgPSBbXVxuICAgIHRoaXMucmVkaXJlY3Rpb25MaW1pdFJlYWNoZWQgPSBmYWxzZVxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0odGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBQcm92aWRlIHNvbWUgd2F5IGZvciB0aGUgdXNlciB0byBjYWNoZSB0aGUgZmlsZSB0byBlLmcuIC90bXBcbiAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYWdhaW4/XG4gICAgICAvLyBUT0RPIChmaXgpOiBEbyB3ZSBuZWVkIDEwMC1leHBlY3Qgc3VwcG9ydCB0byBwcm92aWRlIGEgd2F5IHRvIGRvIHRoaXMgcHJvcGVybHk/XG4gICAgICBpZiAodXRpbC5ib2R5TGVuZ3RoKHRoaXMub3B0cy5ib2R5KSA9PT0gMCkge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVxuICAgICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSlcbiAgICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5ib2R5LnJlYWRhYmxlRGlkUmVhZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0cy5ib2R5W2tCb2R5VXNlZF0gPSBmYWxzZVxuICAgICAgICBFRS5wcm90b3R5cGUub24uY2FsbCh0aGlzLm9wdHMuYm9keSwgJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmJvZHkgJiYgdHlwZW9mIHRoaXMub3B0cy5ib2R5LnBpcGVUbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVE9ETyAoZml4KTogV2UgY2FuJ3QgYWNjZXNzIFJlYWRhYmxlU3RyZWFtIGludGVybmFsIHN0YXRlXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gZGlzdHVyYmVkLiBUaGlzIGlzIGp1c3RcbiAgICAgIC8vIGEgd29ya2Fyb3VuZC5cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLm9wdHMuYm9keSAmJlxuICAgICAgdHlwZW9mIHRoaXMub3B0cy5ib2R5ICE9PSAnc3RyaW5nJyAmJlxuICAgICAgIUFycmF5QnVmZmVyLmlzVmlldyh0aGlzLm9wdHMuYm9keSkgJiZcbiAgICAgIHV0aWwuaXNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICApIHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBhbGxvdyByZS11c2luZyBpdGVyYWJsZSBpZiAhdGhpcy5vcHRzLmlkZW1wb3RlbnRcbiAgICAgIC8vIG9yIHRocm91Z2ggc29tZSBvdGhlciBmbGFnP1xuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBuZXcgQm9keUFzeW5jSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpXG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuaGFuZGxlci5vbkNvbm5lY3QoYWJvcnQsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5IH0pXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldCkge1xuICAgIHRoaXMuaGFuZGxlci5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICB9XG5cbiAgb25FcnJvciAoZXJyb3IpIHtcbiAgICB0aGlzLmhhbmRsZXIub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMuaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhSZWRpcmVjdGlvbnMgfHwgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSlcbiAgICAgID8gbnVsbFxuICAgICAgOiBwYXJzZUxvY2F0aW9uKHN0YXR1c0NvZGUsIGhlYWRlcnMpXG5cbiAgICBpZiAodGhpcy5vcHRzLnRocm93T25NYXhSZWRpcmVjdCAmJiB0aGlzLmhpc3RvcnkubGVuZ3RoID49IHRoaXMubWF4UmVkaXJlY3Rpb25zKSB7XG4gICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMucmVxdWVzdC5hYm9ydChuZXcgRXJyb3IoJ21heCByZWRpcmVjdHMnKSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWRpcmVjdGlvbkxpbWl0UmVhY2hlZCA9IHRydWVcbiAgICAgIHRoaXMuYWJvcnQobmV3IEVycm9yKCdtYXggcmVkaXJlY3RzJykpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLm9yaWdpbikge1xuICAgICAgdGhpcy5oaXN0b3J5LnB1c2gobmV3IFVSTCh0aGlzLm9wdHMucGF0aCwgdGhpcy5vcHRzLm9yaWdpbikpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpXG4gICAgfVxuXG4gICAgY29uc3QgeyBvcmlnaW4sIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHV0aWwucGFyc2VVUkwobmV3IFVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLm9wdHMub3JpZ2luICYmIG5ldyBVUkwodGhpcy5vcHRzLnBhdGgsIHRoaXMub3B0cy5vcmlnaW4pKSlcbiAgICBjb25zdCBwYXRoID0gc2VhcmNoID8gYCR7cGF0aG5hbWV9JHtzZWFyY2h9YCA6IHBhdGhuYW1lXG5cbiAgICAvLyBSZW1vdmUgaGVhZGVycyByZWZlcnJpbmcgdG8gdGhlIG9yaWdpbmFsIFVSTC5cbiAgICAvLyBCeSBkZWZhdWx0IGl0IGlzIEhvc3Qgb25seSwgdW5sZXNzIGl0J3MgYSAzMDMgKHNlZSBiZWxvdyksIHdoaWNoIHJlbW92ZXMgYWxzbyBhbGwgQ29udGVudC0qIGhlYWRlcnMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcbiAgICB0aGlzLm9wdHMuaGVhZGVycyA9IGNsZWFuUmVxdWVzdEhlYWRlcnModGhpcy5vcHRzLmhlYWRlcnMsIHN0YXR1c0NvZGUgPT09IDMwMywgdGhpcy5vcHRzLm9yaWdpbiAhPT0gb3JpZ2luKVxuICAgIHRoaXMub3B0cy5wYXRoID0gcGF0aFxuICAgIHRoaXMub3B0cy5vcmlnaW4gPSBvcmlnaW5cbiAgICB0aGlzLm9wdHMubWF4UmVkaXJlY3Rpb25zID0gMFxuICAgIHRoaXMub3B0cy5xdWVyeSA9IG51bGxcblxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjRcbiAgICAvLyBJbiBjYXNlIG9mIEhUVFAgMzAzLCBhbHdheXMgcmVwbGFjZSBtZXRob2QgdG8gYmUgZWl0aGVyIEhFQUQgb3IgR0VUXG4gICAgaWYgKHN0YXR1c0NvZGUgPT09IDMwMyAmJiB0aGlzLm9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIHRoaXMub3B0cy5tZXRob2QgPSAnR0VUJ1xuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAvKlxuICAgICAgICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuXG4gICAgICAgIFRMRFI6IHVuZGljaSBhbHdheXMgaWdub3JlcyAzeHggcmVzcG9uc2UgYm9kaWVzLlxuXG4gICAgICAgIFJlZGlyZWN0aW9uIGlzIHVzZWQgdG8gc2VydmUgdGhlIHJlcXVlc3RlZCByZXNvdXJjZSBmcm9tIGFub3RoZXIgVVJMLCBzbyBpdCBpcyBhc3N1bWVzIHRoYXRcbiAgICAgICAgbm8gYm9keSBpcyBnZW5lcmF0ZWQgKGFuZCB0aHVzIGNhbiBiZSBpZ25vcmVkKS4gRXZlbiB0aG91Z2ggZ2VuZXJhdGluZyBhIGJvZHkgaXMgbm90IHByb2hpYml0ZWQuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDEsIDMwMiwgMzAzLCAzMDcgYW5kIDMwOCAodGhlIGxhdHRlciBmcm9tIFJGQyA3MjM4KSwgdGhlIHNwZWNzIG1lbnRpb24gdGhhdCB0aGUgYm9keSB1c3VhbGx5XG4gICAgICAgICh3aGljaCBtZWFucyBpdCdzIG9wdGlvbmFsIGFuZCBub3QgbWFuZGF0ZWQpIGNvbnRhaW4ganVzdCBhbiBoeXBlcmxpbmsgdG8gdGhlIHZhbHVlIG9mXG4gICAgICAgIHRoZSBMb2NhdGlvbiByZXNwb25zZSBoZWFkZXIsIHNvIHRoZSBib2R5IGNhbiBiZSBpZ25vcmVkIHNhZmVseS5cblxuICAgICAgICBGb3Igc3RhdHVzIDMwMCwgd2hpY2ggaXMgXCJNdWx0aXBsZSBDaG9pY2VzXCIsIHRoZSBzcGVjIG1lbnRpb25zIGJvdGggZ2VuZXJhdGluZyBhIExvY2F0aW9uXG4gICAgICAgIHJlc3BvbnNlIGhlYWRlciBBTkQgYSByZXNwb25zZSBib2R5IHdpdGggdGhlIG90aGVyIHBvc3NpYmxlIGxvY2F0aW9uIHRvIGZvbGxvdy5cbiAgICAgICAgU2luY2UgdGhlIHNwZWMgZXhwbGljaXRseSBjaG9vc2VzIG5vdCB0byBzcGVjaWZ5IGEgZm9ybWF0IGZvciBzdWNoIGJvZHkgYW5kIGxlYXZlIGl0IHRvXG4gICAgICAgIHNlcnZlcnMgYW5kIGJyb3dzZXJzIGltcGxlbWVudG9ycywgd2UgaWdub3JlIHRoZSBib2R5IGFzIHRoZXJlIGlzIG5vIHNwZWNpZmllZCB3YXkgdG8gZXZlbnR1YWxseSBwYXJzZSBpdC5cbiAgICAgICovXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25EYXRhKGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgIC8qXG4gICAgICAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG5cbiAgICAgICAgVExEUjogdW5kaWNpIGFsd2F5cyBpZ25vcmVzIDN4eCByZXNwb25zZSB0cmFpbGVycyBhcyB0aGV5IGFyZSBub3QgZXhwZWN0ZWQgaW4gY2FzZSBvZiByZWRpcmVjdGlvbnNcbiAgICAgICAgYW5kIG5laXRoZXIgYXJlIHVzZWZ1bCBpZiBwcmVzZW50LlxuXG4gICAgICAgIFNlZSBjb21tZW50IG9uIG9uRGF0YSBtZXRob2QgYWJvdmUgZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXG4gICAgICAqL1xuXG4gICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLm9wdHMsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vbkNvbXBsZXRlKHRyYWlsZXJzKVxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25Cb2R5U2VudChjaHVuaylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhdGlvbiAoc3RhdHVzQ29kZSwgaGVhZGVycykge1xuICBpZiAocmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMuaW5kZXhPZihzdGF0dXNDb2RlKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKGhlYWRlcnNbaV0ubGVuZ3RoID09PSA4ICYmIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcnNbaV0pID09PSAnbG9jYXRpb24nKSB7XG4gICAgICByZXR1cm4gaGVhZGVyc1tpICsgMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuNFxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlSGVhZGVyIChoZWFkZXIsIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pIHtcbiAgaWYgKGhlYWRlci5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmcoaGVhZGVyKSA9PT0gJ2hvc3QnXG4gIH1cbiAgaWYgKHJlbW92ZUNvbnRlbnQgJiYgdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmcoaGVhZGVyKS5zdGFydHNXaXRoKCdjb250ZW50LScpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAodW5rbm93bk9yaWdpbiAmJiAoaGVhZGVyLmxlbmd0aCA9PT0gMTMgfHwgaGVhZGVyLmxlbmd0aCA9PT0gNiB8fCBoZWFkZXIubGVuZ3RoID09PSAxOSkpIHtcbiAgICBjb25zdCBuYW1lID0gdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmcoaGVhZGVyKVxuICAgIHJldHVybiBuYW1lID09PSAnYXV0aG9yaXphdGlvbicgfHwgbmFtZSA9PT0gJ2Nvb2tpZScgfHwgbmFtZSA9PT0gJ3Byb3h5LWF1dGhvcml6YXRpb24nXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG5mdW5jdGlvbiBjbGVhblJlcXVlc3RIZWFkZXJzIChoZWFkZXJzLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIGNvbnN0IHJldCA9IFtdXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihoZWFkZXJzW2ldLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICByZXQucHVzaChoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoa2V5LCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICByZXQucHVzaChrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGhlYWRlcnMgPT0gbnVsbCwgJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWRpcmVjdEhhbmRsZXJcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImtCb2R5VXNlZCIsImFzc2VydCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiRUUiLCJyZWRpcmVjdGFibGVTdGF0dXNDb2RlcyIsImtCb2R5IiwiU3ltYm9sIiwiQm9keUFzeW5jSXRlcmFibGUiLCJib2R5IiwiYXN5bmNJdGVyYXRvciIsIlJlZGlyZWN0SGFuZGxlciIsImRpc3BhdGNoIiwibWF4UmVkaXJlY3Rpb25zIiwib3B0cyIsImhhbmRsZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ2YWxpZGF0ZUhhbmRsZXIiLCJtZXRob2QiLCJ1cGdyYWRlIiwibG9jYXRpb24iLCJhYm9ydCIsImhpc3RvcnkiLCJyZWRpcmVjdGlvbkxpbWl0UmVhY2hlZCIsImlzU3RyZWFtIiwiYm9keUxlbmd0aCIsIm9uIiwicmVhZGFibGVEaWRSZWFkIiwicHJvdG90eXBlIiwiY2FsbCIsInBpcGVUbyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiaXNJdGVyYWJsZSIsIm9uQ29ubmVjdCIsIm9uVXBncmFkZSIsInN0YXR1c0NvZGUiLCJoZWFkZXJzIiwic29ja2V0Iiwib25FcnJvciIsImVycm9yIiwib25IZWFkZXJzIiwicmVzdW1lIiwic3RhdHVzVGV4dCIsImxlbmd0aCIsImlzRGlzdHVyYmVkIiwicGFyc2VMb2NhdGlvbiIsInRocm93T25NYXhSZWRpcmVjdCIsInJlcXVlc3QiLCJFcnJvciIsIm9yaWdpbiIsInB1c2giLCJVUkwiLCJwYXRoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJwYXJzZVVSTCIsImNsZWFuUmVxdWVzdEhlYWRlcnMiLCJxdWVyeSIsIm9uRGF0YSIsImNodW5rIiwib25Db21wbGV0ZSIsInRyYWlsZXJzIiwib25Cb2R5U2VudCIsImluZGV4T2YiLCJpIiwiaGVhZGVyTmFtZVRvU3RyaW5nIiwic2hvdWxkUmVtb3ZlSGVhZGVyIiwiaGVhZGVyIiwicmVtb3ZlQ29udGVudCIsInVua25vd25PcmlnaW4iLCJzdGFydHNXaXRoIiwibmFtZSIsInJldCIsIkFycmF5IiwiaXNBcnJheSIsImtleSIsIk9iamVjdCIsImtleXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/retry-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/retry-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { kRetryHandlerDefaultRetry } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { RequestRetryError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { isDisturbed, parseHeaders, parseRangeHeader, wrapRequestBody } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nfunction calculateRetryAfterHeader(retryAfter) {\n    const current = Date.now();\n    return new Date(retryAfter).getTime() - current;\n}\nclass RetryHandler {\n    constructor(opts, handlers){\n        const { retryOptions, ...dispatchOpts } = opts;\n        const { // Retry scoped\n        retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, // Response scoped\n        methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};\n        this.dispatch = handlers.dispatch;\n        this.handler = handlers.handler;\n        this.opts = {\n            ...dispatchOpts,\n            body: wrapRequestBody(opts.body)\n        };\n        this.abort = null;\n        this.aborted = false;\n        this.retryOpts = {\n            retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n            retryAfter: retryAfter ?? true,\n            maxTimeout: maxTimeout ?? 30 * 1000,\n            minTimeout: minTimeout ?? 500,\n            timeoutFactor: timeoutFactor ?? 2,\n            maxRetries: maxRetries ?? 5,\n            // What errors we should retry\n            methods: methods ?? [\n                'GET',\n                'HEAD',\n                'OPTIONS',\n                'PUT',\n                'DELETE',\n                'TRACE'\n            ],\n            // Indicates which errors to retry\n            statusCodes: statusCodes ?? [\n                500,\n                502,\n                503,\n                504,\n                429\n            ],\n            // List of errors to retry\n            errorCodes: errorCodes ?? [\n                'ECONNRESET',\n                'ECONNREFUSED',\n                'ENOTFOUND',\n                'ENETDOWN',\n                'ENETUNREACH',\n                'EHOSTDOWN',\n                'EHOSTUNREACH',\n                'EPIPE',\n                'UND_ERR_SOCKET'\n            ]\n        };\n        this.retryCount = 0;\n        this.retryCountCheckpoint = 0;\n        this.start = 0;\n        this.end = null;\n        this.etag = null;\n        this.resume = null;\n        // Handle possible onConnect duplication\n        this.handler.onConnect((reason)=>{\n            this.aborted = true;\n            if (this.abort) {\n                this.abort(reason);\n            } else {\n                this.reason = reason;\n            }\n        });\n    }\n    onRequestSent() {\n        if (this.handler.onRequestSent) {\n            this.handler.onRequestSent();\n        }\n    }\n    onUpgrade(statusCode, headers, socket) {\n        if (this.handler.onUpgrade) {\n            this.handler.onUpgrade(statusCode, headers, socket);\n        }\n    }\n    onConnect(abort) {\n        if (this.aborted) {\n            abort(this.reason);\n        } else {\n            this.abort = abort;\n        }\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);\n    }\n    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {\n        const { statusCode, code, headers } = err;\n        const { method, retryOptions } = opts;\n        const { maxRetries, minTimeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;\n        const { counter } = state;\n        // Any code that is not a Undici's originated and allowed to retry\n        if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n            cb(err);\n            return;\n        }\n        // If a set of method are provided and the current method is not in the list\n        if (Array.isArray(methods) && !methods.includes(method)) {\n            cb(err);\n            return;\n        }\n        // If a set of status code are provided and the current status code is not in the list\n        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {\n            cb(err);\n            return;\n        }\n        // If we reached the max number of retries\n        if (counter > maxRetries) {\n            cb(err);\n            return;\n        }\n        let retryAfterHeader = headers?.['retry-after'];\n        if (retryAfterHeader) {\n            retryAfterHeader = Number(retryAfterHeader);\n            retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3; // Retry-After is in seconds\n        }\n        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);\n        setTimeout(()=>cb(null), retryTimeout);\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const headers = parseHeaders(rawHeaders);\n        this.retryCount += 1;\n        if (statusCode >= 300) {\n            if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n                return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n            } else {\n                this.abort(new RequestRetryError('Request failed', statusCode, {\n                    headers,\n                    data: {\n                        count: this.retryCount\n                    }\n                }));\n                return false;\n            }\n        }\n        // Checkpoint for resume from where we left it\n        if (this.resume != null) {\n            this.resume = null;\n            if (statusCode !== 206) {\n                return true;\n            }\n            const contentRange = parseRangeHeader(headers['content-range']);\n            // If no content range\n            if (!contentRange) {\n                this.abort(new RequestRetryError('Content-Range mismatch', statusCode, {\n                    headers,\n                    data: {\n                        count: this.retryCount\n                    }\n                }));\n                return false;\n            }\n            // Let's start with a weak etag check\n            if (this.etag != null && this.etag !== headers.etag) {\n                this.abort(new RequestRetryError('ETag mismatch', statusCode, {\n                    headers,\n                    data: {\n                        count: this.retryCount\n                    }\n                }));\n                return false;\n            }\n            const { start, size, end = size } = contentRange;\n            assert(this.start === start, 'content-range mismatch');\n            assert(this.end == null || this.end === end, 'content-range mismatch');\n            this.resume = resume;\n            return true;\n        }\n        if (this.end == null) {\n            if (statusCode === 206) {\n                // First time we receive 206\n                const range = parseRangeHeader(headers['content-range']);\n                if (range == null) {\n                    return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n                }\n                const { start, size, end = size } = range;\n                assert(start != null && Number.isFinite(start), 'content-range mismatch');\n                assert(end != null && Number.isFinite(end), 'invalid content-length');\n                this.start = start;\n                this.end = end;\n            }\n            // We make our best to checkpoint the body for further range headers\n            if (this.end == null) {\n                const contentLength = headers['content-length'];\n                this.end = contentLength != null ? Number(contentLength) : null;\n            }\n            assert(Number.isFinite(this.start));\n            assert(this.end == null || Number.isFinite(this.end), 'invalid content-length');\n            this.resume = resume;\n            this.etag = headers.etag != null ? headers.etag : null;\n            // Weak etags are not useful for comparison nor cache\n            // for instance not safe to assume if the response is byte-per-byte\n            // equal\n            if (this.etag != null && this.etag.startsWith('W/')) {\n                this.etag = null;\n            }\n            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n        }\n        const err = new RequestRetryError('Request failed', statusCode, {\n            headers,\n            data: {\n                count: this.retryCount\n            }\n        });\n        this.abort(err);\n        return false;\n    }\n    onData(chunk) {\n        this.start += chunk.length;\n        return this.handler.onData(chunk);\n    }\n    onComplete(rawTrailers) {\n        this.retryCount = 0;\n        return this.handler.onComplete(rawTrailers);\n    }\n    onError(err) {\n        if (this.aborted || isDisturbed(this.opts.body)) {\n            return this.handler.onError(err);\n        }\n        // We reconcile in case of a mix between network errors\n        // and server error response\n        if (this.retryCount - this.retryCountCheckpoint > 0) {\n            // We count the difference between the last checkpoint and the current retry count\n            this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);\n        } else {\n            this.retryCount += 1;\n        }\n        this.retryOpts.retry(err, {\n            state: {\n                counter: this.retryCount\n            },\n            opts: {\n                retryOptions: this.retryOpts,\n                ...this.opts\n            }\n        }, onRetry.bind(this));\n        function onRetry(err) {\n            if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n                return this.handler.onError(err);\n            }\n            if (this.start !== 0) {\n                const headers = {\n                    range: `bytes=${this.start}-${this.end ?? ''}`\n                };\n                // Weak etag check - weak etags will make comparison algorithms never match\n                if (this.etag != null) {\n                    headers['if-match'] = this.etag;\n                }\n                this.opts = {\n                    ...this.opts,\n                    headers: {\n                        ...this.opts.headers,\n                        ...headers\n                    }\n                };\n            }\n            try {\n                this.retryCountCheckpoint = this.retryCount;\n                this.dispatch(this.opts, this);\n            } catch (err) {\n                this.handler.onError(err);\n            }\n        }\n    }\n}\nmodule.exports = RetryHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JldHJ5LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUVwQyxNQUFNLEVBQUVDLHlCQUF5QixFQUFFLEdBQUdELG1CQUFPQSxDQUFDLHdFQUFpQjtBQUMvRCxNQUFNLEVBQUVFLGlCQUFpQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDLHNFQUFnQjtBQUN0RCxNQUFNLEVBQ0pHLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxnQkFBZ0IsRUFDaEJDLGVBQWUsRUFDaEIsR0FBR04sbUJBQU9BLENBQUMsa0VBQWM7QUFFMUIsU0FBU08sMEJBQTJCQyxVQUFVO0lBQzVDLE1BQU1DLFVBQVVDLEtBQUtDLEdBQUc7SUFDeEIsT0FBTyxJQUFJRCxLQUFLRixZQUFZSSxPQUFPLEtBQUtIO0FBQzFDO0FBRUEsTUFBTUk7SUFDSixZQUFhQyxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixNQUFNLEVBQUVDLFlBQVksRUFBRSxHQUFHQyxjQUFjLEdBQUdIO1FBQzFDLE1BQU0sRUFDSixlQUFlO1FBQ2ZJLE9BQU9DLE9BQU8sRUFDZEMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsYUFBYSxFQUNiLGtCQUFrQjtRQUNsQkMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZqQixVQUFVLEVBQ1ZrQixXQUFXLEVBQ1osR0FBR1YsZ0JBQWdCLENBQUM7UUFFckIsSUFBSSxDQUFDVyxRQUFRLEdBQUdaLFNBQVNZLFFBQVE7UUFDakMsSUFBSSxDQUFDQyxPQUFPLEdBQUdiLFNBQVNhLE9BQU87UUFDL0IsSUFBSSxDQUFDZCxJQUFJLEdBQUc7WUFBRSxHQUFHRyxZQUFZO1lBQUVZLE1BQU12QixnQkFBZ0JRLEtBQUtlLElBQUk7UUFBRTtRQUNoRSxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxD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U0QsUUFBU2hDLEdBQUc7WUFDbkIsSUFBSUEsT0FBTyxRQUFRLElBQUksQ0FBQ2pCLE9BQU8sSUFBSTVCLFlBQVksSUFBSSxDQUFDVyxJQUFJLENBQUNlLElBQUksR0FBRztnQkFDOUQsT0FBTyxJQUFJLENBQUNELE9BQU8sQ0FBQ21ELE9BQU8sQ0FBQy9CO1lBQzlCO1lBRUEsSUFBSSxJQUFJLENBQUNiLEtBQUssS0FBSyxHQUFHO2dCQUNwQixNQUFNUyxVQUFVO29CQUFFMkIsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUNwQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ0MsR0FBRyxJQUFJLElBQUk7Z0JBQUM7Z0JBRWpFLDJFQUEyRTtnQkFDM0UsSUFBSSxJQUFJLENBQUNDLElBQUksSUFBSSxNQUFNO29CQUNyQk8sT0FBTyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUNQLElBQUk7Z0JBQ2pDO2dCQUVBLElBQUksQ0FBQ3ZCLElBQUksR0FBRztvQkFDVixHQUFHLElBQUksQ0FBQ0EsSUFBSTtvQkFDWjhCLFNBQVM7d0JBQ1AsR0FBRyxJQUFJLENBQUM5QixJQUFJLENBQUM4QixPQUFPO3dCQUNwQixHQUFHQSxPQUFPO29CQUNaO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJO2dCQUNGLElBQUksQ0FBQ1Ysb0JBQW9CLEdBQUcsSUFBSSxDQUFDRCxVQUFVO2dCQUMzQyxJQUFJLENBQUNOLFFBQVEsQ0FBQyxJQUFJLENBQUNiLElBQUksRUFBRSxJQUFJO1lBQy9CLEVBQUUsT0FBT2tDLEtBQUs7Z0JBQ1osSUFBSSxDQUFDcEIsT0FBTyxDQUFDbUQsT0FBTyxDQUFDL0I7WUFDdkI7UUFDRjtJQUNGO0FBQ0Y7QUFFQWtDLE9BQU9DLE9BQU8sR0FBR3RFIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXHJldHJ5LWhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbmNvbnN0IHsga1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeSB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgUmVxdWVzdFJldHJ5RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHtcbiAgaXNEaXN0dXJiZWQsXG4gIHBhcnNlSGVhZGVycyxcbiAgcGFyc2VSYW5nZUhlYWRlcixcbiAgd3JhcFJlcXVlc3RCb2R5XG59ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuZnVuY3Rpb24gY2FsY3VsYXRlUmV0cnlBZnRlckhlYWRlciAocmV0cnlBZnRlcikge1xuICBjb25zdCBjdXJyZW50ID0gRGF0ZS5ub3coKVxuICByZXR1cm4gbmV3IERhdGUocmV0cnlBZnRlcikuZ2V0VGltZSgpIC0gY3VycmVudFxufVxuXG5jbGFzcyBSZXRyeUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cywgaGFuZGxlcnMpIHtcbiAgICBjb25zdCB7IHJldHJ5T3B0aW9ucywgLi4uZGlzcGF0Y2hPcHRzIH0gPSBvcHRzXG4gICAgY29uc3Qge1xuICAgICAgLy8gUmV0cnkgc2NvcGVkXG4gICAgICByZXRyeTogcmV0cnlGbixcbiAgICAgIG1heFJldHJpZXMsXG4gICAgICBtYXhUaW1lb3V0LFxuICAgICAgbWluVGltZW91dCxcbiAgICAgIHRpbWVvdXRGYWN0b3IsXG4gICAgICAvLyBSZXNwb25zZSBzY29wZWRcbiAgICAgIG1ldGhvZHMsXG4gICAgICBlcnJvckNvZGVzLFxuICAgICAgcmV0cnlBZnRlcixcbiAgICAgIHN0YXR1c0NvZGVzXG4gICAgfSA9IHJldHJ5T3B0aW9ucyA/PyB7fVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGhhbmRsZXJzLmRpc3BhdGNoXG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcnMuaGFuZGxlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGlzcGF0Y2hPcHRzLCBib2R5OiB3cmFwUmVxdWVzdEJvZHkob3B0cy5ib2R5KSB9XG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuICAgIHRoaXMucmV0cnlPcHRzID0ge1xuICAgICAgcmV0cnk6IHJldHJ5Rm4gPz8gUmV0cnlIYW5kbGVyW2tSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnldLFxuICAgICAgcmV0cnlBZnRlcjogcmV0cnlBZnRlciA/PyB0cnVlLFxuICAgICAgbWF4VGltZW91dDogbWF4VGltZW91dCA/PyAzMCAqIDEwMDAsIC8vIDMwcyxcbiAgICAgIG1pblRpbWVvdXQ6IG1pblRpbWVvdXQgPz8gNTAwLCAvLyAuNXNcbiAgICAgIHRpbWVvdXRGYWN0b3I6IHRpbWVvdXRGYWN0b3IgPz8gMixcbiAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMgPz8gNSxcbiAgICAgIC8vIFdoYXQgZXJyb3JzIHdlIHNob3VsZCByZXRyeVxuICAgICAgbWV0aG9kczogbWV0aG9kcyA/PyBbJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUFVUJywgJ0RFTEVURScsICdUUkFDRSddLFxuICAgICAgLy8gSW5kaWNhdGVzIHdoaWNoIGVycm9ycyB0byByZXRyeVxuICAgICAgc3RhdHVzQ29kZXM6IHN0YXR1c0NvZGVzID8/IFs1MDAsIDUwMiwgNTAzLCA1MDQsIDQyOV0sXG4gICAgICAvLyBMaXN0IG9mIGVycm9ycyB0byByZXRyeVxuICAgICAgZXJyb3JDb2RlczogZXJyb3JDb2RlcyA/PyBbXG4gICAgICAgICdFQ09OTlJFU0VUJyxcbiAgICAgICAgJ0VDT05OUkVGVVNFRCcsXG4gICAgICAgICdFTk9URk9VTkQnLFxuICAgICAgICAnRU5FVERPV04nLFxuICAgICAgICAnRU5FVFVOUkVBQ0gnLFxuICAgICAgICAnRUhPU1RET1dOJyxcbiAgICAgICAgJ0VIT1NUVU5SRUFDSCcsXG4gICAgICAgICdFUElQRScsXG4gICAgICAgICdVTkRfRVJSX1NPQ0tFVCdcbiAgICAgIF1cbiAgICB9XG5cbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwXG4gICAgdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludCA9IDBcbiAgICB0aGlzLnN0YXJ0ID0gMFxuICAgIHRoaXMuZW5kID0gbnVsbFxuICAgIHRoaXMuZXRhZyA9IG51bGxcbiAgICB0aGlzLnJlc3VtZSA9IG51bGxcblxuICAgIC8vIEhhbmRsZSBwb3NzaWJsZSBvbkNvbm5lY3QgZHVwbGljYXRpb25cbiAgICB0aGlzLmhhbmRsZXIub25Db25uZWN0KHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlXG4gICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICB0aGlzLmFib3J0KHJlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVhc29uID0gcmVhc29uXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uUmVxdWVzdFNlbnQgKCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXIub25SZXF1ZXN0U2VudCkge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uUmVxdWVzdFNlbnQoKVxuICAgIH1cbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vblVwZ3JhZGUpIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgfVxuICB9XG5cbiAgb25Cb2R5U2VudCAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyLm9uQm9keVNlbnQpIHJldHVybiB0aGlzLmhhbmRsZXIub25Cb2R5U2VudChjaHVuaylcbiAgfVxuXG4gIHN0YXRpYyBba1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeV0gKGVyciwgeyBzdGF0ZSwgb3B0cyB9LCBjYikge1xuICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgY29kZSwgaGVhZGVycyB9ID0gZXJyXG4gICAgY29uc3QgeyBtZXRob2QsIHJldHJ5T3B0aW9ucyB9ID0gb3B0c1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFJldHJpZXMsXG4gICAgICBtaW5UaW1lb3V0LFxuICAgICAgbWF4VGltZW91dCxcbiAgICAgIHRpbWVvdXRGYWN0b3IsXG4gICAgICBzdGF0dXNDb2RlcyxcbiAgICAgIGVycm9yQ29kZXMsXG4gICAgICBtZXRob2RzXG4gICAgfSA9IHJldHJ5T3B0aW9uc1xuICAgIGNvbnN0IHsgY291bnRlciB9ID0gc3RhdGVcblxuICAgIC8vIEFueSBjb2RlIHRoYXQgaXMgbm90IGEgVW5kaWNpJ3Mgb3JpZ2luYXRlZCBhbmQgYWxsb3dlZCB0byByZXRyeVxuICAgIGlmIChjb2RlICYmIGNvZGUgIT09ICdVTkRfRVJSX1JFUV9SRVRSWScgJiYgIWVycm9yQ29kZXMuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIGEgc2V0IG9mIG1ldGhvZCBhcmUgcHJvdmlkZWQgYW5kIHRoZSBjdXJyZW50IG1ldGhvZCBpcyBub3QgaW4gdGhlIGxpc3RcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRob2RzKSAmJiAhbWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBhIHNldCBvZiBzdGF0dXMgY29kZSBhcmUgcHJvdmlkZWQgYW5kIHRoZSBjdXJyZW50IHN0YXR1cyBjb2RlIGlzIG5vdCBpbiB0aGUgbGlzdFxuICAgIGlmIChcbiAgICAgIHN0YXR1c0NvZGUgIT0gbnVsbCAmJlxuICAgICAgQXJyYXkuaXNBcnJheShzdGF0dXNDb2RlcykgJiZcbiAgICAgICFzdGF0dXNDb2Rlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKVxuICAgICkge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgcmVhY2hlZCB0aGUgbWF4IG51bWJlciBvZiByZXRyaWVzXG4gICAgaWYgKGNvdW50ZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgcmV0cnlBZnRlckhlYWRlciA9IGhlYWRlcnM/LlsncmV0cnktYWZ0ZXInXVxuICAgIGlmIChyZXRyeUFmdGVySGVhZGVyKSB7XG4gICAgICByZXRyeUFmdGVySGVhZGVyID0gTnVtYmVyKHJldHJ5QWZ0ZXJIZWFkZXIpXG4gICAgICByZXRyeUFmdGVySGVhZGVyID0gTnVtYmVyLmlzTmFOKHJldHJ5QWZ0ZXJIZWFkZXIpXG4gICAgICAgID8gY2FsY3VsYXRlUmV0cnlBZnRlckhlYWRlcihyZXRyeUFmdGVySGVhZGVyKVxuICAgICAgICA6IHJldHJ5QWZ0ZXJIZWFkZXIgKiAxZTMgLy8gUmV0cnktQWZ0ZXIgaXMgaW4gc2Vjb25kc1xuICAgIH1cblxuICAgIGNvbnN0IHJldHJ5VGltZW91dCA9XG4gICAgICByZXRyeUFmdGVySGVhZGVyID4gMFxuICAgICAgICA/IE1hdGgubWluKHJldHJ5QWZ0ZXJIZWFkZXIsIG1heFRpbWVvdXQpXG4gICAgICAgIDogTWF0aC5taW4obWluVGltZW91dCAqIHRpbWVvdXRGYWN0b3IgKiogKGNvdW50ZXIgLSAxKSwgbWF4VGltZW91dClcblxuICAgIHNldFRpbWVvdXQoKCkgPT4gY2IobnVsbCksIHJldHJ5VGltZW91dClcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuXG4gICAgdGhpcy5yZXRyeUNvdW50ICs9IDFcblxuICAgIGlmIChzdGF0dXNDb2RlID49IDMwMCkge1xuICAgICAgaWYgKHRoaXMucmV0cnlPcHRzLnN0YXR1c0NvZGVzLmluY2x1ZGVzKHN0YXR1c0NvZGUpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhcbiAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgIHJhd0hlYWRlcnMsXG4gICAgICAgICAgcmVzdW1lLFxuICAgICAgICAgIHN0YXR1c01lc3NhZ2VcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hYm9ydChcbiAgICAgICAgICBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ1JlcXVlc3QgZmFpbGVkJywgc3RhdHVzQ29kZSwge1xuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgY291bnQ6IHRoaXMucmV0cnlDb3VudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2twb2ludCBmb3IgcmVzdW1lIGZyb20gd2hlcmUgd2UgbGVmdCBpdFxuICAgIGlmICh0aGlzLnJlc3VtZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJlc3VtZSA9IG51bGxcblxuICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwNikge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250ZW50UmFuZ2UgPSBwYXJzZVJhbmdlSGVhZGVyKGhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXSlcbiAgICAgIC8vIElmIG5vIGNvbnRlbnQgcmFuZ2VcbiAgICAgIGlmICghY29udGVudFJhbmdlKSB7XG4gICAgICAgIHRoaXMuYWJvcnQoXG4gICAgICAgICAgbmV3IFJlcXVlc3RSZXRyeUVycm9yKCdDb250ZW50LVJhbmdlIG1pc21hdGNoJywgc3RhdHVzQ29kZSwge1xuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGRhdGE6IHsgY291bnQ6IHRoaXMucmV0cnlDb3VudCB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gTGV0J3Mgc3RhcnQgd2l0aCBhIHdlYWsgZXRhZyBjaGVja1xuICAgICAgaWYgKHRoaXMuZXRhZyAhPSBudWxsICYmIHRoaXMuZXRhZyAhPT0gaGVhZGVycy5ldGFnKSB7XG4gICAgICAgIHRoaXMuYWJvcnQoXG4gICAgICAgICAgbmV3IFJlcXVlc3RSZXRyeUVycm9yKCdFVGFnIG1pc21hdGNoJywgc3RhdHVzQ29kZSwge1xuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGRhdGE6IHsgY291bnQ6IHRoaXMucmV0cnlDb3VudCB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBzdGFydCwgc2l6ZSwgZW5kID0gc2l6ZSB9ID0gY29udGVudFJhbmdlXG5cbiAgICAgIGFzc2VydCh0aGlzLnN0YXJ0ID09PSBzdGFydCwgJ2NvbnRlbnQtcmFuZ2UgbWlzbWF0Y2gnKVxuICAgICAgYXNzZXJ0KHRoaXMuZW5kID09IG51bGwgfHwgdGhpcy5lbmQgPT09IGVuZCwgJ2NvbnRlbnQtcmFuZ2UgbWlzbWF0Y2gnKVxuXG4gICAgICB0aGlzLnJlc3VtZSA9IHJlc3VtZVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmQgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDIwNikge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIHdlIHJlY2VpdmUgMjA2XG4gICAgICAgIGNvbnN0IHJhbmdlID0gcGFyc2VSYW5nZUhlYWRlcihoZWFkZXJzWydjb250ZW50LXJhbmdlJ10pXG5cbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhcbiAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICByYXdIZWFkZXJzLFxuICAgICAgICAgICAgcmVzdW1lLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIHNpemUsIGVuZCA9IHNpemUgfSA9IHJhbmdlXG4gICAgICAgIGFzc2VydChcbiAgICAgICAgICBzdGFydCAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShzdGFydCksXG4gICAgICAgICAgJ2NvbnRlbnQtcmFuZ2UgbWlzbWF0Y2gnXG4gICAgICAgIClcbiAgICAgICAgYXNzZXJ0KGVuZCAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShlbmQpLCAnaW52YWxpZCBjb250ZW50LWxlbmd0aCcpXG5cbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0XG4gICAgICAgIHRoaXMuZW5kID0gZW5kXG4gICAgICB9XG5cbiAgICAgIC8vIFdlIG1ha2Ugb3VyIGJlc3QgdG8gY2hlY2twb2ludCB0aGUgYm9keSBmb3IgZnVydGhlciByYW5nZSBoZWFkZXJzXG4gICAgICBpZiAodGhpcy5lbmQgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuICAgICAgICB0aGlzLmVuZCA9IGNvbnRlbnRMZW5ndGggIT0gbnVsbCA/IE51bWJlcihjb250ZW50TGVuZ3RoKSA6IG51bGxcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh0aGlzLnN0YXJ0KSlcbiAgICAgIGFzc2VydChcbiAgICAgICAgdGhpcy5lbmQgPT0gbnVsbCB8fCBOdW1iZXIuaXNGaW5pdGUodGhpcy5lbmQpLFxuICAgICAgICAnaW52YWxpZCBjb250ZW50LWxlbmd0aCdcbiAgICAgIClcblxuICAgICAgdGhpcy5yZXN1bWUgPSByZXN1bWVcbiAgICAgIHRoaXMuZXRhZyA9IGhlYWRlcnMuZXRhZyAhPSBudWxsID8gaGVhZGVycy5ldGFnIDogbnVsbFxuXG4gICAgICAvLyBXZWFrIGV0YWdzIGFyZSBub3QgdXNlZnVsIGZvciBjb21wYXJpc29uIG5vciBjYWNoZVxuICAgICAgLy8gZm9yIGluc3RhbmNlIG5vdCBzYWZlIHRvIGFzc3VtZSBpZiB0aGUgcmVzcG9uc2UgaXMgYnl0ZS1wZXItYnl0ZVxuICAgICAgLy8gZXF1YWxcbiAgICAgIGlmICh0aGlzLmV0YWcgIT0gbnVsbCAmJiB0aGlzLmV0YWcuc3RhcnRzV2l0aCgnVy8nKSkge1xuICAgICAgICB0aGlzLmV0YWcgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25IZWFkZXJzKFxuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICByYXdIZWFkZXJzLFxuICAgICAgICByZXN1bWUsXG4gICAgICAgIHN0YXR1c01lc3NhZ2VcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBlcnIgPSBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ1JlcXVlc3QgZmFpbGVkJywgc3RhdHVzQ29kZSwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIGRhdGE6IHsgY291bnQ6IHRoaXMucmV0cnlDb3VudCB9XG4gICAgfSlcblxuICAgIHRoaXMuYWJvcnQoZXJyKVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgdGhpcy5zdGFydCArPSBjaHVuay5sZW5ndGhcblxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25EYXRhKGNodW5rKVxuICB9XG5cbiAgb25Db21wbGV0ZSAocmF3VHJhaWxlcnMpIHtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkNvbXBsZXRlKHJhd1RyYWlsZXJzKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgaWYgKHRoaXMuYWJvcnRlZCB8fCBpc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgfVxuXG4gICAgLy8gV2UgcmVjb25jaWxlIGluIGNhc2Ugb2YgYSBtaXggYmV0d2VlbiBuZXR3b3JrIGVycm9yc1xuICAgIC8vIGFuZCBzZXJ2ZXIgZXJyb3IgcmVzcG9uc2VcbiAgICBpZiAodGhpcy5yZXRyeUNvdW50IC0gdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludCA+IDApIHtcbiAgICAgIC8vIFdlIGNvdW50IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGxhc3QgY2hlY2twb2ludCBhbmQgdGhlIGN1cnJlbnQgcmV0cnkgY291bnRcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9XG4gICAgICAgIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgK1xuICAgICAgICAodGhpcy5yZXRyeUNvdW50IC0gdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ICs9IDFcbiAgICB9XG5cbiAgICB0aGlzLnJldHJ5T3B0cy5yZXRyeShcbiAgICAgIGVycixcbiAgICAgIHtcbiAgICAgICAgc3RhdGU6IHsgY291bnRlcjogdGhpcy5yZXRyeUNvdW50IH0sXG4gICAgICAgIG9wdHM6IHsgcmV0cnlPcHRpb25zOiB0aGlzLnJldHJ5T3B0cywgLi4udGhpcy5vcHRzIH1cbiAgICAgIH0sXG4gICAgICBvblJldHJ5LmJpbmQodGhpcylcbiAgICApXG5cbiAgICBmdW5jdGlvbiBvblJldHJ5IChlcnIpIHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCB8fCB0aGlzLmFib3J0ZWQgfHwgaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IHJhbmdlOiBgYnl0ZXM9JHt0aGlzLnN0YXJ0fS0ke3RoaXMuZW5kID8/ICcnfWAgfVxuXG4gICAgICAgIC8vIFdlYWsgZXRhZyBjaGVjayAtIHdlYWsgZXRhZ3Mgd2lsbCBtYWtlIGNvbXBhcmlzb24gYWxnb3JpdGhtcyBuZXZlciBtYXRjaFxuICAgICAgICBpZiAodGhpcy5ldGFnICE9IG51bGwpIHtcbiAgICAgICAgICBoZWFkZXJzWydpZi1tYXRjaCddID0gdGhpcy5ldGFnXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdHMgPSB7XG4gICAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0cy5oZWFkZXJzLFxuICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJldHJ5Q291bnRDaGVja3BvaW50ID0gdGhpcy5yZXRyeUNvdW50XG4gICAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5vcHRzLCB0aGlzKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5vbkVycm9yKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXRyeUhhbmRsZXJcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwia1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeSIsIlJlcXVlc3RSZXRyeUVycm9yIiwiaXNEaXN0dXJiZWQiLCJwYXJzZUhlYWRlcnMiLCJwYXJzZVJhbmdlSGVhZGVyIiwid3JhcFJlcXVlc3RCb2R5IiwiY2FsY3VsYXRlUmV0cnlBZnRlckhlYWRlciIsInJldHJ5QWZ0ZXIiLCJjdXJyZW50IiwiRGF0ZSIsIm5vdyIsImdldFRpbWUiLCJSZXRyeUhhbmRsZXIiLCJvcHRzIiwiaGFuZGxlcnMiLCJyZXRyeU9wdGlvbnMiLCJkaXNwYXRjaE9wdHMiLCJyZXRyeSIsInJldHJ5Rm4iLCJtYXhSZXRyaWVzIiwibWF4VGltZW91dCIsIm1pblRpbWVvdXQiLCJ0aW1lb3V0RmFjdG9yIiwibWV0aG9kcyIsImVycm9yQ29kZXMiLCJzdGF0dXNDb2RlcyIsImRpc3BhdGNoIiwiaGFuZGxlciIsImJvZHkiLCJhYm9ydCIsImFib3J0ZWQiLCJyZXRyeU9wdHMiLCJyZXRyeUNvdW50IiwicmV0cnlDb3VudENoZWNrcG9pbnQiLCJzdGFydCIsImVuZCIsImV0YWciLCJyZXN1bWUiLCJvbkNvbm5lY3QiLCJyZWFzb24iLCJvblJlcXVlc3RTZW50Iiwib25VcGdyYWRlIiwic3RhdHVzQ29kZSIsImhlYWRlcnMiLCJzb2NrZXQiLCJvbkJvZHlTZW50IiwiY2h1bmsiLCJlcnIiLCJzdGF0ZSIsImNiIiwiY29kZSIsIm1ldGhvZCIsImNvdW50ZXIiLCJpbmNsdWRlcyIsIkFycmF5IiwiaXNBcnJheSIsInJldHJ5QWZ0ZXJIZWFkZXIiLCJOdW1iZXIiLCJpc05hTiIsInJldHJ5VGltZW91dCIsIk1hdGgiLCJtaW4iLCJzZXRUaW1lb3V0Iiwib25IZWFkZXJzIiwicmF3SGVhZGVycyIsInN0YXR1c01lc3NhZ2UiLCJkYXRhIiwiY291bnQiLCJjb250ZW50UmFuZ2UiLCJzaXplIiwicmFuZ2UiLCJpc0Zpbml0ZSIsImNvbnRlbnRMZW5ndGgiLCJzdGFydHNXaXRoIiwib25EYXRhIiwibGVuZ3RoIiwib25Db21wbGV0ZSIsInJhd1RyYWlsZXJzIiwib25FcnJvciIsIm9uUmV0cnkiLCJiaW5kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/retry-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/dump.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dump.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\");\nclass DumpHandler extends DecoratorHandler {\n    #maxSize;\n    #abort;\n    #dumped;\n    #aborted;\n    #size;\n    #reason;\n    #handler;\n    constructor({ maxSize }, handler){\n        super(handler), this.#maxSize = 1024 * 1024, this.#abort = null, this.#dumped = false, this.#aborted = false, this.#size = 0, this.#reason = null, this.#handler = null;\n        if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {\n            throw new InvalidArgumentError('maxSize must be a number greater than 0');\n        }\n        this.#maxSize = maxSize ?? this.#maxSize;\n        this.#handler = handler;\n    }\n    onConnect(abort) {\n        this.#abort = abort;\n        this.#handler.onConnect(this.#customAbort.bind(this));\n    }\n    #customAbort(reason) {\n        this.#aborted = true;\n        this.#reason = reason;\n    }\n    // TODO: will require adjustment after new hooks are out\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const headers = util.parseHeaders(rawHeaders);\n        const contentLength = headers['content-length'];\n        if (contentLength != null && contentLength > this.#maxSize) {\n            throw new RequestAbortedError(`Response size (${contentLength}) larger than maxSize (${this.#maxSize})`);\n        }\n        if (this.#aborted) {\n            return true;\n        }\n        return this.#handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n    }\n    onError(err) {\n        if (this.#dumped) {\n            return;\n        }\n        err = this.#reason ?? err;\n        this.#handler.onError(err);\n    }\n    onData(chunk) {\n        this.#size = this.#size + chunk.length;\n        if (this.#size >= this.#maxSize) {\n            this.#dumped = true;\n            if (this.#aborted) {\n                this.#handler.onError(this.#reason);\n            } else {\n                this.#handler.onComplete([]);\n            }\n        }\n        return true;\n    }\n    onComplete(trailers) {\n        if (this.#dumped) {\n            return;\n        }\n        if (this.#aborted) {\n            this.#handler.onError(this.reason);\n            return;\n        }\n        this.#handler.onComplete(trailers);\n    }\n}\nfunction createDumpInterceptor({ maxSize: defaultMaxSize } = {\n    maxSize: 1024 * 1024\n}) {\n    return (dispatch)=>{\n        return function Intercept(opts, handler) {\n            const { dumpMaxSize = defaultMaxSize } = opts;\n            const dumpHandler = new DumpHandler({\n                maxSize: dumpMaxSize\n            }, handler);\n            return dispatch(opts, dumpHandler);\n        };\n    };\n}\nmodule.exports = createDumpInterceptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kdW1wLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUMsa0VBQWM7QUFDbkMsTUFBTSxFQUFFQyxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsc0VBQWdCO0FBQzlFLE1BQU1HLG1CQUFtQkgsbUJBQU9BLENBQUMsa0dBQThCO0FBRS9ELE1BQU1JLG9CQUFvQkQ7SUFDeEIsUUFBUSxDQUFjO0lBQ3RCLE1BQU0sQ0FBTztJQUNiLE9BQU8sQ0FBUTtJQUNmLFFBQVEsQ0FBUTtJQUNoQixLQUFLLENBQUk7SUFDVCxPQUFPLENBQU87SUFDZCxRQUFRLENBQU87SUFFZixZQUFhLEVBQUVFLE9BQU8sRUFBRSxFQUFFQyxPQUFPLENBQUU7UUFDakMsS0FBSyxDQUFDQSxlQVRSLFFBQVEsR0FBRyxPQUFPLFdBQ2xCLE1BQU0sR0FBRyxXQUNULE9BQU8sR0FBRyxZQUNWLFFBQVEsR0FBRyxZQUNYLEtBQUssR0FBRyxRQUNSLE9BQU8sR0FBRyxXQUNWLFFBQVEsR0FBRztRQUtULElBQUlELFdBQVcsUUFBUyxFQUFDRSxPQUFPQyxRQUFRLENBQUNILFlBQVlBLFVBQVUsSUFBSTtZQUNqRSxNQUFNLElBQUlKLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQyxRQUFRLEdBQUdJLFdBQVcsSUFBSSxDQUFDLFFBQVE7UUFDeEMsSUFBSSxDQUFDLFFBQVEsR0FBR0M7SUFDbEI7SUFFQUcsVUFBV0MsS0FBSyxFQUFFO1FBQ2hCLElBQUksQ0FBQyxNQUFNLEdBQUdBO1FBRWQsSUFBSSxDQUFDLFFBQVEsQ0FBQ0QsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUNFLElBQUksQ0FBQyxJQUFJO0lBQ3JEO0lBRUEsWUFBWSxDQUFFQyxNQUFNO1FBQ2xCLElBQUksQ0FBQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDLE9BQU8sR0FBR0E7SUFDakI7SUFFQSx3REFBd0Q7SUFDeERDLFVBQVdDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLGFBQWEsRUFBRTtRQUN4RCxNQUFNQyxVQUFVbkIsS0FBS29CLFlBQVksQ0FBQ0o7UUFDbEMsTUFBTUssZ0JBQWdCRixPQUFPLENBQUMsaUJBQWlCO1FBRS9DLElBQUlFLGlCQUFpQixRQUFRQSxnQkFBZ0IsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUMxRCxNQUFNLElBQUlsQixvQkFDUixDQUFDLGVBQWUsRUFBRWtCLGNBQWMsdUJBQXVCLEVBQ3JELElBQUksQ0FBQyxRQUFRLENBQ2QsQ0FBQyxDQUFDO1FBRVA7UUFFQSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsT0FBTztRQUNUO1FBRUEsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDUCxTQUFTLENBQzVCQyxZQUNBQyxZQUNBQyxRQUNBQztJQUVKO0lBRUFJLFFBQVNDLEdBQUcsRUFBRTtRQUNaLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNoQjtRQUNGO1FBRUFBLE1BQU0sSUFBSSxDQUFDLE9BQU8sSUFBSUE7UUFFdEIsSUFBSSxDQUFDLFFBQVEsQ0FBQ0QsT0FBTyxDQUFDQztJQUN4QjtJQUVBQyxPQUFRQyxLQUFLLEVBQUU7UUFDYixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUdBLE1BQU1DLE1BQU07UUFFdEMsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDL0IsSUFBSSxDQUFDLE9BQU8sR0FBRztZQUVmLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDakIsSUFBSSxDQUFDLFFBQVEsQ0FBQ0osT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPO1lBQ3BDLE9BQU87Z0JBQ0wsSUFBSSxDQUFDLFFBQVEsQ0FBQ0ssVUFBVSxDQUFDLEVBQUU7WUFDN0I7UUFDRjtRQUVBLE9BQU87SUFDVDtJQUVBQSxXQUFZQyxRQUFRLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCO1FBQ0Y7UUFFQSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLFFBQVEsQ0FBQ04sT0FBTyxDQUFDLElBQUksQ0FBQ1QsTUFBTTtZQUNqQztRQUNGO1FBRUEsSUFBSSxDQUFDLFFBQVEsQ0FBQ2MsVUFBVSxDQUFDQztJQUMzQjtBQUNGO0FBRUEsU0FBU0Msc0JBQ1AsRUFBRXZCLFNBQVN3QixjQUFjLEVBQUUsR0FBRztJQUM1QnhCLFNBQVMsT0FBTztBQUNsQixDQUFDO0lBRUQsT0FBT3lCLENBQUFBO1FBQ0wsT0FBTyxTQUFTQyxVQUFXQyxJQUFJLEVBQUUxQixPQUFPO1lBQ3RDLE1BQU0sRUFBRTJCLGNBQWNKLGNBQWMsRUFBRSxHQUNwQ0c7WUFFRixNQUFNRSxjQUFjLElBQUk5QixZQUN0QjtnQkFBRUMsU0FBUzRCO1lBQVksR0FDdkIzQjtZQUdGLE9BQU93QixTQUFTRSxNQUFNRTtRQUN4QjtJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHUiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxpbnRlcmNlcHRvclxcZHVtcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBEZWNvcmF0b3JIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci9kZWNvcmF0b3ItaGFuZGxlcicpXG5cbmNsYXNzIER1bXBIYW5kbGVyIGV4dGVuZHMgRGVjb3JhdG9ySGFuZGxlciB7XG4gICNtYXhTaXplID0gMTAyNCAqIDEwMjRcbiAgI2Fib3J0ID0gbnVsbFxuICAjZHVtcGVkID0gZmFsc2VcbiAgI2Fib3J0ZWQgPSBmYWxzZVxuICAjc2l6ZSA9IDBcbiAgI3JlYXNvbiA9IG51bGxcbiAgI2hhbmRsZXIgPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKHsgbWF4U2l6ZSB9LCBoYW5kbGVyKSB7XG4gICAgc3VwZXIoaGFuZGxlcilcblxuICAgIGlmIChtYXhTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUobWF4U2l6ZSkgfHwgbWF4U2l6ZSA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFNpemUgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpXG4gICAgfVxuXG4gICAgdGhpcy4jbWF4U2l6ZSA9IG1heFNpemUgPz8gdGhpcy4jbWF4U2l6ZVxuICAgIHRoaXMuI2hhbmRsZXIgPSBoYW5kbGVyXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgdGhpcy4jYWJvcnQgPSBhYm9ydFxuXG4gICAgdGhpcy4jaGFuZGxlci5vbkNvbm5lY3QodGhpcy4jY3VzdG9tQWJvcnQuYmluZCh0aGlzKSlcbiAgfVxuXG4gICNjdXN0b21BYm9ydCAocmVhc29uKSB7XG4gICAgdGhpcy4jYWJvcnRlZCA9IHRydWVcbiAgICB0aGlzLiNyZWFzb24gPSByZWFzb25cbiAgfVxuXG4gIC8vIFRPRE86IHdpbGwgcmVxdWlyZSBhZGp1c3RtZW50IGFmdGVyIG5ldyBob29rcyBhcmUgb3V0XG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cblxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCA+IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKFxuICAgICAgICBgUmVzcG9uc2Ugc2l6ZSAoJHtjb250ZW50TGVuZ3RofSkgbGFyZ2VyIHRoYW4gbWF4U2l6ZSAoJHtcbiAgICAgICAgICB0aGlzLiNtYXhTaXplXG4gICAgICAgIH0pYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiNhYm9ydGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uSGVhZGVycyhcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICByYXdIZWFkZXJzLFxuICAgICAgcmVzdW1lLFxuICAgICAgc3RhdHVzTWVzc2FnZVxuICAgIClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGlmICh0aGlzLiNkdW1wZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGVyciA9IHRoaXMuI3JlYXNvbiA/PyBlcnJcblxuICAgIHRoaXMuI2hhbmRsZXIub25FcnJvcihlcnIpXG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgdGhpcy4jc2l6ZSA9IHRoaXMuI3NpemUgKyBjaHVuay5sZW5ndGhcblxuICAgIGlmICh0aGlzLiNzaXplID49IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2R1bXBlZCA9IHRydWVcblxuICAgICAgaWYgKHRoaXMuI2Fib3J0ZWQpIHtcbiAgICAgICAgdGhpcy4jaGFuZGxlci5vbkVycm9yKHRoaXMuI3JlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI2hhbmRsZXIub25Db21wbGV0ZShbXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBpZiAodGhpcy4jZHVtcGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy4jYWJvcnRlZCkge1xuICAgICAgdGhpcy4jaGFuZGxlci5vbkVycm9yKHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy4jaGFuZGxlci5vbkNvbXBsZXRlKHRyYWlsZXJzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1bXBJbnRlcmNlcHRvciAoXG4gIHsgbWF4U2l6ZTogZGVmYXVsdE1heFNpemUgfSA9IHtcbiAgICBtYXhTaXplOiAxMDI0ICogMTAyNFxuICB9XG4pIHtcbiAgcmV0dXJuIGRpc3BhdGNoID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gSW50ZXJjZXB0IChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICBjb25zdCB7IGR1bXBNYXhTaXplID0gZGVmYXVsdE1heFNpemUgfSA9XG4gICAgICAgIG9wdHNcblxuICAgICAgY29uc3QgZHVtcEhhbmRsZXIgPSBuZXcgRHVtcEhhbmRsZXIoXG4gICAgICAgIHsgbWF4U2l6ZTogZHVtcE1heFNpemUgfSxcbiAgICAgICAgaGFuZGxlclxuICAgICAgKVxuXG4gICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgZHVtcEhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRHVtcEludGVyY2VwdG9yXG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJEZWNvcmF0b3JIYW5kbGVyIiwiRHVtcEhhbmRsZXIiLCJtYXhTaXplIiwiaGFuZGxlciIsIk51bWJlciIsImlzRmluaXRlIiwib25Db25uZWN0IiwiYWJvcnQiLCJiaW5kIiwicmVhc29uIiwib25IZWFkZXJzIiwic3RhdHVzQ29kZSIsInJhd0hlYWRlcnMiLCJyZXN1bWUiLCJzdGF0dXNNZXNzYWdlIiwiaGVhZGVycyIsInBhcnNlSGVhZGVycyIsImNvbnRlbnRMZW5ndGgiLCJvbkVycm9yIiwiZXJyIiwib25EYXRhIiwiY2h1bmsiLCJsZW5ndGgiLCJvbkNvbXBsZXRlIiwidHJhaWxlcnMiLCJjcmVhdGVEdW1wSW50ZXJjZXB0b3IiLCJkZWZhdWx0TWF4U2l6ZSIsImRpc3BhdGNoIiwiSW50ZXJjZXB0Iiwib3B0cyIsImR1bXBNYXhTaXplIiwiZHVtcEhhbmRsZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/dump.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect-interceptor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\");\nfunction createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {\n    return (dispatch)=>{\n        return function Intercept(opts, handler) {\n            const { maxRedirections = defaultMaxRedirections } = opts;\n            if (!maxRedirections) {\n                return dispatch(opts, handler);\n            }\n            const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);\n            opts = {\n                ...opts,\n                maxRedirections: 0\n            }; // Stop sub dispatcher from also redirecting.\n            return dispatch(opts, redirectHandler);\n        };\n    };\n}\nmodule.exports = createRedirectInterceptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC1pbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGtCQUFrQkMsbUJBQU9BLENBQUMsZ0dBQTZCO0FBRTdELFNBQVNDLDBCQUEyQixFQUFFQyxpQkFBaUJDLHNCQUFzQixFQUFFO0lBQzdFLE9BQU8sQ0FBQ0M7UUFDTixPQUFPLFNBQVNDLFVBQVdDLElBQUksRUFBRUMsT0FBTztZQUN0QyxNQUFNLEVBQUVMLGtCQUFrQkMsc0JBQXNCLEVBQUUsR0FBR0c7WUFFckQsSUFBSSxDQUFDSixpQkFBaUI7Z0JBQ3BCLE9BQU9FLFNBQVNFLE1BQU1DO1lBQ3hCO1lBRUEsTUFBTUMsa0JBQWtCLElBQUlULGdCQUFnQkssVUFBVUYsaUJBQWlCSSxNQUFNQztZQUM3RUQsT0FBTztnQkFBRSxHQUFHQSxJQUFJO2dCQUFFSixpQkFBaUI7WUFBRSxHQUFFLDZDQUE2QztZQUNwRixPQUFPRSxTQUFTRSxNQUFNRTtRQUN4QjtJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHVCIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxpbnRlcmNlcHRvclxccmVkaXJlY3QtaW50ZXJjZXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgKHsgbWF4UmVkaXJlY3Rpb25zOiBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIH0pIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBJbnRlcmNlcHQgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zID0gZGVmYXVsdE1heFJlZGlyZWN0aW9ucyB9ID0gb3B0c1xuXG4gICAgICBpZiAoIW1heFJlZGlyZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVkaXJlY3RIYW5kbGVyID0gbmV3IFJlZGlyZWN0SGFuZGxlcihkaXNwYXRjaCwgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgb3B0cyA9IHsgLi4ub3B0cywgbWF4UmVkaXJlY3Rpb25zOiAwIH0gLy8gU3RvcCBzdWIgZGlzcGF0Y2hlciBmcm9tIGFsc28gcmVkaXJlY3RpbmcuXG4gICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgcmVkaXJlY3RIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3JcbiJdLCJuYW1lcyI6WyJSZWRpcmVjdEhhbmRsZXIiLCJyZXF1aXJlIiwiY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciIsIm1heFJlZGlyZWN0aW9ucyIsImRlZmF1bHRNYXhSZWRpcmVjdGlvbnMiLCJkaXNwYXRjaCIsIkludGVyY2VwdCIsIm9wdHMiLCJoYW5kbGVyIiwicmVkaXJlY3RIYW5kbGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/redirect.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\");\nmodule.exports = (opts)=>{\n    const globalMaxRedirections = opts?.maxRedirections;\n    return (dispatch)=>{\n        return function redirectInterceptor(opts, handler) {\n            const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts;\n            if (!maxRedirections) {\n                return dispatch(opts, handler);\n            }\n            const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);\n            return dispatch(baseOpts, redirectHandler);\n        };\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLGtCQUFrQkMsbUJBQU9BLENBQUMsZ0dBQTZCO0FBRTdEQyxPQUFPQyxPQUFPLEdBQUdDLENBQUFBO0lBQ2YsTUFBTUMsd0JBQXdCRCxNQUFNRTtJQUNwQyxPQUFPQyxDQUFBQTtRQUNMLE9BQU8sU0FBU0Msb0JBQXFCSixJQUFJLEVBQUVLLE9BQU87WUFDaEQsTUFBTSxFQUFFSCxrQkFBa0JELHFCQUFxQixFQUFFLEdBQUdLLFVBQVUsR0FBR047WUFFakUsSUFBSSxDQUFDRSxpQkFBaUI7Z0JBQ3BCLE9BQU9DLFNBQVNILE1BQU1LO1lBQ3hCO1lBRUEsTUFBTUUsa0JBQWtCLElBQUlYLGdCQUMxQk8sVUFDQUQsaUJBQ0FGLE1BQ0FLO1lBR0YsT0FBT0YsU0FBU0csVUFBVUM7UUFDNUI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGludGVyY2VwdG9yXFxyZWRpcmVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gb3B0cyA9PiB7XG4gIGNvbnN0IGdsb2JhbE1heFJlZGlyZWN0aW9ucyA9IG9wdHM/Lm1heFJlZGlyZWN0aW9uc1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiByZWRpcmVjdEludGVyY2VwdG9yIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICBjb25zdCB7IG1heFJlZGlyZWN0aW9ucyA9IGdsb2JhbE1heFJlZGlyZWN0aW9ucywgLi4uYmFzZU9wdHMgfSA9IG9wdHNcblxuICAgICAgaWYgKCFtYXhSZWRpcmVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZGlyZWN0SGFuZGxlciA9IG5ldyBSZWRpcmVjdEhhbmRsZXIoXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBtYXhSZWRpcmVjdGlvbnMsXG4gICAgICAgIG9wdHMsXG4gICAgICAgIGhhbmRsZXJcbiAgICAgIClcblxuICAgICAgcmV0dXJuIGRpc3BhdGNoKGJhc2VPcHRzLCByZWRpcmVjdEhhbmRsZXIpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiUmVkaXJlY3RIYW5kbGVyIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJvcHRzIiwiZ2xvYmFsTWF4UmVkaXJlY3Rpb25zIiwibWF4UmVkaXJlY3Rpb25zIiwiZGlzcGF0Y2giLCJyZWRpcmVjdEludGVyY2VwdG9yIiwiaGFuZGxlciIsImJhc2VPcHRzIiwicmVkaXJlY3RIYW5kbGVyIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/redirect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/retry.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/retry.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\");\nmodule.exports = (globalOpts)=>{\n    return (dispatch)=>{\n        return function retryInterceptor(opts, handler) {\n            return dispatch(opts, new RetryHandler({\n                ...opts,\n                retryOptions: {\n                    ...globalOpts,\n                    ...opts.retryOptions\n                }\n            }, {\n                handler,\n                dispatch\n            }));\n        };\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDLDBGQUEwQjtBQUV2REMsT0FBT0MsT0FBTyxHQUFHQyxDQUFBQTtJQUNmLE9BQU9DLENBQUFBO1FBQ0wsT0FBTyxTQUFTQyxpQkFBa0JDLElBQUksRUFBRUMsT0FBTztZQUM3QyxPQUFPSCxTQUNMRSxNQUNBLElBQUlQLGFBQ0Y7Z0JBQUUsR0FBR08sSUFBSTtnQkFBRUUsY0FBYztvQkFBRSxHQUFHTCxVQUFVO29CQUFFLEdBQUdHLEtBQUtFLFlBQVk7Z0JBQUM7WUFBRSxHQUNqRTtnQkFDRUQ7Z0JBQ0FIO1lBQ0Y7UUFHTjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaW50ZXJjZXB0b3JcXHJldHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgUmV0cnlIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci9yZXRyeS1oYW5kbGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxPcHRzID0+IHtcbiAgcmV0dXJuIGRpc3BhdGNoID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmV0cnlJbnRlcmNlcHRvciAob3B0cywgaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKFxuICAgICAgICBvcHRzLFxuICAgICAgICBuZXcgUmV0cnlIYW5kbGVyKFxuICAgICAgICAgIHsgLi4ub3B0cywgcmV0cnlPcHRpb25zOiB7IC4uLmdsb2JhbE9wdHMsIC4uLm9wdHMucmV0cnlPcHRpb25zIH0gfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgZGlzcGF0Y2hcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJSZXRyeUhhbmRsZXIiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImdsb2JhbE9wdHMiLCJkaXNwYXRjaCIsInJldHJ5SW50ZXJjZXB0b3IiLCJvcHRzIiwiaGFuZGxlciIsInJldHJ5T3B0aW9ucyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/retry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function(ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function(TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function(FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function(LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function(METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */ METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */ METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */ METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */ METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */ METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */ METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */ METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */ METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */ METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */ METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */ METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS['M-SEARCH'],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key)=>{\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function(FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor(let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++){\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9\n};\nexports.HEX_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 0XA,\n    B: 0XB,\n    C: 0XC,\n    D: 0XD,\n    E: 0XE,\n    F: 0XF,\n    a: 0xa,\n    b: 0xb,\n    c: 0xc,\n    d: 0xd,\n    e: 0xe,\n    f: 0xf\n};\nexports.NUM = [\n    '0',\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8',\n    '9'\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = [\n    '-',\n    '_',\n    '.',\n    '!',\n    '~',\n    '*',\n    '\\'',\n    '(',\n    ')'\n];\nexports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([\n    '%',\n    ';',\n    ':',\n    '&',\n    '=',\n    '+',\n    '$',\n    ','\n]);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    '!',\n    '\"',\n    '$',\n    '%',\n    '&',\n    '\\'',\n    '(',\n    ')',\n    '*',\n    '+',\n    ',',\n    '-',\n    '.',\n    '/',\n    ':',\n    ';',\n    '<',\n    '=',\n    '>',\n    '@',\n    '[',\n    '\\\\',\n    ']',\n    '^',\n    '_',\n    '`',\n    '{',\n    '|',\n    '}',\n    '~'\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR.concat([\n    '\\t',\n    '\\f'\n]);\n// All characters with 0x80 bit set to 1\nfor(let i = 0x80; i <= 0xff; i++){\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat([\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F'\n]);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */ exports.STRICT_TOKEN = [\n    '!',\n    '#',\n    '$',\n    '%',\n    '&',\n    '\\'',\n    '*',\n    '+',\n    '-',\n    '.',\n    '^',\n    '_',\n    '`',\n    '|',\n    '~'\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([\n    ' '\n]);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */ exports.HEADER_CHARS = [\n    '\\t'\n];\nfor(let i = 32; i <= 255; i++){\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c)=>c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function(HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    'connection': HEADER_STATE.CONNECTION,\n    'content-length': HEADER_STATE.CONTENT_LENGTH,\n    'proxy-connection': HEADER_STATE.CONNECTION,\n    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,\n    'upgrade': HEADER_STATE.UPGRADE\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBR0Esb0JBQW9CLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSw4QkFBOEIsR0FBR0Esb0JBQW9CLEdBQUdBLGFBQWEsR0FBR0Esb0JBQW9CLEdBQUdBLFdBQVcsR0FBR0EsZ0JBQWdCLEdBQUdBLHVCQUF1QixHQUFHQSxzQkFBc0IsR0FBR0EsWUFBWSxHQUFHQSxnQkFBZ0IsR0FBR0EsV0FBVyxHQUFHQSxlQUFlLEdBQUdBLGVBQWUsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0Esb0JBQW9CLEdBQUdBLG1CQUFtQixHQUFHQSxvQkFBb0IsR0FBR0EsZUFBZSxHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxZQUFZLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQ3ZrQixNQUFNK0IsVUFBVUMsbUJBQU9BLENBQUMsZ0VBQVM7QUFDakMsWUFBWTtBQUNaLElBQUlGO0FBQ0gsVUFBVUEsS0FBSztJQUNaQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHO0lBQ3pCQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQy9CQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQzdCQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyw0QkFBNEIsR0FBRyxFQUFFLEdBQUc7SUFDaERBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUN4Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsaUJBQWlCLEdBQUcsRUFB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LEdBQUcsRUFBRSxHQUFHO0lBQzVDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyx3QkFBd0IsR0FBRyxFQUFFLEdBQUc7SUFDMURBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUNyREEsWUFBWSxDQUFDQSxZQUFZLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQ3ZEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyw0QkFBNEIsR0FBRyxFQUFFLEdBQUc7QUFDbEUsR0FBR0EsZUFBZUgsUUFBUUcsWUFBWSxJQUFLSCxDQUFBQSxvQkFBb0IsR0FBRyxDQUFDO0FBQ25FQSx1QkFBdUIsR0FBRztJQUN0QixjQUFjRyxhQUFhbUcsVUFBVTtJQUNyQyxrQkFBa0JuRyxhQUFhb0csY0FBYztJQUM3QyxvQkFBb0JwRyxhQUFhbUcsVUFBVTtJQUMzQyxxQkFBcUJuRyxhQUFhcUcsaUJBQWlCO0lBQ25ELFdBQVdyRyxhQUFhc0csT0FBTztBQUNuQyxHQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxsbGh0dHBcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0gZXhwb3J0cy5IRUFERVJfU1RBVEUgPSBleHBvcnRzLk1JTk9SID0gZXhwb3J0cy5NQUpPUiA9IGV4cG9ydHMuQ09OTkVDVElPTl9UT0tFTl9DSEFSUyA9IGV4cG9ydHMuSEVBREVSX0NIQVJTID0gZXhwb3J0cy5UT0tFTiA9IGV4cG9ydHMuU1RSSUNUX1RPS0VOID0gZXhwb3J0cy5IRVggPSBleHBvcnRzLlVSTF9DSEFSID0gZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIgPSBleHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5NQVJLID0gZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuTlVNID0gZXhwb3J0cy5IRVhfTUFQID0gZXhwb3J0cy5OVU1fTUFQID0gZXhwb3J0cy5BTFBIQSA9IGV4cG9ydHMuRklOSVNIID0gZXhwb3J0cy5IX01FVEhPRF9NQVAgPSBleHBvcnRzLk1FVEhPRF9NQVAgPSBleHBvcnRzLk1FVEhPRFNfUlRTUCA9IGV4cG9ydHMuTUVUSE9EU19JQ0UgPSBleHBvcnRzLk1FVEhPRFNfSFRUUCA9IGV4cG9ydHMuTUVUSE9EUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuRkxBR1MgPSBleHBvcnRzLlRZUEUgPSBleHBvcnRzLkVSUk9SID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLy8gQyBoZWFkZXJzXG52YXIgRVJST1I7XG4oZnVuY3Rpb24gKEVSUk9SKSB7XG4gICAgRVJST1JbRVJST1JbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5URVJOQUxcIl0gPSAxXSA9IFwiSU5URVJOQUxcIjtcbiAgICBFUlJPUltFUlJPUltcIlNUUklDVFwiXSA9IDJdID0gXCJTVFJJQ1RcIjtcbiAgICBFUlJPUltFUlJPUltcIkxGX0VYUEVDVEVEXCJdID0gM10gPSBcIkxGX0VYUEVDVEVEXCI7XG4gICAgRVJST1JbRVJST1JbXCJVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIXCJdID0gNF0gPSBcIlVORVhQRUNURURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBFUlJPUltFUlJPUltcIkNMT1NFRF9DT05ORUNUSU9OXCJdID0gNV0gPSBcIkNMT1NFRF9DT05ORUNUSU9OXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX01FVEhPRFwiXSA9IDZdID0gXCJJTlZBTElEX01FVEhPRFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9VUkxcIl0gPSA3XSA9IFwiSU5WQUxJRF9VUkxcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ09OU1RBTlRcIl0gPSA4XSA9IFwiSU5WQUxJRF9DT05TVEFOVFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9WRVJTSU9OXCJdID0gOV0gPSBcIklOVkFMSURfVkVSU0lPTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9IRUFERVJfVE9LRU5cIl0gPSAxMF0gPSBcIklOVkFMSURfSEVBREVSX1RPS0VOXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCJdID0gMTFdID0gXCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NIVU5LX1NJWkVcIl0gPSAxMl0gPSBcIklOVkFMSURfQ0hVTktfU0laRVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9TVEFUVVNcIl0gPSAxM10gPSBcIklOVkFMSURfU1RBVFVTXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0VPRl9TVEFURVwiXSA9IDE0XSA9IFwiSU5WQUxJRF9FT0ZfU1RBVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSAxNV0gPSBcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX01FU1NBR0VfQkVHSU5cIl0gPSAxNl0gPSBcIkNCX01FU1NBR0VfQkVHSU5cIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0hFQURFUlNfQ09NUExFVEVcIl0gPSAxN10gPSBcIkNCX0hFQURFUlNfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX01FU1NBR0VfQ09NUExFVEVcIl0gPSAxOF0gPSBcIkNCX01FU1NBR0VfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0NIVU5LX0hFQURFUlwiXSA9IDE5XSA9IFwiQ0JfQ0hVTktfSEVBREVSXCI7XG4gICAgRVJST1JbRVJST1JbXCJDQl9DSFVOS19DT01QTEVURVwiXSA9IDIwXSA9IFwiQ0JfQ0hVTktfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRFwiXSA9IDIxXSA9IFwiUEFVU0VEXCI7XG4gICAgRVJST1JbRVJST1JbXCJQQVVTRURfVVBHUkFERVwiXSA9IDIyXSA9IFwiUEFVU0VEX1VQR1JBREVcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRF9IMl9VUEdSQURFXCJdID0gMjNdID0gXCJQQVVTRURfSDJfVVBHUkFERVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiVVNFUlwiXSA9IDI0XSA9IFwiVVNFUlwiO1xufSkoRVJST1IgPSBleHBvcnRzLkVSUk9SIHx8IChleHBvcnRzLkVSUk9SID0ge30pKTtcbnZhciBUWVBFO1xuKGZ1bmN0aW9uIChUWVBFKSB7XG4gICAgVFlQRVtUWVBFW1wiQk9USFwiXSA9IDBdID0gXCJCT1RIXCI7XG4gICAgVFlQRVtUWVBFW1wiUkVRVUVTVFwiXSA9IDFdID0gXCJSRVFVRVNUXCI7XG4gICAgVFlQRVtUWVBFW1wiUkVTUE9OU0VcIl0gPSAyXSA9IFwiUkVTUE9OU0VcIjtcbn0pKFRZUEUgPSBleHBvcnRzLlRZUEUgfHwgKGV4cG9ydHMuVFlQRSA9IHt9KSk7XG52YXIgRkxBR1M7XG4oZnVuY3Rpb24gKEZMQUdTKSB7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSAxXSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gMl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fVVBHUkFERVwiXSA9IDRdID0gXCJDT05ORUNUSU9OX1VQR1JBREVcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNIVU5LRURcIl0gPSA4XSA9IFwiQ0hVTktFRFwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiVVBHUkFERVwiXSA9IDE2XSA9IFwiVVBHUkFERVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OVEVOVF9MRU5HVEhcIl0gPSAzMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJTS0lQQk9EWVwiXSA9IDY0XSA9IFwiU0tJUEJPRFlcIjtcbiAgICBGTEFHU1tGTEFHU1tcIlRSQUlMSU5HXCJdID0gMTI4XSA9IFwiVFJBSUxJTkdcIjtcbiAgICAvLyAxIDw8IDggaXMgdW51c2VkXG4gICAgRkxBR1NbRkxBR1NbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDUxMl0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HXCI7XG59KShGTEFHUyA9IGV4cG9ydHMuRkxBR1MgfHwgKGV4cG9ydHMuRkxBR1MgPSB7fSkpO1xudmFyIExFTklFTlRfRkxBR1M7XG4oZnVuY3Rpb24gKExFTklFTlRfRkxBR1MpIHtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJIRUFERVJTXCJdID0gMV0gPSBcIkhFQURFUlNcIjtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJDSFVOS0VEX0xFTkdUSFwiXSA9IDJdID0gXCJDSFVOS0VEX0xFTkdUSFwiO1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIktFRVBfQUxJVkVcIl0gPSA0XSA9IFwiS0VFUF9BTElWRVwiO1xufSkoTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyB8fCAoZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0ge30pKTtcbnZhciBNRVRIT0RTO1xuKGZ1bmN0aW9uIChNRVRIT0RTKSB7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiREVMRVRFXCJdID0gMF0gPSBcIkRFTEVURVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkdFVFwiXSA9IDFdID0gXCJHRVRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJIRUFEXCJdID0gMl0gPSBcIkhFQURcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQT1NUXCJdID0gM10gPSBcIlBPU1RcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQVVRcIl0gPSA0XSA9IFwiUFVUXCI7XG4gICAgLyogcGF0aG9sb2dpY2FsICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQ09OTkVDVFwiXSA9IDVdID0gXCJDT05ORUNUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiT1BUSU9OU1wiXSA9IDZdID0gXCJPUFRJT05TXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVFJBQ0VcIl0gPSA3XSA9IFwiVFJBQ0VcIjtcbiAgICAvKiBXZWJEQVYgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDT1BZXCJdID0gOF0gPSBcIkNPUFlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJMT0NLXCJdID0gOV0gPSBcIkxPQ0tcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNS0NPTFwiXSA9IDEwXSA9IFwiTUtDT0xcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNT1ZFXCJdID0gMTFdID0gXCJNT1ZFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJPUEZJTkRcIl0gPSAxMl0gPSBcIlBST1BGSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJPUFBBVENIXCJdID0gMTNdID0gXCJQUk9QUEFUQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTRUFSQ0hcIl0gPSAxNF0gPSBcIlNFQVJDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOTE9DS1wiXSA9IDE1XSA9IFwiVU5MT0NLXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQklORFwiXSA9IDE2XSA9IFwiQklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFQklORFwiXSA9IDE3XSA9IFwiUkVCSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5CSU5EXCJdID0gMThdID0gXCJVTkJJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJBQ0xcIl0gPSAxOV0gPSBcIkFDTFwiO1xuICAgIC8qIHN1YnZlcnNpb24gKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJSRVBPUlRcIl0gPSAyMF0gPSBcIlJFUE9SVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1LQUNUSVZJVFlcIl0gPSAyMV0gPSBcIk1LQUNUSVZJVFlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDSEVDS09VVFwiXSA9IDIyXSA9IFwiQ0hFQ0tPVVRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNRVJHRVwiXSA9IDIzXSA9IFwiTUVSR0VcIjtcbiAgICAvKiB1cG5wICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTS1TRUFSQ0hcIl0gPSAyNF0gPSBcIk0tU0VBUkNIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTk9USUZZXCJdID0gMjVdID0gXCJOT1RJRllcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTVUJTQ1JJQkVcIl0gPSAyNl0gPSBcIlNVQlNDUklCRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOU1VCU0NSSUJFXCJdID0gMjddID0gXCJVTlNVQlNDUklCRVwiO1xuICAgIC8qIFJGQy01Nzg5ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUEFUQ0hcIl0gPSAyOF0gPSBcIlBBVENIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFVSR0VcIl0gPSAyOV0gPSBcIlBVUkdFXCI7XG4gICAgLyogQ2FsREFWICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUtDQUxFTkRBUlwiXSA9IDMwXSA9IFwiTUtDQUxFTkRBUlwiO1xuICAgIC8qIFJGQy0yMDY4LCBzZWN0aW9uIDE5LjYuMS4yICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTElOS1wiXSA9IDMxXSA9IFwiTElOS1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOTElOS1wiXSA9IDMyXSA9IFwiVU5MSU5LXCI7XG4gICAgLyogaWNlY2FzdCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNPVVJDRVwiXSA9IDMzXSA9IFwiU09VUkNFXCI7XG4gICAgLyogUkZDLTc1NDAsIHNlY3Rpb24gMTEuNiAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBSSVwiXSA9IDM0XSA9IFwiUFJJXCI7XG4gICAgLyogUkZDLTIzMjYgUlRTUCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkRFU0NSSUJFXCJdID0gMzVdID0gXCJERVNDUklCRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkFOTk9VTkNFXCJdID0gMzZdID0gXCJBTk5PVU5DRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNFVFVQXCJdID0gMzddID0gXCJTRVRVUFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBMQVlcIl0gPSAzOF0gPSBcIlBMQVlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQQVVTRVwiXSA9IDM5XSA9IFwiUEFVU0VcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJURUFSRE9XTlwiXSA9IDQwXSA9IFwiVEVBUkRPV05cIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJHRVRfUEFSQU1FVEVSXCJdID0gNDFdID0gXCJHRVRfUEFSQU1FVEVSXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU0VUX1BBUkFNRVRFUlwiXSA9IDQyXSA9IFwiU0VUX1BBUkFNRVRFUlwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFRElSRUNUXCJdID0gNDNdID0gXCJSRURJUkVDVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFQ09SRFwiXSA9IDQ0XSA9IFwiUkVDT1JEXCI7XG4gICAgLyogUkFPUCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkZMVVNIXCJdID0gNDVdID0gXCJGTFVTSFwiO1xufSkoTUVUSE9EUyA9IGV4cG9ydHMuTUVUSE9EUyB8fCAoZXhwb3J0cy5NRVRIT0RTID0ge30pKTtcbmV4cG9ydHMuTUVUSE9EU19IVFRQID0gW1xuICAgIE1FVEhPRFMuREVMRVRFLFxuICAgIE1FVEhPRFMuR0VULFxuICAgIE1FVEhPRFMuSEVBRCxcbiAgICBNRVRIT0RTLlBPU1QsXG4gICAgTUVUSE9EUy5QVVQsXG4gICAgTUVUSE9EUy5DT05ORUNULFxuICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICBNRVRIT0RTLlRSQUNFLFxuICAgIE1FVEhPRFMuQ09QWSxcbiAgICBNRVRIT0RTLkxPQ0ssXG4gICAgTUVUSE9EUy5NS0NPTCxcbiAgICBNRVRIT0RTLk1PVkUsXG4gICAgTUVUSE9EUy5QUk9QRklORCxcbiAgICBNRVRIT0RTLlBST1BQQVRDSCxcbiAgICBNRVRIT0RTLlNFQVJDSCxcbiAgICBNRVRIT0RTLlVOTE9DSyxcbiAgICBNRVRIT0RTLkJJTkQsXG4gICAgTUVUSE9EUy5SRUJJTkQsXG4gICAgTUVUSE9EUy5VTkJJTkQsXG4gICAgTUVUSE9EUy5BQ0wsXG4gICAgTUVUSE9EUy5SRVBPUlQsXG4gICAgTUVUSE9EUy5NS0FDVElWSVRZLFxuICAgIE1FVEhPRFMuQ0hFQ0tPVVQsXG4gICAgTUVUSE9EUy5NRVJHRSxcbiAgICBNRVRIT0RTWydNLVNFQVJDSCddLFxuICAgIE1FVEhPRFMuTk9USUZZLFxuICAgIE1FVEhPRFMuU1VCU0NSSUJFLFxuICAgIE1FVEhPRFMuVU5TVUJTQ1JJQkUsXG4gICAgTUVUSE9EUy5QQVRDSCxcbiAgICBNRVRIT0RTLlBVUkdFLFxuICAgIE1FVEhPRFMuTUtDQUxFTkRBUixcbiAgICBNRVRIT0RTLkxJTkssXG4gICAgTUVUSE9EUy5VTkxJTkssXG4gICAgTUVUSE9EUy5QUkksXG4gICAgLy8gVE9ETyhpbmR1dG55KTogc2hvdWxkIHdlIGFsbG93IGl0IHdpdGggSFRUUD9cbiAgICBNRVRIT0RTLlNPVVJDRSxcbl07XG5leHBvcnRzLk1FVEhPRFNfSUNFID0gW1xuICAgIE1FVEhPRFMuU09VUkNFLFxuXTtcbmV4cG9ydHMuTUVUSE9EU19SVFNQID0gW1xuICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICBNRVRIT0RTLkRFU0NSSUJFLFxuICAgIE1FVEhPRFMuQU5OT1VOQ0UsXG4gICAgTUVUSE9EUy5TRVRVUCxcbiAgICBNRVRIT0RTLlBMQVksXG4gICAgTUVUSE9EUy5QQVVTRSxcbiAgICBNRVRIT0RTLlRFQVJET1dOLFxuICAgIE1FVEhPRFMuR0VUX1BBUkFNRVRFUixcbiAgICBNRVRIT0RTLlNFVF9QQVJBTUVURVIsXG4gICAgTUVUSE9EUy5SRURJUkVDVCxcbiAgICBNRVRIT0RTLlJFQ09SRCxcbiAgICBNRVRIT0RTLkZMVVNILFxuICAgIC8vIEZvciBBaXJQbGF5XG4gICAgTUVUSE9EUy5HRVQsXG4gICAgTUVUSE9EUy5QT1NULFxuXTtcbmV4cG9ydHMuTUVUSE9EX01BUCA9IHV0aWxzXzEuZW51bVRvTWFwKE1FVEhPRFMpO1xuZXhwb3J0cy5IX01FVEhPRF9NQVAgPSB7fTtcbk9iamVjdC5rZXlzKGV4cG9ydHMuTUVUSE9EX01BUCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKC9eSC8udGVzdChrZXkpKSB7XG4gICAgICAgIGV4cG9ydHMuSF9NRVRIT0RfTUFQW2tleV0gPSBleHBvcnRzLk1FVEhPRF9NQVBba2V5XTtcbiAgICB9XG59KTtcbnZhciBGSU5JU0g7XG4oZnVuY3Rpb24gKEZJTklTSCkge1xuICAgIEZJTklTSFtGSU5JU0hbXCJTQUZFXCJdID0gMF0gPSBcIlNBRkVcIjtcbiAgICBGSU5JU0hbRklOSVNIW1wiU0FGRV9XSVRIX0NCXCJdID0gMV0gPSBcIlNBRkVfV0lUSF9DQlwiO1xuICAgIEZJTklTSFtGSU5JU0hbXCJVTlNBRkVcIl0gPSAyXSA9IFwiVU5TQUZFXCI7XG59KShGSU5JU0ggPSBleHBvcnRzLkZJTklTSCB8fCAoZXhwb3J0cy5GSU5JU0ggPSB7fSkpO1xuZXhwb3J0cy5BTFBIQSA9IFtdO1xuZm9yIChsZXQgaSA9ICdBJy5jaGFyQ29kZUF0KDApOyBpIDw9ICdaJy5jaGFyQ29kZUF0KDApOyBpKyspIHtcbiAgICAvLyBVcHBlciBjYXNlXG4gICAgZXhwb3J0cy5BTFBIQS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuICAgIC8vIExvd2VyIGNhc2VcbiAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMHgyMCkpO1xufVxuZXhwb3J0cy5OVU1fTUFQID0ge1xuICAgIDA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsXG4gICAgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSxcbn07XG5leHBvcnRzLkhFWF9NQVAgPSB7XG4gICAgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCxcbiAgICA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LFxuICAgIEE6IDBYQSwgQjogMFhCLCBDOiAwWEMsIEQ6IDBYRCwgRTogMFhFLCBGOiAwWEYsXG4gICAgYTogMHhhLCBiOiAweGIsIGM6IDB4YywgZDogMHhkLCBlOiAweGUsIGY6IDB4Zixcbn07XG5leHBvcnRzLk5VTSA9IFtcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG5dO1xuZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuQUxQSEEuY29uY2F0KGV4cG9ydHMuTlVNKTtcbmV4cG9ydHMuTUFSSyA9IFsnLScsICdfJywgJy4nLCAnIScsICd+JywgJyonLCAnXFwnJywgJygnLCAnKSddO1xuZXhwb3J0cy5VU0VSSU5GT19DSEFSUyA9IGV4cG9ydHMuQUxQSEFOVU1cbiAgICAuY29uY2F0KGV4cG9ydHMuTUFSSylcbiAgICAuY29uY2F0KFsnJScsICc7JywgJzonLCAnJicsICc9JywgJysnLCAnJCcsICcsJ10pO1xuLy8gVE9ETyhpbmR1dG55KTogdXNlIFJGQ1xuZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIgPSBbXG4gICAgJyEnLCAnXCInLCAnJCcsICclJywgJyYnLCAnXFwnJyxcbiAgICAnKCcsICcpJywgJyonLCAnKycsICcsJywgJy0nLCAnLicsICcvJyxcbiAgICAnOicsICc7JywgJzwnLCAnPScsICc+JyxcbiAgICAnQCcsICdbJywgJ1xcXFwnLCAnXScsICdeJywgJ18nLFxuICAgICdgJyxcbiAgICAneycsICd8JywgJ30nLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUlxuICAgIC5jb25jYXQoWydcXHQnLCAnXFxmJ10pO1xuLy8gQWxsIGNoYXJhY3RlcnMgd2l0aCAweDgwIGJpdCBzZXQgdG8gMVxuZm9yIChsZXQgaSA9IDB4ODA7IGkgPD0gMHhmZjsgaSsrKSB7XG4gICAgZXhwb3J0cy5VUkxfQ0hBUi5wdXNoKGkpO1xufVxuZXhwb3J0cy5IRVggPSBleHBvcnRzLk5VTS5jb25jYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRiddKTtcbi8qIFRva2VucyBhcyBkZWZpbmVkIGJ5IHJmYyAyNjE2LiBBbHNvIGxvd2VyY2FzZXMgdGhlbS5cbiAqICAgICAgICB0b2tlbiAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gKiAgICAgc2VwYXJhdG9ycyAgICAgPSBcIihcIiB8IFwiKVwiIHwgXCI8XCIgfCBcIj5cIiB8IFwiQFwiXG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIixcIiB8IFwiO1wiIHwgXCI6XCIgfCBcIlxcXCIgfCA8XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIntcIiB8IFwifVwiIHwgU1AgfCBIVFxuICovXG5leHBvcnRzLlNUUklDVF9UT0tFTiA9IFtcbiAgICAnIScsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsXG4gICAgJyonLCAnKycsICctJywgJy4nLFxuICAgICdeJywgJ18nLCAnYCcsXG4gICAgJ3wnLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuVE9LRU4gPSBleHBvcnRzLlNUUklDVF9UT0tFTi5jb25jYXQoWycgJ10pO1xuLypcbiAqIFZlcmlmeSB0aGF0IGEgY2hhciBpcyBhIHZhbGlkIHZpc2libGUgKHByaW50YWJsZSkgVVMtQVNDSUlcbiAqIGNoYXJhY3RlciBvciAleDgwLUZGXG4gKi9cbmV4cG9ydHMuSEVBREVSX0NIQVJTID0gWydcXHQnXTtcbmZvciAobGV0IGkgPSAzMjsgaSA8PSAyNTU7IGkrKykge1xuICAgIGlmIChpICE9PSAxMjcpIHtcbiAgICAgICAgZXhwb3J0cy5IRUFERVJfQ0hBUlMucHVzaChpKTtcbiAgICB9XG59XG4vLyAnLCcgPSBcXHg0NFxuZXhwb3J0cy5DT05ORUNUSU9OX1RPS0VOX0NIQVJTID0gZXhwb3J0cy5IRUFERVJfQ0hBUlMuZmlsdGVyKChjKSA9PiBjICE9PSA0NCk7XG5leHBvcnRzLk1BSk9SID0gZXhwb3J0cy5OVU1fTUFQO1xuZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1I7XG52YXIgSEVBREVSX1NUQVRFO1xuKGZ1bmN0aW9uIChIRUFERVJfU1RBVEUpIHtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiR0VORVJBTFwiXSA9IDBdID0gXCJHRU5FUkFMXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05cIl0gPSAxXSA9IFwiQ09OTkVDVElPTlwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05URU5UX0xFTkdUSFwiXSA9IDJdID0gXCJDT05URU5UX0xFTkdUSFwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDNdID0gXCJUUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJVUEdSQURFXCJdID0gNF0gPSBcIlVQR1JBREVcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCJdID0gNV0gPSBcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gNl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9VUEdSQURFXCJdID0gN10gPSBcIkNPTk5FQ1RJT05fVVBHUkFERVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJUUkFOU0ZFUl9FTkNPRElOR19DSFVOS0VEXCJdID0gOF0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIjtcbn0pKEhFQURFUl9TVEFURSA9IGV4cG9ydHMuSEVBREVSX1NUQVRFIHx8IChleHBvcnRzLkhFQURFUl9TVEFURSA9IHt9KSk7XG5leHBvcnRzLlNQRUNJQUxfSEVBREVSUyA9IHtcbiAgICAnY29ubmVjdGlvbic6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICdjb250ZW50LWxlbmd0aCc6IEhFQURFUl9TVEFURS5DT05URU5UX0xFTkdUSCxcbiAgICAncHJveHktY29ubmVjdGlvbic6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IEhFQURFUl9TVEFURS5UUkFOU0ZFUl9FTkNPRElORyxcbiAgICAndXBncmFkZSc6IEhFQURFUl9TVEFURS5VUEdSQURFLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTUEVDSUFMX0hFQURFUlMiLCJIRUFERVJfU1RBVEUiLCJNSU5PUiIsIk1BSk9SIiwiQ09OTkVDVElPTl9UT0tFTl9DSEFSUyIsIkhFQURFUl9DSEFSUyIsIlRPS0VOIiwiU1RSSUNUX1RPS0VOIiwiSEVYIiwiVVJMX0NIQVIiLCJTVFJJQ1RfVVJMX0NIQVIiLCJVU0VSSU5GT19DSEFSUyIsIk1BUksiLCJBTFBIQU5VTSIsIk5VTSIsIkhFWF9NQVAiLCJOVU1fTUFQIiwiQUxQSEEiLCJGSU5JU0giLCJIX01FVEhPRF9NQVAiLCJNRVRIT0RfTUFQIiwiTUVUSE9EU19SVFNQIiwiTUVUSE9EU19JQ0UiLCJNRVRIT0RTX0hUVFAiLCJNRVRIT0RTIiwiTEVOSUVOVF9GTEFHUyIsIkZMQUdTIiwiVFlQRSIsIkVSUk9SIiwidXRpbHNfMSIsInJlcXVpcmUiLCJERUxFVEUiLCJHRVQiLCJIRUFEIiwiUE9TVCIsIlBVVCIsIkNPTk5FQ1QiLCJPUFRJT05TIiwiVFJBQ0UiLCJDT1BZIiwiTE9DSyIsIk1LQ09MIiwiTU9WRSIsIlBST1BGSU5EIiwiUFJPUFBBVENIIiwiU0VBUkNIIiwiVU5MT0NLIiwiQklORCIsIlJFQklORCIsIlVOQklORCIsIkFDTCIsIlJFUE9SVCIsIk1LQUNUSVZJVFkiLCJDSEVDS09VVCIsIk1FUkdFIiwiTk9USUZZIiwiU1VCU0NSSUJFIiwiVU5TVUJTQ1JJQkUiLCJQQVRDSCIsIlBVUkdFIiwiTUtDQUxFTkRBUiIsIkxJTksiLCJVTkxJTksiLCJQUkkiLCJTT1VSQ0UiLCJERVNDUklCRSIsIkFOTk9VTkNFIiwiU0VUVVAiLCJQTEFZIiwiUEFVU0UiLCJURUFSRE9XTiIsIkdFVF9QQVJBTUVURVIiLCJTRVRfUEFSQU1FVEVSIiwiUkVESVJFQ1QiLCJSRUNPUkQiLCJGTFVTSCIsImVudW1Ub01hcCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwidGVzdCIsImkiLCJjaGFyQ29kZUF0IiwicHVzaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImNvbmNhdCIsImZpbHRlciIsIkNPTk5FQ1RJT04iLCJDT05URU5UX0xFTkdUSCIsIlRSQU5TRkVSX0VOQ09ESU5HIiwiVVBHUkFERSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nmodule.exports = Buffer.from('AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv', 'base64');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLXdhc20uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUV4Q0MsT0FBT0MsT0FBTyxHQUFHSCxPQUFPSSxJQUFJLENBQUMsd3orREFBd3orRCIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxsbGh0dHBcXGxsaHR0cC13YXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlci5mcm9tKCdBR0Z6YlFFQUFBQUJKd2RnQVg4QmYyQURmMzkvQVg5Z0FYOEFZQUovZndCZ0JIOS9mMzhCZjJBQUFHQURmMzkvQUFMTEFRZ0RaVzUyR0hkaGMyMWZiMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUFFQTJWdWRoVjNZWE50WDI5dVgyMWxjM05oWjJWZlltVm5hVzRBQUFObGJuWUxkMkZ6YlY5dmJsOTFjbXdBQVFObGJuWU9kMkZ6YlY5dmJsOXpkR0YwZFhNQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZabWxsYkdRQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZkbUZzZFdVQUFRTmxibllNZDJGemJWOXZibDlpYjJSNUFBRURaVzUyR0hkaGMyMWZiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaUUFBQXkwc0JRWUFBQUlBQUFBQUFBQUNBUUlBQWdJQ0FBQURBQUFBQUFNREF3TUJBUUVCQVFFQkFRRUFBQUlBQUFBRUJRRndBUklTQlFNQkFBSUdDQUYvQVVHQTFBUUxCOUVGSWdadFpXMXZjbmtDQUF0ZmFXNXBkR2xoYkdsNlpRQUlHVjlmYVc1a2FYSmxZM1JmWm5WdVkzUnBiMjVmZEdGaWJHVUJBQXRzYkdoMGRIQmZhVzVwZEFBSkdHeHNhSFIwY0Y5emFHOTFiR1JmYTJWbGNGOWhiR2wyWlFBdkRHeHNhSFIwY0Y5aGJHeHZZd0FMQm0xaGJHeHZZd0F4QzJ4c2FIUjBjRjltY21WbEFBd0VabkpsWlFBTUQyeHNhSFIwY0Y5blpYUmZkSGx3WlFBTkZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dFlXcHZjZ0FPRld4c2FIUjBjRjluWlhSZmFIUjBjRjl0YVc1dmNnQVBFV3hzYUhSMGNGOW5aWFJmYldWMGFHOWtBQkFXYkd4b2RIUndYMmRsZEY5emRHRjBkWE5mWTI5a1pRQVJFbXhzYUhSMGNGOW5aWFJmZFhCbmNtRmtaUUFTREd4c2FIUjBjRjl5WlhObGRBQVREbXhzYUhSMGNGOWxlR1ZqZFhSbEFCUVViR3hvZEhSd1gzTmxkSFJwYm1kelgybHVhWFFBRlExc2JHaDBkSEJmWm1sdWFYTm9BQllNYkd4b2RIUndYM0JoZFhObEFCY05iR3hvZEhSd1gzSmxjM1Z0WlFBWUcyeHNhSFIwY0Y5eVpYTjFiV1ZmWVdaMFpYSmZkWEJuY21Ga1pRQVpFR3hzYUhSMGNGOW5aWFJmWlhKeWJtOEFHaGRzYkdoMGRIQmZaMlYwWDJWeWNtOXlYM0psWVhOdmJnQWJGMnhzYUhSMGNGOXpaWFJmWlhKeWIzSmZjbVZoYzI5dUFCd1ViR3hvZEhSd1gyZGxkRjlsY25KdmNsOXdiM01BSFJGc2JHaDBkSEJmWlhKeWJtOWZibUZ0WlFBZUVteHNhSFIwY0Y5dFpYUm9iMlJmYm1GdFpRQWZFbXhzYUhSMGNGOXpkR0YwZFhOZmJtRnRaUUFnR214c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5b1pXRmtaWEp6QUNFaGJHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgyTm9kVzVyWldSZmJHVnVaM1JvQUNJZGJHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgydGxaWEJmWVd4cGRtVUFJeVJzYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmZEhKaGJuTm1aWEpmWlc1amIyUnBibWNBSkJoc2JHaDBkSEJmYldWemMyRm5aVjl1WldWa2MxOWxiMllBTGdrWEFRQkJBUXNSQVFJREJBVUtCZ2NyTFN3cUtTZ2xKeVlLMDdNQ0xCWUFRWWpRQUNnQ0FBUkFBQXRCaU5BQVFRRTJBZ0FMRkFBZ0FCQXdJQUFnQWpZQ09DQUFJQUU2QUNnTEZBQWdBQ0FBTHdFeUlBQXRBQzRnQUJBdkVBQUxIZ0VCZjBIQUFCQXlJZ0VRTUNBQlFZQUlOZ0k0SUFFZ0FEb0FLQ0FCQzQ4TUFRZC9Ba0FnQUVVTkFDQUFRUWhySWdFZ0FFRUVheWdDQUNJQVFYaHhJZ1JxSVFVQ1FDQUFRUUZ4RFFBZ0FFRURjVVVOQVNBQklBRW9BZ0FpQUdzaUFVR2MwQUFvQWdCSkRRRWdBQ0FFYWlFRUFrQUNRRUdnMEFBb0FnQWdBVWNFUUNBQVFmOEJUUVJBSUFCQkEzWWhBeUFCS0FJSUlnQWdBU2dDRENJQ1JnUkFRWXpRQUVHTTBBQW9BZ0JCZmlBRGQzRTJBZ0FNQlFzZ0FpQUFOZ0lJSUFBZ0FqWUNEQXdFQ3lBQktBSVlJUVlnQVNBQktBSU1JZ0JIQkVBZ0FDQUJLQUlJSWdJMkFnZ2dBaUFBTmdJTURBTUxJQUZCRkdvaUF5Z0NBQ0lDUlFSQUlBRW9BaEFpQWtVTkFpQUJRUkJxSVFNTEEwQWdBeUVISUFJaUFFRVVhaUlES0FJQUlnSU5BQ0FBUVJCcUlRTWdBQ2dDRUNJQ0RRQUxJQWRCQURZQ0FBd0NDeUFGS0FJRUlnQkJBM0ZCQTBjTkFpQUZJQUJCZm5FMkFnUkJsTkFBSUFRMkFnQWdCU0FFTmdJQUlBRWdCRUVCY2pZQ0JBd0RDMEVBSVFBTElBWkZEUUFDUUNBQktBSWNJZ0pCQW5SQnZOSUFhaUlES0FJQUlBRkdCRUFnQXlBQU5nSUFJQUFOQVVHUTBBQkJrTkFBS0FJQVFYNGdBbmR4TmdJQURBSUxJQVpCRUVFVUlBWW9BaEFnQVVZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQmpZQ0dDQUJLQUlRSWdJRVFDQUFJQUkyQWhBZ0FpQUFOZ0lZQ3lBQlFSUnFLQUlBSWdKRkRRQWdBRUVVYWlBQ05nSUFJQUlnQURZQ0dBc2dBU0FGVHcwQUlBVW9BZ1FpQUVFQmNVVU5BQUpBQWtBQ1FBSkFJQUJCQW5GRkJFQkJwTkFBS0FJQUlBVkdCRUJCcE5BQUlBRTJBZ0JCbU5BQVFaalFBQ2dDQUNBRWFpSUFOZ0lBSUFFZ0FFRUJjallDQkNBQlFhRFFBQ2dDQUVjTkJrR1UwQUJCQURZQ0FFR2cwQUJCQURZQ0FBd0dDMEdnMEFBb0FnQWdCVVlFUUVHZzBBQWdBVFlDQUVHVTBBQkJsTkFBS0FJQUlBUnFJZ0EyQWdBZ0FTQUFRUUZ5TmdJRUlBQWdBV29nQURZQ0FBd0dDeUFBUVhoeElBUnFJUVFnQUVIL0FVMEVRQ0FBUVFOMklRTWdCU2dDQ0NJQUlBVW9BZ3dpQWtZRVFFR00wQUJCak5BQUtBSUFRWDRnQTNkeE5nSUFEQVVMSUFJZ0FEWUNDQ0FBSUFJMkFnd01CQXNnQlNnQ0dDRUdJQVVnQlNnQ0RDSUFSd1JBUVp6UUFDZ0NBQm9nQUNBRktBSUlJZ0kyQWdnZ0FpQUFOZ0lNREFNTElBVkJGR29pQXlnQ0FDSUNSUVJBSUFVb0FoQWlBa1VOQWlBRlFSQnFJUU1MQTBBZ0F5RUhJQUlpQUVFVWFpSURLQUlBSWdJTkFDQUFRUkJxSVFNZ0FDZ0NFQ0lDRFFBTElBZEJBRFlDQUF3Q0N5QUZJQUJCZm5FMkFnUWdBU0FFYWlBRU5nSUFJQUVnQkVFQmNqWUNCQXdEQzBFQUlRQUxJQVpGRFFBQ1FDQUZLQUljSWdKQkFuUkJ2TklBYWlJREtBSUFJQVZHQkVBZ0F5QUFOZ0lBSUFBTkFVR1EwQUJCa05BQUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0JVWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0JqWUNHQ0FGS0FJUUlnSUVRQ0FBSUFJMkFoQWdBaUFBTmdJWUN5QUZRUlJxS0FJQUlnSkZEUUFnQUVFVWFpQUNOZ0lBSUFJZ0FEWUNHQXNnQVNBRWFpQUVOZ0lBSUFFZ0JFRUJjallDQkNBQlFhRFFBQ2dDQUVjTkFFR1UwQUFnQkRZQ0FBd0JDeUFFUWY4QlRRUkFJQVJCZUhGQnROQUFhaUVBQW45QmpOQUFLQUlBSWdKQkFTQUVRUU4yZENJRGNVVUVRRUdNMEFBZ0FpQURjallDQUNBQURBRUxJQUFvQWdnTElnSWdBVFlDRENBQUlBRTJBZ2dnQVNBQU5nSU1JQUVnQWpZQ0NBd0JDMEVmSVFJZ0JFSC8vLzhIVFFSQUlBUkJKaUFFUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEFnc2dBU0FDTmdJY0lBRkNBRGNDRUNBQ1FRSjBRYnpTQUdvaEFBSkFRWkRRQUNnQ0FDSURRUUVnQW5RaUIzRkZCRUFnQUNBQk5nSUFRWkRRQUNBRElBZHlOZ0lBSUFFZ0FEWUNHQ0FCSUFFMkFnZ2dBU0FCTmdJTURBRUxJQVJCR1NBQ1FRRjJhMEVBSUFKQkgwY2JkQ0VDSUFBb0FnQWhBQUpBQTBBZ0FDSURLQUlFUVhoeElBUkdEUUVnQWtFZGRpRUFJQUpCQVhRaEFpQURJQUJCQkhGcVFSQnFJZ2NvQWdBaUFBMEFDeUFISUFFMkFnQWdBU0FETmdJWUlBRWdBVFlDRENBQklBRTJBZ2dNQVFzZ0F5Z0NDQ0lBSUFFMkFnd2dBeUFCTmdJSUlBRkJBRFlDR0NBQklBTTJBZ3dnQVNBQU5nSUlDMEdzMEFCQnJOQUFLQUlBUVFGcklnQkJmeUFBR3pZQ0FBc0xCd0FnQUMwQUtBc0hBQ0FBTFFBcUN3Y0FJQUF0QUNzTEJ3QWdBQzBBS1FzSEFDQUFMd0V5Q3djQUlBQXRBQzRMUUFFRWZ5QUFLQUlZSVFFZ0FDMEFMU0VDSUFBdEFDZ2hBeUFBS0FJNElRUWdBQkF3SUFBZ0JEWUNPQ0FBSUFNNkFDZ2dBQ0FDT2dBdElBQWdBVFlDR0F1NzRnRUNCMzhEZmlBQklBSnFJUVFDUUNBQUlnSW9BZ3dpQUEwQUlBSW9BZ1FFUUNBQ0lBRTJBZ1FMSXdCQkVHc2lDQ1FBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFJb0Fod2lBMEVCYXc3ZEFkb0JBZGtCQWdNRUJRWUhDQWtLQ3d3TkR0Z0JEeERYQVJFUzFnRVRGQlVXRnhnWkdodmdBZDhCSEIwZTFRRWZJQ0VpSXlRbDFBRW1KeWdwS2lzczB3SFNBUzB1MFFIUUFTOHdNVEl6TkRVMk56ZzVPanM4UFQ0L1FFRkNRMFJGUnRzQlIwaEpTczhCemdGTHpRRk16QUZOVGs5UVVWSlRWRlZXVjFoWldsdGNYVjVmWUdGaVkyUmxabWRvYVdwcmJHMXViM0J4Y25OMGRYWjNlSGw2ZTN4OWZuK0FBWUVCZ2dHREFZUUJoUUdHQVljQmlBR0pBWW9CaXdHTUFZMEJqZ0dQQVpBQmtRR1NBWk1CbEFHVkFaWUJsd0dZQVprQm1nR2JBWndCblFHZUFaOEJvQUdoQWFJQm93R2tBYVVCcGdHbkFhZ0JxUUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCeXdIS0FiZ0J5UUc1QWNnQnVnRzdBYndCdlFHK0FiOEJ3QUhCQWNJQnd3SEVBY1VCeGdFQTNBRUxRUUFNeGdFTFFRNE14UUVMUVEwTXhBRUxRUThNd3dFTFFSQU13Z0VMUVJNTXdRRUxRUlFNd0FFTFFSVU12d0VMUVJZTXZnRUxRUmdNdlFFTFFSa012QUVMUVJvTXV3RUxRUnNNdWdFTFFSd011UUVMUVIwTXVBRUxRUWdNdHdFTFFSNE10Z0VMUVNBTXRRRUxRUjhNdEFFTFFRY01zd0VMUVNFTXNnRUxRU0lNc1FFTFFTTU1zQUVMUVNRTXJ3RUxRUklNcmdFTFFSRU1yUUVMUVNVTXJBRUxRU1lNcXdFTFFTY01xZ0VMUVNnTXFRRUxRY01CREtnQkMwRXFES2NCQzBFckRLWUJDMEVzREtVQkMwRXRES1FCQzBFdURLTUJDMEV2REtJQkMwSEVBUXloQVF0Qk1BeWdBUXRCTkF5ZkFRdEJEQXllQVF0Qk1ReWRBUXRCTWd5Y0FRdEJNd3liQVF0Qk9ReWFBUXRCTlF5WkFRdEJ4UUVNbUFFTFFRc01sd0VMUVRvTWxnRUxRVFlNbFFFTFFRb01sQUVMUVRjTWt3RUxRVGdNa2dFTFFUd01rUUVMUVRzTWtBRUxRVDBNandFTFFRa01qZ0VMUVNrTWpRRUxRVDRNakFFTFFUOE1pd0VMUWNBQURJb0JDMEhCQUF5SkFRdEJ3Z0FNaUFFTFFjTUFESWNCQzBIRUFBeUdBUXRCeFFBTWhRRUxRY1lBRElRQkMwRVhESU1CQzBISEFBeUNBUXRCeUFBTWdRRUxRY2tBRElBQkMwSEtBQXgvQzBITEFBeCtDMEhOQUF4OUMwSE1BQXg4QzBIT0FBeDdDMEhQQUF4NkMwSFFBQXg1QzBIUkFBeDRDMEhTQUF4M0MwSFRBQXgyQzBIVUFBeDFDMEhXQUF4MEMwSFZBQXh6QzBFR0RISUxRZGNBREhFTFFRVU1jQXRCMkFBTWJ3dEJCQXh1QzBIWkFBeHRDMEhhQUF4c0MwSGJBQXhyQzBIY0FBeHFDMEVEREdrTFFkMEFER2dMUWQ0QURHY0xRZDhBREdZTFFlRUFER1VMUWVBQURHUUxRZUlBREdNTFFlTUFER0lMUVFJTVlRdEI1QUFNWUF0QjVRQU1Yd3RCNWdBTVhndEI1d0FNWFF0QjZBQU1YQXRCNlFBTVd3dEI2Z0FNV2d0QjZ3QU1XUXRCN0FBTVdBdEI3UUFNVnd0QjdnQU1WZ3RCN3dBTVZRdEI4QUFNVkF0QjhRQU1Vd3RCOGdBTVVndEI4d0FNVVF0QjlBQU1VQXRCOVFBTVR3dEI5Z0FNVGd0Qjl3QU1UUXRCK0FBTVRBdEIrUUFNU3d0QitnQU1TZ3RCK3dBTVNRdEIvQUFNU0F0Qi9RQU1Sd3RCL2dBTVJndEIvd0FNUlF0QmdBRU1SQXRCZ1FFTVF3dEJnZ0VNUWd0Qmd3RU1RUXRCaEFFTVFBdEJoUUVNUHd0QmhnRU1QZ3RCaHdFTVBRdEJpQUVNUEF0QmlRRU1Pd3RCaWdFTU9ndEJpd0VNT1F0QmpBRU1PQXRCalFFTU53dEJqZ0VNTmd0Qmp3RU1OUXRCa0FFTU5BdEJrUUVNTXd0QmtnRU1NZ3RCa3dFTU1RdEJsQUVNTUF0QmxRRU1Md3RCbGdFTUxndEJsd0VNTFF0Qm1BRU1MQXRCbVFFTUt3dEJtZ0VNS2d0Qm13RU1LUXRCbkFFTUtBdEJuUUVNSnd0Qm5nRU1KZ3RCbndFTUpRdEJvQUVNSkF0Qm9RRU1Jd3RCb2dFTUlndEJvd0VNSVF0QnBBRU1JQXRCcFFFTUh3dEJwZ0VNSGd0QnB3RU1IUXRCcUFFTUhBdEJxUUVNR3d0QnFnRU1HZ3RCcXdFTUdRdEJyQUVNR0F0QnJRRU1Gd3RCcmdFTUZndEJBUXdWQzBHdkFRd1VDMEd3QVF3VEMwR3hBUXdTQzBHekFRd1JDMEd5QVF3UUMwRzBBUXdQQzBHMUFRd09DMEcyQVF3TkMwRzNBUXdNQzBHNEFRd0xDMEc1QVF3S0MwRzZBUXdKQzBHN0FRd0lDMEhHQVF3SEMwRzhBUXdHQzBHOUFRd0ZDMEcrQVF3RUMwRy9BUXdEQzBIQUFRd0NDMEhDQVF3QkMwSEJBUXNoQXdOQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBSUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSi9Ba0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBZ0ovQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNmd0pBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBRERzWUJBQUVDQXdRRkJnY0lDUW9MREEwT0R4QVJFaE1VRlJZWEdCa2FHeHdkSHlBaEl5VW1LQ29yTEM4d01USXpORFUyTnprNk96dzlsQU5BUWtSRlJrbExUazlRVVZKVFZGVldXRnBiWEYxZVgyQmhZbU5rWldabmFHcHNiM0J4YzNWMmVIbDZlM3gvZ0FHQkFZSUJnd0dFQVlVQmhnR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBWkVCa2dHVEFaUUJsUUdXQVpjQm1BR1pBWm9CbXdHY0FaMEJuZ0dmQWFBQm9RR2lBYU1CcEFHbEFhWUJwd0dvQWFrQnFnR3JBYXdCclFHdUFhOEJzQUd4QWJJQnN3RzBBYlVCdGdHM0FiZ0J1UUc2QWJzQnZBRzlBYjRCdndIQUFjRUJ3Z0hEQWNRQnhRSEdBY2NCeUFISkFjc0J6QUhOQWM0Qnp3R0tBNGtEaUFPSEE0UURnd09BQS9zQytnTDVBdmdDOXdMMEF2TUM4Z0xMQXNFQ3NBTFpBUXNnQVNBRVJ3M3dBa0hkQVNFRERMTURDeUFCSUFSSERjZ0JRY01CSVFNTXNnTUxJQUVnQkVjTmUwSDNBQ0VERExFREN5QUJJQVJIRFhCQjd3QWhBd3l3QXdzZ0FTQUVSdzFwUWVvQUlRTU1yd01MSUFFZ0JFY05aVUhvQUNFRERLNERDeUFCSUFSSERXSkI1Z0FoQXd5dEF3c2dBU0FFUncwYVFSZ2hBd3lzQXdzZ0FTQUVSdzBWUVJJaEF3eXJBd3NnQVNBRVJ3MUNRY1VBSVFNTXFnTUxJQUVnQkVjTk5FRS9JUU1NcVFNTElBRWdCRWNOTWtFOElRTU1xQU1MSUFFZ0JFY05LMEV4SVFNTXB3TUxJQUl0QUM1QkFVWU5ud01Nd1FJTFFRQWhBQUpBQWtBQ1FDQUNMUUFxUlEwQUlBSXRBQ3RGRFFBZ0FpOEJNQ0lEUVFKeFJRMEJEQUlMSUFJdkFUQWlBMEVCY1VVTkFRdEJBU0VBSUFJdEFDaEJBVVlOQUNBQ0x3RXlJZ1ZCNUFCclFlUUFTUTBBSUFWQnpBRkdEUUFnQlVHd0FrWU5BQ0FEUWNBQWNRMEFRUUFoQUNBRFFZZ0VjVUdBQkVZTkFDQURRU2h4UVFCSElRQUxJQUpCQURzQk1DQUNRUUE2QUM4Z0FFVU4zd0lnQWtJQU53TWdET0FDQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ0xDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRM01BU0FBUVJWSERkMENJQUpCQkRZQ0hDQUNJQUUyQWhRZ0FrR3dHRFlDRUNBQ1FSVTJBZ3hCQUNFRERLUURDeUFCSUFSR0JFQkJCaUVEREtRREN5QUJRUUZxSVFGQkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FsUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FBM1pBZ3djQ3lBQ1FnQTNBeUJCRWlFRERJa0RDeUFCSUFSSERSWkJIU0VEREtFREN5QUJJQVJIQkVBZ0FVRUJhaUVCUVJBaEF3eUlBd3RCQnlFRERLQURDeUFDSUFJcEF5QWlDaUFFSUFGcnJTSUxmU0lNUWdBZ0NpQU1XaHMzQXlBZ0NpQUxXQTNVQWtFSUlRTU1ud01MSUFFZ0JFY0VRQ0FDUVFrMkFnZ2dBaUFCTmdJRVFSUWhBd3lHQXd0QkNTRURESjREQ3lBQ0tRTWdRZ0JTRGNjQklBSWdBaThCTUVHQUFYSTdBVEFNUWdzZ0FTQUVSdzAvUWRBQUlRTU1uQU1MSUFFZ0JFWUVRRUVMSVFNTW5BTUxJQUZCQVdvaEFVRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NVQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEYzhDRE1ZQkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NTQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNHQVNBQVFSVkhEYzBDSUFKQkN6WUNIQ0FDSUFFMkFoUWdBa0dDR1RZQ0VDQUNRUlUyQWd4QkFDRURESm9EQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1NDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRME1JQUJCRlVjTnlnSWdBa0VhTmdJY0lBSWdBVFlDRkNBQ1FZSVpOZ0lRSUFKQkZUWUNERUVBSVFNTW1RTUxRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUpNSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRGNRQklBQkJGVWNOeHdJZ0FrRUxOZ0ljSUFJZ0FUWUNGQ0FDUVpFWE5nSVFJQUpCRlRZQ0RFRUFJUU1NbUFNTElBRWdCRVlFUUVFUElRTU1tQU1MSUFFdEFBQWlBRUU3UmcwSElBQkJEVWNOeEFJZ0FVRUJhaUVCRE1NQkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NUQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNEQVNBQVFSVkhEY0lDSUFKQkR6WUNIQ0FDSUFFMkFoUWdBa0dSRnpZQ0VDQUNRUlUyQWd4QkFDRURESllEQ3dOQUlBRXRBQUJCOERWcUxRQUFJZ0JCQVVjRVFDQUFRUUpIRGNFQ0lBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCUVFGcUlnRVFMU0lBRGNJQ0RNVUJDeUFFSUFGQkFXb2lBVWNOQUF0QkVpRURESlVEQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1RDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRM0ZBU0FBUVJWSERiMENJQUpCR3pZQ0hDQUNJQUUyQWhRZ0FrR1JGellDRUNBQ1FSVTJBZ3hCQUNFRERKUURDeUFCSUFSR0JFQkJGaUVEREpRREN5QUNRUW8yQWdnZ0FpQUJOZ0lFUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKSUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRjSUJJQUJCRlVjTnVRSWdBa0VWTmdJY0lBSWdBVFlDRkNBQ1FZSVpOZ0lRSUFKQkZUWUNERUVBSVFNTWt3TUxJQUVnQkVjRVFBTkFJQUV0QUFCQjhEZHFMUUFBSWdCQkFrY0VRQUpBSUFCQkFXc09CTVFDdlFJQXZnSzlBZ3NnQVVFQmFpRUJRUWdoQXd6OEFnc2dCQ0FCUVFGcUlnRkhEUUFMUVJVaEF3eVRBd3RCRlNFRERKSURDd05BSUFFdEFBQkI4RGxxTFFBQUlnQkJBa2NFUUNBQVFRRnJEZ1RGQXJjQ3d3SzRBcmNDQ3lBRUlBRkJBV29pQVVjTkFBdEJHQ0VEREpFREN5QUJJQVJIQkVBZ0FrRUxOZ0lJSUFJZ0FUWUNCRUVISVFNTStBSUxRUmtoQXd5UUF3c2dBVUVCYWlFQkRBSUxJQUVnQkVZRVFFRWFJUU1NandNTEFrQWdBUzBBQUVFTmF3NFV0UUcvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0VBdndFTFFRQWhBeUFDUVFBMkFod2dBa0d2Q3pZQ0VDQUNRUUkyQWd3Z0FpQUJRUUZxTmdJVURJNERDeUFCSUFSR0JFQkJHeUVEREk0REN5QUJMUUFBSWdCQk8wY0VRQ0FBUVExSERiRUNJQUZCQVdvaEFReTZBUXNnQVVFQmFpRUJDMEVpSVFNTTh3SUxJQUVnQkVZRVFFRWNJUU1NakFNTFFnQWhDZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUV3YXc0M3dRTEFBZ0FCQWdNRUJRWUgwQUhRQWRBQjBBSFFBZEFCMEFFSUNRb0xEQTNRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUJEZzhRRVJJVDBBRUxRZ0loQ2d6QUFndENBeUVLREw4Q0MwSUVJUW9NdmdJTFFnVWhDZ3k5QWd0Q0JpRUtETHdDQzBJSElRb011d0lMUWdnaENneTZBZ3RDQ1NFS0RMa0NDMElLSVFvTXVBSUxRZ3NoQ2d5M0FndENEQ0VLRExZQ0MwSU5JUW9NdFFJTFFnNGhDZ3kwQWd0Q0R5RUtETE1DQzBJS0lRb01zZ0lMUWdzaENneXhBZ3RDRENFS0RMQUNDMElOSVFvTXJ3SUxRZzRoQ2d5dUFndENEeUVLREswQ0MwSUFJUW9DUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRXRBQUJCTUdzT044QUN2d0lBQVFJREJBVUdCNzRDdmdLK0FyNEN2Z0srQXI0Q0NBa0tDd3dOdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBZzRQRUJFU0U3NENDMElDSVFvTXZ3SUxRZ01oQ2d5K0FndENCQ0VLREwwQ0MwSUZJUW9NdkFJTFFnWWhDZ3k3QWd0Q0J5RUtETG9DQzBJSUlRb011UUlMUWdraENneTRBZ3RDQ2lFS0RMY0NDMElMSVFvTXRnSUxRZ3doQ2d5MUFndENEU0VLRExRQ0MwSU9JUW9Nc3dJTFFnOGhDZ3l5QWd0Q0NpRUtETEVDQzBJTElRb01zQUlMUWd3aENneXZBZ3RDRFNFS0RLNENDMElPSVFvTXJRSUxRZzhoQ2d5c0Fnc2dBaUFDS1FNZ0lnb2dCQ0FCYTYwaUMzMGlERUlBSUFvZ0RGb2JOd01nSUFvZ0MxZ05wd0pCSHlFRERJa0RDeUFCSUFSSEJFQWdBa0VKTmdJSUlBSWdBVFlDQkVFbElRTU04QUlMUVNBaEF3eUlBd3RCQVNFRklBSXZBVEFpQTBFSWNVVUVRQ0FDS1FNZ1FnQlNJUVVMQWtBZ0FpMEFMZ1JBUVFFaEFDQUNMUUFwUVFWR0RRRWdBMEhBQUhGRklBVnhSUTBCQzBFQUlRQWdBMEhBQUhFTkFFRUNJUUFnQTBFSWNRMEFJQU5CZ0FSeEJFQUNRQ0FDTFFBb1FRRkhEUUFnQWkwQUxVRUtjUTBBUVFVaEFBd0NDMEVFSVFBTUFRc2dBMEVnY1VVRVFBSkFJQUl0QUNoQkFVWU5BQ0FDTHdFeUlnQkI1QUJyUWVRQVNRMEFJQUJCekFGR0RRQWdBRUd3QWtZTkFFRUVJUUFnQTBFb2NVVU5BaUFEUVlnRWNVR0FCRVlOQWd0QkFDRUFEQUVMUVFCQkF5QUNLUU1nVUJzaEFBc2dBRUVCYXc0RnZnSUFzQUVCcEFLaEFndEJFU0VERE8wQ0N5QUNRUUU2QUM4TWhBTUxJQUVnQkVjTm5RSkJKQ0VERElRREN5QUJJQVJIRFJ4QnhnQWhBd3lEQXd0QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FrUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5KeUFBUVJWSERaZ0NJQUpCMEFBMkFod2dBaUFCTmdJVUlBSkJrUmcyQWhBZ0FrRVZOZ0lNUVFBaEF3eUNBd3NnQVNBRVJnUkFRU2doQXd5Q0F3dEJBQ0VESUFKQkFEWUNCQ0FDUVF3MkFnZ2dBaUFCSUFFUUtpSUFSUTJVQWlBQ1FTYzJBaHdnQWlBQk5nSVVJQUlnQURZQ0RBeUJBd3NnQVNBRVJnUkFRU2toQXd5QkF3c2dBUzBBQUNJQVFTQkdEUk1nQUVFSlJ3MlZBaUFCUVFGcUlRRU1GQXNnQVNBRVJ3UkFJQUZCQVdvaEFRd1dDMEVxSVFNTS93SUxJQUVnQkVZRVFFRXJJUU1NL3dJTElBRXRBQUFpQUVFSlJ5QUFRU0JIY1EyUUFpQUNMUUFzUVFoSERkMENJQUpCQURvQUxBemRBZ3NnQVNBRVJnUkFRU3doQXd6K0Fnc2dBUzBBQUVFS1J3Mk9BaUFCUVFGcUlRRU1zQUVMSUFFZ0JFY05pZ0pCTHlFRERQd0NDd05BSUFFdEFBQWlBRUVnUndSQUlBQkJDbXNPQklRQ2lBS0lBb1FDaGdJTElBUWdBVUVCYWlJQlJ3MEFDMEV4SVFNTSt3SUxRVEloQXlBQklBUkdEZm9DSUFJb0FnQWlBQ0FFSUFGcmFpRUhJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FFSHdPMm90QUFBZ0FTMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUUVnQUVFRFJnUkFRUVloQVF6aUFnc2dBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFjMkFnQU0rd0lMSUFKQkFEWUNBQXlHQWd0Qk15RURJQVFnQVNJQVJnMzVBaUFFSUFGcklBSW9BZ0FpQVdvaEJ5QUFJQUZyUVFocUlRWUNRQU5BSUFGQjlEdHFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MEJJQUZCQ0VZRVFFRUZJUUVNNFFJTElBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURQb0NDeUFDUVFBMkFnQWdBQ0VCRElVQ0MwRTBJUU1nQkNBQklnQkdEZmdDSUFRZ0FXc2dBaWdDQUNJQmFpRUhJQUFnQVd0QkJXb2hCZ0pBQTBBZ0FVSFF3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkJVWUVRRUVISVFFTTRBSUxJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFEUGtDQ3lBQ1FRQTJBZ0FnQUNFQkRJUUNDeUFCSUFSSEJFQURRQ0FCTFFBQVFZQSthaTBBQUNJQVFRRkhCRUFnQUVFQ1JnMEpESUVDQ3lBRUlBRkJBV29pQVVjTkFBdEJNQ0VERFBnQ0MwRXdJUU1NOXdJTElBRWdCRWNFUUFOQUlBRXRBQUFpQUVFZ1J3UkFJQUJCQ21zT0JQOEIvZ0grQWY4Qi9nRUxJQVFnQVVFQmFpSUJSdzBBQzBFNElRTU05d0lMUVRnaEF3ejJBZ3NEUUNBQkxRQUFJZ0JCSUVjZ0FFRUpSM0VOOWdFZ0JDQUJRUUZxSWdGSERRQUxRVHdoQXd6MUFnc0RRQ0FCTFFBQUlnQkJJRWNFUUFKQUlBQkJDbXNPQlBrQkJBVDVBUUFMSUFCQkxFWU45UUVNQXdzZ0JDQUJRUUZxSWdGSERRQUxRVDhoQXd6MEFndEJ3QUFoQXlBQklBUkdEZk1DSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FFR0FRR3N0QUFBZ0FTMEFBRUVnY2tjTkFTQUFRUVpHRGRzQ0lBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURQUUNDeUFDUVFBMkFnQUxRVFloQXd6WkFnc2dBU0FFUmdSQVFjRUFJUU1NOGdJTElBSkJERFlDQ0NBQ0lBRTJBZ1FnQWkwQUxFRUJhdzRFK3dIdUFld0I2d0hVQWdzZ0FVRUJhaUVCRFBvQkN5QUJJQVJIQkVBRFFBSkFJQUV0QUFBaUFFRWdjaUFBSUFCQndRQnJRZjhCY1VFYVNSdEIvd0Z4SWdCQkNVWU5BQ0FBUVNCR0RRQUNRQUpBQWtBQ1FDQUFRZU1BYXc0VEFBTURBd01EQXdNQkF3TURBd01EQXdNREFnTUxJQUZCQVdvaEFVRXhJUU1NM0FJTElBRkJBV29oQVVFeUlRTU0yd0lMSUFGQkFXb2hBVUV6SVFNTTJnSUxEUDRCQ3lBRUlBRkJBV29pQVVjTkFBdEJOU0VERFBBQ0MwRTFJUU1NN3dJTElBRWdCRWNFUUFOQUlBRXRBQUJCZ0R4cUxRQUFRUUZIRGZjQklBUWdBVUVCYWlJQlJ3MEFDMEU5SVFNTTd3SUxRVDBoQXd6dUFndEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9Ba0FpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOQVNBQVFSVkhEZVlCSUFKQndnQTJBaHdnQWlBQk5nSVVJQUpCNHhnMkFoQWdBa0VWTmdJTVFRQWhBd3p0QWdzZ0FVRUJhaUVCQzBFOElRTU0wZ0lMSUFFZ0JFWUVRRUhDQUNFRERPc0NDd0pBQTBBQ1FDQUJMUUFBUVFsckRoZ0FBc3dDekFMUkFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFnRE1BZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFjSUFJUU1NNndJTElBRkJBV29oQVNBQ0xRQXRRUUZ4UlEzK0FRdEJMQ0VERE5BQ0N5QUJJQVJIRGQ0QlFjUUFJUU1NNkFJTEEwQWdBUzBBQUVHUXdBQnFMUUFBUVFGSERad0JJQVFnQVVFQmFpSUJSdzBBQzBIRkFDRURET2NDQ3lBQkxRQUFJZ0JCSUVZTi9nRWdBRUU2UnczQUFpQUNLQUlFSVFCQkFDRURJQUpCQURZQ0JDQUNJQUFnQVJBcElnQU4zZ0VNM1FFTFFjY0FJUU1nQkNBQklnQkdEZVVDSUFRZ0FXc2dBaWdDQUNJQmFpRUhJQUFnQVd0QkJXb2hCZ05BSUFGQmtNSUFhaTBBQUNBQUxRQUFJZ1ZCSUhJZ0JTQUZRY0VBYTBIL0FYRkJHa2tiUWY4QmNVY052d0lnQVVFRlJnM0NBaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFJZ0J6WUNBQXpsQWd0QnlBQWhBeUFFSUFFaUFFWU41QUlnQkNBQmF5QUNLQUlBSWdGcUlRY2dBQ0FCYTBFSmFpRUdBMEFnQVVHV3dnQnFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MitBa0VDSUFGQkNVWU53Z0lhSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRE9RQ0N5QUJJQVJHQkVCQnlRQWhBd3prQWdzQ1FBSkFJQUV0QUFBaUFFRWdjaUFBSUFCQndRQnJRZjhCY1VFYVNSdEIvd0Z4UWU0QWF3NEhBTDhDdndLL0FyOEN2d0lCdndJTElBRkJBV29oQVVFK0lRTU15d0lMSUFGQkFXb2hBVUUvSVFNTXlnSUxRY29BSVFNZ0JDQUJJZ0JHRGVJQ0lBUWdBV3NnQWlnQ0FDSUJhaUVHSUFBZ0FXdEJBV29oQndOQUlBRkJvTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdkFJZ0FVRUJSZzIrQWlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBSWdCallDQUF6aUFndEJ5d0FoQXlBRUlBRWlBRVlONFFJZ0JDQUJheUFDS0FJQUlnRnFJUWNnQUNBQmEwRU9haUVHQTBBZ0FVR2l3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzI3QWlBQlFRNUdEYjRDSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRE9FQ0MwSE1BQ0VESUFRZ0FTSUFSZzNnQWlBRUlBRnJJQUlvQWdBaUFXb2hCeUFBSUFGclFROXFJUVlEUUNBQlFjRENBR290QUFBZ0FDMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEYm9DUVFNZ0FVRVBSZzIrQWhvZ0FVRUJhaUVCSUFRZ0FFRUJhaUlBUncwQUN5QUNJQWMyQWdBTTRBSUxRYzBBSVFNZ0JDQUJJZ0JHRGQ4Q0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdOQUlBRkIwTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdVFKQkJDQUJRUVZHRGIwQ0dpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQUlnQnpZQ0FBemZBZ3NnQVNBRVJnUkFRYzRBSVFNTTN3SUxBa0FDUUFKQUFrQWdBUzBBQUNJQVFTQnlJQUFnQUVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZCNHdCckRoTUF2QUs4QXJ3Q3ZBSzhBcndDdkFLOEFyd0N2QUs4QXJ3Q0Fid0N2QUs4QWdJRHZBSUxJQUZCQVdvaEFVSEJBQ0VERE1nQ0N5QUJRUUZxSVFGQndnQWhBd3pIQWdzZ0FVRUJhaUVCUWNNQUlRTU14Z0lMSUFGQkFXb2hBVUhFQUNFRERNVUNDeUFCSUFSSEJFQWdBa0VOTmdJSUlBSWdBVFlDQkVIRkFDRURETVVDQzBIUEFDRURETjBDQ3dKQUFrQWdBUzBBQUVFS2F3NEVBWkFCa0FFQWtBRUxJQUZCQVdvaEFRdEJLQ0VERE1NQ0N5QUJJQVJHQkVCQjBRQWhBd3pjQWdzZ0FTMEFBRUVnUncwQUlBRkJBV29oQVNBQ0xRQXRRUUZ4UlEzUUFRdEJGeUVERE1FQ0N5QUJJQVJIRGNzQlFkSUFJUU1NMlFJTFFkTUFJUU1nQVNBRVJnM1lBaUFDS0FJQUlnQWdCQ0FCYTJvaEJpQUJJQUJyUVFGcUlRVURRQ0FCTFFBQUlBQkIxc0lBYWkwQUFFY054d0VnQUVFQlJnM0tBU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JqWUNBQXpZQWdzZ0FTQUVSZ1JBUWRVQUlRTU0yQUlMSUFFdEFBQkJDa2NOd2dFZ0FVRUJhaUVCRE1vQkN5QUJJQVJHQkVCQjFnQWhBd3pYQWdzQ1FBSkFJQUV0QUFCQkNtc09CQUREQWNNQkFjTUJDeUFCUVFGcUlRRU15Z0VMSUFGQkFXb2hBVUhLQUNFRERMMENDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDUENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRGI4QlFjMEFJUU1NdkFJTElBSXRBQ2xCSWtZTnp3SU1pUUVMSUFRZ0FTSUZSZ1JBUWRzQUlRTU0xQUlMUVFBaEFFRUJJUUZCQVNFR1FRQWhBd0pBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQ0FGTFFBQVFUQnJEZ3JGQWNRQkFBRUNBd1FGQmdqREFRdEJBZ3dHQzBFRERBVUxRUVFNQkF0QkJRd0RDMEVHREFJTFFRY01BUXRCQ0FzaEEwRUFJUUZCQUNFR0RMMEJDMEVKSVFOQkFTRUFRUUFoQVVFQUlRWU12QUVMSUFFZ0JFWUVRRUhkQUNFREROTUNDeUFCTFFBQVFTNUhEYmdCSUFGQkFXb2hBUXlJQVFzZ0FTQUVSdzIyQVVIZkFDRURETkVDQ3lBQklBUkhCRUFnQWtFT05nSUlJQUlnQVRZQ0JFSFFBQ0VERExnQ0MwSGdBQ0VERE5BQ0MwSGhBQ0VESUFFZ0JFWU56d0lnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBMEFnQVMwQUFDQUFRZUxDQUdvdEFBQkhEYkVCSUFCQkEwWU5zd0VnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNendJTFFlSUFJUU1nQVNBRVJnM09BaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWURRQ0FCTFFBQUlBQkI1c0lBYWkwQUFFY05zQUVnQUVFQ1JnMnZBU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXpPQWd0QjR3QWhBeUFCSUFSR0RjMENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQTJvaEJnTkFJQUV0QUFBZ0FFSHB3Z0JxTFFBQVJ3MnZBU0FBUVFOR0RhMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFETTBDQ3lBQklBUkdCRUJCNVFBaEF3ek5BZ3NnQVVFQmFpRUJRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUl3SWdORkRRQWdBaUFERVFBQUlRQUxJQUFOcWdGQjFnQWhBd3l6QWdzZ0FTQUVSd1JBQTBBZ0FTMEFBQ0lBUVNCSEJFQUNRQUpBQWtBZ0FFSElBR3NPQ3dBQnN3R3pBYk1Cc3dHekFiTUJzd0d6QVFLekFRc2dBVUVCYWlFQlFkSUFJUU1NdHdJTElBRkJBV29oQVVIVEFDRURETFlDQ3lBQlFRRnFJUUZCMUFBaEF3eTFBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFlUUFJUU1NekFJTFFlUUFJUU1NeXdJTEEwQWdBUzBBQUVId3dnQnFMUUFBSWdCQkFVY0VRQ0FBUVFKckRnT25BYVlCcFFHa0FRc2dCQ0FCUVFGcUlnRkhEUUFMUWVZQUlRTU15Z0lMSUFGQkFXb2dBU0FFUncwQ0drSG5BQ0VERE1rQ0N3TkFJQUV0QUFCQjhNUUFhaTBBQUNJQVFRRkhCRUFDUUNBQVFRSnJEZ1NpQWFFQm9BRUFud0VMUWRjQUlRTU1zUUlMSUFRZ0FVRUJhaUlCUncwQUMwSG9BQ0VERE1nQ0N5QUJJQVJHQkVCQjZRQWhBd3pJQWdzQ1FDQUJMUUFBSWdCQkNtc09HcmNCbXdHYkFiUUJtd0diQVpzQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCbXdHYkFac0JwQUdiQVpzQkFKa0JDeUFCUVFGcUN5RUJRUVloQXd5dEFnc0RRQ0FCTFFBQVFmREdBR290QUFCQkFVY05mU0FFSUFGQkFXb2lBVWNOQUF0QjZnQWhBd3pGQWdzZ0FVRUJhaUFCSUFSSERRSWFRZXNBSVFNTXhBSUxJQUVnQkVZRVFFSHNBQ0VERE1RQ0N5QUJRUUZxREFFTElBRWdCRVlFUUVIdEFDRURETU1DQ3lBQlFRRnFDeUVCUVFRaEF3eW9BZ3NnQVNBRVJnUkFRZTRBSVFNTXdRSUxBa0FDUUFKQUlBRXRBQUJCOE1nQWFpMEFBRUVCYXc0SGtBR1BBWTRCQUh3QkFvMEJDeUFCUVFGcUlRRU1Dd3NnQVVFQmFneVRBUXRCQUNFRElBSkJBRFlDSENBQ1Fac1NOZ0lRSUFKQkJ6WUNEQ0FDSUFGQkFXbzJBaFFNd0FJTEFrQURRQ0FCTFFBQVFmRElBR290QUFBaUFFRUVSd1JBQWtBQ1FDQUFRUUZyRGdlVUFaTUJrZ0dOQVFBRUFZMEJDMEhhQUNFRERLb0NDeUFCUVFGcUlRRkIzQUFoQXd5cEFnc2dCQ0FCUVFGcUlnRkhEUUFMUWU4QUlRTU13QUlMSUFGQkFXb01rUUVMSUFRZ0FTSUFSZ1JBUWZBQUlRTU12d0lMSUFBdEFBQkJMMGNOQVNBQVFRRnFJUUVNQndzZ0JDQUJJZ0JHQkVCQjhRQWhBd3krQWdzZ0FDMEFBQ0lCUVM5R0JFQWdBRUVCYWlFQlFkMEFJUU1NcFFJTElBRkJDbXNpQTBFV1N3MEFJQUFoQVVFQklBTjBRWW1BZ0FKeERma0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FEWUNGQ0FDUVl3Y05nSVFJQUpCQnpZQ0RBeThBZ3NnQVNBRVJ3UkFJQUZCQVdvaEFVSGVBQ0VEREtNQ0MwSHlBQ0VERExzQ0N5QUJJQVJHQkVCQjlBQWhBd3k3QWdzQ1FDQUJMUUFBUWZETUFHb3RBQUJCQVdzT0EvY0Jjd0NDQVF0QjRRQWhBd3loQWdzZ0FTQUVSd1JBQTBBZ0FTMEFBRUh3eWdCcUxRQUFJZ0JCQTBjRVFBSkFJQUJCQVdzT0F2a0JBSVVCQzBIZkFDRURES01DQ3lBRUlBRkJBV29pQVVjTkFBdEI4d0FoQXd5NkFndEI4d0FoQXd5NUFnc2dBU0FFUndSQUlBSkJEellDQ0NBQ0lBRTJBZ1JCNEFBaEF3eWdBZ3RCOVFBaEF3eTRBZ3NnQVNBRVJnUkFRZllBSVFNTXVBSUxJQUpCRHpZQ0NDQUNJQUUyQWdRTFFRTWhBd3lkQWdzRFFDQUJMUUFBUVNCSERZNENJQVFnQVVFQmFpSUJSdzBBQzBIM0FDRURETFVDQ3lBQklBUkdCRUJCK0FBaEF3eTFBZ3NnQVMwQUFFRWdSdzE2SUFGQkFXb2hBUXhiQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ09DSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURYZ01nQUlMSUFFZ0JFWUVRRUg2QUNFRERMTUNDeUFCTFFBQVFjd0FSdzEwSUFGQkFXb2hBVUVUREhZTFFmc0FJUU1nQVNBRVJnMnhBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWURRQ0FCTFFBQUlBQkI4TTRBYWkwQUFFY05jeUFBUVFWR0RYVWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1zUUlMSUFFZ0JFWUVRRUg4QUNFRERMRUNDd0pBQWtBZ0FTMEFBRUhEQUdzT0RBQjBkSFIwZEhSMGRIUjBBWFFMSUFGQkFXb2hBVUhtQUNFRERKZ0NDeUFCUVFGcUlRRkI1d0FoQXd5WEFndEIvUUFoQXlBQklBUkdEYThDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWUzUEFHb3RBQUJIRFhJZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRExBQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVJBTWN3dEIvZ0FoQXlBQklBUkdEYTRDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWZiT0FHb3RBQUJIRFhFZ0FFRUZSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREs4Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVJZTWNndEIvd0FoQXlBQklBUkdEYTBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWZ6T0FHb3RBQUJIRFhBZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREs0Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFVTWNRc2dBU0FFUmdSQVFZQUJJUU1NclFJTElBRXRBQUJCMlFCSERXNGdBVUVCYWlFQlFRZ01jQXNnQVNBRVJnUkFRWUVCSVFNTXJBSUxBa0FDUUNBQkxRQUFRYzRBYXc0REFHOEJid3NnQVVFQmFpRUJRZXNBSVFNTWt3SUxJQUZCQVdvaEFVSHNBQ0VEREpJQ0N5QUJJQVJHQkVCQmdnRWhBd3lyQWdzQ1FBSkFJQUV0QUFCQnlBQnJEZ2dBYm01dWJtNXVBVzRMSUFGQkFXb2hBVUhxQUNFRERKSUNDeUFCUVFGcUlRRkI3UUFoQXd5UkFndEJnd0VoQXlBQklBUkdEYWtDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUVlEUEFHb3RBQUJIRFd3Z0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREtvQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFBTWJRdEJoQUVoQXlBQklBUkdEYWdDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJHb2hCZ0pBQTBBZ0FTMEFBQ0FBUVlQUEFHb3RBQUJIRFdzZ0FFRUVSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREtrQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVNNTWJBc2dBU0FFUmdSQVFZVUJJUU1NcUFJTEFrQUNRQ0FCTFFBQVFjd0FhdzRJQUd0cmEydHJhd0ZyQ3lBQlFRRnFJUUZCN3dBaEF3eVBBZ3NnQVVFQmFpRUJRZkFBSVFNTWpnSUxJQUVnQkVZRVFFR0dBU0VEREtjQ0N5QUJMUUFBUWNVQVJ3MW9JQUZCQVdvaEFReGdDMEdIQVNFRElBRWdCRVlOcFFJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQWtBRFFDQUJMUUFBSUFCQmlNOEFhaTBBQUVjTmFDQUFRUU5HRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXBnSUxJQUpCQURZQ0FDQUdRUUZxSVFGQkxReHBDMEdJQVNFRElBRWdCRVlOcEFJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUlhaUVHQWtBRFFDQUJMUUFBSUFCQjBNOEFhaTBBQUVjTlp5QUFRUWhHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXBRSUxJQUpCQURZQ0FDQUdRUUZxSVFGQktReG9DeUFCSUFSR0JFQkJpUUVoQXd5a0FndEJBU0FCTFFBQVFkOEFSdzFuR2lBQlFRRnFJUUVNWGd0QmlnRWhBeUFCSUFSR0RhSUNJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnTkFJQUV0QUFBZ0FFR016d0JxTFFBQVJ3MWtJQUJCQVVZTitnRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1vZ0lMUVlzQklRTWdBU0FFUmcyaEFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFR096d0JxTFFBQVJ3MWtJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWlBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRUNER1VMUVl3QklRTWdBU0FFUmcyZ0FpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFSHd6d0JxTFFBQVJ3MWpJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWhBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRWZER1FMUVkwQklRTWdBU0FFUmcyZkFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFSHl6d0JxTFFBQVJ3MWlJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWdBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRUpER01MSUFFZ0JFWUVRRUdPQVNFRERKOENDd0pBQWtBZ0FTMEFBRUhKQUdzT0J3QmlZbUppWWdGaUN5QUJRUUZxSVFGQitBQWhBd3lHQWdzZ0FVRUJhaUVCUWZrQUlRTU1oUUlMUVk4QklRTWdBU0FFUmcyZEFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVZxSVFZQ1FBTkFJQUV0QUFBZ0FFR1J6d0JxTFFBQVJ3MWdJQUJCQlVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWVBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVlER0VMUVpBQklRTWdBU0FFUmcyY0FpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFR1h6d0JxTFFBQVJ3MWZJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWRBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVhER0FMUVpFQklRTWdBU0FFUmcyYkFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVpxSVFZQ1FBTkFJQUV0QUFBZ0FFR2F6d0JxTFFBQVJ3MWVJQUJCQmtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWNBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVZERjhMUVpJQklRTWdBU0FFUmcyYUFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVZxSVFZQ1FBTkFJQUV0QUFBZ0FFR2h6d0JxTFFBQVJ3MWRJQUJCQlVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWJBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRWVERjRMSUFFZ0JFWUVRRUdUQVNFRERKb0NDeUFCTFFBQVFjd0FSdzFiSUFGQkFXb2hBVUVLREYwTElBRWdCRVlFUUVHVUFTRURESmtDQ3dKQUFrQWdBUzBBQUVIQkFHc09Ed0JjWEZ4Y1hGeGNYRnhjWEZ4Y0FWd0xJQUZCQVdvaEFVSCtBQ0VERElBQ0N5QUJRUUZxSVFGQi93QWhBd3ovQVFzZ0FTQUVSZ1JBUVpVQklRTU1tQUlMQWtBQ1FDQUJMUUFBUWNFQWF3NERBRnNCV3dzZ0FVRUJhaUVCUWYwQUlRTU0vd0VMSUFGQkFXb2hBVUdBQVNFRERQNEJDMEdXQVNFRElBRWdCRVlObGdJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUJhaUVHQWtBRFFDQUJMUUFBSUFCQnA4OEFhaTBBQUVjTldTQUFRUUZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWx3SUxJQUpCQURZQ0FDQUdRUUZxSVFGQkN3eGFDeUFCSUFSR0JFQkJsd0VoQXd5V0Fnc0NRQUpBQWtBQ1FDQUJMUUFBUVMxckRpTUFXMXRiVzF0YlcxdGJXMXRiVzF0YlcxdGJXMXRiVzFzQlcxdGJXMXNDVzF0YkExc0xJQUZCQVdvaEFVSDdBQ0VERFA4QkN5QUJRUUZxSVFGQi9BQWhBd3orQVFzZ0FVRUJhaUVCUVlFQklRTU0vUUVMSUFGQkFXb2hBVUdDQVNFRERQd0JDMEdZQVNFRElBRWdCRVlObEFJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUVhaUVHQWtBRFFDQUJMUUFBSUFCQnFjOEFhaTBBQUVjTlZ5QUFRUVJHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWxRSUxJQUpCQURZQ0FDQUdRUUZxSVFGQkdReFlDMEdaQVNFRElBRWdCRVlOa3dJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUZhaUVHQWtBRFFDQUJMUUFBSUFCQnJzOEFhaTBBQUVjTlZpQUFRUVZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWxBSUxJQUpCQURZQ0FDQUdRUUZxSVFGQkJneFhDMEdhQVNFRElBRWdCRVlOa2dJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUJhaUVHQWtBRFFDQUJMUUFBSUFCQnRNOEFhaTBBQUVjTlZTQUFRUUZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWt3SUxJQUpCQURZQ0FDQUdRUUZxSVFGQkhBeFdDMEdiQVNFRElBRWdCRVlOa1FJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUJhaUVHQWtBRFFDQUJMUUFBSUFCQnRzOEFhaTBBQUVjTlZDQUFRUUZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWtnSUxJQUpCQURZQ0FDQUdRUUZxSVFGQkp3eFZDeUFCSUFSR0JFQkJuQUVoQXd5UkFnc0NRQUpBSUFFdEFBQkIxQUJyRGdJQUFWUUxJQUZCQVdvaEFVR0dBU0VERFBnQkN5QUJRUUZxSVFGQmh3RWhBd3ozQVF0Qm5RRWhBeUFCSUFSR0RZOENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnSkFBMEFnQVMwQUFDQUFRYmpQQUdvdEFBQkhEVklnQUVFQlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESkFDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRU1lNVXd0Qm5nRWhBeUFCSUFSR0RZNENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnSkFBMEFnQVMwQUFDQUFRYnJQQUdvdEFBQkhEVkVnQUVFQlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESThDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUU1NVWd0Qm53RWhBeUFCSUFSR0RZMENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQW1vaEJnSkFBMEFnQVMwQUFDQUFRZTNQQUdvdEFBQkhEVkFnQUVFQ1JnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESTRDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUXdNVVF0Qm9BRWhBeUFCSUFSR0RZd0NJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQTJvaEJnSkFBMEFnQVMwQUFDQUFRYnpQQUdvdEFBQkhEVThnQUVFRFJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESTBDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUTBNVUFzZ0FTQUVSZ1JBUWFFQklRTU1qQUlMQWtBQ1FDQUJMUUFBUWNZQWF3NExBRTlQVDA5UFQwOVBUd0ZQQ3lBQlFRRnFJUUZCaXdFaEF3enpBUXNnQVVFQmFpRUJRWXdCSVFNTThnRUxJQUVnQkVZRVFFR2lBU0VERElzQ0N5QUJMUUFBUWRBQVJ3MU1JQUZCQVdvaEFReEdDeUFCSUFSR0JFQkJvd0VoQXd5S0Fnc0NRQUpBSUFFdEFBQkJ5UUJyRGdjQlRVMU5UVTBBVFFzZ0FVRUJhaUVCUVk0QklRTU04UUVMSUFGQkFXb2hBVUVpREUwTFFhUUJJUU1nQVNBRVJnMklBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUhBendCcUxRQUFSdzFMSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlKQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVkREV3TElBRWdCRVlFUUVHbEFTRURESWdDQ3dKQUFrQWdBUzBBQUVIU0FHc09Bd0JMQVVzTElBRkJBV29oQVVHUUFTRURETzhCQ3lBQlFRRnFJUUZCQkF4TEN5QUJJQVJHQkVCQnBnRWhBd3lIQWdzQ1FBSkFBa0FDUUFKQUlBRXRBQUJCd1FCckRoVUFUVTFOVFUxTlRVMU5UUUZOVFFKTlRRTk5UUVJOQ3lBQlFRRnFJUUZCaUFFaEF3enhBUXNnQVVFQmFpRUJRWWtCSVFNTThBRUxJQUZCQVdvaEFVR0tBU0VERE84QkN5QUJRUUZxSVFGQmp3RWhBd3p1QVFzZ0FVRUJhaUVCUVpFQklRTU03UUVMUWFjQklRTWdBU0FFUmcyRkFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSHR6d0JxTFFBQVJ3MUlJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUdBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVJERWtMUWFnQklRTWdBU0FFUmcyRUFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSEN6d0JxTFFBQVJ3MUhJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUZBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRXNERWdMUWFrQklRTWdBU0FFUmcyREFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVJxSVFZQ1FBTkFJQUV0QUFBZ0FFSEZ6d0JxTFFBQVJ3MUdJQUJCQkVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUVBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRXJERWNMUWFvQklRTWdBU0FFUmcyQ0FpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSEt6d0JxTFFBQVJ3MUZJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeURBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVVERVlMSUFFZ0JFWUVRRUdyQVNFRERJSUNDd0pBQWtBQ1FBSkFJQUV0QUFCQndnQnJEZzhBQVFKSFIwZEhSMGRIUjBkSFJ3TkhDeUFCUVFGcUlRRkJrd0VoQXd6ckFRc2dBVUVCYWlFQlFaUUJJUU1NNmdFTElBRkJBV29oQVVHVkFTRURET2tCQ3lBQlFRRnFJUUZCbGdFaEF3em9BUXNnQVNBRVJnUkFRYXdCSVFNTWdRSUxJQUV0QUFCQnhRQkhEVUlnQVVFQmFpRUJERDBMUWEwQklRTWdBU0FFUmczL0FTQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSE56d0JxTFFBQVJ3MUNJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUFBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRU9ERU1MSUFFZ0JFWUVRRUd1QVNFRERQOEJDeUFCTFFBQVFkQUFSdzFBSUFGQkFXb2hBVUVsREVJTFFhOEJJUU1nQVNBRVJnMzlBU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFocUlRWUNRQU5BSUFFdEFBQWdBRUhRendCcUxRQUFSdzFBSUFCQkNFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXorQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVxREVFTElBRWdCRVlFUUVHd0FTRUREUDBCQ3dKQUFrQWdBUzBBQUVIVkFHc09Dd0JBUUVCQVFFQkFRRUFCUUFzZ0FVRUJhaUVCUVpvQklRTU01QUVMSUFGQkFXb2hBVUdiQVNFRERPTUJDeUFCSUFSR0JFQkJzUUVoQXd6OEFRc0NRQUpBSUFFdEFBQkJ3UUJyRGhRQVB6OC9QejgvUHo4L1B6OC9QejgvUHo4L0FUOExJQUZCQVdvaEFVR1pBU0VERE9NQkN5QUJRUUZxSVFGQm5BRWhBd3ppQVF0QnNnRWhBeUFCSUFSR0Rmb0JJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQTJvaEJnSkFBMEFnQVMwQUFDQUFRZG5QQUdvdEFBQkhEVDBnQUVFRFJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUHNCQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRU0VNUGd0QnN3RWhBeUFCSUFSR0Rma0JJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQm1vaEJnSkFBMEFnQVMwQUFDQUFRZDNQQUdvdEFBQkhEVHdnQUVFR1JnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUG9CQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUm9NUFFzZ0FTQUVSZ1JBUWJRQklRTU0rUUVMQWtBQ1FBSkFJQUV0QUFCQnhRQnJEaEVBUFQwOVBUMDlQVDA5QVQwOVBUMDlBajBMSUFGQkFXb2hBVUdkQVNFRERPRUJDeUFCUVFGcUlRRkJuZ0VoQXd6Z0FRc2dBVUVCYWlFQlFaOEJJUU1NM3dFTFFiVUJJUU1nQVNBRVJnMzNBU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUhrendCcUxRQUFSdzA2SUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXo0QVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVvRERzTFFiWUJJUU1nQVNBRVJnMzJBU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhxendCcUxRQUFSdzA1SUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXozQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVIRERvTElBRWdCRVlFUUVHM0FTRUREUFlCQ3dKQUFrQWdBUzBBQUVIRkFHc09EZ0E1T1RrNU9UazVPVGs1T1RrQk9Rc2dBVUVCYWlFQlFhRUJJUU1NM1FFTElBRkJBV29oQVVHaUFTRURETndCQzBHNEFTRURJQUVnQkVZTjlBRWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkI3YzhBYWkwQUFFY05OeUFBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU05UUVMSUFKQkFEWUNBQ0FHUVFGcUlRRkJFZ3c0QzBHNUFTRURJQUVnQkVZTjh3RWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkI4TThBYWkwQUFFY05OaUFBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU05QUVMSUFKQkFEWUNBQ0FHUVFGcUlRRkJJQXczQzBHNkFTRURJQUVnQkVZTjhnRWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkI4czhBYWkwQUFFY05OU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU04d0VMSUFKQkFEWUNBQ0FHUVFGcUlRRkJEd3cyQ3lBQklBUkdCRUJCdXdFaEF3enlBUXNDUUFKQUlBRXRBQUJCeVFCckRnY0FOVFUxTlRVQk5Rc2dBVUVCYWlFQlFhVUJJUU1NMlFFTElBRkJBV29oQVVHbUFTRURETmdCQzBHOEFTRURJQUVnQkVZTjhBRWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVIYWlFR0FrQURRQ0FCTFFBQUlBQkI5TThBYWkwQUFFY05NeUFBUVFkR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU04UUVMSUFKQkFEWUNBQ0FHUVFGcUlRRkJHd3cwQ3lBQklBUkdCRUJCdlFFaEF3endBUXNDUUFKQUFrQWdBUzBBQUVIQ0FHc09FZ0EwTkRRME5EUTBORFFCTkRRME5EUTBBalFMSUFGQkFXb2hBVUdrQVNFREROZ0JDeUFCUVFGcUlRRkJwd0VoQXd6WEFRc2dBVUVCYWlFQlFhZ0JJUU1NMWdFTElBRWdCRVlFUUVHK0FTRURETzhCQ3lBQkxRQUFRYzRBUncwd0lBRkJBV29oQVF3c0N5QUJJQVJHQkVCQnZ3RWhBd3p1QVFzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FCTFFBQVFjRUFhdzRWQUFFQ0F6OEVCUVkvUHo4SENBa0tDejhNRFE0UFB3c2dBVUVCYWlFQlFlZ0FJUU1NNHdFTElBRkJBV29oQVVIcEFDRURET0lCQ3lBQlFRRnFJUUZCN2dBaEF3emhBUXNnQVVFQmFpRUJRZklBSVFNTTRBRUxJQUZCQVdvaEFVSHpBQ0VERE44QkN5QUJRUUZxSVFGQjlnQWhBd3plQVFzZ0FVRUJhaUVCUWZjQUlRTU0zUUVMSUFGQkFXb2hBVUg2QUNFREROd0JDeUFCUVFGcUlRRkJnd0VoQXd6YkFRc2dBVUVCYWlFQlFZUUJJUU1NMmdFTElBRkJBV29oQVVHRkFTRURETmtCQ3lBQlFRRnFJUUZCa2dFaEF3ellBUXNnQVVFQmFpRUJRWmdCSVFNTTF3RUxJQUZCQVdvaEFVR2dBU0VERE5ZQkN5QUJRUUZxSVFGQm93RWhBd3pWQVFzZ0FVRUJhaUVCUWFvQklRTU0xQUVMSUFFZ0JFY0VRQ0FDUVJBMkFnZ2dBaUFCTmdJRVFhc0JJUU1NMUFFTFFjQUJJUU1NN0FFTFFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSTBJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEVjRnQUVFVlJ3MEhJQUpCMFFBMkFod2dBaUFCTmdJVUlBSkJzQmMyQWhBZ0FrRVZOZ0lNUVFBaEF3enJBUXNnQVVFQmFpQUJJQVJIRFFnYVFjSUJJUU1NNmdFTEEwQUNRQ0FCTFFBQVFRcHJEZ1FJQUFBTEFBc2dCQ0FCUVFGcUlnRkhEUUFMUWNNQklRTU02UUVMSUFFZ0JFY0VRQ0FDUVJFMkFnZ2dBaUFCTmdJRVFRRWhBd3pRQVF0QnhBRWhBd3pvQVFzZ0FTQUVSZ1JBUWNVQklRTU02QUVMQWtBQ1FDQUJMUUFBUVFwckRnUUJLQ2dBS0FzZ0FVRUJhZ3dKQ3lBQlFRRnFEQVVMSUFFZ0JFWUVRRUhHQVNFRERPY0JDd0pBQWtBZ0FTMEFBRUVLYXc0WEFRc0xBUXNMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd0FMQ3lBQlFRRnFJUUVMUWJBQklRTU16UUVMSUFFZ0JFWUVRRUhJQVNFRERPWUJDeUFCTFFBQVFTQkhEUWtnQWtFQU93RXlJQUZCQVdvaEFVR3pBU0VERE13QkN3TkFJQUVoQUFKQUlBRWdCRWNFUUNBQkxRQUFRVEJyUWY4QmNTSURRUXBKRFFFTUp3dEJ4d0VoQXd6bUFRc0NRQ0FDTHdFeUlnRkJtVE5MRFFBZ0FpQUJRUXBzSWdVN0FUSWdCVUgrL3dOeElBTkIvLzhEYzBzTkFDQUFRUUZxSVFFZ0FpQURJQVZxSWdNN0FUSWdBMEgvL3dOeFFlZ0hTUTBCQ3d0QkFDRURJQUpCQURZQ0hDQUNRY0VKTmdJUUlBSkJEVFlDRENBQ0lBQkJBV28yQWhRTTVBRUxJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSHdERFlDRUNBQ1FSczJBZ3hCQUNFRERPTUJDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNZaUFBMEJJQUZCQVdvTElRRkJyUUVoQXd6SUFRc2dBa0hCQVRZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVVFRQWhBd3pnQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQW1JZ0FOQVNBQlFRRnFDeUVCUWE0QklRTU14UUVMSUFKQndnRTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGRUVBSVFNTTNRRUxJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1hDellDRUNBQ1FRMDJBZ3hCQUNFREROd0JDeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI0eEEyQWhBZ0FrRUpOZ0lNUVFBaEF3emJBUXNnQWtFQ09nQW9ES3dCQzBFQUlRTWdBa0VBTmdJY0lBSkJyd3MyQWhBZ0FrRUNOZ0lNSUFJZ0FVRUJhallDRkF6WkFRdEJBaUVEREw4QkMwRU5JUU1NdmdFTFFTWWhBd3k5QVF0QkZTRURETHdCQzBFV0lRTU11d0VMUVJnaEF3eTZBUXRCSENFRERMa0JDMEVkSVFNTXVBRUxRU0FoQXd5M0FRdEJJU0VERExZQkMwRWpJUU1NdFFFTFFjWUFJUU1NdEFFTFFTNGhBd3l6QVF0QlBTRURETElCQzBITEFDRURETEVCQzBIT0FDRURETEFCQzBIWUFDRURESzhCQzBIWkFDRURESzRCQzBIYkFDRURESzBCQzBIeEFDRURES3dCQzBIMEFDRURES3NCQzBHTkFTRURES29CQzBHWEFTRURES2tCQzBHcEFTRURES2dCQzBHdkFTRURES2NCQzBHeEFTRURES1lCQ3lBQ1FRQTJBZ0FMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjhSczJBaEFnQWtFR05nSU1ETDBCQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRU1FMT2dBcElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKeUlBUlFSQVFlVUFJUU1Nb3dFTElBSkIrUUEyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXV3RUxJQUJCRlVjRVFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnpBNDJBaEFnQWtFZ05nSU1RUUFoQXd5N0FRc2dBa0g0QURZQ0hDQUNJQUUyQWhRZ0FrSEtHRFlDRUNBQ1FSVTJBZ3hCQUNFRERMb0JDeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJqaHMyQWhBZ0FrRUdOZ0lNUVFBaEF3eTVBUXNnQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZjRSTmdJUUlBSkJCellDREVFQUlRTU11QUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dNSERZQ0VDQUNRUWMyQWd4QkFDRURETGNCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCd3c4MkFoQWdBa0VITmdJTVFRQWhBd3kyQVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNNUE5nSVFJQUpCQnpZQ0RFRUFJUU1NdFFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwUklBSkI1UUEyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXRBRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMGdJQUpCMHdBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zd0VMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBpSUFKQjBnQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc2dFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwT0lBSkI1UUEyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXNRRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMGRJQUpCMHdBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBmSUFKQjBnQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NcndFTElBQkJQMGNOQVNBQlFRRnFDeUVCUVFVaEF3eVVBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIOUVqWUNFQ0FDUVFjMkFnd01yQUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hjQ0RZQ0VDQUNRUWMyQWd4QkFDRURES3NCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDVWlBRVVOQnlBQ1FlVUFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREtvQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1VpQUVVTkZpQUNRZE1BTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERLa0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNVaUFFVU5HQ0FDUWRJQU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURES2dCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCeGdvMkFoQWdBa0VITmdJTVFRQWhBd3luQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFFNZ0FrSGxBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5bUFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRSSWdBa0hUQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eWxBUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUlFnQWtIU0FEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3lrQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFFBZ0FrSGxBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5akFRdEIxUUFoQXd5SkFRc2dBRUVWUndSQUlBSkJBRFlDSENBQ0lBRTJBaFFnQWtHNURUWUNFQ0FDUVJvMkFneEJBQ0VEREtJQkN5QUNRZVFBTmdJY0lBSWdBVFlDRkNBQ1FlTVhOZ0lRSUFKQkZUWUNERUVBSVFNTW9RRUxJQUpCQURZQ0FDQUdRUUZxSVFFZ0FpMEFLU0lBUVNOclFRdEpEUVFDUUNBQVFRWkxEUUJCQVNBQWRFSEtBSEZGRFFBTUJRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0gzQ1RZQ0VDQUNRUWcyQWd3TW9BRUxJQUpCQURZQ0FDQUdRUUZxSVFFZ0FpMEFLVUVoUmcwRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYkNqWUNFQ0FDUVFnMkFneEJBQ0VEREo4QkN5QUNRUUEyQWdBTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJrRE0yQWhBZ0FrRUlOZ0lNREowQkN5QUNRUUEyQWdBZ0JrRUJhaUVCSUFJdEFDbEJJMGtOQUNBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCMHdrMkFoQWdBa0VJTmdJTVFRQWhBd3ljQVF0QjBRQWhBd3lDQVFzZ0FTMEFBRUV3YXlJQVFmOEJjVUVLU1FSQUlBSWdBRG9BS2lBQlFRRnFJUUZCendBaEF3eUNBUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBb0lnQkZEWVlCSUFKQjNnQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NbWdFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFLQ0lBUlEyR0FTQUNRZHdBTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERKa0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FGRUNnaUFFVUVRQ0FGSVFFTWh3RUxJQUpCMmdBMkFod2dBaUFGTmdJVUlBSWdBRFlDREF5WUFRdEJBQ0VCUVFFaEF3c2dBaUFET2dBcklBVkJBV29oQXdKQUFrQUNRQ0FDTFFBdFFSQnhEUUFDUUFKQUFrQWdBaTBBS2c0REFRQUNCQXNnQmtVTkF3d0NDeUFBRFFFTUFnc2dBVVVOQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0F4QW9JZ0JGQkVBZ0F5RUJEQUlMSUFKQjJBQTJBaHdnQWlBRE5nSVVJQUlnQURZQ0RFRUFJUU1NbUFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBTVFLQ0lBUlFSQUlBTWhBUXlIQVFzZ0FrSFpBRFlDSENBQ0lBTTJBaFFnQWlBQU5nSU1RUUFoQXd5WEFRdEJ6QUFoQXd4OUN5QUFRUlZIQkVBZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpRTk5nSVFJQUpCSVRZQ0RFRUFJUU1NbGdFTElBSkIxd0EyQWh3Z0FpQUJOZ0lVSUFKQnlSYzJBaEFnQWtFVk5nSU1RUUFoQXd5VkFRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dBRVRZQ0VDQUNRUWsyQWd3TWxBRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMEFJQUpCMHdBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1rd0VMUWNrQUlRTU1lUXNnQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY0VvTmdJUUlBSkJCellDRENBQ1FRQTJBZ0JCQUNFRERKRUJDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFFBZ0FrSFNBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1ESkFCQzBISUFDRURESFlMSUFKQkFEWUNBQ0FGSVFFTElBSkJnQkk3QVNvZ0FVRUJhaUVCUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FJd0lnTkZEUUFnQWlBREVRQUFJUUFMSUFBTkFRdEJ4d0FoQXd4ekN5QUFRUlZHQkVBZ0FrSFJBRFlDSENBQ0lBRTJBaFFnQWtIakZ6WUNFQ0FDUVJVMkFneEJBQ0VEREl3QkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYmtOTmdJUUlBSkJHallDREF5TEFRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dnR1RZQ0VDQUNRUjQyQWd3TWlnRUxJQUV0QUFCQk9rWUVRQ0FDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXBJZ0JGRFFFZ0FrSERBRFlDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVRElvQkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYkVSTmdJUUlBSkJDallDREF5SkFRc2dBVUVCYWlFQlFUc2hBd3h2Q3lBQ1FjTUFOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNaHdFTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI4QTQyQWhBZ0FrRWNOZ0lNRElZQkN5QUNJQUl2QVRCQkVISTdBVEFNWmdzQ1FDQUNMd0V3SWdCQkNIRkZEUUFnQWkwQUtFRUJSdzBBSUFJdEFDMUJDSEZGRFFNTElBSWdBRUgzK3dOeFFZQUVjanNCTUF3RUN5QUJJQVJIQkVBQ1FBTkFJQUV0QUFCQk1Hc2lBRUgvQVhGQkNrOEVRRUUxSVFNTWJnc2dBaWtESUNJS1FwbXo1c3lacytiTUdWWU5BU0FDSUFwQ0NuNGlDamNESUNBS0lBQ3RRdjhCZ3lJTFFuK0ZWZzBCSUFJZ0NpQUxmRGNESUNBRUlBRkJBV29pQVVjTkFBdEJPU0VERElVQkN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JDQUNJQUFnQVVFQmFpSUJFQ29pQUEwTURIY0xRVGtoQXd5REFRc2dBaTBBTUVFZ2NRMEdRY1VCSVFNTWFRdEJBQ0VESUFKQkFEWUNCQ0FDSUFFZ0FSQXFJZ0JGRFFRZ0FrRTZOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNZ1FFTElBSXRBQ2hCQVVjTkFDQUNMUUF0UVFoeFJRMEJDMEUzSVFNTVpnc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFCRUFnQWtFN05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1md3NnQVVFQmFpRUJERzRMSUFKQkNEb0FMQXdFQ3lBQlFRRnFJUUVNYlF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGtFallDRUNBQ1FRUTJBZ3dNZXdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRS2lJQVJRMXNJQUpCTnpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREhvTElBSWdBaThCTUVFZ2Nqc0JNQXRCTUNFRERGOExJQUpCTmpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREhjTElBQkJMRWNOQVNBQlFRRnFJUUJCQVNFQkFrQUNRQUpBQWtBQ1FDQUNMUUFzUVFWckRnUURBUUlFQUFzZ0FDRUJEQVFMUVFJaEFRd0JDMEVFSVFFTElBSkJBVG9BTENBQ0lBSXZBVEFnQVhJN0FUQWdBQ0VCREFFTElBSWdBaThCTUVFSWNqc0JNQ0FBSVFFTFFUa2hBd3hjQ3lBQ1FRQTZBQ3dMUVRRaEF3eGFDeUFCSUFSR0JFQkJMU0VEREhNTEFrQUNRQU5BQWtBZ0FTMEFBRUVLYXc0RUFnQUFBd0FMSUFRZ0FVRUJhaUlCUncwQUMwRXRJUU1NZEFzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRS2lJQVJRMENJQUpCTERZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREhNTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCRUNvaUFFVUVRQ0FCUVFGcUlRRU1BZ3NnQWtFc05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1jZ3NnQVMwQUFFRU5SZ1JBSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJFQ29pQUVVRVFDQUJRUUZxSVFFTUFnc2dBa0VzTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWNnc2dBaTBBTFVFQmNRUkFRY1FCSVFNTVdRc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFEUUVNWlF0Qkx5RURERmNMSUFKQkxqWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURHOExRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCOEJRMkFoQWdBa0VETmdJTURHNExRUUVoQXdKQUFrQUNRQUpBSUFJdEFDeEJCV3NPQkFNQkFnQUVDeUFDSUFJdkFUQkJDSEk3QVRBTUF3dEJBaUVEREFFTFFRUWhBd3NnQWtFQk9nQXNJQUlnQWk4Qk1DQURjanNCTUF0QktpRURERk1MUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjRRODJBaEFnQWtFS05nSU1ER3NMUVFFaEF3SkFBa0FDUUFKQUFrQUNRQ0FDTFFBc1FRSnJEZ2NGQkFRREFRSUFCQXNnQWlBQ0x3RXdRUWh5T3dFd0RBTUxRUUloQXd3QkMwRUVJUU1MSUFKQkFUb0FMQ0FDSUFJdkFUQWdBM0k3QVRBTFFTc2hBd3hTQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1Fhc1NOZ0lRSUFKQkN6WUNEQXhxQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FmME5OZ0lRSUFKQkhUWUNEQXhwQ3lBQklBUkhCRUFEUUNBQkxRQUFRU0JIRFVnZ0JDQUJRUUZxSWdGSERRQUxRU1VoQXd4cEMwRWxJUU1NYUFzZ0FpMEFMVUVCY1FSQVFjTUJJUU1NVHdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRS1NJQUJFQWdBa0VtTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWFBc2dBVUVCYWlFQkRGd0xJQUZCQVdvaEFTQUNMd0V3SWdCQmdBRnhCRUJCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWxRaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTkJpQUFRUlZIRFI4Z0FrRUZOZ0ljSUFJZ0FUWUNGQ0FDUWZrWE5nSVFJQUpCRlRZQ0RFRUFJUU1NWndzQ1FDQUFRYUFFY1VHZ0JFY05BQ0FDTFFBdFFRSnhEUUJCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHV0V6WUNFQ0FDUVFRMkFnd01ad3NnQWdKL0lBSXZBVEJCRkhGQkZFWUVRRUVCSUFJdEFDaEJBVVlOQVJvZ0FpOEJNa0hsQUVZTUFRc2dBaTBBS1VFRlJnczZBQzVCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWlRaUEwVU5BQ0FDSUFNUkFBQWhBQXNDUUFKQUFrQUNRQUpBSUFBT0ZnSUJBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQU1FQ3lBQ1FRRTZBQzRMSUFJZ0FpOEJNRUhBQUhJN0FUQUxRU2NoQXd4UEN5QUNRU00yQWh3Z0FpQUJOZ0lVSUFKQnBSWTJBaEFnQWtFVk5nSU1RUUFoQXd4bkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZFVMTmdJUUlBSkJFVFlDREF4bUMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NMQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEUUVMUVE0aEF3eExDeUFBUVJWR0JFQWdBa0VDTmdJY0lBSWdBVFlDRkNBQ1FiQVlOZ0lRSUFKQkZUWUNERUVBSVFNTVpBdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0duRGpZQ0VDQUNRUkkyQWd3TVl3dEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dxSERZQ0VDQUNRUTgyQWd3TVlnc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFZ0NxZHFJZ0VRS3lJQVJRMEFJQUpCQlRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREdFTFFROGhBd3hIQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjMFROZ0lRSUFKQkREWUNEQXhmQzBJQklRb0xJQUZCQVdvaEFRSkFJQUlwQXlBaUMwTC8vLy8vLy8vLy93OVlCRUFnQWlBTFFnU0dJQXFFTndNZ0RBRUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCclFrMkFoQWdBa0VNTmdJTURGNExRU1FoQXd4RUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBUTmdJUUlBSkJERFlDREF4Y0N5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JDQUNJQUFnQVJBc0lnQkZCRUFnQVVFQmFpRUJERklMSUFKQkZ6WUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVERnNMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFQWtBZ0FpQUFJQUVRTENJQVJRUkFJQUZCQVdvaEFRd0JDeUFDUVJZMkFod2dBaUFBTmdJTUlBSWdBVUVCYWpZQ0ZBeGJDMEVmSVFNTVFRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dhRHpZQ0VDQUNRU0kyQWd3TVdRc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUxTSUFSUVJBSUFGQkFXb2hBUXhRQ3lBQ1FSUTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhZQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkFKQUlBSWdBQ0FCRUMwaUFFVUVRQ0FCUVFGcUlRRU1BUXNnQWtFVE5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1XQXRCSGlFRERENExRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCeGd3MkFoQWdBa0VqTmdJTURGWUxJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQkVDMGlBRVVFUUNBQlFRRnFJUUVNVGdzZ0FrRVJOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNVlFzZ0FrRVFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFnd01WQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIR0REWUNFQ0FDUVNNMkFnd01Vd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIQUZUWUNFQ0FDUVFJMkFnd01VZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FDUUNBQ0lBQWdBUkF0SWdCRkJFQWdBVUVCYWlFQkRBRUxJQUpCRGpZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVURGSUxRUnNoQXd3NEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY1lNTmdJUUlBSkJJellDREF4UUN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JBSkFJQUlnQUNBQkVDd2lBRVVFUUNBQlFRRnFJUUVNQVFzZ0FrRU5OZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNVUF0QkdpRURERFlMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQm1nODJBaEFnQWtFaU5nSU1ERTRMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFQWtBZ0FpQUFJQUVRTENJQVJRUkFJQUZCQVdvaEFRd0JDeUFDUVF3MkFod2dBaUFBTmdJTUlBSWdBVUVCYWpZQ0ZBeE9DMEVaSVFNTU5BdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dhRHpZQ0VDQUNRU0kyQWd3TVRBc2dBRUVWUndSQVFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJnd3cyQWhBZ0FrRVROZ0lNREV3TElBSkJDallDSENBQ0lBRTJBaFFnQWtIa0ZqWUNFQ0FDUVJVMkFneEJBQ0VEREVzTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCSUFxbmFpSUJFQ3NpQUFSQUlBSkJCellDSENBQ0lBRTJBaFFnQWlBQU5nSU1ERXNMUVJNaEF3d3hDeUFBUVJWSEJFQkJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hhRFRZQ0VDQUNRUlEyQWd3TVNnc2dBa0VlTmdJY0lBSWdBVFlDRkNBQ1Fma1hOZ0lRSUFKQkZUWUNERUVBSVFNTVNRdEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BaXdpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOUVNBQVFSVkdCRUFnQWtFRE5nSWNJQUlnQVRZQ0ZDQUNRYkFZTmdJUUlBSkJGVFlDREVFQUlRTU1TUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01TQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIYURUWUNFQ0FDUVJRMkFnd01Sd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01SZ3NnQWtFQU9nQXZJQUl0QUMxQkJIRkZEVDhMSUFKQkFEb0FMeUFDUVFFNkFEUkJBQ0VERENzTFFRQWhBeUFDUVFBMkFod2dBa0hrRVRZQ0VDQUNRUWMyQWd3Z0FpQUJRUUZxTmdJVURFTUxBa0FEUUFKQUlBRXRBQUJCQ21zT0JBQUNBZ0FDQ3lBRUlBRkJBV29pQVVjTkFBdEIzUUVoQXd4REN3SkFBa0FnQWkwQU5FRUJSdzBBUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKWUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRRQWdBRUVWUncwQklBSkIzQUUyQWh3Z0FpQUJOZ0lVSUFKQjFSWTJBaEFnQWtFVk5nSU1RUUFoQXd4RUMwSEJBU0VERENvTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIcEN6WUNFQ0FDUVI4MkFneEJBQ0VEREVJTEFrQUNRQ0FDTFFBb1FRRnJEZ0lFQVFBTFFjQUJJUU1NS1F0QnVRRWhBd3dvQ3lBQ1FRSTZBQzlCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWdBaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVRVFFSENBU0VERENnTElBQkJGVWNFUUNBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCcEF3MkFoQWdBa0VRTmdJTVFRQWhBd3hCQ3lBQ1Fkc0JOZ0ljSUFJZ0FUWUNGQ0FDUWZvV05nSVFJQUpCRlRZQ0RFRUFJUU1NUUFzZ0FTQUVSZ1JBUWRvQklRTU1RQXNnQVMwQUFFSElBRVlOQVNBQ1FRRTZBQ2dMUWF3QklRTU1KUXRCdndFaEF3d2tDeUFCSUFSSEJFQWdBa0VRTmdJSUlBSWdBVFlDQkVHK0FTRUREQ1FMUWRrQklRTU1QQXNnQVNBRVJnUkFRZGdCSVFNTVBBc2dBUzBBQUVISUFFY05CQ0FCUVFGcUlRRkJ2UUVoQXd3aUN5QUJJQVJHQkVCQjF3RWhBd3c3Q3dKQUFrQWdBUzBBQUVIRkFHc09FQUFGQlFVRkJRVUZCUVVGQlFVRkJRRUZDeUFCUVFGcUlRRkJ1d0VoQXd3aUN5QUJRUUZxSVFGQnZBRWhBd3doQzBIV0FTRURJQUVnQkVZTk9TQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFR0QwQUJxTFFBQVJ3MERJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBdzZDeUFDS0FJRUlRQWdBa0lBTndNQUlBSWdBQ0FHUVFGcUlnRVFKeUlBUlFSQVFjWUJJUU1NSVFzZ0FrSFZBVFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd3NUMwSFVBU0VESUFFZ0JFWU5PQ0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUdCMEFCcUxRQUFSdzBDSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXc1Q3lBQ1FZRUVPd0VvSUFJb0FnUWhBQ0FDUWdBM0F3QWdBaUFBSUFaQkFXb2lBUkFuSWdBTkF3d0NDeUFDUVFBMkFnQUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCMkJzMkFoQWdBa0VJTmdJTUREWUxRYm9CSVFNTUhBc2dBa0hUQVRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3dzBDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDT0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEwQUlBQkJGVVlOQVNBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCekE0MkFoQWdBa0VnTmdJTVFRQWhBd3d6QzBIa0FDRUREQmtMSUFKQitBQTJBaHdnQWlBQk5nSVVJQUpCeWhnMkFoQWdBa0VWTmdJTVFRQWhBd3d4QzBIU0FTRURJQVFnQVNJQVJnMHdJQVFnQVdzZ0FpZ0NBQ0lCYWlFRklBQWdBV3RCQkdvaEJnSkFBMEFnQUMwQUFDQUJRZnpQQUdvdEFBQkhEUUVnQVVFRVJnMERJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBRk5nSUFEREVMSUFKQkFEWUNIQ0FDSUFBMkFoUWdBa0dRTXpZQ0VDQUNRUWcyQWd3Z0FrRUFOZ0lBUVFBaEF3d3dDeUFCSUFSSEJFQWdBa0VPTmdJSUlBSWdBVFlDQkVHM0FTRUREQmNMUWRFQklRTU1Md3NnQWtFQU5nSUFJQVpCQVdvaEFRdEJ1QUVoQXd3VUN5QUJJQVJHQkVCQjBBRWhBd3d0Q3lBQkxRQUFRVEJySWdCQi93RnhRUXBKQkVBZ0FpQUFPZ0FxSUFGQkFXb2hBVUcyQVNFRERCUUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRS0NJQVJRMFVJQUpCendFMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1MQXNnQVNBRVJnUkFRYzRCSVFNTUxBc0NRQ0FCTFFBQVFTNUdCRUFnQVVFQmFpRUJEQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUtDSUFSUTBWSUFKQnpRRTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NTEF0QnRRRWhBd3dTQ3lBRUlBRWlCVVlFUUVITUFTRUREQ3NMUVFBaEFFRUJJUUZCQVNFR1FRQWhBd0pBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFJQVV0QUFCQk1Hc09DZ29KQUFFQ0F3UUZCZ2dMQzBFQ0RBWUxRUU1NQlF0QkJBd0VDMEVGREFNTFFRWU1BZ3RCQnd3QkMwRUlDeUVEUVFBaEFVRUFJUVlNQWd0QkNTRURRUUVoQUVFQUlRRkJBQ0VHREFFTFFRQWhBVUVCSVFNTElBSWdBem9BS3lBRlFRRnFJUU1DUUFKQUlBSXRBQzFCRUhFTkFBSkFBa0FDUUNBQ0xRQXFEZ01CQUFJRUN5QUdSUTBEREFJTElBQU5BUXdDQ3lBQlJRMEJDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FERUNnaUFFVUVRQ0FESVFFTUF3c2dBa0hKQVRZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3d3RDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FERUNnaUFFVUVRQ0FESVFFTUdBc2dBa0hLQVRZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3d3NDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FGRUNnaUFFVUVRQ0FGSVFFTUZnc2dBa0hMQVRZQ0hDQUNJQVUyQWhRZ0FpQUFOZ0lNRENzTFFiUUJJUU1NRVF0QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0Fqd2lBMFVOQUNBQ0lBTVJBQUFoQUFzQ1FDQUFCRUFnQUVFVlJnMEJJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1VEVFlDRUNBQ1FTRTJBZ3hCQUNFRERDc0xRYklCSVFNTUVRc2dBa0hJQVRZQ0hDQUNJQUUyQWhRZ0FrSEpGellDRUNBQ1FSVTJBZ3hCQUNFRERDa0xJQUpCQURZQ0FDQUdRUUZxSVFGQjlRQWhBd3dQQ3lBQ0xRQXBRUVZHQkVCQjR3QWhBd3dQQzBIaUFDRUREQTRMSUFBaEFTQUNRUUEyQWdBTElBSkJBRG9BTEVFSklRTU1EQXNnQWtFQU5nSUFJQWRCQVdvaEFVSEFBQ0VEREFzTFFRRUxPZ0FzSUFKQkFEWUNBQ0FHUVFGcUlRRUxRU2toQXd3SUMwRTRJUU1NQndzQ1FDQUJJQVJIQkVBRFFDQUJMUUFBUVlBK2FpMEFBQ0lBUVFGSEJFQWdBRUVDUncwRElBRkJBV29oQVF3RkN5QUVJQUZCQVdvaUFVY05BQXRCUGlFRERDRUxRVDRoQXd3Z0N3c2dBa0VBT2dBc0RBRUxRUXNoQXd3RUMwRTZJUU1NQXdzZ0FVRUJhaUVCUVMwaEF3d0NDeUFDSUFFNkFDd2dBa0VBTmdJQUlBWkJBV29oQVVFTUlRTU1BUXNnQWtFQU5nSUFJQVpCQVdvaEFVRUtJUU1NQUFzQUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBRTmdJUUlBSkJDVFlDREF3WEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZWtLTmdJUUlBSkJDVFlDREF3V0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYmNRTmdJUUlBSkJDVFlDREF3VkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWndSTmdJUUlBSkJDVFlDREF3VUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBRTmdJUUlBSkJDVFlDREF3VEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZWtLTmdJUUlBSkJDVFlDREF3U0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYmNRTmdJUUlBSkJDVFlDREF3UkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWndSTmdJUUlBSkJDVFlDREF3UUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWmNWTmdJUUlBSkJEellDREF3UEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWmNWTmdJUUlBSkJEellDREF3T0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY0FTTmdJUUlBSkJDellDREF3TkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWlVKTmdJUUlBSkJDellDREF3TUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZUVQTmdJUUlBSkJDallDREF3TEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZnNQTmdJUUlBSkJDallDREF3S0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZkVaTmdJUUlBSkJBallDREF3SkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY1FVTmdJUUlBSkJBallDREF3SUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZklWTmdJUUlBSkJBallDREF3SEN5QUNRUUkyQWh3Z0FpQUJOZ0lVSUFKQm5CbzJBaEFnQWtFV05nSU1RUUFoQXd3R0MwRUJJUU1NQlF0QjFBQWhBeUFCSUFSR0RRUWdDRUVJYWlFSklBSW9BZ0FoQlFKQUFrQWdBU0FFUndSQUlBVkIyTUlBYWlFSElBUWdCV29nQVdzaEFDQUZRWDl6UVFwcUlnVWdBV29oQmdOQUlBRXRBQUFnQnkwQUFFY0VRRUVDSVFjTUF3c2dCVVVFUUVFQUlRY2dCaUVCREFNTElBVkJBV3NoQlNBSFFRRnFJUWNnQkNBQlFRRnFJZ0ZIRFFBTElBQWhCU0FFSVFFTElBbEJBVFlDQUNBQ0lBVTJBZ0FNQVFzZ0FrRUFOZ0lBSUFrZ0J6WUNBQXNnQ1NBQk5nSUVJQWdvQWd3aEFDQUlLQUlJRGdNQkJBSUFDd0FMSUFKQkFEWUNIQ0FDUWJVYU5nSVFJQUpCRnpZQ0RDQUNJQUJCQVdvMkFoUkJBQ0VEREFJTElBSkJBRFlDSENBQ0lBQTJBaFFnQWtIS0dqWUNFQ0FDUVFrMkFneEJBQ0VEREFFTElBRWdCRVlFUUVFaUlRTU1BUXNnQWtFSk5nSUlJQUlnQVRZQ0JFRWhJUU1MSUFoQkVHb2tBQ0FEUlFSQUlBSW9BZ3doQUF3QkN5QUNJQU0yQWh4QkFDRUFJQUlvQWdRaUFVVU5BQ0FDSUFFZ0JDQUNLQUlJRVFFQUlnRkZEUUFnQWlBRU5nSVVJQUlnQVRZQ0RDQUJJUUFMSUFBTHZnSUJBbjhnQUVFQU9nQUFJQUJCM0FCcUlnRkJBV3RCQURvQUFDQUFRUUE2QUFJZ0FFRUFPZ0FCSUFGQkEydEJBRG9BQUNBQlFRSnJRUUE2QUFBZ0FFRUFPZ0FESUFGQkJHdEJBRG9BQUVFQUlBQnJRUU54SWdFZ0FHb2lBRUVBTmdJQVFkd0FJQUZyUVh4eElnSWdBR29pQVVFRWEwRUFOZ0lBQWtBZ0FrRUpTUTBBSUFCQkFEWUNDQ0FBUVFBMkFnUWdBVUVJYTBFQU5nSUFJQUZCREd0QkFEWUNBQ0FDUVJsSkRRQWdBRUVBTmdJWUlBQkJBRFlDRkNBQVFRQTJBaEFnQUVFQU5nSU1JQUZCRUd0QkFEWUNBQ0FCUVJSclFRQTJBZ0FnQVVFWWEwRUFOZ0lBSUFGQkhHdEJBRFlDQUNBQ0lBQkJCSEZCR0hJaUFtc2lBVUVnU1EwQUlBQWdBbW9oQUFOQUlBQkNBRGNER0NBQVFnQTNBeEFnQUVJQU53TUlJQUJDQURjREFDQUFRU0JxSVFBZ0FVRWdheUlCUVI5TERRQUxDd3RXQVFGL0FrQWdBQ2dDREEwQUFrQUNRQUpBQWtBZ0FDMEFMdzREQVFBREFnc2dBQ2dDT0NJQlJRMEFJQUVvQWl3aUFVVU5BQ0FBSUFFUkFBQWlBUTBEQzBFQUR3c0FDeUFBUWNNV05nSVFRUTRoQVFzZ0FRc2FBQ0FBS0FJTVJRUkFJQUJCMFJzMkFoQWdBRUVWTmdJTUN3c1VBQ0FBS0FJTVFSVkdCRUFnQUVFQU5nSU1Dd3NVQUNBQUtBSU1RUlpHQkVBZ0FFRUFOZ0lNQ3dzSEFDQUFLQUlNQ3djQUlBQW9BaEFMQ1FBZ0FDQUJOZ0lRQ3djQUlBQW9BaFFMRndBZ0FFRWtUd1JBQUFzZ0FFRUNkRUdnTTJvb0FnQUxGd0FnQUVFdVR3UkFBQXNnQUVFQ2RFR3dOR29vQWdBTHZ3a0JBWDlCNnlnaEFRSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCNUFCckR2UURZMklBQVdGaFlXRmhZUUlEQkFWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhCZ2NJQ1FvTERBME9EMkZoWVdGaEVHRmhZV0ZoWVdGaFlXRmhFV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZUklURkJVV0Z4Z1pHaHRoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoSEIwZUh5QWhJaU1rSlNZbktDa3FLeXd0TGk4d01USXpORFUyWVRjNE9UcGhZV0ZoWVdGaFlUdGhZV0U4WVdGaFlUMCtQMkZoWVdGaFlXRmhRR0ZoUVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UyRmhZV0ZoWVdGaFZGVldWMWhaV2x0aFhGMWhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZlWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWDJCaEMwSGhKdzhMUWFRaER3dEJ5eXdQQzBIK01ROExRY0FrRHd0QnF5UVBDMEdOS0E4TFFlSW1Ed3RCZ0RBUEMwRzVMdzhMUWRja0R3dEI3eDhQQzBIaEh3OExRZm9mRHd0QjhpQVBDMEdvTHc4TFFhNHlEd3RCaURBUEMwSHNKdzhMUVlJaUR3dEJqaDBQQzBIUUxnOExRY29qRHd0QnhUSVBDMEhmSEE4TFFkSWNEd3RCeENBUEMwSFhJQThMUWFJZkR3dEI3UzRQQzBHck1BOExRZFFsRHd0QnpDNFBDMEg2TGc4TFFmd3JEd3RCMGpBUEMwSHhIUThMUWJzZ0R3dEI5eXNQQzBHUU1ROExRZGN4RHd0Qm9pMFBDMEhVSnc4TFFlQXJEd3RCbnl3UEMwSHJNUThMUWRVZkR3dEJ5akVQQzBIZUpROExRZFFlRHd0QjlCd1BDMEduTWc4TFFiRWREd3RCb0IwUEMwRzVNUThMUWJ3d0R3dEJraUVQQzBHekpnOExRZWtzRHd0QnJCNFBDMEhVS3c4TFFmY21Ed3RCZ0NZUEMwR3dJUThMUWY0ZUR3dEJqU01QQzBHSkxROExRZmNpRHd0Qm9ERVBDMEd1SHc4TFFjWWxEd3RCNkI0UEMwR1RJZzhMUWNJdkR3dEJ3eDBQQzBHTExBOExRZUVkRHd0QmpTOFBDMEhxSVE4TFFiUXREd3RCMGk4UEMwSGZNZzhMUWRJeUR3dEI4REFQQzBHcElnOExRZmtqRHd0Qm1SNFBDMEcxTEE4TFFac3dEd3RCa2pJUEMwRzJLdzhMUWNJaUR3dEIrRElQQzBHZUpROExRZEFpRHd0QnVoNFBDMEdCSGc4TEFBdEIxaUVoQVFzZ0FRc1dBQ0FBSUFBdEFDMUIvZ0Z4SUFGQkFFZHlPZ0F0Q3hrQUlBQWdBQzBBTFVIOUFYRWdBVUVBUjBFQmRISTZBQzBMR1FBZ0FDQUFMUUF0UWZzQmNTQUJRUUJIUVFKMGNqb0FMUXNaQUNBQUlBQXRBQzFCOXdGeElBRkJBRWRCQTNSeU9nQXRDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDQkNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQnhoRTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDQ0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjlnbzJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRENJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjdSbzJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRUNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQmxSQTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRkNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQnFoczJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDR0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjdSTTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDS0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjlnZzJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDSENJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQndoazJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDSUNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQmxCUTJBaEJCR0NFRUN5QUVDMWtCQW44Q1FDQUFMUUFvUVFGR0RRQWdBQzhCTWlJQlFlUUFhMEhrQUVrTkFDQUJRY3dCUmcwQUlBRkJzQUpHRFFBZ0FDOEJNQ0lBUWNBQWNRMEFRUUVoQWlBQVFZZ0VjVUdBQkVZTkFDQUFRU2h4UlNFQ0N5QUNDNHdCQVFKL0FrQUNRQUpBSUFBdEFDcEZEUUFnQUMwQUswVU5BQ0FBTHdFd0lnRkJBbkZGRFFFTUFnc2dBQzhCTUNJQlFRRnhSUTBCQzBFQklRSWdBQzBBS0VFQlJnMEFJQUF2QVRJaUFFSGtBR3RCNUFCSkRRQWdBRUhNQVVZTkFDQUFRYkFDUmcwQUlBRkJ3QUJ4RFFCQkFDRUNJQUZCaUFSeFFZQUVSZzBBSUFGQktIRkJBRWNoQWdzZ0FndFhBQ0FBUVJocVFnQTNBd0FnQUVJQU53TUFJQUJCT0dwQ0FEY0RBQ0FBUVRCcVFnQTNBd0FnQUVFb2FrSUFOd01BSUFCQklHcENBRGNEQUNBQVFSQnFRZ0EzQXdBZ0FFRUlha0lBTndNQUlBQkIzUUUyQWh3TEJnQWdBQkF5QzVvdEFRdC9Jd0JCRUdzaUNpUUFRYVRRQUNnQ0FDSUpSUVJBUWVUVEFDZ0NBQ0lGUlFSQVFmRFRBRUovTndJQVFlalRBRUtBZ0lTQWdJREFBRGNDQUVIazB3QWdDa0VJYWtGd2NVSFlxdFdxQlhNaUJUWUNBRUg0MHdCQkFEWUNBRUhJMHdCQkFEWUNBQXRCek5NQVFZRFVCRFlDQUVHYzBBQkJnTlFFTmdJQVFiRFFBQ0FGTmdJQVFhelFBRUYvTmdJQVFkRFRBRUdBckFNMkFnQURRQ0FCUWNqUUFHb2dBVUc4MEFCcUlnSTJBZ0FnQWlBQlFiVFFBR29pQXpZQ0FDQUJRY0RRQUdvZ0F6WUNBQ0FCUWREUUFHb2dBVUhFMEFCcUlnTTJBZ0FnQXlBQ05nSUFJQUZCMk5BQWFpQUJRY3pRQUdvaUFqWUNBQ0FDSUFNMkFnQWdBVUhVMEFCcUlBSTJBZ0FnQVVFZ2FpSUJRWUFDUncwQUMwR00xQVJCd2FzRE5nSUFRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFRY0NyQXpZQ0FFR2swQUJCaU5RRU5nSUFRY3ovQjBFNE5nSUFRWWpVQkNFSkN3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjdBRk5CRUJCak5BQUtBSUFJZ1pCRUNBQVFSTnFRWEJ4SUFCQkMwa2JJZ1JCQTNZaUFIWWlBVUVEY1FSQUFrQWdBVUVCY1NBQWNrRUJjeUlDUVFOMElnQkJ0TkFBYWlJQklBQkJ2TkFBYWlnQ0FDSUFLQUlJSWdOR0JFQkJqTkFBSUFaQmZpQUNkM0UyQWdBTUFRc2dBU0FETmdJSUlBTWdBVFlDREFzZ0FFRUlhaUVCSUFBZ0FrRURkQ0lDUVFOeU5nSUVJQUFnQW1vaUFDQUFLQUlFUVFGeU5nSUVEQkVMUVpUUUFDZ0NBQ0lJSUFSUERRRWdBUVJBQWtCQkFpQUFkQ0lDUVFBZ0FtdHlJQUVnQUhSeGFDSUFRUU4wSWdKQnROQUFhaUlCSUFKQnZOQUFhaWdDQUNJQ0tBSUlJZ05HQkVCQmpOQUFJQVpCZmlBQWQzRWlCallDQUF3QkN5QUJJQU0yQWdnZ0F5QUJOZ0lNQ3lBQ0lBUkJBM0kyQWdRZ0FFRURkQ0lBSUFScklRVWdBQ0FDYWlBRk5nSUFJQUlnQkdvaUJDQUZRUUZ5TmdJRUlBZ0VRQ0FJUVhoeFFiVFFBR29oQUVHZzBBQW9BZ0FoQXdKL1FRRWdDRUVEZG5RaUFTQUdjVVVFUUVHTTBBQWdBU0FHY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQXpZQ0RDQUFJQU0yQWdnZ0F5QUFOZ0lNSUFNZ0FUWUNDQXNnQWtFSWFpRUJRYURRQUNBRU5nSUFRWlRRQUNBRk5nSUFEQkVMUVpEUUFDZ0NBQ0lMUlEwQklBdG9RUUowUWJ6U0FHb29BZ0FpQUNnQ0JFRjRjU0FFYXlFRklBQWhBZ05BQWtBZ0FpZ0NFQ0lCUlFSQUlBSkJGR29vQWdBaUFVVU5BUXNnQVNnQ0JFRjRjU0FFYXlJRElBVkpJUUlnQXlBRklBSWJJUVVnQVNBQUlBSWJJUUFnQVNFQ0RBRUxDeUFBS0FJWUlRa2dBQ2dDRENJRElBQkhCRUJCbk5BQUtBSUFHaUFESUFBb0FnZ2lBVFlDQ0NBQklBTTJBZ3dNRUFzZ0FFRVVhaUlDS0FJQUlnRkZCRUFnQUNnQ0VDSUJSUTBESUFCQkVHb2hBZ3NEUUNBQ0lRY2dBU0lEUVJScUlnSW9BZ0FpQVEwQUlBTkJFR29oQWlBREtBSVFJZ0VOQUFzZ0IwRUFOZ0lBREE4TFFYOGhCQ0FBUWI5L1N3MEFJQUJCRTJvaUFVRndjU0VFUVpEUUFDZ0NBQ0lJUlEwQVFRQWdCR3NoQlFKQUFrQUNRQUovUVFBZ0JFR0FBa2tOQUJwQkh5QUVRZi8vL3dkTERRQWFJQVJCSmlBQlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb0xJZ1pCQW5SQnZOSUFhaWdDQUNJQ1JRUkFRUUFoQVVFQUlRTU1BUXRCQUNFQklBUkJHU0FHUVFGMmEwRUFJQVpCSDBjYmRDRUFRUUFoQXdOQUFrQWdBaWdDQkVGNGNTQUVheUlISUFWUERRQWdBaUVESUFjaUJRMEFRUUFoQlNBQ0lRRU1Bd3NnQVNBQ1FSUnFLQUlBSWdjZ0J5QUNJQUJCSFhaQkJIRnFRUkJxS0FJQUlnSkdHeUFCSUFjYklRRWdBRUVCZENFQUlBSU5BQXNMSUFFZ0EzSkZCRUJCQUNFRFFRSWdCblFpQUVFQUlBQnJjaUFJY1NJQVJRMERJQUJvUVFKMFFielNBR29vQWdBaEFRc2dBVVVOQVFzRFFDQUJLQUlFUVhoeElBUnJJZ0lnQlVraEFDQUNJQVVnQUJzaEJTQUJJQU1nQUJzaEF5QUJLQUlRSWdBRWZ5QUFCU0FCUVJScUtBSUFDeUlCRFFBTEN5QURSUTBBSUFWQmxOQUFLQUlBSUFSclR3MEFJQU1vQWhnaEJ5QURJQU1vQWd3aUFFY0VRRUdjMEFBb0FnQWFJQUFnQXlnQ0NDSUJOZ0lJSUFFZ0FEWUNEQXdPQ3lBRFFSUnFJZ0lvQWdBaUFVVUVRQ0FES0FJUUlnRkZEUU1nQTBFUWFpRUNDd05BSUFJaEJpQUJJZ0JCRkdvaUFpZ0NBQ0lCRFFBZ0FFRVFhaUVDSUFBb0FoQWlBUTBBQ3lBR1FRQTJBZ0FNRFF0QmxOQUFLQUlBSWdNZ0JFOEVRRUdnMEFBb0FnQWhBUUpBSUFNZ0JHc2lBa0VRVHdSQUlBRWdCR29pQUNBQ1FRRnlOZ0lFSUFFZ0Eyb2dBallDQUNBQklBUkJBM0kyQWdRTUFRc2dBU0FEUVFOeU5nSUVJQUVnQTJvaUFDQUFLQUlFUVFGeU5nSUVRUUFoQUVFQUlRSUxRWlRRQUNBQ05nSUFRYURRQUNBQU5nSUFJQUZCQ0dvaEFRd1BDMEdZMEFBb0FnQWlBeUFFU3dSQUlBUWdDV29pQUNBRElBUnJJZ0ZCQVhJMkFnUkJwTkFBSUFBMkFnQkJtTkFBSUFFMkFnQWdDU0FFUVFOeU5nSUVJQWxCQ0dvaEFRd1BDMEVBSVFFZ0JBSi9RZVRUQUNnQ0FBUkFRZXpUQUNnQ0FBd0JDMEh3MHdCQ2Z6Y0NBRUhvMHdCQ2dJQ0VnSUNBd0FBM0FnQkI1Tk1BSUFwQkRHcEJjSEZCMktyVnFnVnpOZ0lBUWZqVEFFRUFOZ0lBUWNqVEFFRUFOZ0lBUVlDQUJBc2lBQ0FFUWNjQWFpSUZhaUlHUVFBZ0FHc2lCM0VpQWs4RVFFSDgwd0JCTURZQ0FBd1BDd0pBUWNUVEFDZ0NBQ0lCUlEwQVFielRBQ2dDQUNJSUlBSnFJUUFnQUNBQlRTQUFJQWhMY1EwQVFRQWhBVUg4MHdCQk1EWUNBQXdQQzBISTB3QXRBQUJCQkhFTkJBSkFBa0FnQ1FSQVFjelRBQ0VCQTBBZ0FTZ0NBQ0lBSUFsTkJFQWdBQ0FCS0FJRWFpQUpTdzBEQ3lBQktBSUlJZ0VOQUFzTFFRQVFNeUlBUVg5R0RRVWdBaUVHUWVqVEFDZ0NBQ0lCUVFGcklnTWdBSEVFUUNBQ0lBQnJJQUFnQTJwQkFDQUJhM0ZxSVFZTElBUWdCazhOQlNBR1FmNy8vLzhIU3cwRlFjVFRBQ2dDQUNJREJFQkJ2Tk1BS0FJQUlnY2dCbW9oQVNBQklBZE5EUVlnQVNBRFN3MEdDeUFHRURNaUFTQUFSdzBCREFjTElBWWdBMnNnQjNFaUJrSCsvLy8vQjBzTkJDQUdFRE1oQUNBQUlBRW9BZ0FnQVNnQ0JHcEdEUU1nQUNFQkN3SkFJQVlnQkVISUFHcFBEUUFnQVVGL1JnMEFRZXpUQUNnQ0FDSUFJQVVnQm10cVFRQWdBR3R4SWdCQi92Ly8vd2RMQkVBZ0FTRUFEQWNMSUFBUU0wRi9Sd1JBSUFBZ0Jtb2hCaUFCSVFBTUJ3dEJBQ0FHYXhBekdnd0VDeUFCSWdCQmYwY05CUXdEQzBFQUlRTU1EQXRCQUNFQURBb0xJQUJCZjBjTkFndEJ5Tk1BUWNqVEFDZ0NBRUVFY2pZQ0FBc2dBa0grLy8vL0Iwc05BU0FDRURNaEFFRUFFRE1oQVNBQVFYOUdEUUVnQVVGL1JnMEJJQUFnQVU4TkFTQUJJQUJySWdZZ0JFRTRhazBOQVF0QnZOTUFRYnpUQUNnQ0FDQUdhaUlCTmdJQVFjRFRBQ2dDQUNBQlNRUkFRY0RUQUNBQk5nSUFDd0pBQWtBQ1FFR2swQUFvQWdBaUFnUkFRY3pUQUNFQkEwQWdBQ0FCS0FJQUlnTWdBU2dDQkNJRmFrWU5BaUFCS0FJSUlnRU5BQXNNQWd0Qm5OQUFLQUlBSWdGQkFFY2dBQ0FCVDNGRkJFQkJuTkFBSUFBMkFnQUxRUUFoQVVIUTB3QWdCallDQUVITTB3QWdBRFlDQUVHczBBQkJmellDQUVHdzBBQkI1Tk1BS0FJQU5nSUFRZGpUQUVFQU5nSUFBMEFnQVVISTBBQnFJQUZCdk5BQWFpSUNOZ0lBSUFJZ0FVRzAwQUJxSWdNMkFnQWdBVUhBMEFCcUlBTTJBZ0FnQVVIUTBBQnFJQUZCeE5BQWFpSUROZ0lBSUFNZ0FqWUNBQ0FCUWRqUUFHb2dBVUhNMEFCcUlnSTJBZ0FnQWlBRE5nSUFJQUZCMU5BQWFpQUNOZ0lBSUFGQklHb2lBVUdBQWtjTkFBdEJlQ0FBYTBFUGNTSUJJQUJxSWdJZ0JrRTRheUlESUFGcklnRkJBWEkyQWdSQnFOQUFRZlRUQUNnQ0FEWUNBRUdZMEFBZ0FUWUNBRUdrMEFBZ0FqWUNBQ0FBSUFOcVFUZzJBZ1FNQWdzZ0FDQUNUUTBBSUFJZ0Ewa05BQ0FCS0FJTVFRaHhEUUJCZUNBQ2EwRVBjU0lBSUFKcUlnTkJtTkFBS0FJQUlBWnFJZ2NnQUdzaUFFRUJjallDQkNBQklBVWdCbW8yQWdSQnFOQUFRZlRUQUNnQ0FEWUNBRUdZMEFBZ0FEWUNBRUdrMEFBZ0F6WUNBQ0FDSUFkcVFUZzJBZ1FNQVFzZ0FFR2MwQUFvQWdCSkJFQkJuTkFBSUFBMkFnQUxJQUFnQm1vaEEwSE0wd0FoQVFKQUFrQUNRQU5BSUFNZ0FTZ0NBRWNFUUNBQktBSUlJZ0VOQVF3Q0N3c2dBUzBBREVFSWNVVU5BUXRCek5NQUlRRURRQ0FCS0FJQUlnTWdBazBFUUNBRElBRW9BZ1JxSWdVZ0Frc05Bd3NnQVNnQ0NDRUJEQUFMQUFzZ0FTQUFOZ0lBSUFFZ0FTZ0NCQ0FHYWpZQ0JDQUFRWGdnQUd0QkQzRnFJZ2tnQkVFRGNqWUNCQ0FEUVhnZ0EydEJEM0ZxSWdZZ0JDQUphaUlFYXlFQklBSWdCa1lFUUVHazBBQWdCRFlDQUVHWTBBQkJtTkFBS0FJQUlBRnFJZ0EyQWdBZ0JDQUFRUUZ5TmdJRURBZ0xRYURRQUNnQ0FDQUdSZ1JBUWFEUUFDQUVOZ0lBUVpUUUFFR1UwQUFvQWdBZ0FXb2lBRFlDQUNBRUlBQkJBWEkyQWdRZ0FDQUVhaUFBTmdJQURBZ0xJQVlvQWdRaUJVRURjVUVCUncwR0lBVkJlSEVoQ0NBRlFmOEJUUVJBSUFWQkEzWWhBeUFHS0FJSUlnQWdCaWdDRENJQ1JnUkFRWXpRQUVHTTBBQW9BZ0JCZmlBRGQzRTJBZ0FNQndzZ0FpQUFOZ0lJSUFBZ0FqWUNEQXdHQ3lBR0tBSVlJUWNnQmlBR0tBSU1JZ0JIQkVBZ0FDQUdLQUlJSWdJMkFnZ2dBaUFBTmdJTURBVUxJQVpCRkdvaUFpZ0NBQ0lGUlFSQUlBWW9BaEFpQlVVTkJDQUdRUkJxSVFJTEEwQWdBaUVESUFVaUFFRVVhaUlDS0FJQUlnVU5BQ0FBUVJCcUlRSWdBQ2dDRUNJRkRRQUxJQU5CQURZQ0FBd0VDMEY0SUFCclFROXhJZ0VnQUdvaUJ5QUdRVGhySWdNZ0FXc2lBVUVCY2pZQ0JDQUFJQU5xUVRnMkFnUWdBaUFGUVRjZ0JXdEJEM0ZxUVQ5cklnTWdBeUFDUVJCcVNSc2lBMEVqTmdJRVFhalFBRUgwMHdBb0FnQTJBZ0JCbU5BQUlBRTJBZ0JCcE5BQUlBYzJBZ0FnQTBFUWFrSFUwd0FwQWdBM0FnQWdBMEhNMHdBcEFnQTNBZ2hCMU5NQUlBTkJDR28yQWdCQjBOTUFJQVkyQWdCQnpOTUFJQUEyQWdCQjJOTUFRUUEyQWdBZ0EwRWthaUVCQTBBZ0FVRUhOZ0lBSUFVZ0FVRUVhaUlCU3cwQUN5QUNJQU5HRFFBZ0F5QURLQUlFUVg1eE5nSUVJQU1nQXlBQ2F5SUZOZ0lBSUFJZ0JVRUJjallDQkNBRlFmOEJUUVJBSUFWQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnRkJBU0FGUVFOMmRDSURjVVVFUUVHTTBBQWdBU0FEY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FpQUFOZ0lNSUFJZ0FUWUNDQXdCQzBFZklRRWdCVUgvLy84SFRRUkFJQVZCSmlBRlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBUXNnQWlBQk5nSWNJQUpDQURjQ0VDQUJRUUowUWJ6U0FHb2hBRUdRMEFBb0FnQWlBMEVCSUFGMElnWnhSUVJBSUFBZ0FqWUNBRUdRMEFBZ0F5QUdjallDQUNBQ0lBQTJBaGdnQWlBQ05nSUlJQUlnQWpZQ0RBd0JDeUFGUVJrZ0FVRUJkbXRCQUNBQlFSOUhHM1FoQVNBQUtBSUFJUU1DUUFOQUlBTWlBQ2dDQkVGNGNTQUZSZzBCSUFGQkhYWWhBeUFCUVFGMElRRWdBQ0FEUVFSeGFrRVFhaUlHS0FJQUlnTU5BQXNnQmlBQ05nSUFJQUlnQURZQ0dDQUNJQUkyQWd3Z0FpQUNOZ0lJREFFTElBQW9BZ2dpQVNBQ05nSU1JQUFnQWpZQ0NDQUNRUUEyQWhnZ0FpQUFOZ0lNSUFJZ0FUWUNDQXRCbU5BQUtBSUFJZ0VnQkUwTkFFR2swQUFvQWdBaUFDQUVhaUlDSUFFZ0JHc2lBVUVCY2pZQ0JFR1kwQUFnQVRZQ0FFR2swQUFnQWpZQ0FDQUFJQVJCQTNJMkFnUWdBRUVJYWlFQkRBZ0xRUUFoQVVIODB3QkJNRFlDQUF3SEMwRUFJUUFMSUFkRkRRQUNRQ0FHS0FJY0lnSkJBblJCdk5JQWFpSURLQUlBSUFaR0JFQWdBeUFBTmdJQUlBQU5BVUdRMEFCQmtOQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBZEJFRUVVSUFjb0FoQWdCa1liYWlBQU5nSUFJQUJGRFFFTElBQWdCellDR0NBR0tBSVFJZ0lFUUNBQUlBSTJBaEFnQWlBQU5nSVlDeUFHUVJScUtBSUFJZ0pGRFFBZ0FFRVVhaUFDTmdJQUlBSWdBRFlDR0FzZ0FTQUlhaUVCSUFZZ0NHb2lCaWdDQkNFRkN5QUdJQVZCZm5FMkFnUWdBU0FFYWlBQk5nSUFJQVFnQVVFQmNqWUNCQ0FCUWY4QlRRUkFJQUZCZUhGQnROQUFhaUVBQW45QmpOQUFLQUlBSWdKQkFTQUJRUU4yZENJQmNVVUVRRUdNMEFBZ0FTQUNjallDQUNBQURBRUxJQUFvQWdnTElnRWdCRFlDRENBQUlBUTJBZ2dnQkNBQU5nSU1JQVFnQVRZQ0NBd0JDMEVmSVFVZ0FVSC8vLzhIVFFSQUlBRkJKaUFCUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEJRc2dCQ0FGTmdJY0lBUkNBRGNDRUNBRlFRSjBRYnpTQUdvaEFFR1EwQUFvQWdBaUFrRUJJQVYwSWdOeFJRUkFJQUFnQkRZQ0FFR1EwQUFnQWlBRGNqWUNBQ0FFSUFBMkFoZ2dCQ0FFTmdJSUlBUWdCRFlDREF3QkN5QUJRUmtnQlVFQmRtdEJBQ0FGUVI5SEczUWhCU0FBS0FJQUlRQUNRQU5BSUFBaUFpZ0NCRUY0Y1NBQlJnMEJJQVZCSFhZaEFDQUZRUUYwSVFVZ0FpQUFRUVJ4YWtFUWFpSURLQUlBSWdBTkFBc2dBeUFFTmdJQUlBUWdBallDR0NBRUlBUTJBZ3dnQkNBRU5nSUlEQUVMSUFJb0FnZ2lBQ0FFTmdJTUlBSWdCRFlDQ0NBRVFRQTJBaGdnQkNBQ05nSU1JQVFnQURZQ0NBc2dDVUVJYWlFQkRBSUxBa0FnQjBVTkFBSkFJQU1vQWh3aUFVRUNkRUc4MGdCcUlnSW9BZ0FnQTBZRVFDQUNJQUEyQWdBZ0FBMEJRWkRRQUNBSVFYNGdBWGR4SWdnMkFnQU1BZ3NnQjBFUVFSUWdCeWdDRUNBRFJodHFJQUEyQWdBZ0FFVU5BUXNnQUNBSE5nSVlJQU1vQWhBaUFRUkFJQUFnQVRZQ0VDQUJJQUEyQWhnTElBTkJGR29vQWdBaUFVVU5BQ0FBUVJScUlBRTJBZ0FnQVNBQU5nSVlDd0pBSUFWQkQwMEVRQ0FESUFRZ0JXb2lBRUVEY2pZQ0JDQUFJQU5xSWdBZ0FDZ0NCRUVCY2pZQ0JBd0JDeUFESUFScUlnSWdCVUVCY2pZQ0JDQURJQVJCQTNJMkFnUWdBaUFGYWlBRk5nSUFJQVZCL3dGTkJFQWdCVUY0Y1VHMDBBQnFJUUFDZjBHTTBBQW9BZ0FpQVVFQklBVkJBM1owSWdWeFJRUkFRWXpRQUNBQklBVnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaUFTQUNOZ0lNSUFBZ0FqWUNDQ0FDSUFBMkFnd2dBaUFCTmdJSURBRUxRUjhoQVNBRlFmLy8vd2ROQkVBZ0JVRW1JQVZCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWlFQkN5QUNJQUUyQWh3Z0FrSUFOd0lRSUFGQkFuUkJ2TklBYWlFQVFRRWdBWFFpQkNBSWNVVUVRQ0FBSUFJMkFnQkJrTkFBSUFRZ0NISTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUFRc2dCVUVaSUFGQkFYWnJRUUFnQVVFZlJ4dDBJUUVnQUNnQ0FDRUVBa0FEUUNBRUlnQW9BZ1JCZUhFZ0JVWU5BU0FCUVIxMklRUWdBVUVCZENFQklBQWdCRUVFY1dwQkVHb2lCaWdDQUNJRURRQUxJQVlnQWpZQ0FDQUNJQUEyQWhnZ0FpQUNOZ0lNSUFJZ0FqWUNDQXdCQ3lBQUtBSUlJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FrRUFOZ0lZSUFJZ0FEWUNEQ0FDSUFFMkFnZ0xJQU5CQ0dvaEFRd0JDd0pBSUFsRkRRQUNRQ0FBS0FJY0lnRkJBblJCdk5JQWFpSUNLQUlBSUFCR0JFQWdBaUFETmdJQUlBTU5BVUdRMEFBZ0MwRitJQUYzY1RZQ0FBd0NDeUFKUVJCQkZDQUpLQUlRSUFCR0cyb2dBellDQUNBRFJRMEJDeUFESUFrMkFoZ2dBQ2dDRUNJQkJFQWdBeUFCTmdJUUlBRWdBellDR0FzZ0FFRVVhaWdDQUNJQlJRMEFJQU5CRkdvZ0FUWUNBQ0FCSUFNMkFoZ0xBa0FnQlVFUFRRUkFJQUFnQkNBRmFpSUJRUU55TmdJRUlBQWdBV29pQVNBQktBSUVRUUZ5TmdJRURBRUxJQUFnQkdvaUJ5QUZRUUZ5TmdJRUlBQWdCRUVEY2pZQ0JDQUZJQWRxSUFVMkFnQWdDQVJBSUFoQmVIRkJ0TkFBYWlFQlFhRFFBQ2dDQUNFREFuOUJBU0FJUVFOMmRDSUNJQVp4UlFSQVFZelFBQ0FDSUFaeU5nSUFJQUVNQVFzZ0FTZ0NDQXNpQWlBRE5nSU1JQUVnQXpZQ0NDQURJQUUyQWd3Z0F5QUNOZ0lJQzBHZzBBQWdCellDQUVHVTBBQWdCVFlDQUFzZ0FFRUlhaUVCQ3lBS1FSQnFKQUFnQVF0REFDQUFSUVJBUHdCQkVIUVBDd0pBSUFCQi8vOERjUTBBSUFCQkFFZ05BQ0FBUVJCMlFBQWlBRUYvUmdSQVFmelRBRUV3TmdJQVFYOFBDeUFBUVJCMER3c0FDd3ZjUHlJQVFZQUlDd2tCQUFBQUFnQUFBQU1BUVpRSUN3VUVBQUFBQlFCQnBBZ0xDUVlBQUFBSEFBQUFDQUJCM0FnTGlpMUpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEYxWlhKNUFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZlltOWtlUUJEYjI1MFpXNTBMVXhsYm1kMGFDQnZkbVZ5Wm14dmR3QkRhSFZ1YXlCemFYcGxJRzkyWlhKbWJHOTNBRkpsYzNCdmJuTmxJRzkyWlhKbWJHOTNBRWx1ZG1Gc2FXUWdiV1YwYUc5a0lHWnZjaUJJVkZSUUwzZ3VlQ0J5WlhGMVpYTjBBRWx1ZG1Gc2FXUWdiV1YwYUc5a0lHWnZjaUJTVkZOUUwzZ3VlQ0J5WlhGMVpYTjBBRVY0Y0dWamRHVmtJRk5QVlZKRFJTQnRaWFJvYjJRZ1ptOXlJRWxEUlM5NExuZ2djbVZ4ZFdWemRBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJR1p5WVdkdFpXNTBJSE4wWVhKMEFFVjRjR1ZqZEdWa0lHUnZkQUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM04wWVhSMWN3QkpiblpoYkdsa0lISmxjM0J2Ym5ObElITjBZWFIxY3dCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCbGVIUmxibk5wYjI1ekFGVnpaWElnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNKbGMyVjBZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZhR1ZoWkdWeVlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1Z6YzJGblpWOWlaV2RwYm1BZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5MllXeDFaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNOMFlYUjFjMTlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNabGNuTnBiMjVmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5MWNteGZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMmhsWVdSbGNsOTJZV3gxWlY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyMWxjM05oWjJWZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWFJvYjJSZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOW9aV0ZrWlhKZlptbGxiR1JmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmYm1GdFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVZXNWxlSEJsWTNSbFpDQmphR0Z5SUdsdUlIVnliQ0J6WlhKMlpYSUFTVzUyWVd4cFpDQm9aV0ZrWlhJZ2RtRnNkV1VnWTJoaGNnQkpiblpoYkdsa0lHaGxZV1JsY2lCbWFXVnNaQ0JqYUdGeUFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmRtVnljMmx2YmdCSmJuWmhiR2xrSUcxcGJtOXlJSFpsY25OcGIyNEFTVzUyWVd4cFpDQnRZV3B2Y2lCMlpYSnphVzl1QUVWNGNHVmpkR1ZrSUhOd1lXTmxJR0ZtZEdWeUlIWmxjbk5wYjI0QVJYaHdaV04wWldRZ1ExSk1SaUJoWm5SbGNpQjJaWEp6YVc5dUFFbHVkbUZzYVdRZ1NGUlVVQ0IyWlhKemFXOXVBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlIUnZhMlZ1QUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmZFhKc0FFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeWN5QnBiaUIxY213QVZXNWxlSEJsWTNSbFpDQnpkR0Z5ZENCamFHRnlJR2x1SUhWeWJBQkViM1ZpYkdVZ1FDQnBiaUIxY213QVJXMXdkSGtnUTI5dWRHVnVkQzFNWlc1bmRHZ0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnUTI5dWRHVnVkQzFNWlc1bmRHZ0FSSFZ3YkdsallYUmxJRU52Ym5SbGJuUXRUR1Z1WjNSb0FFbHVkbUZzYVdRZ1kyaGhjaUJwYmlCMWNtd2djR0YwYUFCRGIyNTBaVzUwTFV4bGJtZDBhQ0JqWVc0bmRDQmlaU0J3Y21WelpXNTBJSGRwZEdnZ1ZISmhibk5tWlhJdFJXNWpiMlJwYm1jQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ2MybDZaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMmhsWVdSbGNsOTJZV3gxWlFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDkyWVd4MVpRQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpJSFpoYkhWbEFFMXBjM05wYm1jZ1pYaHdaV04wWldRZ1RFWWdZV1owWlhJZ2FHVmhaR1Z5SUhaaGJIVmxBRWx1ZG1Gc2FXUWdZRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5ZQ0JvWldGa1pYSWdkbUZzZFdVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QnhkVzkwWlNCMllXeDFaUUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6SUhGMWIzUmxaQ0IyWVd4MVpRQlFZWFZ6WldRZ1lua2diMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUJKYm5aaGJHbGtJRVZQUmlCemRHRjBaUUJ2Ymw5eVpYTmxkQ0J3WVhWelpRQnZibDlqYUhWdWExOW9aV0ZrWlhJZ2NHRjFjMlVBYjI1ZmJXVnpjMkZuWlY5aVpXZHBiaUJ3WVhWelpRQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZkbUZzZFdVZ2NHRjFjMlVBYjI1ZmMzUmhkSFZ6WDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDNabGNuTnBiMjVmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmZFhKc1gyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyTm9kVzVyWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJobFlXUmxjbDkyWVd4MVpWOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOXRaWE56WVdkbFgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyMWxkR2h2WkY5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5b1pXRmtaWEpmWm1sbGJHUmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgyNWhiV1VnY0dGMWMyVUFWVzVsZUhCbFkzUmxaQ0J6Y0dGalpTQmhablJsY2lCemRHRnlkQ0JzYVc1bEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUJ1WVcxbEFGQmhkWE5sSUc5dUlFTlBUazVGUTFRdlZYQm5jbUZrWlFCUVlYVnpaU0J2YmlCUVVra3ZWWEJuY21Ga1pRQkZlSEJsWTNSbFpDQklWRlJRTHpJZ1EyOXVibVZqZEdsdmJpQlFjbVZtWVdObEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmJXVjBhRzlrQUVWNGNHVmpkR1ZrSUhOd1lXTmxJR0ZtZEdWeUlHMWxkR2h2WkFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJobFlXUmxjbDltYVdWc1pBQlFZWFZ6WldRQVNXNTJZV3hwWkNCM2IzSmtJR1Z1WTI5MWJuUmxjbVZrQUVsdWRtRnNhV1FnYldWMGFHOWtJR1Z1WTI5MWJuUmxjbVZrQUZWdVpYaHdaV04wWldRZ1kyaGhjaUJwYmlCMWNtd2djMk5vWlcxaEFGSmxjWFZsYzNRZ2FHRnpJR2x1ZG1Gc2FXUWdZRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5ZQUJUVjBsVVEwaGZVRkpQV0ZrQVZWTkZYMUJTVDFoWkFFMUxRVU5VU1ZaSlZGa0FWVTVRVWs5RFJWTlRRVUpNUlY5RlRsUkpWRmtBUTA5UVdRQk5UMVpGUkY5UVJWSk5RVTVGVGxSTVdRQlVUMDlmUlVGU1RGa0FUazlVU1VaWkFFWkJTVXhGUkY5RVJWQkZUa1JGVGtOWkFFSkJSRjlIUVZSRlYwRlpBRkJNUVZrQVVGVlVBRU5JUlVOTFQxVlVBRWRCVkVWWFFWbGZWRWxOUlU5VlZBQlNSVkZWUlZOVVgxUkpUVVZQVlZRQVRrVlVWMDlTUzE5RFQwNU9SVU5VWDFSSlRVVlBWVlFBUTA5T1RrVkRWRWxQVGw5VVNVMUZUMVZVQUV4UFIwbE9YMVJKVFVWUFZWUUFUa1ZVVjA5U1MxOVNSVUZFWDFSSlRVVlBWVlFBVUU5VFZBQk5TVk5FU1ZKRlExUkZSRjlTUlZGVlJWTlVBRU5NU1VWT1ZGOURURTlUUlVSZlVrVlJWVVZUVkFCRFRFbEZUbFJmUTB4UFUwVkVYMHhQUVVSZlFrRk1RVTVEUlVSZlVrVlJWVVZUVkFCQ1FVUmZVa1ZSVlVWVFZBQklWRlJRWDFKRlVWVkZVMVJmVTBWT1ZGOVVUMTlJVkZSUVUxOVFUMUpVQUZKRlVFOVNWQUJKVFY5QlgxUkZRVkJQVkFCU1JWTkZWRjlEVDA1VVJVNVVBRTVQWDBOUFRsUkZUbFFBVUVGU1ZFbEJURjlEVDA1VVJVNVVBRWhRUlY5SlRsWkJURWxFWDBOUFRsTlVRVTVVQUVoUVJWOURRbDlTUlZORlZBQkhSVlFBU0ZCRlgxTlVVa2xEVkFCRFQwNUdURWxEVkFCVVJVMVFUMUpCVWxsZlVrVkVTVkpGUTFRQVVFVlNUVUZPUlU1VVgxSkZSRWxTUlVOVUFFTlBUazVGUTFRQVRWVk1WRWxmVTFSQlZGVlRBRWhRUlY5SlRsWkJURWxFWDFOVVFWUlZVd0JVVDA5ZlRVRk9XVjlTUlZGVlJWTlVVd0JGUVZKTVdWOUlTVTVVVXdCVlRrRldRVWxNUVVKTVJWOUdUMUpmVEVWSFFVeGZVa1ZCVTA5T1V3QlBVRlJKVDA1VEFGTlhTVlJEU0VsT1IxOVFVazlVVDBOUFRGTUFWa0ZTU1VGT1ZGOUJURk5QWDA1RlIwOVVTVUZVUlZNQVRWVk1WRWxRVEVWZlEwaFBTVU5GVXdCSlRsUkZVazVCVEY5VFJWSldSVkpmUlZKU1QxSUFWMFZDWDFORlVsWkZVbDlWVGt0T1QxZE9YMFZTVWs5U0FGSkJTVXhIVlU1ZlJWSlNUMUlBU1VSRlRsUkpWRmxmVUZKUFZrbEVSVkpmUVZWVVNFVk9WRWxEUVZSSlQwNWZSVkpTVDFJQVUxTk1YME5GVWxSSlJrbERRVlJGWDBWU1VrOVNBRWxPVmtGTVNVUmZXRjlHVDFKWFFWSkVSVVJmUms5U0FGTkZWRjlRUVZKQlRVVlVSVklBUjBWVVgxQkJVa0ZOUlZSRlVnQklVRVZmVlZORlVnQlRSVVZmVDFSSVJWSUFTRkJGWDBOQ1gwTklWVTVMWDBoRlFVUkZVZ0JOUzBOQlRFVk9SRUZTQUZORlZGVlFBRmRGUWw5VFJWSldSVkpmU1ZOZlJFOVhUZ0JVUlVGU1JFOVhUZ0JJVUVWZlEweFBVMFZFWDBOUFRrNUZRMVJKVDA0QVNFVlZVa2xUVkVsRFgwVllVRWxTUVZSSlQwNEFSRWxUUTA5T1RrVkRWRVZFWDA5UVJWSkJWRWxQVGdCT1QwNWZRVlZVU0U5U1NWUkJWRWxXUlY5SlRrWlBVazFCVkVsUFRnQklVRVZmU1U1V1FVeEpSRjlXUlZKVFNVOU9BRWhRUlY5RFFsOU5SVk5UUVVkRlgwSkZSMGxPQUZOSlZFVmZTVk5mUmxKUFdrVk9BRWhRUlY5SlRsWkJURWxFWDBoRlFVUkZVbDlVVDB0RlRnQkpUbFpCVEVsRVgxUlBTMFZPQUVaUFVrSkpSRVJGVGdCRlRraEJUa05GWDFsUFZWSmZRMEZNVFFCSVVFVmZTVTVXUVV4SlJGOVZVa3dBUWt4UFEwdEZSRjlDV1Y5UVFWSkZUbFJCVEY5RFQwNVVVazlNQUUxTFEwOU1BRUZEVEFCSVVFVmZTVTVVUlZKT1FVd0FVa1ZSVlVWVFZGOUlSVUZFUlZKZlJrbEZURVJUWDFSUFQxOU1RVkpIUlY5VlRrOUdSa2xEU1VGTUFFaFFSVjlQU3dCVlRreEpUa3NBVlU1TVQwTkxBRkJTU1FCU1JWUlNXVjlYU1ZSSUFFaFFSVjlKVGxaQlRFbEVYME5QVGxSRlRsUmZURVZPUjFSSUFFaFFSVjlWVGtWWVVFVkRWRVZFWDBOUFRsUkZUbFJmVEVWT1IxUklBRVpNVlZOSUFGQlNUMUJRUVZSRFNBQk5MVk5GUVZKRFNBQlZVa2xmVkU5UFgweFBUa2NBVUZKUFEwVlRVMGxPUndCTlNWTkRSVXhNUVU1RlQxVlRYMUJGVWxOSlUxUkZUbFJmVjBGU1RrbE9Sd0JOU1ZORFJVeE1RVTVGVDFWVFgxZEJVazVKVGtjQVNGQkZYMGxPVmtGTVNVUmZWRkpCVGxOR1JWSmZSVTVEVDBSSlRrY0FSWGh3WldOMFpXUWdRMUpNUmdCSVVFVmZTVTVXUVV4SlJGOURTRlZPUzE5VFNWcEZBRTFQVmtVQVEwOU9WRWxPVlVVQVNGQkZYME5DWDFOVVFWUlZVMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZTRVZCUkVWU1UxOURUMDFRVEVWVVJRQklVRVZmUTBKZlZrVlNVMGxQVGw5RFQwMVFURVZVUlFCSVVFVmZRMEpmVlZKTVgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZTRVZCUkVWU1gxWkJURlZGWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlEU0ZWT1MxOUZXRlJGVGxOSlQwNWZWa0ZNVlVWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYMFZZVkVWT1UwbFBUbDlPUVUxRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5TlJWTlRRVWRGWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlOUlZSSVQwUmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwaEZRVVJGVWw5R1NVVk1SRjlEVDAxUVRFVlVSUUJFUlV4RlZFVUFTRkJGWDBsT1ZrRk1TVVJmUlU5R1gxTlVRVlJGQUVsT1ZrRk1TVVJmVTFOTVgwTkZVbFJKUmtsRFFWUkZBRkJCVlZORkFFNVBYMUpGVTFCUFRsTkZBRlZPVTFWUVVFOVNWRVZFWDAxRlJFbEJYMVJaVUVVQVIwOU9SUUJPVDFSZlFVTkRSVkJVUVVKTVJRQlRSVkpXU1VORlgxVk9RVlpCU1V4QlFreEZBRkpCVGtkRlgwNVBWRjlUUVZSSlUwWkpRVUpNUlFCUFVrbEhTVTVmU1ZOZlZVNVNSVUZEU0VGQ1RFVUFVa1ZUVUU5T1UwVmZTVk5mVTFSQlRFVUFVRlZTUjBVQVRVVlNSMFVBVWtWUlZVVlRWRjlJUlVGRVJWSmZSa2xGVEVSVFgxUlBUMTlNUVZKSFJRQlNSVkZWUlZOVVgwaEZRVVJGVWw5VVQwOWZURUZTUjBVQVVFRlpURTlCUkY5VVQwOWZURUZTUjBVQVNVNVRWVVpHU1VOSlJVNVVYMU5VVDFKQlIwVUFTRkJGWDFCQlZWTkZSRjlWVUVkU1FVUkZBRWhRUlY5UVFWVlRSVVJmU0RKZlZWQkhVa0ZFUlFCVFQxVlNRMFVBUVU1T1QxVk9RMFVBVkZKQlEwVUFTRkJGWDFWT1JWaFFSVU5VUlVSZlUxQkJRMFVBUkVWVFExSkpRa1VBVlU1VFZVSlRRMUpKUWtVQVVrVkRUMUpFQUVoUVJWOUpUbFpCVEVsRVgwMUZWRWhQUkFCT1QxUmZSazlWVGtRQVVGSlBVRVpKVGtRQVZVNUNTVTVFQUZKRlFrbE9SQUJWVGtGVlZFaFBVa2xhUlVRQVRVVlVTRTlFWDA1UFZGOUJURXhQVjBWRUFFaFVWRkJmVmtWU1UwbFBUbDlPVDFSZlUxVlFVRTlTVkVWRUFFRk1Va1ZCUkZsZlVrVlFUMUpVUlVRQVFVTkRSVkJVUlVRQVRrOVVYMGxOVUV4RlRVVk9WRVZFQUV4UFQxQmZSRVZVUlVOVVJVUUFTRkJGWDBOU1gwVllVRVZEVkVWRUFFaFFSVjlNUmw5RldGQkZRMVJGUkFCRFVrVkJWRVZFQUVsTlgxVlRSVVFBU0ZCRlgxQkJWVk5GUkFCVVNVMUZUMVZVWDA5RFExVlNSVVFBVUVGWlRVVk9WRjlTUlZGVlNWSkZSQUJRVWtWRFQwNUVTVlJKVDA1ZlVrVlJWVWxTUlVRQVVGSlBXRmxmUVZWVVNFVk9WRWxEUVZSSlQwNWZVa1ZSVlVsU1JVUUFUa1ZVVjA5U1MxOUJWVlJJUlU1VVNVTkJWRWxQVGw5U1JWRlZTVkpGUkFCTVJVNUhWRWhmVWtWUlZVbFNSVVFBVTFOTVgwTkZVbFJKUmtsRFFWUkZYMUpGVVZWSlVrVkVBRlZRUjFKQlJFVmZVa1ZSVlVsU1JVUUFVRUZIUlY5RldGQkpVa1ZFQUZCU1JVTlBUa1JKVkVsUFRsOUdRVWxNUlVRQVJWaFFSVU5VUVZSSlQwNWZSa0ZKVEVWRUFGSkZWa0ZNU1VSQlZFbFBUbDlHUVVsTVJVUUFVMU5NWDBoQlRrUlRTRUZMUlY5R1FVbE1SVVFBVEU5RFMwVkVBRlJTUVU1VFJrOVNUVUZVU1U5T1gwRlFVRXhKUlVRQVRrOVVYMDFQUkVsR1NVVkVBRTVQVkY5RldGUkZUa1JGUkFCQ1FVNUVWMGxFVkVoZlRFbE5TVlJmUlZoRFJVVkVSVVFBVTBsVVJWOUpVMTlQVmtWU1RFOUJSRVZFQUVoRlFVUUFSWGh3WldOMFpXUWdTRlJVVUM4QUFGNFRBQUFtRXdBQU1CQUFBUEFYQUFDZEV3QUFGUklBQURrWEFBRHdFZ0FBQ2hBQUFIVVNBQUN0RWdBQWdoTUFBRThVQUFCL0VBQUFvQlVBQUNNVUFBQ0pFZ0FBaXhRQUFFMFZBQURVRVFBQXp4UUFBQkFZQUFESkZnQUEzQllBQU1FUkFBRGdGd0FBdXhRQUFIUVVBQUI4RlFBQTVSUUFBQWdYQUFBZkVBQUFaUlVBQUtNVUFBQW9GUUFBQWhVQUFKa1ZBQUFzRUFBQWl4a0FBRThQQUFEVURnQUFhaEFBQU00UUFBQUNGd0FBaVE0QUFHNFRBQUFjRXdBQVpoUUFBRllYQUFEQkV3QUF6Uk1BQUd3VEFBQm9Gd0FBWmhjQUFGOFhBQUFpRXdBQXpnOEFBR2tPQUFEWURnQUFZeFlBQU1zVEFBQ3FEZ0FBS0JjQUFDWVhBQURGRXdBQVhSWUFBT2dSQUFCbkV3QUFaUk1BQVBJV0FBQnpFd0FBSFJjQUFQa1dBQUR6RVFBQXp3NEFBTTRWQUFBTUVnQUFzeEVBQUtVUkFBQmhFQUFBTWhjQUFMc1RBRUg1TlFzQkFRQkJrRFlMNEFFQkFRSUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFCQi9UY0xBUUVBUVpFNEMxNENBd0lDQWdJQ0FBQUNBZ0FDQWdBQ0FnSUNBZ0lDQWdJQ0FBUUFBQUFBQUFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFBZ0FDQUVIOU9Rc0JBUUJCa1RvTFhnSUFBZ0lDQWdJQUFBSUNBQUlDQUFJQ0FnSUNBZ0lDQWdJQUF3QUVBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQUFBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUNBQUlBUWZBN0N3MXNiM05sWldWd0xXRnNhWFpsQUVHSlBBc0JBUUJCb0R3TDRBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkJpVDRMQVFFQVFhQStDK2NCQVFFQkFRRUJBUUVCQVFFQkFnRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUZqYUhWdWEyVmtBRUd3d0FBTFh3RUJBQUVCQVFFQkFBQUJBUUFCQVFBQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUVHUXdnQUxJV1ZqZEdsdmJtVnVkQzFzWlc1bmRHaHZibkp2ZUhrdFkyOXVibVZqZEdsdmJnQkJ3TUlBQ3kxeVlXNXpabVZ5TFdWdVkyOWthVzVuY0dkeVlXUmxEUW9OQ2cwS1UwME5DZzBLVkZSUUwwTkZMMVJUVUM4QVFmbkNBQXNGQVFJQUFRTUFRWkREQUF2Z0FRUUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFFSDV4QUFMQlFFQ0FBRURBRUdReFFBTDRBRUVBUUVGQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkIrY1lBQ3dRQkFBQUJBRUdSeHdBTDN3RUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFFSDZ5QUFMQkFFQUFBSUFRWkRKQUF0ZkF3UUFBQVFFQkFRRUJBUUVCQVFFQlFRRUJBUUVCQVFFQkFRRUJBQUVBQVlIQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRQUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQVFBUWZyS0FBc0VBUUFBQVFCQmtNc0FDd0VCQUVHcXl3QUxRUUlBQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QUFBQUFBQUFNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQUVINnpBQUxCQUVBQUFFQVFaRE5BQXNCQVFCQm1zMEFDd1lDQUFBQUFBSUFRYkhOQUFzNkF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0JCOE00QUM1WUJUazlWVGtORlJVTkxUMVZVVGtWRFZFVlVSVU5TU1VKRlRGVlRTRVZVUlVGRVUwVkJVa05JVWtkRlExUkpWa2xVV1V4RlRrUkJVbFpGVDFSSlJsbFFWRWxQVGxORFNGTkZRVmxUVkVGVVEwaEhSVTlTUkVsU1JVTlVUMUpVVWtOSVVFRlNRVTFGVkVWU1ZWSkRSVUpUUTFKSlFrVkJVa1JQVjA1QlEwVkpUa1JPUzBOTFZVSlRRMUpKUWtWSVZGUlFMMEZFVkZBdicsICdiYXNlNjQnKVxuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZnJvbSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nmodule.exports = Buffer.from('AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==', 'base64');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLGdDQUFhO0FBRXhDQyxPQUFPQyxPQUFPLEdBQUdILE9BQU9JLElBQUksQ0FBQyxnMitEQUFnMitEIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGxsaHR0cFxcbGxodHRwX3NpbWQtd2FzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXIuZnJvbSgnQUdGemJRRUFBQUFCSndkZ0FYOEJmMkFEZjM5L0FYOWdBWDhBWUFKL2Z3QmdCSDkvZjM4QmYyQUFBR0FEZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBRUEyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUF5MHNCUVlBQUFJQUFBQUFBQUFDQVFJQUFnSUNBQUFEQUFBQUFBTURBd01CQVFFQkFRRUJBUUVBQUFJQUFBQUVCUUZ3QVJJU0JRTUJBQUlHQ0FGL0FVR0ExQVFMQjlFRklnWnRaVzF2Y25rQ0FBdGZhVzVwZEdsaGJHbDZaUUFJR1Y5ZmFXNWthWEpsWTNSZlpuVnVZM1JwYjI1ZmRHRmliR1VCQUF0c2JHaDBkSEJmYVc1cGRBQUpHR3hzYUhSMGNGOXphRzkxYkdSZmEyVmxjRjloYkdsMlpRQXZER3hzYUhSMGNGOWhiR3h2WXdBTEJtMWhiR3h2WXdBeEMyeHNhSFIwY0Y5bWNtVmxBQXdFWm5KbFpRQU1EMnhzYUhSMGNGOW5aWFJmZEhsd1pRQU5GV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRZV3B2Y2dBT0ZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dGFXNXZjZ0FQRVd4c2FIUjBjRjluWlhSZmJXVjBhRzlrQUJBV2JHeG9kSFJ3WDJkbGRGOXpkR0YwZFhOZlkyOWtaUUFSRW14c2FIUjBjRjluWlhSZmRYQm5jbUZrWlFBU0RHeHNhSFIwY0Y5eVpYTmxkQUFURG14c2FIUjBjRjlsZUdWamRYUmxBQlFVYkd4b2RIUndYM05sZEhScGJtZHpYMmx1YVhRQUZRMXNiR2gwZEhCZlptbHVhWE5vQUJZTWJHeG9kSFJ3WDNCaGRYTmxBQmNOYkd4b2RIUndYM0psYzNWdFpRQVlHMnhzYUhSMGNGOXlaWE4xYldWZllXWjBaWEpmZFhCbmNtRmtaUUFaRUd4c2FIUjBjRjluWlhSZlpYSnlibThBR2hkc2JHaDBkSEJmWjJWMFgyVnljbTl5WDNKbFlYTnZiZ0FiRjJ4c2FIUjBjRjl6WlhSZlpYSnliM0pmY21WaGMyOXVBQndVYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl3YjNNQUhSRnNiR2gwZEhCZlpYSnlibTlmYm1GdFpRQWVFbXhzYUhSMGNGOXRaWFJvYjJSZmJtRnRaUUFmRW14c2FIUjBjRjl6ZEdGMGRYTmZibUZ0WlFBZ0dteHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOW9aV0ZrWlhKekFDRWhiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMk5vZFc1clpXUmZiR1Z1WjNSb0FDSWRiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMnRsWlhCZllXeHBkbVVBSXlSc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmRISmhibk5tWlhKZlpXNWpiMlJwYm1jQUpCaHNiR2gwZEhCZmJXVnpjMkZuWlY5dVpXVmtjMTlsYjJZQUxna1hBUUJCQVFzUkFRSURCQVVLQmdjckxTd3FLU2dsSnlZSzc3TUNMQllBUVlqUUFDZ0NBQVJBQUF0QmlOQUFRUUUyQWdBTEZBQWdBQkF3SUFBZ0FqWUNPQ0FBSUFFNkFDZ0xGQUFnQUNBQUx3RXlJQUF0QUM0Z0FCQXZFQUFMSGdFQmYwSEFBQkF5SWdFUU1DQUJRWUFJTmdJNElBRWdBRG9BS0NBQkM0OE1BUWQvQWtBZ0FFVU5BQ0FBUVFocklnRWdBRUVFYXlnQ0FDSUFRWGh4SWdScUlRVUNRQ0FBUVFGeERRQWdBRUVEY1VVTkFTQUJJQUVvQWdBaUFHc2lBVUdjMEFBb0FnQkpEUUVnQUNBRWFpRUVBa0FDUUVHZzBBQW9BZ0FnQVVjRVFDQUFRZjhCVFFSQUlBQkJBM1loQXlBQktBSUlJZ0FnQVNnQ0RDSUNSZ1JBUVl6UUFFR00wQUFvQWdCQmZpQURkM0UyQWdBTUJRc2dBaUFBTmdJSUlBQWdBallDREF3RUN5QUJLQUlZSVFZZ0FTQUJLQUlNSWdCSEJFQWdBQ0FCS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQU1MSUFGQkZHb2lBeWdDQUNJQ1JRUkFJQUVvQWhBaUFrVU5BaUFCUVJCcUlRTUxBMEFnQXlFSElBSWlBRUVVYWlJREtBSUFJZ0lOQUNBQVFSQnFJUU1nQUNnQ0VDSUNEUUFMSUFkQkFEWUNBQXdDQ3lBRktBSUVJZ0JCQTNGQkEwY05BaUFGSUFCQmZuRTJBZ1JCbE5BQUlBUTJBZ0FnQlNBRU5nSUFJQUVnQkVFQmNqWUNCQXdEQzBFQUlRQUxJQVpGRFFBQ1FDQUJLQUljSWdKQkFuUkJ2TklBYWlJREtBSUFJQUZHQkVBZ0F5QUFOZ0lBSUFBTkFVR1EwQUJCa05BQUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0FVWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0JqWUNHQ0FCS0FJUUlnSUVRQ0FBSUFJMkFoQWdBaUFBTmdJWUN5QUJRUlJxS0FJQUlnSkZEUUFnQUVFVWFpQUNOZ0lBSUFJZ0FEWUNHQXNnQVNBRlR3MEFJQVVvQWdRaUFFRUJjVVVOQUFKQUFrQUNRQUpBSUFCQkFuRkZCRUJCcE5BQUtBSUFJQVZHQkVCQnBOQUFJQUUyQWdCQm1OQUFRWmpRQUNnQ0FDQUVhaUlBTmdJQUlBRWdBRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05Ca0dVMEFCQkFEWUNBRUdnMEFCQkFEWUNBQXdHQzBHZzBBQW9BZ0FnQlVZRVFFR2cwQUFnQVRZQ0FFR1UwQUJCbE5BQUtBSUFJQVJxSWdBMkFnQWdBU0FBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQXdHQ3lBQVFYaHhJQVJxSVFRZ0FFSC9BVTBFUUNBQVFRTjJJUU1nQlNnQ0NDSUFJQVVvQWd3aUFrWUVRRUdNMEFCQmpOQUFLQUlBUVg0Z0EzZHhOZ0lBREFVTElBSWdBRFlDQ0NBQUlBSTJBZ3dNQkFzZ0JTZ0NHQ0VHSUFVZ0JTZ0NEQ0lBUndSQVFaelFBQ2dDQUJvZ0FDQUZLQUlJSWdJMkFnZ2dBaUFBTmdJTURBTUxJQVZCRkdvaUF5Z0NBQ0lDUlFSQUlBVW9BaEFpQWtVTkFpQUZRUkJxSVFNTEEwQWdBeUVISUFJaUFFRVVhaUlES0FJQUlnSU5BQ0FBUVJCcUlRTWdBQ2dDRUNJQ0RRQUxJQWRCQURZQ0FBd0NDeUFGSUFCQmZuRTJBZ1FnQVNBRWFpQUVOZ0lBSUFFZ0JFRUJjallDQkF3REMwRUFJUUFMSUFaRkRRQUNRQ0FGS0FJY0lnSkJBblJCdk5JQWFpSURLQUlBSUFWR0JFQWdBeUFBTmdJQUlBQU5BVUdRMEFCQmtOQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQU5nSUFJQUJGRFFFTElBQWdCallDR0NBRktBSVFJZ0lFUUNBQUlBSTJBaEFnQWlBQU5nSVlDeUFGUVJScUtBSUFJZ0pGRFFBZ0FFRVVhaUFDTmdJQUlBSWdBRFlDR0FzZ0FTQUVhaUFFTmdJQUlBRWdCRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05BRUdVMEFBZ0JEWUNBQXdCQ3lBRVFmOEJUUVJBSUFSQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnSkJBU0FFUVFOMmRDSURjVVVFUUVHTTBBQWdBaUFEY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0lnQVRZQ0RDQUFJQUUyQWdnZ0FTQUFOZ0lNSUFFZ0FqWUNDQXdCQzBFZklRSWdCRUgvLy84SFRRUkFJQVJCSmlBRVFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBZ3NnQVNBQ05nSWNJQUZDQURjQ0VDQUNRUUowUWJ6U0FHb2hBQUpBUVpEUUFDZ0NBQ0lEUVFFZ0FuUWlCM0ZGQkVBZ0FDQUJOZ0lBUVpEUUFDQURJQWR5TmdJQUlBRWdBRFlDR0NBQklBRTJBZ2dnQVNBQk5nSU1EQUVMSUFSQkdTQUNRUUYyYTBFQUlBSkJIMGNiZENFQ0lBQW9BZ0FoQUFKQUEwQWdBQ0lES0FJRVFYaHhJQVJHRFFFZ0FrRWRkaUVBSUFKQkFYUWhBaUFESUFCQkJIRnFRUkJxSWdjb0FnQWlBQTBBQ3lBSElBRTJBZ0FnQVNBRE5nSVlJQUVnQVRZQ0RDQUJJQUUyQWdnTUFRc2dBeWdDQ0NJQUlBRTJBZ3dnQXlBQk5nSUlJQUZCQURZQ0dDQUJJQU0yQWd3Z0FTQUFOZ0lJQzBHczBBQkJyTkFBS0FJQVFRRnJJZ0JCZnlBQUd6WUNBQXNMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFFBRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJBd0lBQWdCRFlDT0NBQUlBTTZBQ2dnQUNBQ09nQXRJQUFnQVRZQ0dBdTc0Z0VDQjM4RGZpQUJJQUpxSVFRQ1FDQUFJZ0lvQWd3aUFBMEFJQUlvQWdRRVFDQUNJQUUyQWdRTEl3QkJFR3NpQ0NRQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBSW9BaHdpQTBFQmF3N2RBZG9CQWRrQkFnTUVCUVlIQ0FrS0N3d05EdGdCRHhEWEFSRVMxZ0VURkJVV0Z4Z1pHaHZnQWQ4QkhCMGUxUUVmSUNFaUl5UWwxQUVtSnlncEtpc3Mwd0hTQVMwdTBRSFFBUzh3TVRJek5EVTJOemc1T2pzOFBUNC9RRUZDUTBSRlJ0c0JSMGhKU3M4QnpnRkx6UUZNekFGTlRrOVFVVkpUVkZWV1YxaFpXbHRjWFY1ZllHRmlZMlJsWm1kb2FXcHJiRzF1YjNCeGNuTjBkWFozZUhsNmUzeDlmbitBQVlFQmdnR0RBWVFCaFFHR0FZY0JpQUdKQVlvQml3R01BWTBCamdHUEFaQUJrUUdTQVpNQmxBR1ZBWllCbHdHWUFaa0JtZ0diQVp3Qm5RR2VBWjhCb0FHaEFhSUJvd0drQWFVQnBnR25BYWdCcVFHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnl3SEtBYmdCeVFHNUFjZ0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnRUEzQUVMUVFBTXhnRUxRUTRNeFFFTFFRME14QUVMUVE4TXd3RUxRUkFNd2dFTFFSTU13UUVMUVJRTXdBRUxRUlVNdndFTFFSWU12Z0VMUVJnTXZRRUxRUmtNdkFFTFFSb011d0VMUVJzTXVnRUxRUndNdVFFTFFSME11QUVMUVFnTXR3RUxRUjRNdGdFTFFTQU10UUVMUVI4TXRBRUxRUWNNc3dFTFFTRU1zZ0VMUVNJTXNRRUxRU01Nc0FFTFFTUU1yd0VMUVJJTXJnRUxRUkVNclFFTFFTVU1yQUVMUVNZTXF3RUxRU2NNcWdFTFFTZ01xUUVMUWNNQkRLZ0JDMEVxREtjQkMwRXJES1lCQzBFc0RLVUJDMEV0REtRQkMwRXVES01CQzBFdkRLSUJDMEhFQVF5aEFRdEJNQXlnQVF0Qk5BeWZBUXRCREF5ZUFRdEJNUXlkQVF0Qk1neWNBUXRCTXd5YkFRdEJPUXlhQVF0Qk5ReVpBUXRCeFFFTW1BRUxRUXNNbHdFTFFUb01sZ0VMUVRZTWxRRUxRUW9NbEFFTFFUY01rd0VMUVRnTWtnRUxRVHdNa1FFTFFUc01rQUVMUVQwTWp3RUxRUWtNamdFTFFTa01qUUVMUVQ0TWpBRUxRVDhNaXdFTFFjQUFESW9CQzBIQkFBeUpBUXRCd2dBTWlBRUxRY01BREljQkMwSEVBQXlHQVF0QnhRQU1oUUVMUWNZQURJUUJDMEVYRElNQkMwSEhBQXlDQVF0QnlBQU1nUUVMUWNrQURJQUJDMEhLQUF4L0MwSExBQXgrQzBITkFBeDlDMEhNQUF4OEMwSE9BQXg3QzBIUEFBeDZDMEhRQUF4NUMwSFJBQXg0QzBIU0FBeDNDMEhUQUF4MkMwSFVBQXgxQzBIV0FBeDBDMEhWQUF4ekMwRUdESElMUWRjQURIRUxRUVVNY0F0QjJBQU1id3RCQkF4dUMwSFpBQXh0QzBIYUFBeHNDMEhiQUF4ckMwSGNBQXhxQzBFRERHa0xRZDBBREdnTFFkNEFER2NMUWQ4QURHWUxRZUVBREdVTFFlQUFER1FMUWVJQURHTUxRZU1BREdJTFFRSU1ZUXRCNUFBTVlBdEI1UUFNWHd0QjVnQU1YZ3RCNXdBTVhRdEI2QUFNWEF0QjZRQU1Xd3RCNmdBTVdndEI2d0FNV1F0QjdBQU1XQXRCN1FBTVZ3dEI3Z0FNVmd0Qjd3QU1WUXRCOEFBTVZBdEI4UUFNVXd0QjhnQU1VZ3RCOHdBTVVRdEI5QUFNVUF0QjlRQU1Ud3RCOWdBTVRndEI5d0FNVFF0QitBQU1UQXRCK1FBTVN3dEIrZ0FNU2d0Qit3QU1TUXRCL0FBTVNBdEIvUUFNUnd0Qi9nQU1SZ3RCL3dBTVJRdEJnQUVNUkF0QmdRRU1Rd3RCZ2dFTVFndEJnd0VNUVF0QmhBRU1RQXRCaFFFTVB3dEJoZ0VNUGd0Qmh3RU1QUXRCaUFFTVBBdEJpUUVNT3d0QmlnRU1PZ3RCaXdFTU9RdEJqQUVNT0F0QmpRRU1Od3RCamdFTU5ndEJqd0VNTlF0QmtBRU1OQXRCa1FFTU13dEJrZ0VNTWd0Qmt3RU1NUXRCbEFFTU1BdEJsUUVNTHd0QmxnRU1MZ3RCbHdFTUxRdEJtQUVNTEF0Qm1RRU1Ld3RCbWdFTUtndEJtd0VNS1F0Qm5BRU1LQXRCblFFTUp3dEJuZ0VNSmd0Qm53RU1KUXRCb0FFTUpBdEJvUUVNSXd0Qm9nRU1JZ3RCb3dFTUlRdEJwQUVNSUF0QnBRRU1Id3RCcGdFTUhndEJwd0VNSFF0QnFBRU1IQXRCcVFFTUd3dEJxZ0VNR2d0QnF3RU1HUXRCckFFTUdBdEJyUUVNRnd0QnJnRU1GZ3RCQVF3VkMwR3ZBUXdVQzBHd0FRd1RDMEd4QVF3U0MwR3pBUXdSQzBHeUFRd1FDMEcwQVF3UEMwRzFBUXdPQzBHMkFRd05DMEczQVF3TUMwRzRBUXdMQzBHNUFRd0tDMEc2QVF3SkMwRzdBUXdJQzBIR0FRd0hDMEc4QVF3R0MwRzlBUXdGQzBHK0FRd0VDMEcvQVF3REMwSEFBUXdDQzBIQ0FRd0JDMEhCQVFzaEF3TkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUlDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUovQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQWdKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUREc1lCQUFFQ0F3UUZCZ2NJQ1FvTERBME9EeEFSRWhNVUZSWVhHQmthR3h3ZEh5QWhJeVVtS0NvckxDOHdNVEl6TkRVMk56azZPenc5bEFOQVFrUkZSa2xMVGs5UVVWSlRWRlZXV0ZwYlhGMWVYMkJoWW1Oa1pXWm5hR3BzYjNCeGMzVjJlSGw2ZTN4L2dBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0JxZ0dyQWF3QnJRR3VBYThCc0FHeEFiSUJzd0cwQWJVQnRnRzNBYmdCdVFHNkFic0J2QUc5QWI0QnZ3SEFBY0VCd2dIREFjUUJ4UUhHQWNjQnlBSEpBY3NCekFITkFjNEJ6d0dLQTRrRGlBT0hBNFFEZ3dPQUEvc0MrZ0w1QXZnQzl3TDBBdk1DOGdMTEFzRUNzQUxaQVFzZ0FTQUVSdzN3QWtIZEFTRURETE1EQ3lBQklBUkhEY2dCUWNNQklRTU1zZ01MSUFFZ0JFY05lMEgzQUNFRERMRURDeUFCSUFSSERYQkI3d0FoQXd5d0F3c2dBU0FFUncxcFFlb0FJUU1NcndNTElBRWdCRWNOWlVIb0FDRURESzREQ3lBQklBUkhEV0pCNWdBaEF3eXRBd3NnQVNBRVJ3MGFRUmdoQXd5c0F3c2dBU0FFUncwVlFSSWhBd3lyQXdzZ0FTQUVSdzFDUWNVQUlRTU1xZ01MSUFFZ0JFY05ORUUvSVFNTXFRTUxJQUVnQkVjTk1rRThJUU1NcUFNTElBRWdCRWNOSzBFeElRTU1wd01MSUFJdEFDNUJBVVlObndNTXdRSUxRUUFoQUFKQUFrQUNRQ0FDTFFBcVJRMEFJQUl0QUN0RkRRQWdBaThCTUNJRFFRSnhSUTBCREFJTElBSXZBVEFpQTBFQmNVVU5BUXRCQVNFQUlBSXRBQ2hCQVVZTkFDQUNMd0V5SWdWQjVBQnJRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRFFjQUFjUTBBUVFBaEFDQURRWWdFY1VHQUJFWU5BQ0FEUVNoeFFRQkhJUUFMSUFKQkFEc0JNQ0FDUVFBNkFDOGdBRVVOM3dJZ0FrSUFOd01nRE9BQ0MwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NMQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNNQVNBQVFSVkhEZDBDSUFKQkJEWUNIQ0FDSUFFMkFoUWdBa0d3R0RZQ0VDQUNRUlUyQWd4QkFDRURES1FEQ3lBQklBUkdCRUJCQmlFRERLUURDeUFCUVFGcUlRRkJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BbFFpQTBVTkFDQUNJQU1SQUFBaEFBc2dBQTNaQWd3Y0N5QUNRZ0EzQXlCQkVpRURESWtEQ3lBQklBUkhEUlpCSFNFRERLRURDeUFCSUFSSEJFQWdBVUVCYWlFQlFSQWhBd3lJQXd0QkJ5RURES0FEQ3lBQ0lBSXBBeUFpQ2lBRUlBRnJyU0lMZlNJTVFnQWdDaUFNV2hzM0F5QWdDaUFMV0EzVUFrRUlJUU1NbndNTElBRWdCRWNFUUNBQ1FRazJBZ2dnQWlBQk5nSUVRUlFoQXd5R0F3dEJDU0VEREo0REN5QUNLUU1nUWdCU0RjY0JJQUlnQWk4Qk1FR0FBWEk3QVRBTVFnc2dBU0FFUncwL1FkQUFJUU1NbkFNTElBRWdCRVlFUUVFTElRTU1uQU1MSUFGQkFXb2hBVUVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVUNJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRGM4Q0RNWUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDU0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzR0FTQUFRUlZIRGMwQ0lBSkJDellDSENBQ0lBRTJBaFFnQWtHQ0dUWUNFQ0FDUVJVMkFneEJBQ0VEREpvREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NTQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTBNSUFCQkZVY055Z0lnQWtFYU5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1tUU1MUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKTUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRjUUJJQUJCRlVjTnh3SWdBa0VMTmdJY0lBSWdBVFlDRkNBQ1FaRVhOZ0lRSUFKQkZUWUNERUVBSVFNTW1BTUxJQUVnQkVZRVFFRVBJUU1NbUFNTElBRXRBQUFpQUVFN1JnMEhJQUJCRFVjTnhBSWdBVUVCYWlFQkRNTUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzREFTQUFRUlZIRGNJQ0lBSkJEellDSENBQ0lBRTJBaFFnQWtHUkZ6WUNFQ0FDUVJVMkFneEJBQ0VEREpZREN3TkFJQUV0QUFCQjhEVnFMUUFBSWdCQkFVY0VRQ0FBUVFKSERjRUNJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQlFRRnFJZ0VRTFNJQURjSUNETVVCQ3lBRUlBRkJBV29pQVVjTkFBdEJFaUVEREpVREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NUQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNGQVNBQVFSVkhEYjBDSUFKQkd6WUNIQ0FDSUFFMkFoUWdBa0dSRnpZQ0VDQUNRUlUyQWd4QkFDRURESlFEQ3lBQklBUkdCRUJCRmlFRERKUURDeUFDUVFvMkFnZ2dBaUFCTmdJRVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSklJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEY0lCSUFCQkZVY051UUlnQWtFVk5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1rd01MSUFFZ0JFY0VRQU5BSUFFdEFBQkI4RGRxTFFBQUlnQkJBa2NFUUFKQUlBQkJBV3NPQk1RQ3ZRSUF2Z0s5QWdzZ0FVRUJhaUVCUVFnaEF3ejhBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFSVWhBd3lUQXd0QkZTRURESklEQ3dOQUlBRXRBQUJCOERscUxRQUFJZ0JCQWtjRVFDQUFRUUZyRGdURkFyY0N3d0s0QXJjQ0N5QUVJQUZCQVdvaUFVY05BQXRCR0NFRERKRURDeUFCSUFSSEJFQWdBa0VMTmdJSUlBSWdBVFlDQkVFSElRTU0rQUlMUVJraEF3eVFBd3NnQVVFQmFpRUJEQUlMSUFFZ0JFWUVRRUVhSVFNTWp3TUxBa0FnQVMwQUFFRU5hdzRVdFFHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndFQXZ3RUxRUUFoQXlBQ1FRQTJBaHdnQWtHdkN6WUNFQ0FDUVFJMkFnd2dBaUFCUVFGcU5nSVVESTREQ3lBQklBUkdCRUJCR3lFRERJNERDeUFCTFFBQUlnQkJPMGNFUUNBQVFRMUhEYkVDSUFGQkFXb2hBUXk2QVFzZ0FVRUJhaUVCQzBFaUlRTU04d0lMSUFFZ0JFWUVRRUVjSVFNTWpBTUxRZ0FoQ2dKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVFd2F3NDN3UUxBQWdBQkFnTUVCUVlIMEFIUUFkQUIwQUhRQWRBQjBBRUlDUW9MREEzUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCRGc4UUVSSVQwQUVMUWdJaENnekFBZ3RDQXlFS0RMOENDMElFSVFvTXZnSUxRZ1VoQ2d5OUFndENCaUVLREx3Q0MwSUhJUW9NdXdJTFFnZ2hDZ3k2QWd0Q0NTRUtETGtDQzBJS0lRb011QUlMUWdzaENneTNBZ3RDRENFS0RMWUNDMElOSVFvTXRRSUxRZzRoQ2d5MEFndENEeUVLRExNQ0MwSUtJUW9Nc2dJTFFnc2hDZ3l4QWd0Q0RDRUtETEFDQzBJTklRb01yd0lMUWc0aENneXVBZ3RDRHlFS0RLMENDMElBSVFvQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQk1Hc09OOEFDdndJQUFRSURCQVVHQjc0Q3ZnSytBcjRDdmdLK0FyNENDQWtLQ3d3TnZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQWc0UEVCRVNFNzRDQzBJQ0lRb012d0lMUWdNaENneStBZ3RDQkNFS0RMMENDMElGSVFvTXZBSUxRZ1loQ2d5N0FndENCeUVLRExvQ0MwSUlJUW9NdVFJTFFna2hDZ3k0QWd0Q0NpRUtETGNDQzBJTElRb010Z0lMUWd3aENneTFBZ3RDRFNFS0RMUUNDMElPSVFvTXN3SUxRZzhoQ2d5eUFndENDaUVLRExFQ0MwSUxJUW9Nc0FJTFFnd2hDZ3l2QWd0Q0RTRUtESzRDQzBJT0lRb01yUUlMUWc4aENneXNBZ3NnQWlBQ0tRTWdJZ29nQkNBQmE2MGlDMzBpREVJQUlBb2dERm9iTndNZ0lBb2dDMWdOcHdKQkh5RURESWtEQ3lBQklBUkhCRUFnQWtFSk5nSUlJQUlnQVRZQ0JFRWxJUU1NOEFJTFFTQWhBd3lJQXd0QkFTRUZJQUl2QVRBaUEwRUljVVVFUUNBQ0tRTWdRZ0JTSVFVTEFrQWdBaTBBTGdSQVFRRWhBQ0FDTFFBcFFRVkdEUUVnQTBIQUFIRkZJQVZ4UlEwQkMwRUFJUUFnQTBIQUFIRU5BRUVDSVFBZ0EwRUljUTBBSUFOQmdBUnhCRUFDUUNBQ0xRQW9RUUZIRFFBZ0FpMEFMVUVLY1EwQVFRVWhBQXdDQzBFRUlRQU1BUXNnQTBFZ2NVVUVRQUpBSUFJdEFDaEJBVVlOQUNBQ0x3RXlJZ0JCNUFCclFlUUFTUTBBSUFCQnpBRkdEUUFnQUVHd0FrWU5BRUVFSVFBZ0EwRW9jVVVOQWlBRFFZZ0VjVUdBQkVZTkFndEJBQ0VBREFFTFFRQkJBeUFDS1FNZ1VCc2hBQXNnQUVFQmF3NEZ2Z0lBc0FFQnBBS2hBZ3RCRVNFRERPMENDeUFDUVFFNkFDOE1oQU1MSUFFZ0JFY05uUUpCSkNFRERJUURDeUFCSUFSSERSeEJ4Z0FoQXd5REF3dEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9Ba1FpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOSnlBQVFSVkhEWmdDSUFKQjBBQTJBaHdnQWlBQk5nSVVJQUpCa1JnMkFoQWdBa0VWTmdJTVFRQWhBd3lDQXdzZ0FTQUVSZ1JBUVNnaEF3eUNBd3RCQUNFRElBSkJBRFlDQkNBQ1FRdzJBZ2dnQWlBQklBRVFLaUlBUlEyVUFpQUNRU2MyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNEQXlCQXdzZ0FTQUVSZ1JBUVNraEF3eUJBd3NnQVMwQUFDSUFRU0JHRFJNZ0FFRUpSdzJWQWlBQlFRRnFJUUVNRkFzZ0FTQUVSd1JBSUFGQkFXb2hBUXdXQzBFcUlRTU0vd0lMSUFFZ0JFWUVRRUVySVFNTS93SUxJQUV0QUFBaUFFRUpSeUFBUVNCSGNRMlFBaUFDTFFBc1FRaEhEZDBDSUFKQkFEb0FMQXpkQWdzZ0FTQUVSZ1JBUVN3aEF3eitBZ3NnQVMwQUFFRUtSdzJPQWlBQlFRRnFJUUVNc0FFTElBRWdCRWNOaWdKQkx5RUREUHdDQ3dOQUlBRXRBQUFpQUVFZ1J3UkFJQUJCQ21zT0JJUUNpQUtJQW9RQ2hnSUxJQVFnQVVFQmFpSUJSdzBBQzBFeElRTU0rd0lMUVRJaEF5QUJJQVJHRGZvQ0lBSW9BZ0FpQUNBRUlBRnJhaUVISUFFZ0FHdEJBMm9oQmdKQUEwQWdBRUh3TzJvdEFBQWdBUzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFFZ0FFRURSZ1JBUVFZaEFRemlBZ3NnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBYzJBZ0FNK3dJTElBSkJBRFlDQUF5R0FndEJNeUVESUFRZ0FTSUFSZzM1QWlBRUlBRnJJQUlvQWdBaUFXb2hCeUFBSUFGclFRaHFJUVlDUUFOQUlBRkI5RHRxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkNFWUVRRUVGSVFFTTRRSUxJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFEUG9DQ3lBQ1FRQTJBZ0FnQUNFQkRJVUNDMEUwSVFNZ0JDQUJJZ0JHRGZnQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdKQUEwQWdBVUhRd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwQklBRkJCVVlFUUVFSElRRU00QUlMSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRFBrQ0N5QUNRUUEyQWdBZ0FDRUJESVFDQ3lBQklBUkhCRUFEUUNBQkxRQUFRWUErYWkwQUFDSUFRUUZIQkVBZ0FFRUNSZzBKRElFQ0N5QUVJQUZCQVdvaUFVY05BQXRCTUNFRERQZ0NDMEV3SVFNTTl3SUxJQUVnQkVjRVFBTkFJQUV0QUFBaUFFRWdSd1JBSUFCQkNtc09CUDhCL2dIK0FmOEIvZ0VMSUFRZ0FVRUJhaUlCUncwQUMwRTRJUU1NOXdJTFFUZ2hBd3oyQWdzRFFDQUJMUUFBSWdCQklFY2dBRUVKUjNFTjlnRWdCQ0FCUVFGcUlnRkhEUUFMUVR3aEF3ejFBZ3NEUUNBQkxRQUFJZ0JCSUVjRVFBSkFJQUJCQ21zT0JQa0JCQVQ1QVFBTElBQkJMRVlOOVFFTUF3c2dCQ0FCUVFGcUlnRkhEUUFMUVQ4aEF3ejBBZ3RCd0FBaEF5QUJJQVJHRGZNQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCbW9oQmdKQUEwQWdBRUdBUUdzdEFBQWdBUzBBQUVFZ2NrY05BU0FBUVFaR0Rkc0NJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUFFDQ3lBQ1FRQTJBZ0FMUVRZaEF3elpBZ3NnQVNBRVJnUkFRY0VBSVFNTThnSUxJQUpCRERZQ0NDQUNJQUUyQWdRZ0FpMEFMRUVCYXc0RSt3SHVBZXdCNndIVUFnc2dBVUVCYWlFQkRQb0JDeUFCSUFSSEJFQURRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeElnQkJDVVlOQUNBQVFTQkdEUUFDUUFKQUFrQUNRQ0FBUWVNQWF3NFRBQU1EQXdNREF3TUJBd01EQXdNREF3TURBZ01MSUFGQkFXb2hBVUV4SVFNTTNBSUxJQUZCQVdvaEFVRXlJUU1NMndJTElBRkJBV29oQVVFeklRTU0yZ0lMRFA0QkN5QUVJQUZCQVdvaUFVY05BQXRCTlNFRERQQUNDMEUxSVFNTTd3SUxJQUVnQkVjRVFBTkFJQUV0QUFCQmdEeHFMUUFBUVFGSERmY0JJQVFnQVVFQmFpSUJSdzBBQzBFOUlRTU03d0lMUVQwaEF3enVBZ3RCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWtBaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTkFTQUFRUlZIRGVZQklBSkJ3Z0EyQWh3Z0FpQUJOZ0lVSUFKQjR4ZzJBaEFnQWtFVk5nSU1RUUFoQXd6dEFnc2dBVUVCYWlFQkMwRThJUU1NMGdJTElBRWdCRVlFUUVIQ0FDRURET3NDQ3dKQUEwQUNRQ0FCTFFBQVFRbHJEaGdBQXN3Q3pBTFJBc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1BZ0RNQWdzZ0JDQUJRUUZxSWdGSERRQUxRY0lBSVFNTTZ3SUxJQUZCQVdvaEFTQUNMUUF0UVFGeFJRMytBUXRCTENFREROQUNDeUFCSUFSSERkNEJRY1FBSVFNTTZBSUxBMEFnQVMwQUFFR1F3QUJxTFFBQVFRRkhEWndCSUFRZ0FVRUJhaUlCUncwQUMwSEZBQ0VERE9jQ0N5QUJMUUFBSWdCQklFWU4vZ0VnQUVFNlJ3M0FBaUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXBJZ0FOM2dFTTNRRUxRY2NBSVFNZ0JDQUJJZ0JHRGVVQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdOQUlBRkJrTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdndJZ0FVRUZSZzNDQWlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBSWdCellDQUF6bEFndEJ5QUFoQXlBRUlBRWlBRVlONUFJZ0JDQUJheUFDS0FJQUlnRnFJUWNnQUNBQmEwRUphaUVHQTBBZ0FVR1d3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzIrQWtFQ0lBRkJDVVlOd2dJYUlBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPUUNDeUFCSUFSR0JFQkJ5UUFoQXd6a0Fnc0NRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFFlNEFhdzRIQUw4Q3Z3Sy9BcjhDdndJQnZ3SUxJQUZCQVdvaEFVRStJUU1NeXdJTElBRkJBV29oQVVFL0lRTU15Z0lMUWNvQUlRTWdCQ0FCSWdCR0RlSUNJQVFnQVdzZ0FpZ0NBQ0lCYWlFR0lBQWdBV3RCQVdvaEJ3TkFJQUZCb01JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnZBSWdBVUVCUmcyK0FpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQUlnQmpZQ0FBemlBZ3RCeXdBaEF5QUVJQUVpQUVZTjRRSWdCQ0FCYXlBQ0tBSUFJZ0ZxSVFjZ0FDQUJhMEVPYWlFR0EwQWdBVUdpd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncyN0FpQUJRUTVHRGI0Q0lBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPRUNDMEhNQUNFRElBUWdBU0lBUmczZ0FpQUVJQUZySUFJb0FnQWlBV29oQnlBQUlBRnJRUTlxSVFZRFFDQUJRY0RDQUdvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRGJvQ1FRTWdBVUVQUmcyK0Fob2dBVUVCYWlFQklBUWdBRUVCYWlJQVJ3MEFDeUFDSUFjMkFnQU00QUlMUWMwQUlRTWdCQ0FCSWdCR0RkOENJQVFnQVdzZ0FpZ0NBQ0lCYWlFSElBQWdBV3RCQldvaEJnTkFJQUZCME1JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnVRSkJCQ0FCUVFWR0RiMENHaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFJZ0J6WUNBQXpmQWdzZ0FTQUVSZ1JBUWM0QUlRTU0zd0lMQWtBQ1FBSkFBa0FnQVMwQUFDSUFRU0J5SUFBZ0FFSEJBR3RCL3dGeFFScEpHMEgvQVhGQjR3QnJEaE1BdkFLOEFyd0N2QUs4QXJ3Q3ZBSzhBcndDdkFLOEFyd0NBYndDdkFLOEFnSUR2QUlMSUFGQkFXb2hBVUhCQUNFRERNZ0NDeUFCUVFGcUlRRkJ3Z0FoQXd6SEFnc2dBVUVCYWlFQlFjTUFJUU1NeGdJTElBRkJBV29oQVVIRUFDRURETVVDQ3lBQklBUkhCRUFnQWtFTk5nSUlJQUlnQVRZQ0JFSEZBQ0VERE1VQ0MwSFBBQ0VERE4wQ0N3SkFBa0FnQVMwQUFFRUthdzRFQVpBQmtBRUFrQUVMSUFGQkFXb2hBUXRCS0NFRERNTUNDeUFCSUFSR0JFQkIwUUFoQXd6Y0Fnc2dBUzBBQUVFZ1J3MEFJQUZCQVdvaEFTQUNMUUF0UVFGeFJRM1FBUXRCRnlFRERNRUNDeUFCSUFSSERjc0JRZElBSVFNTTJRSUxRZE1BSVFNZ0FTQUVSZzNZQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCaUFCSUFCclFRRnFJUVVEUUNBQkxRQUFJQUJCMXNJQWFpMEFBRWNOeHdFZ0FFRUJSZzNLQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCallDQUF6WUFnc2dBU0FFUmdSQVFkVUFJUU1NMkFJTElBRXRBQUJCQ2tjTndnRWdBVUVCYWlFQkRNb0JDeUFCSUFSR0JFQkIxZ0FoQXd6WEFnc0NRQUpBSUFFdEFBQkJDbXNPQkFEREFjTUJBY01CQ3lBQlFRRnFJUUVNeWdFTElBRkJBV29oQVVIS0FDRURETDBDQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1BDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURiOEJRYzBBSVFNTXZBSUxJQUl0QUNsQklrWU56d0lNaVFFTElBUWdBU0lGUmdSQVFkc0FJUU1NMUFJTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBRkxRQUFRVEJyRGdyRkFjUUJBQUVDQXdRRkJnakRBUXRCQWd3R0MwRUREQVVMUVFRTUJBdEJCUXdEQzBFR0RBSUxRUWNNQVF0QkNBc2hBMEVBSVFGQkFDRUdETDBCQzBFSklRTkJBU0VBUVFBaEFVRUFJUVlNdkFFTElBRWdCRVlFUUVIZEFDRURETk1DQ3lBQkxRQUFRUzVIRGJnQklBRkJBV29oQVF5SUFRc2dBU0FFUncyMkFVSGZBQ0VERE5FQ0N5QUJJQVJIQkVBZ0FrRU9OZ0lJSUFJZ0FUWUNCRUhRQUNFRERMZ0NDMEhnQUNFREROQUNDMEhoQUNFRElBRWdCRVlOendJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQTBBZ0FTMEFBQ0FBUWVMQ0FHb3RBQUJIRGJFQklBQkJBMFlOc3dFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXp3SUxRZUlBSVFNZ0FTQUVSZzNPQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlEUUNBQkxRQUFJQUJCNXNJQWFpMEFBRWNOc0FFZ0FFRUNSZzJ2QVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6T0FndEI0d0FoQXlBQklBUkdEYzBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ05BSUFFdEFBQWdBRUhwd2dCcUxRQUFSdzJ2QVNBQVFRTkdEYTBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRE0wQ0N5QUJJQVJHQkVCQjVRQWhBd3pOQWdzZ0FVRUJhaUVCUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FJd0lnTkZEUUFnQWlBREVRQUFJUUFMSUFBTnFnRkIxZ0FoQXd5ekFnc2dBU0FFUndSQUEwQWdBUzBBQUNJQVFTQkhCRUFDUUFKQUFrQWdBRUhJQUdzT0N3QUJzd0d6QWJNQnN3R3pBYk1Cc3dHekFRS3pBUXNnQVVFQmFpRUJRZElBSVFNTXR3SUxJQUZCQVdvaEFVSFRBQ0VERExZQ0N5QUJRUUZxSVFGQjFBQWhBd3kxQWdzZ0JDQUJRUUZxSWdGSERRQUxRZVFBSVFNTXpBSUxRZVFBSVFNTXl3SUxBMEFnQVMwQUFFSHd3Z0JxTFFBQUlnQkJBVWNFUUNBQVFRSnJEZ09uQWFZQnBRR2tBUXNnQkNBQlFRRnFJZ0ZIRFFBTFFlWUFJUU1NeWdJTElBRkJBV29nQVNBRVJ3MENHa0huQUNFRERNa0NDd05BSUFFdEFBQkI4TVFBYWkwQUFDSUFRUUZIQkVBQ1FDQUFRUUpyRGdTaUFhRUJvQUVBbndFTFFkY0FJUU1Nc1FJTElBUWdBVUVCYWlJQlJ3MEFDMEhvQUNFRERNZ0NDeUFCSUFSR0JFQkI2UUFoQXd6SUFnc0NRQ0FCTFFBQUlnQkJDbXNPR3JjQm13R2JBYlFCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCcEFHYkFac0JBSmtCQ3lBQlFRRnFDeUVCUVFZaEF3eXRBZ3NEUUNBQkxRQUFRZkRHQUdvdEFBQkJBVWNOZlNBRUlBRkJBV29pQVVjTkFBdEI2Z0FoQXd6RkFnc2dBVUVCYWlBQklBUkhEUUlhUWVzQUlRTU14QUlMSUFFZ0JFWUVRRUhzQUNFRERNUUNDeUFCUVFGcURBRUxJQUVnQkVZRVFFSHRBQ0VERE1NQ0N5QUJRUUZxQ3lFQlFRUWhBd3lvQWdzZ0FTQUVSZ1JBUWU0QUlRTU13UUlMQWtBQ1FBSkFJQUV0QUFCQjhNZ0FhaTBBQUVFQmF3NEhrQUdQQVk0QkFId0JBbzBCQ3lBQlFRRnFJUUVNQ3dzZ0FVRUJhZ3lUQVF0QkFDRURJQUpCQURZQ0hDQUNRWnNTTmdJUUlBSkJCellDRENBQ0lBRkJBV28yQWhRTXdBSUxBa0FEUUNBQkxRQUFRZkRJQUdvdEFBQWlBRUVFUndSQUFrQUNRQ0FBUVFGckRnZVVBWk1Ca2dHTkFRQUVBWTBCQzBIYUFDRURES29DQ3lBQlFRRnFJUUZCM0FBaEF3eXBBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFlOEFJUU1Nd0FJTElBRkJBV29Na1FFTElBUWdBU0lBUmdSQVFmQUFJUU1NdndJTElBQXRBQUJCTDBjTkFTQUFRUUZxSVFFTUJ3c2dCQ0FCSWdCR0JFQkI4UUFoQXd5K0Fnc2dBQzBBQUNJQlFTOUdCRUFnQUVFQmFpRUJRZDBBSVFNTXBRSUxJQUZCQ21zaUEwRVdTdzBBSUFBaEFVRUJJQU4wUVltQWdBSnhEZmtCQzBFQUlRTWdBa0VBTmdJY0lBSWdBRFlDRkNBQ1FZd2NOZ0lRSUFKQkJ6WUNEQXk4QWdzZ0FTQUVSd1JBSUFGQkFXb2hBVUhlQUNFRERLTUNDMEh5QUNFRERMc0NDeUFCSUFSR0JFQkI5QUFoQXd5N0Fnc0NRQ0FCTFFBQVFmRE1BR290QUFCQkFXc09BL2NCY3dDQ0FRdEI0UUFoQXd5aEFnc2dBU0FFUndSQUEwQWdBUzBBQUVId3lnQnFMUUFBSWdCQkEwY0VRQUpBSUFCQkFXc09BdmtCQUlVQkMwSGZBQ0VEREtNQ0N5QUVJQUZCQVdvaUFVY05BQXRCOHdBaEF3eTZBZ3RCOHdBaEF3eTVBZ3NnQVNBRVJ3UkFJQUpCRHpZQ0NDQUNJQUUyQWdSQjRBQWhBd3lnQWd0QjlRQWhBd3k0QWdzZ0FTQUVSZ1JBUWZZQUlRTU11QUlMSUFKQkR6WUNDQ0FDSUFFMkFnUUxRUU1oQXd5ZEFnc0RRQ0FCTFFBQVFTQkhEWTRDSUFRZ0FVRUJhaUlCUncwQUMwSDNBQ0VERExVQ0N5QUJJQVJHQkVCQitBQWhBd3kxQWdzZ0FTMEFBRUVnUncxNklBRkJBV29oQVF4YkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NPQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEWGdNZ0FJTElBRWdCRVlFUUVINkFDRURETE1DQ3lBQkxRQUFRY3dBUncxMElBRkJBV29oQVVFVERIWUxRZnNBSVFNZ0FTQUVSZzJ4QWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlEUUNBQkxRQUFJQUJCOE00QWFpMEFBRWNOY3lBQVFRVkdEWFVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNc1FJTElBRWdCRVlFUUVIOEFDRURETEVDQ3dKQUFrQWdBUzBBQUVIREFHc09EQUIwZEhSMGRIUjBkSFIwQVhRTElBRkJBV29oQVVIbUFDRURESmdDQ3lBQlFRRnFJUUZCNXdBaEF3eVhBZ3RCL1FBaEF5QUJJQVJHRGE4Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFlM1BBR290QUFCSERYSWdBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURMQUNDeUFDUVFBMkFnQWdCa0VCYWlFQlFSQU1jd3RCL2dBaEF5QUJJQVJHRGE0Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFmYk9BR290QUFCSERYRWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLOENDeUFDUVFBMkFnQWdCa0VCYWlFQlFSWU1jZ3RCL3dBaEF5QUJJQVJHRGEwQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFmek9BR290QUFCSERYQWdBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLNENDeUFDUVFBMkFnQWdCa0VCYWlFQlFRVU1jUXNnQVNBRVJnUkFRWUFCSVFNTXJRSUxJQUV0QUFCQjJRQkhEVzRnQVVFQmFpRUJRUWdNY0FzZ0FTQUVSZ1JBUVlFQklRTU1yQUlMQWtBQ1FDQUJMUUFBUWM0QWF3NERBRzhCYndzZ0FVRUJhaUVCUWVzQUlRTU1rd0lMSUFGQkFXb2hBVUhzQUNFRERKSUNDeUFCSUFSR0JFQkJnZ0VoQXd5ckFnc0NRQUpBSUFFdEFBQkJ5QUJyRGdnQWJtNXVibTV1QVc0TElBRkJBV29oQVVIcUFDRURESklDQ3lBQlFRRnFJUUZCN1FBaEF3eVJBZ3RCZ3dFaEF5QUJJQVJHRGFrQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFZRFBBR290QUFCSERXd2dBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLb0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFRQU1iUXRCaEFFaEF5QUJJQVJHRGFnQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCR29oQmdKQUEwQWdBUzBBQUNBQVFZUFBBR290QUFCSERXc2dBRUVFUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLa0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFTTU1iQXNnQVNBRVJnUkFRWVVCSVFNTXFBSUxBa0FDUUNBQkxRQUFRY3dBYXc0SUFHdHJhMnRyYXdGckN5QUJRUUZxSVFGQjd3QWhBd3lQQWdzZ0FVRUJhaUVCUWZBQUlRTU1qZ0lMSUFFZ0JFWUVRRUdHQVNFRERLY0NDeUFCTFFBQVFjVUFSdzFvSUFGQkFXb2hBUXhnQzBHSEFTRURJQUVnQkVZTnBRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVEYWlFR0FrQURRQ0FCTFFBQUlBQkJpTThBYWkwQUFFY05hQ0FBUVFOR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJMUXhwQzBHSUFTRURJQUVnQkVZTnBBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVJYWlFR0FrQURRQ0FCTFFBQUlBQkIwTThBYWkwQUFFY05aeUFBUVFoR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJLUXhvQ3lBQklBUkdCRUJCaVFFaEF3eWtBZ3RCQVNBQkxRQUFRZDhBUncxbkdpQUJRUUZxSVFFTVhndEJpZ0VoQXlBQklBUkdEYUlDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ05BSUFFdEFBQWdBRUdNendCcUxRQUFSdzFrSUFCQkFVWU4rZ0VnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNb2dJTFFZc0JJUU1nQVNBRVJnMmhBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdPendCcUxRQUFSdzFrSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlpQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVDREdVTFFZd0JJUU1nQVNBRVJnMmdBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh3endCcUxRQUFSdzFqSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXloQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVmREdRTFFZMEJJUU1nQVNBRVJnMmZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh5endCcUxRQUFSdzFpSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlnQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVKREdNTElBRWdCRVlFUUVHT0FTRURESjhDQ3dKQUFrQWdBUzBBQUVISkFHc09Cd0JpWW1KaVlnRmlDeUFCUVFGcUlRRkIrQUFoQXd5R0Fnc2dBVUVCYWlFQlFma0FJUU1NaFFJTFFZOEJJUU1nQVNBRVJnMmRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdSendCcUxRQUFSdzFnSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXllQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVZREdFTFFaQUJJUU1nQVNBRVJnMmNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdYendCcUxRQUFSdzFmSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlkQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVYREdBTFFaRUJJUU1nQVNBRVJnMmJBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFacUlRWUNRQU5BSUFFdEFBQWdBRUdhendCcUxRQUFSdzFlSUFCQkJrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXljQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVWREY4TFFaSUJJUU1nQVNBRVJnMmFBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdoendCcUxRQUFSdzFkSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXliQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVlREY0TElBRWdCRVlFUUVHVEFTRURESm9DQ3lBQkxRQUFRY3dBUncxYklBRkJBV29oQVVFS0RGMExJQUVnQkVZRVFFR1VBU0VEREprQ0N3SkFBa0FnQVMwQUFFSEJBR3NPRHdCY1hGeGNYRnhjWEZ4Y1hGeGNBVndMSUFGQkFXb2hBVUgrQUNFRERJQUNDeUFCUVFGcUlRRkIvd0FoQXd6L0FRc2dBU0FFUmdSQVFaVUJJUU1NbUFJTEFrQUNRQ0FCTFFBQVFjRUFhdzREQUZzQld3c2dBVUVCYWlFQlFmMEFJUU1NL3dFTElBRkJBV29oQVVHQUFTRUREUDRCQzBHV0FTRURJQUVnQkVZTmxnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJwODhBYWkwQUFFY05XU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJDd3hhQ3lBQklBUkdCRUJCbHdFaEF3eVdBZ3NDUUFKQUFrQUNRQ0FCTFFBQVFTMXJEaU1BVzF0YlcxdGJXMXRiVzF0YlcxdGJXMXRiVzF0Ylcxc0JXMXRiVzFzQ1cxdGJBMXNMSUFGQkFXb2hBVUg3QUNFRERQOEJDeUFCUVFGcUlRRkIvQUFoQXd6K0FRc2dBVUVCYWlFQlFZRUJJUU1NL1FFTElBRkJBV29oQVVHQ0FTRUREUHdCQzBHWUFTRURJQUVnQkVZTmxBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVFYWlFR0FrQURRQ0FCTFFBQUlBQkJxYzhBYWkwQUFFY05WeUFBUVFSR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJHUXhZQzBHWkFTRURJQUVnQkVZTmt3SWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkJyczhBYWkwQUFFY05WaUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sQUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJCZ3hYQzBHYUFTRURJQUVnQkVZTmtnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0TThBYWkwQUFFY05WU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJIQXhXQzBHYkFTRURJQUVnQkVZTmtRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0czhBYWkwQUFFY05WQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJKd3hWQ3lBQklBUkdCRUJCbkFFaEF3eVJBZ3NDUUFKQUlBRXRBQUJCMUFCckRnSUFBVlFMSUFGQkFXb2hBVUdHQVNFRERQZ0JDeUFCUVFGcUlRRkJod0VoQXd6M0FRdEJuUUVoQXlBQklBUkdEWThDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJqUEFHb3RBQUJIRFZJZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREpBQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVNZTVV3dEJuZ0VoQXlBQklBUkdEWTRDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJyUEFHb3RBQUJIRFZFZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk4Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFNTVVndEJud0VoQXlBQklBUkdEWTBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWUzUEFHb3RBQUJIRFZBZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk0Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVF3TVVRdEJvQUVoQXlBQklBUkdEWXdDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJ6UEFHb3RBQUJIRFU4Z0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREkwQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVEwTVVBc2dBU0FFUmdSQVFhRUJJUU1NakFJTEFrQUNRQ0FCTFFBQVFjWUFhdzRMQUU5UFQwOVBUMDlQVHdGUEN5QUJRUUZxSVFGQml3RWhBd3p6QVFzZ0FVRUJhaUVCUVl3QklRTU04Z0VMSUFFZ0JFWUVRRUdpQVNFRERJc0NDeUFCTFFBQVFkQUFSdzFNSUFGQkFXb2hBUXhHQ3lBQklBUkdCRUJCb3dFaEF3eUtBZ3NDUUFKQUlBRXRBQUJCeVFCckRnY0JUVTFOVFUwQVRRc2dBVUVCYWlFQlFZNEJJUU1NOFFFTElBRkJBV29oQVVFaURFMExRYVFCSVFNZ0FTQUVSZzJJQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIQXp3QnFMUUFBUncxTElBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5SkFnc2dBa0VBTmdJQUlBWkJBV29oQVVFZERFd0xJQUVnQkVZRVFFR2xBU0VERElnQ0N3SkFBa0FnQVMwQUFFSFNBR3NPQXdCTEFVc0xJQUZCQVdvaEFVR1FBU0VERE84QkN5QUJRUUZxSVFGQkJBeExDeUFCSUFSR0JFQkJwZ0VoQXd5SEFnc0NRQUpBQWtBQ1FBSkFJQUV0QUFCQndRQnJEaFVBVFUxTlRVMU5UVTFOVFFGTlRRSk5UUU5OVFFSTkN5QUJRUUZxSVFGQmlBRWhBd3p4QVFzZ0FVRUJhaUVCUVlrQklRTU04QUVMSUFGQkFXb2hBVUdLQVNFRERPOEJDeUFCUVFGcUlRRkJqd0VoQXd6dUFRc2dBVUVCYWlFQlFaRUJJUU1NN1FFTFFhY0JJUU1nQVNBRVJnMkZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUh0endCcUxRQUFSdzFJSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlHQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVSREVrTFFhZ0JJUU1nQVNBRVJnMkVBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhDendCcUxRQUFSdzFISUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlGQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVzREVnTFFha0JJUU1nQVNBRVJnMkRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUhGendCcUxRQUFSdzFHSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlFQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVyREVjTFFhb0JJUU1nQVNBRVJnMkNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhLendCcUxRQUFSdzFGSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlEQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVVREVZTElBRWdCRVlFUUVHckFTRURESUlDQ3dKQUFrQUNRQUpBSUFFdEFBQkJ3Z0JyRGc4QUFRSkhSMGRIUjBkSFIwZEhSd05IQ3lBQlFRRnFJUUZCa3dFaEF3enJBUXNnQVVFQmFpRUJRWlFCSVFNTTZnRUxJQUZCQVdvaEFVR1ZBU0VERE9rQkN5QUJRUUZxSVFGQmxnRWhBd3pvQVFzZ0FTQUVSZ1JBUWF3QklRTU1nUUlMSUFFdEFBQkJ4UUJIRFVJZ0FVRUJhaUVCREQwTFFhMEJJUU1nQVNBRVJnMy9BU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhOendCcUxRQUFSdzFDSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlBQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVPREVNTElBRWdCRVlFUUVHdUFTRUREUDhCQ3lBQkxRQUFRZEFBUncxQUlBRkJBV29oQVVFbERFSUxRYThCSVFNZ0FTQUVSZzM5QVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRaHFJUVlDUUFOQUlBRXRBQUFnQUVIUXp3QnFMUUFBUncxQUlBQkJDRVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6K0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFcURFRUxJQUVnQkVZRVFFR3dBU0VERFAwQkN3SkFBa0FnQVMwQUFFSFZBR3NPQ3dCQVFFQkFRRUJBUUVBQlFBc2dBVUVCYWlFQlFab0JJUU1NNUFFTElBRkJBV29oQVVHYkFTRURET01CQ3lBQklBUkdCRUJCc1FFaEF3ejhBUXNDUUFKQUlBRXRBQUJCd1FCckRoUUFQejgvUHo4L1B6OC9QejgvUHo4L1B6OC9BVDhMSUFGQkFXb2hBVUdaQVNFRERPTUJDeUFCUVFGcUlRRkJuQUVoQXd6aUFRdEJzZ0VoQXlBQklBUkdEZm9CSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWRuUEFHb3RBQUJIRFQwZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBzQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNFTVBndEJzd0VoQXlBQklBUkdEZmtCSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWQzUEFHb3RBQUJIRFR3Z0FFRUdSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBvQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVJvTVBRc2dBU0FFUmdSQVFiUUJJUU1NK1FFTEFrQUNRQUpBSUFFdEFBQkJ4UUJyRGhFQVBUMDlQVDA5UFQwOUFUMDlQVDA5QWowTElBRkJBV29oQVVHZEFTRURET0VCQ3lBQlFRRnFJUUZCbmdFaEF3emdBUXNnQVVFQmFpRUJRWjhCSVFNTTN3RUxRYlVCSVFNZ0FTQUVSZzMzQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVIa3p3QnFMUUFBUncwNklBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6NEFRc2dBa0VBTmdJQUlBWkJBV29oQVVFb0REc0xRYllCSVFNZ0FTQUVSZzMyQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIcXp3QnFMUUFBUncwNUlBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6M0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFSEREb0xJQUVnQkVZRVFFRzNBU0VERFBZQkN3SkFBa0FnQVMwQUFFSEZBR3NPRGdBNU9UazVPVGs1T1RrNU9Ua0JPUXNnQVVFQmFpRUJRYUVCSVFNTTNRRUxJQUZCQVdvaEFVR2lBU0VERE53QkMwRzRBU0VESUFFZ0JFWU45QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCN2M4QWFpMEFBRWNOTnlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOVFFTElBSkJBRFlDQUNBR1FRRnFJUUZCRWd3NEMwRzVBU0VESUFFZ0JFWU44d0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOE04QWFpMEFBRWNOTmlBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOUFFTElBSkJBRFlDQUNBR1FRRnFJUUZCSUF3M0MwRzZBU0VESUFFZ0JFWU44Z0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOHM4QWFpMEFBRWNOTlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOHdFTElBSkJBRFlDQUNBR1FRRnFJUUZCRHd3MkN5QUJJQVJHQkVCQnV3RWhBd3p5QVFzQ1FBSkFJQUV0QUFCQnlRQnJEZ2NBTlRVMU5UVUJOUXNnQVVFQmFpRUJRYVVCSVFNTTJRRUxJQUZCQVdvaEFVR21BU0VERE5nQkMwRzhBU0VESUFFZ0JFWU44QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSGFpRUdBa0FEUUNBQkxRQUFJQUJCOU04QWFpMEFBRWNOTXlBQVFRZEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOFFFTElBSkJBRFlDQUNBR1FRRnFJUUZCR3d3MEN5QUJJQVJHQkVCQnZRRWhBd3p3QVFzQ1FBSkFBa0FnQVMwQUFFSENBR3NPRWdBME5EUTBORFEwTkRRQk5EUTBORFEwQWpRTElBRkJBV29oQVVHa0FTRURETmdCQ3lBQlFRRnFJUUZCcHdFaEF3elhBUXNnQVVFQmFpRUJRYWdCSVFNTTFnRUxJQUVnQkVZRVFFRytBU0VERE84QkN5QUJMUUFBUWM0QVJ3MHdJQUZCQVdvaEFRd3NDeUFCSUFSR0JFQkJ2d0VoQXd6dUFRc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRY0VBYXc0VkFBRUNBejhFQlFZL1B6OEhDQWtLQ3o4TURRNFBQd3NnQVVFQmFpRUJRZWdBSVFNTTR3RUxJQUZCQVdvaEFVSHBBQ0VERE9JQkN5QUJRUUZxSVFGQjdnQWhBd3poQVFzZ0FVRUJhaUVCUWZJQUlRTU00QUVMSUFGQkFXb2hBVUh6QUNFREROOEJDeUFCUVFGcUlRRkI5Z0FoQXd6ZUFRc2dBVUVCYWlFQlFmY0FJUU1NM1FFTElBRkJBV29oQVVINkFDRURETndCQ3lBQlFRRnFJUUZCZ3dFaEF3emJBUXNnQVVFQmFpRUJRWVFCSVFNTTJnRUxJQUZCQVdvaEFVR0ZBU0VERE5rQkN5QUJRUUZxSVFGQmtnRWhBd3pZQVFzZ0FVRUJhaUVCUVpnQklRTU0xd0VMSUFGQkFXb2hBVUdnQVNFREROWUJDeUFCUVFGcUlRRkJvd0VoQXd6VkFRc2dBVUVCYWlFQlFhb0JJUU1NMUFFTElBRWdCRWNFUUNBQ1FSQTJBZ2dnQWlBQk5nSUVRYXNCSVFNTTFBRUxRY0FCSVFNTTdBRUxRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUkwSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRFY0Z0FFRVZSdzBISUFKQjBRQTJBaHdnQWlBQk5nSVVJQUpCc0JjMkFoQWdBa0VWTmdJTVFRQWhBd3pyQVFzZ0FVRUJhaUFCSUFSSERRZ2FRY0lCSVFNTTZnRUxBMEFDUUNBQkxRQUFRUXByRGdRSUFBQUxBQXNnQkNBQlFRRnFJZ0ZIRFFBTFFjTUJJUU1NNlFFTElBRWdCRWNFUUNBQ1FSRTJBZ2dnQWlBQk5nSUVRUUVoQXd6UUFRdEJ4QUVoQXd6b0FRc2dBU0FFUmdSQVFjVUJJUU1NNkFFTEFrQUNRQ0FCTFFBQVFRcHJEZ1FCS0NnQUtBc2dBVUVCYWd3SkN5QUJRUUZxREFVTElBRWdCRVlFUUVIR0FTRURET2NCQ3dKQUFrQWdBUzBBQUVFS2F3NFhBUXNMQVFzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dBTEN5QUJRUUZxSVFFTFFiQUJJUU1NelFFTElBRWdCRVlFUUVISUFTRURET1lCQ3lBQkxRQUFRU0JIRFFrZ0FrRUFPd0V5SUFGQkFXb2hBVUd6QVNFRERNd0JDd05BSUFFaEFBSkFJQUVnQkVjRVFDQUJMUUFBUVRCclFmOEJjU0lEUVFwSkRRRU1Kd3RCeHdFaEF3em1BUXNDUUNBQ0x3RXlJZ0ZCbVROTERRQWdBaUFCUVFwc0lnVTdBVElnQlVIKy93TnhJQU5CLy84RGMwc05BQ0FBUVFGcUlRRWdBaUFESUFWcUlnTTdBVElnQTBILy93TnhRZWdIU1EwQkN3dEJBQ0VESUFKQkFEWUNIQ0FDUWNFSk5nSVFJQUpCRFRZQ0RDQUNJQUJCQVdvMkFoUU01QUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0h3RERZQ0VDQUNRUnMyQWd4QkFDRURET01CQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDWWlBQTBCSUFGQkFXb0xJUUZCclFFaEF3eklBUXNnQWtIQkFUWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVRUUFoQXd6Z0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFtSWdBTkFTQUJRUUZxQ3lFQlFhNEJJUU1NeFFFTElBSkJ3Z0UyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkVFQUlRTU0zUUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dYQ3pZQ0VDQUNRUTAyQWd4QkFDRURETndCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCNHhBMkFoQWdBa0VKTmdJTVFRQWhBd3piQVFzZ0FrRUNPZ0FvREt3QkMwRUFJUU1nQWtFQU5nSWNJQUpCcndzMkFoQWdBa0VDTmdJTUlBSWdBVUVCYWpZQ0ZBelpBUXRCQWlFRERMOEJDMEVOSVFNTXZnRUxRU1loQXd5OUFRdEJGU0VEREx3QkMwRVdJUU1NdXdFTFFSZ2hBd3k2QVF0QkhDRURETGtCQzBFZElRTU11QUVMUVNBaEF3eTNBUXRCSVNFRERMWUJDMEVqSVFNTXRRRUxRY1lBSVFNTXRBRUxRUzRoQXd5ekFRdEJQU0VERExJQkMwSExBQ0VERExFQkMwSE9BQ0VERExBQkMwSFlBQ0VEREs4QkMwSFpBQ0VEREs0QkMwSGJBQ0VEREswQkMwSHhBQ0VEREt3QkMwSDBBQ0VEREtzQkMwR05BU0VEREtvQkMwR1hBU0VEREtrQkMwR3BBU0VEREtnQkMwR3ZBU0VEREtjQkMwR3hBU0VEREtZQkN5QUNRUUEyQWdBTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI4UnMyQWhBZ0FrRUdOZ0lNREwwQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNRTE9nQXBJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSnlJQVJRUkFRZVVBSVFNTW93RUxJQUpCK1FBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU11d0VMSUFCQkZVY0VRQ0FDUVFBMkFod2dBaUFCTmdJVUlBSkJ6QTQyQWhBZ0FrRWdOZ0lNUVFBaEF3eTdBUXNnQWtINEFEWUNIQ0FDSUFFMkFoUWdBa0hLR0RZQ0VDQUNRUlUyQWd4QkFDRURETG9CQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCamhzMkFoQWdBa0VHTmdJTVFRQWhBd3k1QVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWY0Uk5nSVFJQUpCQnpZQ0RFRUFJUU1NdUFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHTUhEWUNFQ0FDUVFjMkFneEJBQ0VERExjQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnd3ODJBaEFnQWtFSE5nSU1RUUFoQXd5MkFRc2dBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjTVBOZ0lRSUFKQkJ6WUNERUVBSVFNTXRRRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMFJJQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU10QUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBnSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc3dFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwaUlBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXNnRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRME9JQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zUUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBkSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc0FFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwZklBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXJ3RUxJQUJCUDBjTkFTQUJRUUZxQ3lFQlFRVWhBd3lVQVF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSDlFallDRUNBQ1FRYzJBZ3dNckFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIY0NEWUNFQ0FDUVFjMkFneEJBQ0VEREtzQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1VpQUVVTkJ5QUNRZVVBTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERLb0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNVaUFFVU5GaUFDUWRNQU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURES2tCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDVWlBRVVOR0NBQ1FkSUFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREtnQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhnbzJBaEFnQWtFSE5nSU1RUUFoQXd5bkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRTWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eW1BUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUklnQWtIVEFEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3lsQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFJRZ0FrSFNBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5a0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eWpBUXRCMVFBaEF3eUpBUXNnQUVFVlJ3UkFJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrRzVEVFlDRUNBQ1FSbzJBZ3hCQUNFRERLSUJDeUFDUWVRQU5nSWNJQUlnQVRZQ0ZDQUNRZU1YTmdJUUlBSkJGVFlDREVFQUlRTU1vUUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1NJQVFTTnJRUXRKRFFRQ1FDQUFRUVpMRFFCQkFTQUFkRUhLQUhGRkRRQU1CUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIM0NUWUNFQ0FDUVFnMkFnd01vQUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1VFaFJnMERJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR2JDallDRUNBQ1FRZzJBZ3hCQUNFRERKOEJDeUFDUVFBMkFnQUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCa0RNMkFoQWdBa0VJTmdJTURKMEJDeUFDUVFBMkFnQWdCa0VCYWlFQklBSXRBQ2xCSTBrTkFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjB3azJBaEFnQWtFSU5nSU1RUUFoQXd5Y0FRdEIwUUFoQXd5Q0FRc2dBUzBBQUVFd2F5SUFRZjhCY1VFS1NRUkFJQUlnQURvQUtpQUJRUUZxSVFGQnp3QWhBd3lDQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQW9JZ0JGRFlZQklBSkIzZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTW1nRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRS0NJQVJRMkdBU0FDUWR3QU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURESmtCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1od0VMSUFKQjJnQTJBaHdnQWlBRk5nSVVJQUlnQURZQ0RBeVlBUXRCQUNFQlFRRWhBd3NnQWlBRE9nQXJJQVZCQVdvaEF3SkFBa0FDUUNBQ0xRQXRRUkJ4RFFBQ1FBSkFBa0FnQWkwQUtnNERBUUFDQkFzZ0JrVU5Bd3dDQ3lBQURRRU1BZ3NnQVVVTkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBeEFvSWdCRkJFQWdBeUVCREFJTElBSkIyQUEyQWh3Z0FpQUROZ0lVSUFJZ0FEWUNERUVBSVFNTW1BRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQU1RS0NJQVJRUkFJQU1oQVF5SEFRc2dBa0haQURZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3eVhBUXRCekFBaEF3eDlDeUFBUVJWSEJFQWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FaUU5OZ0lRSUFKQklUWUNERUVBSVFNTWxnRUxJQUpCMXdBMkFod2dBaUFCTmdJVUlBSkJ5UmMyQWhBZ0FrRVZOZ0lNUVFBaEF3eVZBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHQUVUWUNFQ0FDUVFrMkFnd01sQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBBSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Na3dFTFFja0FJUU1NZVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNFb05nSVFJQUpCQnpZQ0RDQUNRUUEyQWdCQkFDRURESkVCQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hTQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREpBQkMwSElBQ0VEREhZTElBSkJBRFlDQUNBRklRRUxJQUpCZ0JJN0FTb2dBVUVCYWlFQlFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSXdJZ05GRFFBZ0FpQURFUUFBSVFBTElBQU5BUXRCeHdBaEF3eHpDeUFBUVJWR0JFQWdBa0hSQURZQ0hDQUNJQUUyQWhRZ0FrSGpGellDRUNBQ1FSVTJBZ3hCQUNFRERJd0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJrTk5nSVFJQUpCR2pZQ0RBeUxBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHZ0dUWUNFQ0FDUVI0MkFnd01pZ0VMSUFFdEFBQkJPa1lFUUNBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFwSWdCRkRRRWdBa0hEQURZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVURJb0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJFUk5nSVFJQUpCQ2pZQ0RBeUpBUXNnQVVFQmFpRUJRVHNoQXd4dkN5QUNRY01BTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWh3RUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCOEE0MkFoQWdBa0VjTmdJTURJWUJDeUFDSUFJdkFUQkJFSEk3QVRBTVpnc0NRQ0FDTHdFd0lnQkJDSEZGRFFBZ0FpMEFLRUVCUncwQUlBSXRBQzFCQ0hGRkRRTUxJQUlnQUVIMyt3TnhRWUFFY2pzQk1Bd0VDeUFCSUFSSEJFQUNRQU5BSUFFdEFBQkJNR3NpQUVIL0FYRkJDazhFUUVFMUlRTU1iZ3NnQWlrRElDSUtRcG16NXN5WnMrYk1HVllOQVNBQ0lBcENDbjRpQ2pjRElDQUtJQUN0UXY4Qmd5SUxRbitGVmcwQklBSWdDaUFMZkRjRElDQUVJQUZCQVdvaUFVY05BQXRCT1NFRERJVUJDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FVRUJhaUlCRUNvaUFBME1ESGNMUVRraEF3eURBUXNnQWkwQU1FRWdjUTBHUWNVQklRTU1hUXRCQUNFRElBSkJBRFlDQkNBQ0lBRWdBUkFxSWdCRkRRUWdBa0U2TmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWdRRUxJQUl0QUNoQkFVY05BQ0FDTFFBdFFRaHhSUTBCQzBFM0lRTU1aZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBQkVBZ0FrRTdOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNZndzZ0FVRUJhaUVCREc0TElBSkJDRG9BTEF3RUN5QUJRUUZxSVFFTWJRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hrRWpZQ0VDQUNRUVEyQWd3TWV3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTFzSUFKQk56WUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIb0xJQUlnQWk4Qk1FRWdjanNCTUF0Qk1DRURERjhMSUFKQk5qWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIY0xJQUJCTEVjTkFTQUJRUUZxSVFCQkFTRUJBa0FDUUFKQUFrQUNRQ0FDTFFBc1FRVnJEZ1FEQVFJRUFBc2dBQ0VCREFRTFFRSWhBUXdCQzBFRUlRRUxJQUpCQVRvQUxDQUNJQUl2QVRBZ0FYSTdBVEFnQUNFQkRBRUxJQUlnQWk4Qk1FRUljanNCTUNBQUlRRUxRVGtoQXd4Y0N5QUNRUUE2QUN3TFFUUWhBd3hhQ3lBQklBUkdCRUJCTFNFRERITUxBa0FDUUFOQUFrQWdBUzBBQUVFS2F3NEVBZ0FBQXdBTElBUWdBVUVCYWlJQlJ3MEFDMEV0SVFNTWRBc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTBDSUFKQkxEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURITUxJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQkVDb2lBRVVFUUNBQlFRRnFJUUVNQWdzZ0FrRXNOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNY2dzZ0FTMEFBRUVOUmdSQUlBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCRUNvaUFFVUVRQ0FCUVFGcUlRRU1BZ3NnQWtFc05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1jZ3NnQWkwQUxVRUJjUVJBUWNRQklRTU1XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBRFFFTVpRdEJMeUVEREZjTElBSkJMallDSENBQ0lBRTJBaFFnQWlBQU5nSU1ERzhMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjhCUTJBaEFnQWtFRE5nSU1ERzRMUVFFaEF3SkFBa0FDUUFKQUlBSXRBQ3hCQldzT0JBTUJBZ0FFQ3lBQ0lBSXZBVEJCQ0hJN0FUQU1Bd3RCQWlFRERBRUxRUVFoQXdzZ0FrRUJPZ0FzSUFJZ0FpOEJNQ0FEY2pzQk1BdEJLaUVEREZNTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI0UTgyQWhBZ0FrRUtOZ0lNREdzTFFRRWhBd0pBQWtBQ1FBSkFBa0FDUUNBQ0xRQXNRUUpyRGdjRkJBUURBUUlBQkFzZ0FpQUNMd0V3UVFoeU93RXdEQU1MUVFJaEF3d0JDMEVFSVFNTElBSkJBVG9BTENBQ0lBSXZBVEFnQTNJN0FUQUxRU3NoQXd4U0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYXNTTmdJUUlBSkJDellDREF4cUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZjBOTmdJUUlBSkJIVFlDREF4cEN5QUJJQVJIQkVBRFFDQUJMUUFBUVNCSERVZ2dCQ0FCUVFGcUlnRkhEUUFMUVNVaEF3eHBDMEVsSVFNTWFBc2dBaTBBTFVFQmNRUkFRY01CSVFNTVR3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtTSUFCRUFnQWtFbU5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1hQXNnQVVFQmFpRUJERndMSUFGQkFXb2hBU0FDTHdFd0lnQkJnQUZ4QkVCQkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FsUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5CaUFBUVJWSERSOGdBa0VGTmdJY0lBSWdBVFlDRkNBQ1Fma1hOZ0lRSUFKQkZUWUNERUVBSVFNTVp3c0NRQ0FBUWFBRWNVR2dCRWNOQUNBQ0xRQXRRUUp4RFFCQkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1dFellDRUNBQ1FRUTJBZ3dNWndzZ0FnSi9JQUl2QVRCQkZIRkJGRVlFUUVFQklBSXRBQ2hCQVVZTkFSb2dBaThCTWtIbEFFWU1BUXNnQWkwQUtVRUZSZ3M2QUM1QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FpUWlBMFVOQUNBQ0lBTVJBQUFoQUFzQ1FBSkFBa0FDUUFKQUlBQU9GZ0lCQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFNRUN5QUNRUUU2QUM0TElBSWdBaThCTUVIQUFISTdBVEFMUVNjaEF3eFBDeUFDUVNNMkFod2dBaUFCTmdJVUlBSkJwUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eG5DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWRVTE5nSVFJQUpCRVRZQ0RBeG1DMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDTENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRFFFTFFRNGhBd3hMQ3lBQVFSVkdCRUFnQWtFQ05nSWNJQUlnQVRZQ0ZDQUNRYkFZTmdJUUlBSkJGVFlDREVFQUlRTU1aQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01Zd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHcUhEWUNFQ0FDUVE4MkFnd01ZZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRWdDcWRxSWdFUUt5SUFSUTBBSUFKQkJUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURHRUxRUThoQXd4SEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBUTmdJUUlBSkJERFlDREF4ZkMwSUJJUW9MSUFGQkFXb2hBUUpBSUFJcEF5QWlDMEwvLy8vLy8vLy8vdzlZQkVBZ0FpQUxRZ1NHSUFxRU53TWdEQUVMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnJRazJBaEFnQWtFTU5nSU1ERjRMUVNRaEF3eEVDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwVE5nSVFJQUpCRERZQ0RBeGNDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXNJZ0JGQkVBZ0FVRUJhaUVCREZJTElBSkJGellDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVREZzTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FSWTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhiQzBFZklRTU1RUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFMU0lBUlFSQUlBRkJBV29oQVF4UUN5QUNRUlEyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkF4WUN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JBSkFJQUlnQUNBQkVDMGlBRVVFUUNBQlFRRnFJUUVNQVFzZ0FrRVROZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNV0F0QkhpRURERDRMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhndzJBaEFnQWtFak5nSU1ERllMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJFQzBpQUVVRVFDQUJRUUZxSVFFTVRnc2dBa0VSTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVZRc2dBa0VRTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3dNVkF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEdERFlDRUNBQ1FTTTJBZ3dNVXd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEFGVFlDRUNBQ1FRSTJBZ3dNVWdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRQ1FDQUNJQUFnQVJBdElnQkZCRUFnQVVFQmFpRUJEQUVMSUFKQkRqWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVERklMUVJzaEF3dzRDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNZTU5nSVFJQUpCSXpZQ0RBeFFDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQUpBSUFJZ0FDQUJFQ3dpQUVVRVFDQUJRUUZxSVFFTUFRc2dBa0VOTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVVBdEJHaUVERERZTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJtZzgyQWhBZ0FrRWlOZ0lNREU0TElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FRdzJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhPQzBFWklRTU1OQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01UQXNnQUVFVlJ3UkFRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCZ3d3MkFoQWdBa0VUTmdJTURFd0xJQUpCQ2pZQ0hDQUNJQUUyQWhRZ0FrSGtGallDRUNBQ1FSVTJBZ3hCQUNFRERFc0xJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQklBcW5haUlCRUNzaUFBUkFJQUpCQnpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREVzTFFSTWhBd3d4Q3lBQVFSVkhCRUJCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIYURUWUNFQ0FDUVJRMkFnd01TZ3NnQWtFZU5nSWNJQUlnQVRZQ0ZDQUNRZmtYTmdJUUlBSkJGVFlDREVFQUlRTU1TUXRCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWl3aUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTlFTQUFRUlZHQkVBZ0FrRUROZ0ljSUFJZ0FUWUNGQ0FDUWJBWU5nSVFJQUpCRlRZQ0RFRUFJUU1NU1F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNU0F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGFEVFlDRUNBQ1FSUTJBZ3dNUnd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNUmdzZ0FrRUFPZ0F2SUFJdEFDMUJCSEZGRFQ4TElBSkJBRG9BTHlBQ1FRRTZBRFJCQUNFRERDc0xRUUFoQXlBQ1FRQTJBaHdnQWtIa0VUWUNFQ0FDUVFjMkFnd2dBaUFCUVFGcU5nSVVERU1MQWtBRFFBSkFJQUV0QUFCQkNtc09CQUFDQWdBQ0N5QUVJQUZCQVdvaUFVY05BQXRCM1FFaEF3eERDd0pBQWtBZ0FpMEFORUVCUncwQVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSllJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEUUFnQUVFVlJ3MEJJQUpCM0FFMkFod2dBaUFCTmdJVUlBSkIxUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eEVDMEhCQVNFRERDb0xJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSHBDellDRUNBQ1FSODJBZ3hCQUNFRERFSUxBa0FDUUNBQ0xRQW9RUUZyRGdJRUFRQUxRY0FCSVFNTUtRdEJ1UUVoQXd3b0N5QUNRUUk2QUM5QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FnQWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVUVRRUhDQVNFRERDZ0xJQUJCRlVjRVFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnBBdzJBaEFnQWtFUU5nSU1RUUFoQXd4QkN5QUNRZHNCTmdJY0lBSWdBVFlDRkNBQ1Fmb1dOZ0lRSUFKQkZUWUNERUVBSVFNTVFBc2dBU0FFUmdSQVFkb0JJUU1NUUFzZ0FTMEFBRUhJQUVZTkFTQUNRUUU2QUNnTFFhd0JJUU1NSlF0QnZ3RWhBd3drQ3lBQklBUkhCRUFnQWtFUU5nSUlJQUlnQVRZQ0JFRytBU0VERENRTFFka0JJUU1NUEFzZ0FTQUVSZ1JBUWRnQklRTU1QQXNnQVMwQUFFSElBRWNOQkNBQlFRRnFJUUZCdlFFaEF3d2lDeUFCSUFSR0JFQkIxd0VoQXd3N0N3SkFBa0FnQVMwQUFFSEZBR3NPRUFBRkJRVUZCUVVGQlFVRkJRVUZCUUVGQ3lBQlFRRnFJUUZCdXdFaEF3d2lDeUFCUVFGcUlRRkJ2QUVoQXd3aEMwSFdBU0VESUFFZ0JFWU5PU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdEMEFCcUxRQUFSdzBESUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXc2Q3lBQ0tBSUVJUUFnQWtJQU53TUFJQUlnQUNBR1FRRnFJZ0VRSnlJQVJRUkFRY1lCSVFNTUlRc2dBa0hWQVRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3dzVDMEhVQVNFRElBRWdCRVlOT0NBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHQjBBQnFMUUFBUncwQ0lBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF3NUN5QUNRWUVFT3dFb0lBSW9BZ1FoQUNBQ1FnQTNBd0FnQWlBQUlBWkJBV29pQVJBbklnQU5Bd3dDQ3lBQ1FRQTJBZ0FMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjJCczJBaEFnQWtFSU5nSU1ERFlMUWJvQklRTU1IQXNnQWtIVEFUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3cwQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ09DSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRMEFJQUJCRlVZTkFTQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnpBNDJBaEFnQWtFZ05nSU1RUUFoQXd3ekMwSGtBQ0VEREJrTElBSkIrQUEyQWh3Z0FpQUJOZ0lVSUFKQnloZzJBaEFnQWtFVk5nSU1RUUFoQXd3eEMwSFNBU0VESUFRZ0FTSUFSZzB3SUFRZ0FXc2dBaWdDQUNJQmFpRUZJQUFnQVd0QkJHb2hCZ0pBQTBBZ0FDMEFBQ0FCUWZ6UEFHb3RBQUJIRFFFZ0FVRUVSZzBESUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUZOZ0lBRERFTElBSkJBRFlDSENBQ0lBQTJBaFFnQWtHUU16WUNFQ0FDUVFnMkFnd2dBa0VBTmdJQVFRQWhBd3d3Q3lBQklBUkhCRUFnQWtFT05nSUlJQUlnQVRZQ0JFRzNBU0VEREJjTFFkRUJJUU1NTHdzZ0FrRUFOZ0lBSUFaQkFXb2hBUXRCdUFFaEF3d1VDeUFCSUFSR0JFQkIwQUVoQXd3dEN5QUJMUUFBUVRCcklnQkIvd0Z4UVFwSkJFQWdBaUFBT2dBcUlBRkJBV29oQVVHMkFTRUREQlFMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUtDSUFSUTBVSUFKQnp3RTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NTEFzZ0FTQUVSZ1JBUWM0QklRTU1MQXNDUUNBQkxRQUFRUzVHQkVBZ0FVRUJhaUVCREFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFLQ0lBUlEwVklBSkJ6UUUyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTUxBdEJ0UUVoQXd3U0N5QUVJQUVpQlVZRVFFSE1BU0VERENzTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBSUFVdEFBQkJNR3NPQ2dvSkFBRUNBd1FGQmdnTEMwRUNEQVlMUVFNTUJRdEJCQXdFQzBFRkRBTUxRUVlNQWd0QkJ3d0JDMEVJQ3lFRFFRQWhBVUVBSVFZTUFndEJDU0VEUVFFaEFFRUFJUUZCQUNFR0RBRUxRUUFoQVVFQklRTUxJQUlnQXpvQUt5QUZRUUZxSVFNQ1FBSkFJQUl0QUMxQkVIRU5BQUpBQWtBQ1FDQUNMUUFxRGdNQkFBSUVDeUFHUlEwRERBSUxJQUFOQVF3Q0N5QUJSUTBCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1Bd3NnQWtISkFUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3d0Q3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1HQXNnQWtIS0FUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3dzQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1GZ3NnQWtITEFUWUNIQ0FDSUFVMkFoUWdBaUFBTmdJTURDc0xRYlFCSVFNTUVRdEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BandpQTBVTkFDQUNJQU1SQUFBaEFBc0NRQ0FBQkVBZ0FFRVZSZzBCSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dVRFRZQ0VDQUNRU0UyQWd4QkFDRUREQ3NMUWJJQklRTU1FUXNnQWtISUFUWUNIQ0FDSUFFMkFoUWdBa0hKRnpZQ0VDQUNRUlUyQWd4QkFDRUREQ2tMSUFKQkFEWUNBQ0FHUVFGcUlRRkI5UUFoQXd3UEN5QUNMUUFwUVFWR0JFQkI0d0FoQXd3UEMwSGlBQ0VEREE0TElBQWhBU0FDUVFBMkFnQUxJQUpCQURvQUxFRUpJUU1NREFzZ0FrRUFOZ0lBSUFkQkFXb2hBVUhBQUNFRERBc0xRUUVMT2dBc0lBSkJBRFlDQUNBR1FRRnFJUUVMUVNraEF3d0lDMEU0SVFNTUJ3c0NRQ0FCSUFSSEJFQURRQ0FCTFFBQVFZQSthaTBBQUNJQVFRRkhCRUFnQUVFQ1J3MERJQUZCQVdvaEFRd0ZDeUFFSUFGQkFXb2lBVWNOQUF0QlBpRUREQ0VMUVQ0aEF3d2dDd3NnQWtFQU9nQXNEQUVMUVFzaEF3d0VDMEU2SVFNTUF3c2dBVUVCYWlFQlFTMGhBd3dDQ3lBQ0lBRTZBQ3dnQWtFQU5nSUFJQVpCQVdvaEFVRU1JUU1NQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVLSVFNTUFBc0FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1hDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1dDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1ZDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1VDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1RDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1NDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd1BDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd09DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNBU05nSVFJQUpCQ3pZQ0RBd05DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpVSk5nSVFJQUpCQ3pZQ0RBd01DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVFUE5nSVFJQUpCQ2pZQ0RBd0xDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZzUE5nSVFJQUpCQ2pZQ0RBd0tDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZFWk5nSVFJQUpCQWpZQ0RBd0pDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNRVU5nSVFJQUpCQWpZQ0RBd0lDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZJVk5nSVFJQUpCQWpZQ0RBd0hDeUFDUVFJMkFod2dBaUFCTmdJVUlBSkJuQm8yQWhBZ0FrRVdOZ0lNUVFBaEF3d0dDMEVCSVFNTUJRdEIxQUFoQXlBQklBUkdEUVFnQ0VFSWFpRUpJQUlvQWdBaEJRSkFBa0FnQVNBRVJ3UkFJQVZCMk1JQWFpRUhJQVFnQldvZ0FXc2hBQ0FGUVg5elFRcHFJZ1VnQVdvaEJnTkFJQUV0QUFBZ0J5MEFBRWNFUUVFQ0lRY01Bd3NnQlVVRVFFRUFJUWNnQmlFQkRBTUxJQVZCQVdzaEJTQUhRUUZxSVFjZ0JDQUJRUUZxSWdGSERRQUxJQUFoQlNBRUlRRUxJQWxCQVRZQ0FDQUNJQVUyQWdBTUFRc2dBa0VBTmdJQUlBa2dCellDQUFzZ0NTQUJOZ0lFSUFnb0Fnd2hBQ0FJS0FJSURnTUJCQUlBQ3dBTElBSkJBRFlDSENBQ1FiVWFOZ0lRSUFKQkZ6WUNEQ0FDSUFCQkFXbzJBaFJCQUNFRERBSUxJQUpCQURZQ0hDQUNJQUEyQWhRZ0FrSEtHallDRUNBQ1FRazJBZ3hCQUNFRERBRUxJQUVnQkVZRVFFRWlJUU1NQVFzZ0FrRUpOZ0lJSUFJZ0FUWUNCRUVoSVFNTElBaEJFR29rQUNBRFJRUkFJQUlvQWd3aEFBd0JDeUFDSUFNMkFoeEJBQ0VBSUFJb0FnUWlBVVVOQUNBQ0lBRWdCQ0FDS0FJSUVRRUFJZ0ZGRFFBZ0FpQUVOZ0lVSUFJZ0FUWUNEQ0FCSVFBTElBQUx2Z0lCQW44Z0FFRUFPZ0FBSUFCQjNBQnFJZ0ZCQVd0QkFEb0FBQ0FBUVFBNkFBSWdBRUVBT2dBQklBRkJBMnRCQURvQUFDQUJRUUpyUVFBNkFBQWdBRUVBT2dBRElBRkJCR3RCQURvQUFFRUFJQUJyUVFOeElnRWdBR29pQUVFQU5nSUFRZHdBSUFGclFYeHhJZ0lnQUdvaUFVRUVhMEVBTmdJQUFrQWdBa0VKU1EwQUlBQkJBRFlDQ0NBQVFRQTJBZ1FnQVVFSWEwRUFOZ0lBSUFGQkRHdEJBRFlDQUNBQ1FSbEpEUUFnQUVFQU5nSVlJQUJCQURZQ0ZDQUFRUUEyQWhBZ0FFRUFOZ0lNSUFGQkVHdEJBRFlDQUNBQlFSUnJRUUEyQWdBZ0FVRVlhMEVBTmdJQUlBRkJIR3RCQURZQ0FDQUNJQUJCQkhGQkdISWlBbXNpQVVFZ1NRMEFJQUFnQW1vaEFBTkFJQUJDQURjREdDQUFRZ0EzQXhBZ0FFSUFOd01JSUFCQ0FEY0RBQ0FBUVNCcUlRQWdBVUVnYXlJQlFSOUxEUUFMQ3d0V0FRRi9Ba0FnQUNnQ0RBMEFBa0FDUUFKQUFrQWdBQzBBTHc0REFRQURBZ3NnQUNnQ09DSUJSUTBBSUFFb0Fpd2lBVVVOQUNBQUlBRVJBQUFpQVEwREMwRUFEd3NBQ3lBQVFjTVdOZ0lRUVE0aEFRc2dBUXNhQUNBQUtBSU1SUVJBSUFCQjBSczJBaEFnQUVFVk5nSU1Dd3NVQUNBQUtBSU1RUlZHQkVBZ0FFRUFOZ0lNQ3dzVUFDQUFLQUlNUVJaR0JFQWdBRUVBTmdJTUN3c0hBQ0FBS0FJTUN3Y0FJQUFvQWhBTENRQWdBQ0FCTmdJUUN3Y0FJQUFvQWhRTEZ3QWdBRUVrVHdSQUFBc2dBRUVDZEVHZ00yb29BZ0FMRndBZ0FFRXVUd1JBQUFzZ0FFRUNkRUd3Tkdvb0FnQUx2d2tCQVg5QjZ5Z2hBUUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjVBQnJEdlFEWTJJQUFXRmhZV0ZoWVFJREJBVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoQmdjSUNRb0xEQTBPRDJGaFlXRmhFR0ZoWVdGaFlXRmhZV0ZoRVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVJJVEZCVVdGeGdaR2h0aFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEhCMGVIeUFoSWlNa0pTWW5LQ2txS3l3dExpOHdNVEl6TkRVMllUYzRPVHBoWVdGaFlXRmhZVHRoWVdFOFlXRmhZVDArUDJGaFlXRmhZV0ZoUUdGaFFXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMkZoWVdGaFlXRmhWRlZXVjFoWldsdGhYRjFoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGZVlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFgyQmhDMEhoSnc4TFFhUWhEd3RCeXl3UEMwSCtNUThMUWNBa0R3dEJxeVFQQzBHTktBOExRZUltRHd0QmdEQVBDMEc1THc4TFFkY2tEd3RCN3g4UEMwSGhIdzhMUWZvZkR3dEI4aUFQQzBHb0x3OExRYTR5RHd0QmlEQVBDMEhzSnc4TFFZSWlEd3RCamgwUEMwSFFMZzhMUWNvakR3dEJ4VElQQzBIZkhBOExRZEljRHd0QnhDQVBDMEhYSUE4TFFhSWZEd3RCN1M0UEMwR3JNQThMUWRRbER3dEJ6QzRQQzBINkxnOExRZndyRHd0QjBqQVBDMEh4SFE4TFFic2dEd3RCOXlzUEMwR1FNUThMUWRjeER3dEJvaTBQQzBIVUp3OExRZUFyRHd0Qm55d1BDMEhyTVE4TFFkVWZEd3RCeWpFUEMwSGVKUThMUWRRZUR3dEI5QndQQzBHbk1nOExRYkVkRHd0Qm9CMFBDMEc1TVE4TFFid3dEd3RCa2lFUEMwR3pKZzhMUWVrc0R3dEJyQjRQQzBIVUt3OExRZmNtRHd0QmdDWVBDMEd3SVE4TFFmNGVEd3RCalNNUEMwR0pMUThMUWZjaUR3dEJvREVQQzBHdUh3OExRY1lsRHd0QjZCNFBDMEdUSWc4TFFjSXZEd3RCd3gwUEMwR0xMQThMUWVFZER3dEJqUzhQQzBIcUlROExRYlF0RHd0QjBpOFBDMEhmTWc4TFFkSXlEd3RCOERBUEMwR3BJZzhMUWZrakR3dEJtUjRQQzBHMUxBOExRWnN3RHd0QmtqSVBDMEcyS3c4TFFjSWlEd3RCK0RJUEMwR2VKUThMUWRBaUR3dEJ1aDRQQzBHQkhnOExBQXRCMWlFaEFRc2dBUXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTEdRQWdBQ0FBTFFBdFFmc0JjU0FCUVFCSFFRSjBjam9BTFFzWkFDQUFJQUF0QUMxQjl3RnhJQUZCQUVkQkEzUnlPZ0F0Q3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0JDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ4aEUyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0NDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z28yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0RDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Um8yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0VDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsUkEyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0ZDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJxaHMyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0dDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Uk0yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0tDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z2cyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0hDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ3aGsyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0lDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsQlEyQWhCQkdDRUVDeUFFQzFrQkFuOENRQ0FBTFFBb1FRRkdEUUFnQUM4Qk1pSUJRZVFBYTBIa0FFa05BQ0FCUWN3QlJnMEFJQUZCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFpQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUNDeUFDQzR3QkFRSi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUNBQUx3RXdJZ0ZCQW5GRkRRRU1BZ3NnQUM4Qk1DSUJRUUZ4UlEwQkMwRUJJUUlnQUMwQUtFRUJSZzBBSUFBdkFUSWlBRUhrQUd0QjVBQkpEUUFnQUVITUFVWU5BQ0FBUWJBQ1JnMEFJQUZCd0FCeERRQkJBQ0VDSUFGQmlBUnhRWUFFUmcwQUlBRkJLSEZCQUVjaEFnc2dBZ3R6QUNBQVFSQnEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUVRCcS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUVNCcS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUWQwQk5nSWNDd1lBSUFBUU1ndWFMUUVMZnlNQVFSQnJJZ29rQUVHazBBQW9BZ0FpQ1VVRVFFSGswd0FvQWdBaUJVVUVRRUh3MHdCQ2Z6Y0NBRUhvMHdCQ2dJQ0VnSUNBd0FBM0FnQkI1Tk1BSUFwQkNHcEJjSEZCMktyVnFnVnpJZ1UyQWdCQitOTUFRUUEyQWdCQnlOTUFRUUEyQWdBTFFjelRBRUdBMUFRMkFnQkJuTkFBUVlEVUJEWUNBRUd3MEFBZ0JUWUNBRUdzMEFCQmZ6WUNBRUhRMHdCQmdLd0ROZ0lBQTBBZ0FVSEkwQUJxSUFGQnZOQUFhaUlDTmdJQUlBSWdBVUcwMEFCcUlnTTJBZ0FnQVVIQTBBQnFJQU0yQWdBZ0FVSFEwQUJxSUFGQnhOQUFhaUlETmdJQUlBTWdBallDQUNBQlFkalFBR29nQVVITTBBQnFJZ0kyQWdBZ0FpQUROZ0lBSUFGQjFOQUFhaUFDTmdJQUlBRkJJR29pQVVHQUFrY05BQXRCak5RRVFjR3JBellDQUVHbzBBQkI5Tk1BS0FJQU5nSUFRWmpRQUVIQXF3TTJBZ0JCcE5BQVFZalVCRFlDQUVITS93ZEJPRFlDQUVHSTFBUWhDUXNDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFRZXdCVFFSQVFZelFBQ2dDQUNJR1FSQWdBRUVUYWtGd2NTQUFRUXRKR3lJRVFRTjJJZ0IySWdGQkEzRUVRQUpBSUFGQkFYRWdBSEpCQVhNaUFrRURkQ0lBUWJUUUFHb2lBU0FBUWJ6UUFHb29BZ0FpQUNnQ0NDSURSZ1JBUVl6UUFDQUdRWDRnQW5keE5nSUFEQUVMSUFFZ0F6WUNDQ0FESUFFMkFnd0xJQUJCQ0dvaEFTQUFJQUpCQTNRaUFrRURjallDQkNBQUlBSnFJZ0FnQUNnQ0JFRUJjallDQkF3UkMwR1UwQUFvQWdBaUNDQUVUdzBCSUFFRVFBSkFRUUlnQUhRaUFrRUFJQUpyY2lBQklBQjBjV2dpQUVFRGRDSUNRYlRRQUdvaUFTQUNRYnpRQUdvb0FnQWlBaWdDQ0NJRFJnUkFRWXpRQUNBR1FYNGdBSGR4SWdZMkFnQU1BUXNnQVNBRE5nSUlJQU1nQVRZQ0RBc2dBaUFFUVFOeU5nSUVJQUJCQTNRaUFDQUVheUVGSUFBZ0Ftb2dCVFlDQUNBQ0lBUnFJZ1FnQlVFQmNqWUNCQ0FJQkVBZ0NFRjRjVUcwMEFCcUlRQkJvTkFBS0FJQUlRTUNmMEVCSUFoQkEzWjBJZ0VnQm5GRkJFQkJqTkFBSUFFZ0JuSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQklBTTJBZ3dnQUNBRE5nSUlJQU1nQURZQ0RDQURJQUUyQWdnTElBSkJDR29oQVVHZzBBQWdCRFlDQUVHVTBBQWdCVFlDQUF3UkMwR1EwQUFvQWdBaUMwVU5BU0FMYUVFQ2RFRzgwZ0JxS0FJQUlnQW9BZ1JCZUhFZ0JHc2hCU0FBSVFJRFFBSkFJQUlvQWhBaUFVVUVRQ0FDUVJScUtBSUFJZ0ZGRFFFTElBRW9BZ1JCZUhFZ0JHc2lBeUFGU1NFQ0lBTWdCU0FDR3lFRklBRWdBQ0FDR3lFQUlBRWhBZ3dCQ3dzZ0FDZ0NHQ0VKSUFBb0Fnd2lBeUFBUndSQVFaelFBQ2dDQUJvZ0F5QUFLQUlJSWdFMkFnZ2dBU0FETmdJTURCQUxJQUJCRkdvaUFpZ0NBQ0lCUlFSQUlBQW9BaEFpQVVVTkF5QUFRUkJxSVFJTEEwQWdBaUVISUFFaUEwRVVhaUlDS0FJQUlnRU5BQ0FEUVJCcUlRSWdBeWdDRUNJQkRRQUxJQWRCQURZQ0FBd1BDMEYvSVFRZ0FFRy9mMHNOQUNBQVFSTnFJZ0ZCY0hFaEJFR1EwQUFvQWdBaUNFVU5BRUVBSUFScklRVUNRQUpBQWtBQ2YwRUFJQVJCZ0FKSkRRQWFRUjhnQkVILy8vOEhTdzBBR2lBRVFTWWdBVUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxQ3lJR1FRSjBRYnpTQUdvb0FnQWlBa1VFUUVFQUlRRkJBQ0VEREFFTFFRQWhBU0FFUVJrZ0JrRUJkbXRCQUNBR1FSOUhHM1FoQUVFQUlRTURRQUpBSUFJb0FnUkJlSEVnQkdzaUJ5QUZUdzBBSUFJaEF5QUhJZ1VOQUVFQUlRVWdBaUVCREFNTElBRWdBa0VVYWlnQ0FDSUhJQWNnQWlBQVFSMTJRUVJ4YWtFUWFpZ0NBQ0lDUmhzZ0FTQUhHeUVCSUFCQkFYUWhBQ0FDRFFBTEN5QUJJQU55UlFSQVFRQWhBMEVDSUFaMElnQkJBQ0FBYTNJZ0NIRWlBRVVOQXlBQWFFRUNkRUc4MGdCcUtBSUFJUUVMSUFGRkRRRUxBMEFnQVNnQ0JFRjRjU0FFYXlJQ0lBVkpJUUFnQWlBRklBQWJJUVVnQVNBRElBQWJJUU1nQVNnQ0VDSUFCSDhnQUFVZ0FVRVVhaWdDQUFzaUFRMEFDd3NnQTBVTkFDQUZRWlRRQUNnQ0FDQUVhMDhOQUNBREtBSVlJUWNnQXlBREtBSU1JZ0JIQkVCQm5OQUFLQUlBR2lBQUlBTW9BZ2dpQVRZQ0NDQUJJQUEyQWd3TURnc2dBMEVVYWlJQ0tBSUFJZ0ZGQkVBZ0F5Z0NFQ0lCUlEwRElBTkJFR29oQWdzRFFDQUNJUVlnQVNJQVFSUnFJZ0lvQWdBaUFRMEFJQUJCRUdvaEFpQUFLQUlRSWdFTkFBc2dCa0VBTmdJQURBMExRWlRRQUNnQ0FDSURJQVJQQkVCQm9OQUFLQUlBSVFFQ1FDQURJQVJySWdKQkVFOEVRQ0FCSUFScUlnQWdBa0VCY2pZQ0JDQUJJQU5xSUFJMkFnQWdBU0FFUVFOeU5nSUVEQUVMSUFFZ0EwRURjallDQkNBQklBTnFJZ0FnQUNnQ0JFRUJjallDQkVFQUlRQkJBQ0VDQzBHVTBBQWdBallDQUVHZzBBQWdBRFlDQUNBQlFRaHFJUUVNRHd0Qm1OQUFLQUlBSWdNZ0JFc0VRQ0FFSUFscUlnQWdBeUFFYXlJQlFRRnlOZ0lFUWFUUUFDQUFOZ0lBUVpqUUFDQUJOZ0lBSUFrZ0JFRURjallDQkNBSlFRaHFJUUVNRHd0QkFDRUJJQVFDZjBIazB3QW9BZ0FFUUVIczB3QW9BZ0FNQVF0QjhOTUFRbjgzQWdCQjZOTUFRb0NBaElDQWdNQUFOd0lBUWVUVEFDQUtRUXhxUVhCeFFkaXExYW9GY3pZQ0FFSDQwd0JCQURZQ0FFSEkwd0JCQURZQ0FFR0FnQVFMSWdBZ0JFSEhBR29pQldvaUJrRUFJQUJySWdkeElnSlBCRUJCL05NQVFUQTJBZ0FNRHdzQ1FFSEUwd0FvQWdBaUFVVU5BRUc4MHdBb0FnQWlDQ0FDYWlFQUlBQWdBVTBnQUNBSVMzRU5BRUVBSVFGQi9OTUFRVEEyQWdBTUR3dEJ5Tk1BTFFBQVFRUnhEUVFDUUFKQUlBa0VRRUhNMHdBaEFRTkFJQUVvQWdBaUFDQUpUUVJBSUFBZ0FTZ0NCR29nQ1VzTkF3c2dBU2dDQ0NJQkRRQUxDMEVBRURNaUFFRi9SZzBGSUFJaEJrSG8wd0FvQWdBaUFVRUJheUlESUFCeEJFQWdBaUFBYXlBQUlBTnFRUUFnQVd0eGFpRUdDeUFFSUFaUERRVWdCa0grLy8vL0Iwc05CVUhFMHdBb0FnQWlBd1JBUWJ6VEFDZ0NBQ0lISUFacUlRRWdBU0FIVFEwR0lBRWdBMHNOQmdzZ0JoQXpJZ0VnQUVjTkFRd0hDeUFHSUFOcklBZHhJZ1pCL3YvLy93ZExEUVFnQmhBeklRQWdBQ0FCS0FJQUlBRW9BZ1JxUmcwRElBQWhBUXNDUUNBR0lBUkJ5QUJxVHcwQUlBRkJmMFlOQUVIczB3QW9BZ0FpQUNBRklBWnJha0VBSUFCcmNTSUFRZjcvLy84SFN3UkFJQUVoQUF3SEN5QUFFRE5CZjBjRVFDQUFJQVpxSVFZZ0FTRUFEQWNMUVFBZ0Jtc1FNeG9NQkFzZ0FTSUFRWDlIRFFVTUF3dEJBQ0VEREF3TFFRQWhBQXdLQ3lBQVFYOUhEUUlMUWNqVEFFSEkwd0FvQWdCQkJISTJBZ0FMSUFKQi92Ly8vd2RMRFFFZ0FoQXpJUUJCQUJBeklRRWdBRUYvUmcwQklBRkJmMFlOQVNBQUlBRlBEUUVnQVNBQWF5SUdJQVJCT0dwTkRRRUxRYnpUQUVHODB3QW9BZ0FnQm1vaUFUWUNBRUhBMHdBb0FnQWdBVWtFUUVIQTB3QWdBVFlDQUFzQ1FBSkFBa0JCcE5BQUtBSUFJZ0lFUUVITTB3QWhBUU5BSUFBZ0FTZ0NBQ0lESUFFb0FnUWlCV3BHRFFJZ0FTZ0NDQ0lCRFFBTERBSUxRWnpRQUNnQ0FDSUJRUUJISUFBZ0FVOXhSUVJBUVp6UUFDQUFOZ0lBQzBFQUlRRkIwTk1BSUFZMkFnQkJ6Tk1BSUFBMkFnQkJyTkFBUVg4MkFnQkJzTkFBUWVUVEFDZ0NBRFlDQUVIWTB3QkJBRFlDQUFOQUlBRkJ5TkFBYWlBQlFielFBR29pQWpZQ0FDQUNJQUZCdE5BQWFpSUROZ0lBSUFGQndOQUFhaUFETmdJQUlBRkIwTkFBYWlBQlFjVFFBR29pQXpZQ0FDQURJQUkyQWdBZ0FVSFkwQUJxSUFGQnpOQUFhaUlDTmdJQUlBSWdBellDQUNBQlFkVFFBR29nQWpZQ0FDQUJRU0JxSWdGQmdBSkhEUUFMUVhnZ0FHdEJEM0VpQVNBQWFpSUNJQVpCT0dzaUF5QUJheUlCUVFGeU5nSUVRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFJQUUyQWdCQnBOQUFJQUkyQWdBZ0FDQURha0U0TmdJRURBSUxJQUFnQWswTkFDQUNJQU5KRFFBZ0FTZ0NERUVJY1EwQVFYZ2dBbXRCRDNFaUFDQUNhaUlEUVpqUUFDZ0NBQ0FHYWlJSElBQnJJZ0JCQVhJMkFnUWdBU0FGSUFacU5nSUVRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFJQUEyQWdCQnBOQUFJQU0yQWdBZ0FpQUhha0U0TmdJRURBRUxJQUJCbk5BQUtBSUFTUVJBUVp6UUFDQUFOZ0lBQ3lBQUlBWnFJUU5Cek5NQUlRRUNRQUpBQWtBRFFDQURJQUVvQWdCSEJFQWdBU2dDQ0NJQkRRRU1BZ3NMSUFFdEFBeEJDSEZGRFFFTFFjelRBQ0VCQTBBZ0FTZ0NBQ0lESUFKTkJFQWdBeUFCS0FJRWFpSUZJQUpMRFFNTElBRW9BZ2doQVF3QUN3QUxJQUVnQURZQ0FDQUJJQUVvQWdRZ0JtbzJBZ1FnQUVGNElBQnJRUTl4YWlJSklBUkJBM0kyQWdRZ0EwRjRJQU5yUVE5eGFpSUdJQVFnQ1dvaUJHc2hBU0FDSUFaR0JFQkJwTkFBSUFRMkFnQkJtTkFBUVpqUUFDZ0NBQ0FCYWlJQU5nSUFJQVFnQUVFQmNqWUNCQXdJQzBHZzBBQW9BZ0FnQmtZRVFFR2cwQUFnQkRZQ0FFR1UwQUJCbE5BQUtBSUFJQUZxSWdBMkFnQWdCQ0FBUVFGeU5nSUVJQUFnQkdvZ0FEWUNBQXdJQ3lBR0tBSUVJZ1ZCQTNGQkFVY05CaUFGUVhoeElRZ2dCVUgvQVUwRVFDQUZRUU4ySVFNZ0JpZ0NDQ0lBSUFZb0Fnd2lBa1lFUUVHTTBBQkJqTkFBS0FJQVFYNGdBM2R4TmdJQURBY0xJQUlnQURZQ0NDQUFJQUkyQWd3TUJnc2dCaWdDR0NFSElBWWdCaWdDRENJQVJ3UkFJQUFnQmlnQ0NDSUNOZ0lJSUFJZ0FEWUNEQXdGQ3lBR1FSUnFJZ0lvQWdBaUJVVUVRQ0FHS0FJUUlnVkZEUVFnQmtFUWFpRUNDd05BSUFJaEF5QUZJZ0JCRkdvaUFpZ0NBQ0lGRFFBZ0FFRVFhaUVDSUFBb0FoQWlCUTBBQ3lBRFFRQTJBZ0FNQkF0QmVDQUFhMEVQY1NJQklBQnFJZ2NnQmtFNGF5SURJQUZySWdGQkFYSTJBZ1FnQUNBRGFrRTROZ0lFSUFJZ0JVRTNJQVZyUVE5eGFrRS9heUlESUFNZ0FrRVFha2tiSWdOQkl6WUNCRUdvMEFCQjlOTUFLQUlBTmdJQVFaalFBQ0FCTmdJQVFhVFFBQ0FITmdJQUlBTkJFR3BCMU5NQUtRSUFOd0lBSUFOQnpOTUFLUUlBTndJSVFkVFRBQ0FEUVFocU5nSUFRZERUQUNBR05nSUFRY3pUQUNBQU5nSUFRZGpUQUVFQU5nSUFJQU5CSkdvaEFRTkFJQUZCQnpZQ0FDQUZJQUZCQkdvaUFVc05BQXNnQWlBRFJnMEFJQU1nQXlnQ0JFRitjVFlDQkNBRElBTWdBbXNpQlRZQ0FDQUNJQVZCQVhJMkFnUWdCVUgvQVUwRVFDQUZRWGh4UWJUUUFHb2hBQUovUVl6UUFDZ0NBQ0lCUVFFZ0JVRURkblFpQTNGRkJFQkJqTkFBSUFFZ0EzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQklBSTJBZ3dnQUNBQ05nSUlJQUlnQURZQ0RDQUNJQUUyQWdnTUFRdEJIeUVCSUFWQi8vLy9CMDBFUUNBRlFTWWdCVUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxSVFFTElBSWdBVFlDSENBQ1FnQTNBaEFnQVVFQ2RFRzgwZ0JxSVFCQmtOQUFLQUlBSWdOQkFTQUJkQ0lHY1VVRVFDQUFJQUkyQWdCQmtOQUFJQU1nQm5JMkFnQWdBaUFBTmdJWUlBSWdBallDQ0NBQ0lBSTJBZ3dNQVFzZ0JVRVpJQUZCQVhaclFRQWdBVUVmUnh0MElRRWdBQ2dDQUNFREFrQURRQ0FESWdBb0FnUkJlSEVnQlVZTkFTQUJRUjEySVFNZ0FVRUJkQ0VCSUFBZ0EwRUVjV3BCRUdvaUJpZ0NBQ0lERFFBTElBWWdBallDQUNBQ0lBQTJBaGdnQWlBQ05nSU1JQUlnQWpZQ0NBd0JDeUFBS0FJSUlnRWdBallDRENBQUlBSTJBZ2dnQWtFQU5nSVlJQUlnQURZQ0RDQUNJQUUyQWdnTFFaalFBQ2dDQUNJQklBUk5EUUJCcE5BQUtBSUFJZ0FnQkdvaUFpQUJJQVJySWdGQkFYSTJBZ1JCbU5BQUlBRTJBZ0JCcE5BQUlBSTJBZ0FnQUNBRVFRTnlOZ0lFSUFCQkNHb2hBUXdJQzBFQUlRRkIvTk1BUVRBMkFnQU1Cd3RCQUNFQUN5QUhSUTBBQWtBZ0JpZ0NIQ0lDUVFKMFFielNBR29pQXlnQ0FDQUdSZ1JBSUFNZ0FEWUNBQ0FBRFFGQmtOQUFRWkRRQUNnQ0FFRitJQUozY1RZQ0FBd0NDeUFIUVJCQkZDQUhLQUlRSUFaR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFjMkFoZ2dCaWdDRUNJQ0JFQWdBQ0FDTmdJUUlBSWdBRFlDR0FzZ0JrRVVhaWdDQUNJQ1JRMEFJQUJCRkdvZ0FqWUNBQ0FDSUFBMkFoZ0xJQUVnQ0dvaEFTQUdJQWhxSWdZb0FnUWhCUXNnQmlBRlFYNXhOZ0lFSUFFZ0JHb2dBVFlDQUNBRUlBRkJBWEkyQWdRZ0FVSC9BVTBFUUNBQlFYaHhRYlRRQUdvaEFBSi9RWXpRQUNnQ0FDSUNRUUVnQVVFRGRuUWlBWEZGQkVCQmpOQUFJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUlCSUFRMkFnd2dBQ0FFTmdJSUlBUWdBRFlDRENBRUlBRTJBZ2dNQVF0Qkh5RUZJQUZCLy8vL0IwMEVRQ0FCUVNZZ0FVRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFJUVVMSUFRZ0JUWUNIQ0FFUWdBM0FoQWdCVUVDZEVHODBnQnFJUUJCa05BQUtBSUFJZ0pCQVNBRmRDSURjVVVFUUNBQUlBUTJBZ0JCa05BQUlBSWdBM0kyQWdBZ0JDQUFOZ0lZSUFRZ0JEWUNDQ0FFSUFRMkFnd01BUXNnQVVFWklBVkJBWFpyUVFBZ0JVRWZSeHQwSVFVZ0FDZ0NBQ0VBQWtBRFFDQUFJZ0lvQWdSQmVIRWdBVVlOQVNBRlFSMTJJUUFnQlVFQmRDRUZJQUlnQUVFRWNXcEJFR29pQXlnQ0FDSUFEUUFMSUFNZ0JEWUNBQ0FFSUFJMkFoZ2dCQ0FFTmdJTUlBUWdCRFlDQ0F3QkN5QUNLQUlJSWdBZ0JEWUNEQ0FDSUFRMkFnZ2dCRUVBTmdJWUlBUWdBallDRENBRUlBQTJBZ2dMSUFsQkNHb2hBUXdDQ3dKQUlBZEZEUUFDUUNBREtBSWNJZ0ZCQW5SQnZOSUFhaUlDS0FJQUlBTkdCRUFnQWlBQU5nSUFJQUFOQVVHUTBBQWdDRUYrSUFGM2NTSUlOZ0lBREFJTElBZEJFRUVVSUFjb0FoQWdBMFliYWlBQU5nSUFJQUJGRFFFTElBQWdCellDR0NBREtBSVFJZ0VFUUNBQUlBRTJBaEFnQVNBQU5nSVlDeUFEUVJScUtBSUFJZ0ZGRFFBZ0FFRVVhaUFCTmdJQUlBRWdBRFlDR0FzQ1FDQUZRUTlOQkVBZ0F5QUVJQVZxSWdCQkEzSTJBZ1FnQUNBRGFpSUFJQUFvQWdSQkFYSTJBZ1FNQVFzZ0F5QUVhaUlDSUFWQkFYSTJBZ1FnQXlBRVFRTnlOZ0lFSUFJZ0JXb2dCVFlDQUNBRlFmOEJUUVJBSUFWQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnRkJBU0FGUVFOMmRDSUZjVVVFUUVHTTBBQWdBU0FGY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FpQUFOZ0lNSUFJZ0FUWUNDQXdCQzBFZklRRWdCVUgvLy84SFRRUkFJQVZCSmlBRlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBUXNnQWlBQk5nSWNJQUpDQURjQ0VDQUJRUUowUWJ6U0FHb2hBRUVCSUFGMElnUWdDSEZGQkVBZ0FDQUNOZ0lBUVpEUUFDQUVJQWh5TmdJQUlBSWdBRFlDR0NBQ0lBSTJBZ2dnQWlBQ05nSU1EQUVMSUFWQkdTQUJRUUYyYTBFQUlBRkJIMGNiZENFQklBQW9BZ0FoQkFKQUEwQWdCQ0lBS0FJRVFYaHhJQVZHRFFFZ0FVRWRkaUVFSUFGQkFYUWhBU0FBSUFSQkJIRnFRUkJxSWdZb0FnQWlCQTBBQ3lBR0lBSTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0RDQUNJQUkyQWdnTUFRc2dBQ2dDQ0NJQklBSTJBZ3dnQUNBQ05nSUlJQUpCQURZQ0dDQUNJQUEyQWd3Z0FpQUJOZ0lJQ3lBRFFRaHFJUUVNQVFzQ1FDQUpSUTBBQWtBZ0FDZ0NIQ0lCUVFKMFFielNBR29pQWlnQ0FDQUFSZ1JBSUFJZ0F6WUNBQ0FERFFGQmtOQUFJQXRCZmlBQmQzRTJBZ0FNQWdzZ0NVRVFRUlFnQ1NnQ0VDQUFSaHRxSUFNMkFnQWdBMFVOQVFzZ0F5QUpOZ0lZSUFBb0FoQWlBUVJBSUFNZ0FUWUNFQ0FCSUFNMkFoZ0xJQUJCRkdvb0FnQWlBVVVOQUNBRFFSUnFJQUUyQWdBZ0FTQUROZ0lZQ3dKQUlBVkJEMDBFUUNBQUlBUWdCV29pQVVFRGNqWUNCQ0FBSUFGcUlnRWdBU2dDQkVFQmNqWUNCQXdCQ3lBQUlBUnFJZ2NnQlVFQmNqWUNCQ0FBSUFSQkEzSTJBZ1FnQlNBSGFpQUZOZ0lBSUFnRVFDQUlRWGh4UWJUUUFHb2hBVUdnMEFBb0FnQWhBd0ovUVFFZ0NFRURkblFpQWlBR2NVVUVRRUdNMEFBZ0FpQUdjallDQUNBQkRBRUxJQUVvQWdnTElnSWdBellDRENBQklBTTJBZ2dnQXlBQk5nSU1JQU1nQWpZQ0NBdEJvTkFBSUFjMkFnQkJsTkFBSUFVMkFnQUxJQUJCQ0dvaEFRc2dDa0VRYWlRQUlBRUxRd0FnQUVVRVFEOEFRUkIwRHdzQ1FDQUFRZi8vQTNFTkFDQUFRUUJJRFFBZ0FFRVFka0FBSWdCQmYwWUVRRUg4MHdCQk1EWUNBRUYvRHdzZ0FFRVFkQThMQUFzTDNEOGlBRUdBQ0FzSkFRQUFBQUlBQUFBREFFR1VDQXNGQkFBQUFBVUFRYVFJQ3drR0FBQUFCd0FBQUFnQVFkd0lDNG90U1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCeGRXVnllUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMkp2WkhrQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnYjNabGNtWnNiM2NBUTJoMWJtc2djMmw2WlNCdmRtVnlabXh2ZHdCU1pYTndiMjV6WlNCdmRtVnlabXh2ZHdCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1NGUlVVQzk0TG5nZ2NtVnhkV1Z6ZEFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1VsUlRVQzk0TG5nZ2NtVnhkV1Z6ZEFCRmVIQmxZM1JsWkNCVFQxVlNRMFVnYldWMGFHOWtJR1p2Y2lCSlEwVXZlQzU0SUhKbGNYVmxjM1FBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCbWNtRm5iV1Z1ZENCemRHRnlkQUJGZUhCbFkzUmxaQ0JrYjNRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5emRHRjBkWE1BU1c1MllXeHBaQ0J5WlhOd2IyNXpaU0J6ZEdGMGRYTUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjd0JWYzJWeUlHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXlaWE5sZEdBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJobFlXUmxjbUFnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDIxbGMzTmhaMlZmWW1WbmFXNWdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZkbUZzZFdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXpkR0YwZFhOZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOTJaWEp6YVc5dVgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZkWEpzWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5b1pXRmtaWEpmZG1Gc2RXVmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhOellXZGxYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYldWMGFHOWtYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYUdWaFpHVnlYMlpwWld4a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgyNWhiV1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBRlZ1Wlhod1pXTjBaV1FnWTJoaGNpQnBiaUIxY213Z2MyVnlkbVZ5QUVsdWRtRnNhV1FnYUdWaFpHVnlJSFpoYkhWbElHTm9ZWElBU1c1MllXeHBaQ0JvWldGa1pYSWdabWxsYkdRZ1kyaGhjZ0JUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM1psY25OcGIyNEFTVzUyWVd4cFpDQnRhVzV2Y2lCMlpYSnphVzl1QUVsdWRtRnNhV1FnYldGcWIzSWdkbVZ5YzJsdmJnQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUIyWlhKemFXOXVBRVY0Y0dWamRHVmtJRU5TVEVZZ1lXWjBaWElnZG1WeWMybHZiZ0JKYm5aaGJHbGtJRWhVVkZBZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUdobFlXUmxjaUIwYjJ0bGJnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzVnliQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjbk1nYVc0Z2RYSnNBRlZ1Wlhod1pXTjBaV1FnYzNSaGNuUWdZMmhoY2lCcGJpQjFjbXdBUkc5MVlteGxJRUFnYVc0Z2RYSnNBRVZ0Y0hSNUlFTnZiblJsYm5RdFRHVnVaM1JvQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlFTnZiblJsYm5RdFRHVnVaM1JvQUVSMWNHeHBZMkYwWlNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUhCaGRHZ0FRMjl1ZEdWdWRDMU1aVzVuZEdnZ1kyRnVKM1FnWW1VZ2NISmxjMlZ1ZENCM2FYUm9JRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJSE5wZW1VQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCMllXeDFaUUJOYVhOemFXNW5JR1Y0Y0dWamRHVmtJRXhHSUdGbWRHVnlJR2hsWVdSbGNpQjJZV3gxWlFCSmJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBZ2FHVmhaR1Z5SUhaaGJIVmxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nY1hWdmRHVWdkbUZzZFdVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QnhkVzkwWldRZ2RtRnNkV1VBVUdGMWMyVmtJR0o1SUc5dVgyaGxZV1JsY25OZlkyOXRjR3hsZEdVQVNXNTJZV3hwWkNCRlQwWWdjM1JoZEdVQWIyNWZjbVZ6WlhRZ2NHRjFjMlVBYjI1ZlkyaDFibXRmYUdWaFpHVnlJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZbVZuYVc0Z2NHRjFjMlVBYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxJSEJoZFhObEFHOXVYM04wWVhSMWMxOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOTJaWEp6YVc5dVgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgzVnliRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlqYUhWdWExOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOW9aV0ZrWlhKZmRtRnNkV1ZmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDl0WlhSb2IyUmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDl1WVcxbElIQmhkWE5sQUZWdVpYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdjM1JoY25RZ2JHbHVaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2JtRnRaUUJRWVhWelpTQnZiaUJEVDA1T1JVTlVMMVZ3WjNKaFpHVUFVR0YxYzJVZ2IyNGdVRkpKTDFWd1ozSmhaR1VBUlhod1pXTjBaV1FnU0ZSVVVDOHlJRU52Ym01bFkzUnBiMjRnVUhKbFptRmpaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMjFsZEdodlpBQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUJ0WlhSb2IyUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOW9aV0ZrWlhKZlptbGxiR1FBVUdGMWMyVmtBRWx1ZG1Gc2FXUWdkMjl5WkNCbGJtTnZkVzUwWlhKbFpBQkpiblpoYkdsa0lHMWxkR2h2WkNCbGJtTnZkVzUwWlhKbFpBQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhOamFHVnRZUUJTWlhGMVpYTjBJR2hoY3lCcGJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBQVUxZEpWRU5JWDFCU1QxaFpBRlZUUlY5UVVrOVlXUUJOUzBGRFZFbFdTVlJaQUZWT1VGSlBRMFZUVTBGQ1RFVmZSVTVVU1ZSWkFFTlBVRmtBVFU5V1JVUmZVRVZTVFVGT1JVNVVURmtBVkU5UFgwVkJVa3haQUU1UFZFbEdXUUJHUVVsTVJVUmZSRVZRUlU1RVJVNURXUUJDUVVSZlIwRlVSVmRCV1FCUVRFRlpBRkJWVkFCRFNFVkRTMDlWVkFCSFFWUkZWMEZaWDFSSlRVVlBWVlFBVWtWUlZVVlRWRjlVU1UxRlQxVlVBRTVGVkZkUFVrdGZRMDlPVGtWRFZGOVVTVTFGVDFWVUFFTlBUazVGUTFSSlQwNWZWRWxOUlU5VlZBQk1UMGRKVGw5VVNVMUZUMVZVQUU1RlZGZFBVa3RmVWtWQlJGOVVTVTFGVDFWVUFGQlBVMVFBVFVsVFJFbFNSVU5VUlVSZlVrVlJWVVZUVkFCRFRFbEZUbFJmUTB4UFUwVkVYMUpGVVZWRlUxUUFRMHhKUlU1VVgwTk1UMU5GUkY5TVQwRkVYMEpCVEVGT1EwVkVYMUpGVVZWRlUxUUFRa0ZFWDFKRlVWVkZVMVFBU0ZSVVVGOVNSVkZWUlZOVVgxTkZUbFJmVkU5ZlNGUlVVRk5mVUU5U1ZBQlNSVkJQVWxRQVNVMWZRVjlVUlVGUVQxUUFVa1ZUUlZSZlEwOU9WRVZPVkFCT1QxOURUMDVVUlU1VUFGQkJVbFJKUVV4ZlEwOU9WRVZPVkFCSVVFVmZTVTVXUVV4SlJGOURUMDVUVkVGT1ZBQklVRVZmUTBKZlVrVlRSVlFBUjBWVUFFaFFSVjlUVkZKSlExUUFRMDlPUmt4SlExUUFWRVZOVUU5U1FWSlpYMUpGUkVsU1JVTlVBRkJGVWsxQlRrVk9WRjlTUlVSSlVrVkRWQUJEVDA1T1JVTlVBRTFWVEZSSlgxTlVRVlJWVXdCSVVFVmZTVTVXUVV4SlJGOVRWRUZVVlZNQVZFOVBYMDFCVGxsZlVrVlJWVVZUVkZNQVJVRlNURmxmU0VsT1ZGTUFWVTVCVmtGSlRFRkNURVZmUms5U1gweEZSMEZNWDFKRlFWTlBUbE1BVDFCVVNVOU9Vd0JUVjBsVVEwaEpUa2RmVUZKUFZFOURUMHhUQUZaQlVrbEJUbFJmUVV4VFQxOU9SVWRQVkVsQlZFVlRBRTFWVEZSSlVFeEZYME5JVDBsRFJWTUFTVTVVUlZKT1FVeGZVMFZTVmtWU1gwVlNVazlTQUZkRlFsOVRSVkpXUlZKZlZVNUxUazlYVGw5RlVsSlBVZ0JTUVVsTVIxVk9YMFZTVWs5U0FFbEVSVTVVU1ZSWlgxQlNUMVpKUkVWU1gwRlZWRWhGVGxSSlEwRlVTVTlPWDBWU1VrOVNBRk5UVEY5RFJWSlVTVVpKUTBGVVJWOUZVbEpQVWdCSlRsWkJURWxFWDFoZlJrOVNWMEZTUkVWRVgwWlBVZ0JUUlZSZlVFRlNRVTFGVkVWU0FFZEZWRjlRUVZKQlRVVlVSVklBU0ZCRlgxVlRSVklBVTBWRlgwOVVTRVZTQUVoUVJWOURRbDlEU0ZWT1MxOUlSVUZFUlZJQVRVdERRVXhGVGtSQlVnQlRSVlJWVUFCWFJVSmZVMFZTVmtWU1gwbFRYMFJQVjA0QVZFVkJVa1JQVjA0QVNGQkZYME5NVDFORlJGOURUMDVPUlVOVVNVOU9BRWhGVlZKSlUxUkpRMTlGV0ZCSlVrRlVTVTlPQUVSSlUwTlBUazVGUTFSRlJGOVBVRVZTUVZSSlQwNEFUazlPWDBGVlZFaFBVa2xVUVZSSlZrVmZTVTVHVDFKTlFWUkpUMDRBU0ZCRlgwbE9Wa0ZNU1VSZlZrVlNVMGxQVGdCSVVFVmZRMEpmVFVWVFUwRkhSVjlDUlVkSlRnQlRTVlJGWDBsVFgwWlNUMXBGVGdCSVVFVmZTVTVXUVV4SlJGOUlSVUZFUlZKZlZFOUxSVTRBU1U1V1FVeEpSRjlVVDB0RlRnQkdUMUpDU1VSRVJVNEFSVTVJUVU1RFJWOVpUMVZTWDBOQlRFMEFTRkJGWDBsT1ZrRk1TVVJmVlZKTUFFSk1UME5MUlVSZlFsbGZVRUZTUlU1VVFVeGZRMDlPVkZKUFRBQk5TME5QVEFCQlEwd0FTRkJGWDBsT1ZFVlNUa0ZNQUZKRlVWVkZVMVJmU0VWQlJFVlNYMFpKUlV4RVUxOVVUMDlmVEVGU1IwVmZWVTVQUmtaSlEwbEJUQUJJVUVWZlQwc0FWVTVNU1U1TEFGVk9URTlEU3dCUVVra0FVa1ZVVWxsZlYwbFVTQUJJVUVWZlNVNVdRVXhKUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJJVUVWZlZVNUZXRkJGUTFSRlJGOURUMDVVUlU1VVgweEZUa2RVU0FCR1RGVlRTQUJRVWs5UVVFRlVRMGdBVFMxVFJVRlNRMGdBVlZKSlgxUlBUMTlNVDA1SEFGQlNUME5GVTFOSlRrY0FUVWxUUTBWTVRFRk9SVTlWVTE5UVJWSlRTVk5VUlU1VVgxZEJVazVKVGtjQVRVbFRRMFZNVEVGT1JVOVZVMTlYUVZKT1NVNUhBRWhRUlY5SlRsWkJURWxFWDFSU1FVNVRSa1ZTWDBWT1EwOUVTVTVIQUVWNGNHVmpkR1ZrSUVOU1RFWUFTRkJGWDBsT1ZrRk1TVVJmUTBoVlRrdGZVMGxhUlFCTlQxWkZBRU5QVGxSSlRsVkZBRWhRUlY5RFFsOVRWRUZVVlZOZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbE5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMVpGVWxOSlQwNWZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxVlNURjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZRMGhWVGt0ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbDlXUVV4VlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUlZoVVJVNVRTVTlPWDFaQlRGVkZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOURTRlZPUzE5RldGUkZUbE5KVDA1ZlRrRk5SVjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZUVVZUVTBGSFJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlRVVlVTRTlFWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSmZSa2xGVEVSZlEwOU5VRXhGVkVVQVJFVk1SVlJGQUVoUVJWOUpUbFpCVEVsRVgwVlBSbDlUVkVGVVJRQkpUbFpCVEVsRVgxTlRURjlEUlZKVVNVWkpRMEZVUlFCUVFWVlRSUUJPVDE5U1JWTlFUMDVUUlFCVlRsTlZVRkJQVWxSRlJGOU5SVVJKUVY5VVdWQkZBRWRQVGtVQVRrOVVYMEZEUTBWUVZFRkNURVVBVTBWU1ZrbERSVjlWVGtGV1FVbE1RVUpNUlFCU1FVNUhSVjlPVDFSZlUwRlVTVk5HU1VGQ1RFVUFUMUpKUjBsT1gwbFRYMVZPVWtWQlEwaEJRa3hGQUZKRlUxQlBUbE5GWDBsVFgxTlVRVXhGQUZCVlVrZEZBRTFGVWtkRkFGSkZVVlZGVTFSZlNFVkJSRVZTWDBaSlJVeEVVMTlVVDA5ZlRFRlNSMFVBVWtWUlZVVlRWRjlJUlVGRVJWSmZWRTlQWDB4QlVrZEZBRkJCV1V4UFFVUmZWRTlQWDB4QlVrZEZBRWxPVTFWR1JrbERTVVZPVkY5VFZFOVNRVWRGQUVoUVJWOVFRVlZUUlVSZlZWQkhVa0ZFUlFCSVVFVmZVRUZWVTBWRVgwZ3lYMVZRUjFKQlJFVUFVMDlWVWtORkFFRk9UazlWVGtORkFGUlNRVU5GQUVoUVJWOVZUa1ZZVUVWRFZFVkVYMU5RUVVORkFFUkZVME5TU1VKRkFGVk9VMVZDVTBOU1NVSkZBRkpGUTA5U1JBQklVRVZmU1U1V1FVeEpSRjlOUlZSSVQwUUFUazlVWDBaUFZVNUVBRkJTVDFCR1NVNUVBRlZPUWtsT1JBQlNSVUpKVGtRQVZVNUJWVlJJVDFKSldrVkVBRTFGVkVoUFJGOU9UMVJmUVV4TVQxZEZSQUJJVkZSUVgxWkZVbE5KVDA1ZlRrOVVYMU5WVUZCUFVsUkZSQUJCVEZKRlFVUlpYMUpGVUU5U1ZFVkVBRUZEUTBWUVZFVkVBRTVQVkY5SlRWQk1SVTFGVGxSRlJBQk1UMDlRWDBSRlZFVkRWRVZFQUVoUVJWOURVbDlGV0ZCRlExUkZSQUJJVUVWZlRFWmZSVmhRUlVOVVJVUUFRMUpGUVZSRlJBQkpUVjlWVTBWRUFFaFFSVjlRUVZWVFJVUUFWRWxOUlU5VlZGOVBRME5WVWtWRUFGQkJXVTFGVGxSZlVrVlJWVWxTUlVRQVVGSkZRMDlPUkVsVVNVOU9YMUpGVVZWSlVrVkVBRkJTVDFoWlgwRlZWRWhGVGxSSlEwRlVTVTlPWDFKRlVWVkpVa1ZFQUU1RlZGZFBVa3RmUVZWVVNFVk9WRWxEUVZSSlQwNWZVa1ZSVlVsU1JVUUFURVZPUjFSSVgxSkZVVlZKVWtWRUFGTlRURjlEUlZKVVNVWkpRMEZVUlY5U1JWRlZTVkpGUkFCVlVFZFNRVVJGWDFKRlVWVkpVa1ZFQUZCQlIwVmZSVmhRU1ZKRlJBQlFVa1ZEVDA1RVNWUkpUMDVmUmtGSlRFVkVBRVZZVUVWRFZFRlVTVTlPWDBaQlNVeEZSQUJTUlZaQlRFbEVRVlJKVDA1ZlJrRkpURVZFQUZOVFRGOUlRVTVFVTBoQlMwVmZSa0ZKVEVWRUFFeFBRMHRGUkFCVVVrRk9VMFpQVWsxQlZFbFBUbDlCVUZCTVNVVkVBRTVQVkY5TlQwUkpSa2xGUkFCT1QxUmZSVmhVUlU1RVJVUUFRa0ZPUkZkSlJGUklYMHhKVFVsVVgwVllRMFZGUkVWRUFGTkpWRVZmU1ZOZlQxWkZVa3hQUVVSRlJBQklSVUZFQUVWNGNHVmpkR1ZrSUVoVVZGQXZBQUJlRXdBQUpoTUFBREFRQUFEd0Z3QUFuUk1BQUJVU0FBQTVGd0FBOEJJQUFBb1FBQUIxRWdBQXJSSUFBSUlUQUFCUEZBQUFmeEFBQUtBVkFBQWpGQUFBaVJJQUFJc1VBQUJORlFBQTFCRUFBTThVQUFBUUdBQUF5UllBQU53V0FBREJFUUFBNEJjQUFMc1VBQUIwRkFBQWZCVUFBT1VVQUFBSUZ3QUFIeEFBQUdVVkFBQ2pGQUFBS0JVQUFBSVZBQUNaRlFBQUxCQUFBSXNaQUFCUER3QUExQTRBQUdvUUFBRE9FQUFBQWhjQUFJa09BQUJ1RXdBQUhCTUFBR1lVQUFCV0Z3QUF3Uk1BQU0wVEFBQnNFd0FBYUJjQUFHWVhBQUJmRndBQUloTUFBTTRQQUFCcERnQUEyQTRBQUdNV0FBRExFd0FBcWc0QUFDZ1hBQUFtRndBQXhSTUFBRjBXQUFEb0VRQUFaeE1BQUdVVEFBRHlGZ0FBY3hNQUFCMFhBQUQ1RmdBQTh4RUFBTThPQUFET0ZRQUFEQklBQUxNUkFBQ2xFUUFBWVJBQUFESVhBQUM3RXdCQitUVUxBUUVBUVpBMkMrQUJBUUVDQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFRZjAzQ3dFQkFFR1JPQXRlQWdNQ0FnSUNBZ0FBQWdJQUFnSUFBZ0lDQWdJQ0FnSUNBZ0FFQUFBQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFJQUFnQkIvVGtMQVFFQVFaRTZDMTRDQUFJQ0FnSUNBQUFDQWdBQ0FnQUNBZ0lDQWdJQ0FnSUNBQU1BQkFBQUFBSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdBQ0FFSHdPd3NOYkc5elpXVmxjQzFoYkdsMlpRQkJpVHdMQVFFQVFhQThDK0FCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBUVlrK0N3RUJBRUdnUGd2bkFRRUJBUUVCQVFFQkFRRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQlkyaDFibXRsWkFCQnNNQUFDMThCQVFBQkFRRUJBUUFBQVFFQUFRRUFBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQUFRQkJrTUlBQ3lGbFkzUnBiMjVsYm5RdGJHVnVaM1JvYjI1eWIzaDVMV052Ym01bFkzUnBiMjRBUWNEQ0FBc3RjbUZ1YzJabGNpMWxibU52WkdsdVozQm5jbUZrWlEwS0RRb05DbE5ORFFvTkNsUlVVQzlEUlM5VVUxQXZBRUg1d2dBTEJRRUNBQUVEQUVHUXd3QUw0QUVFQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCK2NRQUN3VUJBZ0FCQXdCQmtNVUFDK0FCQkFFQkJRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBUWZuR0FBc0VBUUFBQVFCQmtjY0FDOThCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCK3NnQUN3UUJBQUFDQUVHUXlRQUxYd01FQUFBRUJBUUVCQVFFQkFRRUJBVUVCQVFFQkFRRUJBUUVCQVFBQkFBR0J3UUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBRUFFSDZ5Z0FMQkFFQUFBRUFRWkRMQUFzQkFRQkJxc3NBQzBFQ0FBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QkIrc3dBQ3dRQkFBQUJBRUdRelFBTEFRRUFRWnJOQUFzR0FnQUFBQUFDQUVHeHpRQUxPZ01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQVFmRE9BQXVXQVU1UFZVNURSVVZEUzA5VlZFNUZRMVJGVkVWRFVrbENSVXhWVTBoRlZFVkJSRk5GUVZKRFNGSkhSVU5VU1ZaSlZGbE1SVTVFUVZKV1JVOVVTVVpaVUZSSlQwNVRRMGhUUlVGWlUxUkJWRU5JUjBWUFVrUkpVa1ZEVkU5U1ZGSkRTRkJCVWtGTlJWUkZVbFZTUTBWQ1UwTlNTVUpGUVZKRVQxZE9RVU5GU1U1RVRrdERTMVZDVTBOU1NVSkZTRlJVVUM5QlJGUlFMdz09JywgJ2Jhc2U2NCcpXG4iXSwibmFtZXMiOlsiQnVmZmVyIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJmcm9tIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key)=>{\n        const value = obj[key];\n        if (typeof value === 'number') {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsU0FBU0UsVUFBVUMsR0FBRztJQUNsQixNQUFNQyxNQUFNLENBQUM7SUFDYk4sT0FBT08sSUFBSSxDQUFDRixLQUFLRyxPQUFPLENBQUMsQ0FBQ0M7UUFDdEIsTUFBTU4sUUFBUUUsR0FBRyxDQUFDSSxJQUFJO1FBQ3RCLElBQUksT0FBT04sVUFBVSxVQUFVO1lBQzNCRyxHQUFHLENBQUNHLElBQUksR0FBR047UUFDZjtJQUNKO0lBQ0EsT0FBT0c7QUFDWDtBQUNBSixpQkFBaUIsR0FBR0UsV0FDcEIsaUNBQWlDIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGxsaHR0cFxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVudW1Ub01hcCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVudW1Ub01hcChvYmopIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVudW1Ub01hcCA9IGVudW1Ub01hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1Ub01hcCIsIm9iaiIsInJlcyIsImtleXMiLCJmb3JFYWNoIiwia2V5Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst Agent = __webpack_require__(/*! ../dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nconst { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(ssr)/./node_modules/undici/lib/mock/mock-client.js\");\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(ssr)/./node_modules/undici/lib/mock/mock-pool.js\");\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst Dispatcher = __webpack_require__(/*! ../dispatcher/dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\");\nconst Pluralizer = __webpack_require__(/*! ./pluralizer */ \"(ssr)/./node_modules/undici/lib/mock/pluralizer.js\");\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\");\nclass MockAgent extends Dispatcher {\n    constructor(opts){\n        super(opts);\n        this[kNetConnect] = true;\n        this[kIsMockActive] = true;\n        // Instantiate Agent and encapsulate\n        if (opts?.agent && typeof opts.agent.dispatch !== 'function') {\n            throw new InvalidArgumentError('Argument opts.agent must implement Agent');\n        }\n        const agent = opts?.agent ? opts.agent : new Agent(opts);\n        this[kAgent] = agent;\n        this[kClients] = agent[kClients];\n        this[kOptions] = buildMockOptions(opts);\n    }\n    get(origin) {\n        let dispatcher = this[kMockAgentGet](origin);\n        if (!dispatcher) {\n            dispatcher = this[kFactory](origin);\n            this[kMockAgentSet](origin, dispatcher);\n        }\n        return dispatcher;\n    }\n    dispatch(opts, handler) {\n        // Call MockAgent.get to perform additional setup before dispatching as normal\n        this.get(opts.origin);\n        return this[kAgent].dispatch(opts, handler);\n    }\n    async close() {\n        await this[kAgent].close();\n        this[kClients].clear();\n    }\n    deactivate() {\n        this[kIsMockActive] = false;\n    }\n    activate() {\n        this[kIsMockActive] = true;\n    }\n    enableNetConnect(matcher) {\n        if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n            if (Array.isArray(this[kNetConnect])) {\n                this[kNetConnect].push(matcher);\n            } else {\n                this[kNetConnect] = [\n                    matcher\n                ];\n            }\n        } else if (typeof matcher === 'undefined') {\n            this[kNetConnect] = true;\n        } else {\n            throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.');\n        }\n    }\n    disableNetConnect() {\n        this[kNetConnect] = false;\n    }\n    // This is required to bypass issues caused by using global symbols - see:\n    // https://github.com/nodejs/undici/issues/1447\n    get isMockActive() {\n        return this[kIsMockActive];\n    }\n    [kMockAgentSet](origin, dispatcher) {\n        this[kClients].set(origin, dispatcher);\n    }\n    [kFactory](origin) {\n        const mockOptions = Object.assign({\n            agent: this\n        }, this[kOptions]);\n        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n    }\n    [kMockAgentGet](origin) {\n        // First check if we can immediately find it\n        const client = this[kClients].get(origin);\n        if (client) {\n            return client;\n        }\n        // If the origin is not a string create a dummy parent pool and return to user\n        if (typeof origin !== 'string') {\n            const dispatcher = this[kFactory]('http://localhost:9999');\n            this[kMockAgentSet](origin, dispatcher);\n            return dispatcher;\n        }\n        // If we match, create a pool and assign the same dispatches\n        for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])){\n            if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n                const dispatcher = this[kFactory](origin);\n                this[kMockAgentSet](origin, dispatcher);\n                dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n                return dispatcher;\n            }\n        }\n    }\n    [kGetNetConnect]() {\n        return this[kNetConnect];\n    }\n    pendingInterceptors() {\n        const mockAgentClients = this[kClients];\n        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope])=>scope[kDispatches].map((dispatch)=>({\n                    ...dispatch,\n                    origin\n                }))).filter(({ pending })=>pending);\n    }\n    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n        const pending = this.pendingInterceptors();\n        if (pending.length === 0) {\n            return;\n        }\n        const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);\n        throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n    }\n}\nmodule.exports = MockAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQVEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyx3RUFBaUI7QUFDOUMsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsZ0ZBQXFCO0FBQzNDLE1BQU0sRUFDSkUsTUFBTSxFQUNOQyxhQUFhLEVBQ2JDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsY0FBYyxFQUNkQyxRQUFRLEVBQ1JDLFFBQVEsRUFDVCxHQUFHVixtQkFBT0EsQ0FBQyw0RUFBZ0I7QUFDNUIsTUFBTVcsYUFBYVgsbUJBQU9BLENBQUMsMEVBQWU7QUFDMUMsTUFBTVksV0FBV1osbUJBQU9BLENBQUMsc0VBQWE7QUFDdEMsTUFBTSxFQUFFYSxVQUFVLEVBQUVDLGdCQUFnQixFQUFFLEdBQUdkLG1CQUFPQSxDQUFDLHdFQUFjO0FBQy9ELE1BQU0sRUFBRWUsb0JBQW9CLEVBQUVDLFdBQVcsRUFBRSxHQUFHaEIsbUJBQU9BLENBQUMsc0VBQWdCO0FBQ3RFLE1BQU1pQixhQUFhakIsbUJBQU9BLENBQUMsMEZBQTBCO0FBQ3JELE1BQU1rQixhQUFhbEIsbUJBQU9BLENBQUMsd0VBQWM7QUFDekMsTUFBTW1CLCtCQUErQm5CLG1CQUFPQSxDQUFDLGdIQUFrQztBQUUvRSxNQUFNb0Isa0JBQWtCSDtJQUN0QixZQUFhSSxJQUFJLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUVOLElBQUksQ0FBQ2QsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBRXRCLG9DQUFvQztRQUNwQyxJQUFLZSxNQUFNQyxTQUFTLE9BQU9ELEtBQUtDLEtBQUssQ0FBQ0MsUUFBUSxLQUFLLFlBQWE7WUFDOUQsTUFBTSxJQUFJUixxQkFBcUI7UUFDakM7UUFDQSxNQUFNTyxRQUFRRCxNQUFNQyxRQUFRRCxLQUFLQyxLQUFLLEdBQUcs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QUk7SUFDSjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR2hEIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NsaWVudHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvYWdlbnQnKVxuY29uc3Qge1xuICBrQWdlbnQsXG4gIGtNb2NrQWdlbnRTZXQsXG4gIGtNb2NrQWdlbnRHZXQsXG4gIGtEaXNwYXRjaGVzLFxuICBrSXNNb2NrQWN0aXZlLFxuICBrTmV0Q29ubmVjdCxcbiAga0dldE5ldENvbm5lY3QsXG4gIGtPcHRpb25zLFxuICBrRmFjdG9yeVxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IE1vY2tDbGllbnQgPSByZXF1aXJlKCcuL21vY2stY2xpZW50JylcbmNvbnN0IE1vY2tQb29sID0gcmVxdWlyZSgnLi9tb2NrLXBvb2wnKVxuY29uc3QgeyBtYXRjaFZhbHVlLCBidWlsZE1vY2tPcHRpb25zIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInKVxuY29uc3QgUGx1cmFsaXplciA9IHJlcXVpcmUoJy4vcGx1cmFsaXplcicpXG5jb25zdCBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9wZW5kaW5nLWludGVyY2VwdG9ycy1mb3JtYXR0ZXInKVxuXG5jbGFzcyBNb2NrQWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpc1trTmV0Q29ubmVjdF0gPSB0cnVlXG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWVcblxuICAgIC8vIEluc3RhbnRpYXRlIEFnZW50IGFuZCBlbmNhcHN1bGF0ZVxuICAgIGlmICgob3B0cz8uYWdlbnQgJiYgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cbiAgICBjb25zdCBhZ2VudCA9IG9wdHM/LmFnZW50ID8gb3B0cy5hZ2VudCA6IG5ldyBBZ2VudChvcHRzKVxuICAgIHRoaXNba0FnZW50XSA9IGFnZW50XG5cbiAgICB0aGlzW2tDbGllbnRzXSA9IGFnZW50W2tDbGllbnRzXVxuICAgIHRoaXNba09wdGlvbnNdID0gYnVpbGRNb2NrT3B0aW9ucyhvcHRzKVxuICB9XG5cbiAgZ2V0IChvcmlnaW4pIHtcbiAgICBsZXQgZGlzcGF0Y2hlciA9IHRoaXNba01vY2tBZ2VudEdldF0ob3JpZ2luKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKVxuICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgfVxuICAgIHJldHVybiBkaXNwYXRjaGVyXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIC8vIENhbGwgTW9ja0FnZW50LmdldCB0byBwZXJmb3JtIGFkZGl0aW9uYWwgc2V0dXAgYmVmb3JlIGRpc3BhdGNoaW5nIGFzIG5vcm1hbFxuICAgIHRoaXMuZ2V0KG9wdHMub3JpZ2luKVxuICAgIHJldHVybiB0aGlzW2tBZ2VudF0uZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcbiAgfVxuXG4gIGRlYWN0aXZhdGUgKCkge1xuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSBmYWxzZVxuICB9XG5cbiAgYWN0aXZhdGUgKCkge1xuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSB0cnVlXG4gIH1cblxuICBlbmFibGVOZXRDb25uZWN0IChtYXRjaGVyKSB7XG4gICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWF0Y2hlciA9PT0gJ2Z1bmN0aW9uJyB8fCBtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzW2tOZXRDb25uZWN0XSkpIHtcbiAgICAgICAgdGhpc1trTmV0Q29ubmVjdF0ucHVzaChtYXRjaGVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1trTmV0Q29ubmVjdF0gPSBbbWF0Y2hlcl1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1trTmV0Q29ubmVjdF0gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignVW5zdXBwb3J0ZWQgbWF0Y2hlci4gTXVzdCBiZSBvbmUgb2YgU3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cC4nKVxuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVOZXRDb25uZWN0ICgpIHtcbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IGZhbHNlXG4gIH1cblxuICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIGJ5cGFzcyBpc3N1ZXMgY2F1c2VkIGJ5IHVzaW5nIGdsb2JhbCBzeW1ib2xzIC0gc2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTQ0N1xuICBnZXQgaXNNb2NrQWN0aXZlICgpIHtcbiAgICByZXR1cm4gdGhpc1trSXNNb2NrQWN0aXZlXVxuICB9XG5cbiAgW2tNb2NrQWdlbnRTZXRdIChvcmlnaW4sIGRpc3BhdGNoZXIpIHtcbiAgICB0aGlzW2tDbGllbnRzXS5zZXQob3JpZ2luLCBkaXNwYXRjaGVyKVxuICB9XG5cbiAgW2tGYWN0b3J5XSAob3JpZ2luKSB7XG4gICAgY29uc3QgbW9ja09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWdlbnQ6IHRoaXMgfSwgdGhpc1trT3B0aW9uc10pXG4gICAgcmV0dXJuIHRoaXNba09wdGlvbnNdICYmIHRoaXNba09wdGlvbnNdLmNvbm5lY3Rpb25zID09PSAxXG4gICAgICA/IG5ldyBNb2NrQ2xpZW50KG9yaWdpbiwgbW9ja09wdGlvbnMpXG4gICAgICA6IG5ldyBNb2NrUG9vbChvcmlnaW4sIG1vY2tPcHRpb25zKVxuICB9XG5cbiAgW2tNb2NrQWdlbnRHZXRdIChvcmlnaW4pIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBjYW4gaW1tZWRpYXRlbHkgZmluZCBpdFxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudHNdLmdldChvcmlnaW4pXG4gICAgaWYgKGNsaWVudCkge1xuICAgICAgcmV0dXJuIGNsaWVudFxuICAgIH1cblxuICAgIC8vIElmIHRoZSBvcmlnaW4gaXMgbm90IGEgc3RyaW5nIGNyZWF0ZSBhIGR1bW15IHBhcmVudCBwb29sIGFuZCByZXR1cm4gdG8gdXNlclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKCdodHRwOi8vbG9jYWxob3N0Ojk5OTknKVxuICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIElmIHdlIG1hdGNoLCBjcmVhdGUgYSBwb29sIGFuZCBhc3NpZ24gdGhlIHNhbWUgZGlzcGF0Y2hlc1xuICAgIGZvciAoY29uc3QgW2tleU1hdGNoZXIsIG5vbkV4cGxpY2l0RGlzcGF0Y2hlcl0gb2YgQXJyYXkuZnJvbSh0aGlzW2tDbGllbnRzXSkpIHtcbiAgICAgIGlmIChub25FeHBsaWNpdERpc3BhdGNoZXIgJiYgdHlwZW9mIGtleU1hdGNoZXIgIT09ICdzdHJpbmcnICYmIG1hdGNoVmFsdWUoa2V5TWF0Y2hlciwgb3JpZ2luKSkge1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKVxuICAgICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICAgICAgZGlzcGF0Y2hlcltrRGlzcGF0Y2hlc10gPSBub25FeHBsaWNpdERpc3BhdGNoZXJba0Rpc3BhdGNoZXNdXG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW2tHZXROZXRDb25uZWN0XSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba05ldENvbm5lY3RdXG4gIH1cblxuICBwZW5kaW5nSW50ZXJjZXB0b3JzICgpIHtcbiAgICBjb25zdCBtb2NrQWdlbnRDbGllbnRzID0gdGhpc1trQ2xpZW50c11cblxuICAgIHJldHVybiBBcnJheS5mcm9tKG1vY2tBZ2VudENsaWVudHMuZW50cmllcygpKVxuICAgICAgLmZsYXRNYXAoKFtvcmlnaW4sIHNjb3BlXSkgPT4gc2NvcGVba0Rpc3BhdGNoZXNdLm1hcChkaXNwYXRjaCA9PiAoeyAuLi5kaXNwYXRjaCwgb3JpZ2luIH0pKSlcbiAgICAgIC5maWx0ZXIoKHsgcGVuZGluZyB9KSA9PiBwZW5kaW5nKVxuICB9XG5cbiAgYXNzZXJ0Tm9QZW5kaW5nSW50ZXJjZXB0b3JzICh7IHBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSBuZXcgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlcigpIH0gPSB7fSkge1xuICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdJbnRlcmNlcHRvcnMoKVxuXG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwbHVyYWxpemVyID0gbmV3IFBsdXJhbGl6ZXIoJ2ludGVyY2VwdG9yJywgJ2ludGVyY2VwdG9ycycpLnBsdXJhbGl6ZShwZW5kaW5nLmxlbmd0aClcblxuICAgIHRocm93IG5ldyBVbmRpY2lFcnJvcihgXG4ke3BsdXJhbGl6ZXIuY291bnR9ICR7cGx1cmFsaXplci5ub3VufSAke3BsdXJhbGl6ZXIuaXN9IHBlbmRpbmc6XG5cbiR7cGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlci5mb3JtYXQocGVuZGluZyl9XG5gLnRyaW0oKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tBZ2VudFxuIl0sIm5hbWVzIjpbImtDbGllbnRzIiwicmVxdWlyZSIsIkFnZW50Iiwia0FnZW50Iiwia01vY2tBZ2VudFNldCIsImtNb2NrQWdlbnRHZXQiLCJrRGlzcGF0Y2hlcyIsImtJc01vY2tBY3RpdmUiLCJrTmV0Q29ubmVjdCIsImtHZXROZXRDb25uZWN0Iiwia09wdGlvbnMiLCJrRmFjdG9yeSIsIk1vY2tDbGllbnQiLCJNb2NrUG9vbCIsIm1hdGNoVmFsdWUiLCJidWlsZE1vY2tPcHRpb25zIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJVbmRpY2lFcnJvciIsIkRpc3BhdGNoZXIiLCJQbHVyYWxpemVyIiwiUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciIsIk1vY2tBZ2VudCIsIm9wdHMiLCJhZ2VudCIsImRpc3BhdGNoIiwiZ2V0Iiwib3JpZ2luIiwiZGlzcGF0Y2hlciIsImhhbmRsZXIiLCJjbG9zZSIsImNsZWFyIiwiZGVhY3RpdmF0ZSIsImFjdGl2YXRlIiwiZW5hYmxlTmV0Q29ubmVjdCIsIm1hdGNoZXIiLCJSZWdFeHAiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwiZGlzYWJsZU5ldENvbm5lY3QiLCJpc01vY2tBY3RpdmUiLCJzZXQiLCJtb2NrT3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImNvbm5lY3Rpb25zIiwiY2xpZW50Iiwia2V5TWF0Y2hlciIsIm5vbkV4cGxpY2l0RGlzcGF0Y2hlciIsImZyb20iLCJwZW5kaW5nSW50ZXJjZXB0b3JzIiwibW9ja0FnZW50Q2xpZW50cyIsImVudHJpZXMiLCJmbGF0TWFwIiwic2NvcGUiLCJtYXAiLCJmaWx0ZXIiLCJwZW5kaW5nIiwiYXNzZXJ0Tm9QZW5kaW5nSW50ZXJjZXB0b3JzIiwicGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciIsImxlbmd0aCIsInBsdXJhbGl6ZXIiLCJwbHVyYWxpemUiLCJjb3VudCIsIm5vdW4iLCJpcyIsImZvcm1hdCIsInRyaW0iLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\");\nconst Client = __webpack_require__(/*! ../dispatcher/client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */ class MockClient extends Client {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n            throw new InvalidArgumentError('Argument opts.agent must implement Agent');\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsNEJBQVc7QUFDekMsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsa0ZBQXNCO0FBQzdDLE1BQU0sRUFBRUUsaUJBQWlCLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsd0VBQWM7QUFDcEQsTUFBTSxFQUNKRyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsTUFBTSxFQUNOQyxjQUFjLEVBQ2RDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1gsR0FBR1QsbUJBQU9BLENBQUMsNEVBQWdCO0FBQzVCLE1BQU0sRUFBRVUsZUFBZSxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUN4RCxNQUFNVyxVQUFVWCxtQkFBT0EsQ0FBQyx3RUFBaUI7QUFDekMsTUFBTSxFQUFFWSxvQkFBb0IsRUFBRSxHQUFHWixtQkFBT0EsQ0FBQyxzRUFBZ0I7QUFFekQ7O0NBRUMsR0FDRCxNQUFNYSxtQkFBbUJaO0lBQ3ZCLFlBQWFhLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0QsUUFBUUM7UUFFZCxJQUFJLENBQUNBLFFBQVEsQ0FBQ0EsS0FBS0MsS0FBSyxJQUFJLE9BQU9ELEtBQUtDLEtBQUssQ0FBQ0MsUUFBUSxLQUFLLFlBQVk7WUFDckUsTUFBTSxJQUFJTCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNSLFdBQVcsR0FBR1csS0FBS0MsS0FBSztRQUM3QixJQUFJLENBQUNULFFBQVEsR0FBR087UUFDaEIsSUFBSSxDQUFDWCxZQUFZLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUNNLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNELGtCQUFrQixHQUFHLElBQUksQ0FBQ1MsUUFBUTtRQUN2QyxJQUFJLENBQUNYLGVBQWUsR0FBRyxJQUFJLENBQUNZLEtBQUssQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFFM0MsSUFBSSxDQUFDRixRQUFRLEdBQUdmLGtCQUFrQmtCLElBQUksQ0FBQyxJQUFJO1FBQzNDLElBQUksQ0FBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQ2IsT0FBTztJQUMzQjtJQUVBLElBQUksQ0FBQ00sUUFBUUYsVUFBVSxDQUFDLEdBQUk7UUFDMUIsT0FBTyxJQUFJLENBQUNBLFdBQVc7SUFDekI7SUFFQTs7R0FFQyxHQUNEWSxVQUFXTixJQUFJLEVBQUU7UUFDZixPQUFPLElBQUlMLGdCQUFnQkssTUFBTSxJQUFJLENBQUNaLFlBQVk7SUFDcEQ7SUFFQSxNQUFNLENBQUNFLE9BQU8sR0FBSTtRQUNoQixNQUFNTixVQUFVLElBQUksQ0FBQ08sZUFBZTtRQUNwQyxJQUFJLENBQUNHLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNMLFdBQVcsQ0FBQ08sUUFBUVcsUUFBUSxDQUFDLENBQUNDLE1BQU0sQ0FBQyxJQUFJLENBQUNoQixRQUFRO0lBQ3pEO0FBQ0Y7QUFFQWlCLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay1jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9jbGllbnQnKVxuY29uc3QgeyBidWlsZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtDbG9zZSxcbiAga09yaWdpbmFsQ2xvc2UsXG4gIGtPcmlnaW4sXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrQ29ubmVjdGVkXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmUoJy4vbW9jay1pbnRlcmNlcHRvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuLyoqXG4gKiBNb2NrQ2xpZW50IHByb3ZpZGVzIGFuIEFQSSB0aGF0IGV4dGVuZHMgdGhlIENsaWVudCB0byBpbmZsdWVuY2UgdGhlIG1vY2tEaXNwYXRjaGVzLlxuICovXG5jbGFzcyBNb2NrQ2xpZW50IGV4dGVuZHMgQ2xpZW50IHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwgb3B0cykge1xuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy5hZ2VudCB8fCB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrQWdlbnRdID0gb3B0cy5hZ2VudFxuICAgIHRoaXNba09yaWdpbl0gPSBvcmlnaW5cbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgcHJvbWlzaWZ5KHRoaXNba09yaWdpbmFsQ2xvc2VdKSgpXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDBcbiAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja0NsaWVudFxuIl0sIm5hbWVzIjpbInByb21pc2lmeSIsInJlcXVpcmUiLCJDbGllbnQiLCJidWlsZE1vY2tEaXNwYXRjaCIsImtEaXNwYXRjaGVzIiwia01vY2tBZ2VudCIsImtDbG9zZSIsImtPcmlnaW5hbENsb3NlIiwia09yaWdpbiIsImtPcmlnaW5hbERpc3BhdGNoIiwia0Nvbm5lY3RlZCIsIk1vY2tJbnRlcmNlcHRvciIsIlN5bWJvbHMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIk1vY2tDbGllbnQiLCJvcmlnaW4iLCJvcHRzIiwiYWdlbnQiLCJkaXNwYXRjaCIsImNsb3NlIiwiYmluZCIsImNhbGwiLCJpbnRlcmNlcHQiLCJrQ2xpZW50cyIsImRlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nclass MockNotMatchedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, MockNotMatchedError);\n        this.name = 'MockNotMatchedError';\n        this.message = message || 'The request does not match any registered mock dispatches';\n        this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED';\n    }\n}\nmodule.exports = {\n    MockNotMatchedError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxXQUFXLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsc0VBQWdCO0FBRWhELE1BQU1DLDRCQUE0QkY7SUFDaEMsWUFBYUcsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkMsTUFBTUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFSDtRQUM5QixJQUFJLENBQUNJLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0gsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0ksSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZlA7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxtb2NrLWVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBVbmRpY2lFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5jbGFzcyBNb2NrTm90TWF0Y2hlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTW9ja05vdE1hdGNoZWRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnTW9ja05vdE1hdGNoZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGUgcmVxdWVzdCBkb2VzIG5vdCBtYXRjaCBhbnkgcmVnaXN0ZXJlZCBtb2NrIGRpc3BhdGNoZXMnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9NT0NLX0VSUl9NT0NLX05PVF9NQVRDSEVEJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNb2NrTm90TWF0Y2hlZEVycm9yXG59XG4iXSwibmFtZXMiOlsiVW5kaWNpRXJyb3IiLCJyZXF1aXJlIiwiTW9ja05vdE1hdGNoZWRFcnJvciIsIm1lc3NhZ2UiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwibmFtZSIsImNvZGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\n/**\n * Defines the scope API for an interceptor reply\n */ class MockScope {\n    constructor(mockDispatch){\n        this[kMockDispatch] = mockDispatch;\n    }\n    /**\n   * Delay a reply by a set amount in ms.\n   */ delay(waitInMs) {\n        if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n            throw new InvalidArgumentError('waitInMs must be a valid integer > 0');\n        }\n        this[kMockDispatch].delay = waitInMs;\n        return this;\n    }\n    /**\n   * For a defined reply, never mark as consumed.\n   */ persist() {\n        this[kMockDispatch].persist = true;\n        return this;\n    }\n    /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */ times(repeatTimes) {\n        if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n            throw new InvalidArgumentError('repeatTimes must be a valid integer > 0');\n        }\n        this[kMockDispatch].times = repeatTimes;\n        return this;\n    }\n}\n/**\n * Defines an interceptor for a Mock\n */ class MockInterceptor {\n    constructor(opts, mockDispatches){\n        if (typeof opts !== 'object') {\n            throw new InvalidArgumentError('opts must be an object');\n        }\n        if (typeof opts.path === 'undefined') {\n            throw new InvalidArgumentError('opts.path must be defined');\n        }\n        if (typeof opts.method === 'undefined') {\n            opts.method = 'GET';\n        }\n        // See https://github.com/nodejs/undici/issues/1245\n        // As per RFC 3986, clients are not supposed to send URI\n        // fragments to servers when they retrieve a document,\n        if (typeof opts.path === 'string') {\n            if (opts.query) {\n                opts.path = buildURL(opts.path, opts.query);\n            } else {\n                // Matches https://github.com/nodejs/undici/blob/main/lib/web/fetch/index.js#L1811\n                const parsedURL = new URL(opts.path, 'data://');\n                opts.path = parsedURL.pathname + parsedURL.search;\n            }\n        }\n        if (typeof opts.method === 'string') {\n            opts.method = opts.method.toUpperCase();\n        }\n        this[kDispatchKey] = buildKey(opts);\n        this[kDispatches] = mockDispatches;\n        this[kDefaultHeaders] = {};\n        this[kDefaultTrailers] = {};\n        this[kContentLength] = false;\n    }\n    createMockScopeDispatchData({ statusCode, data, responseOptions }) {\n        const responseData = getResponseData(data);\n        const contentLength = this[kContentLength] ? {\n            'content-length': responseData.length\n        } : {};\n        const headers = {\n            ...this[kDefaultHeaders],\n            ...contentLength,\n            ...responseOptions.headers\n        };\n        const trailers = {\n            ...this[kDefaultTrailers],\n            ...responseOptions.trailers\n        };\n        return {\n            statusCode,\n            data,\n            headers,\n            trailers\n        };\n    }\n    validateReplyParameters(replyParameters) {\n        if (typeof replyParameters.statusCode === 'undefined') {\n            throw new InvalidArgumentError('statusCode must be defined');\n        }\n        if (typeof replyParameters.responseOptions !== 'object' || replyParameters.responseOptions === null) {\n            throw new InvalidArgumentError('responseOptions must be an object');\n        }\n    }\n    /**\n   * Mock an undici request with a defined reply.\n   */ reply(replyOptionsCallbackOrStatusCode) {\n        // Values of reply aren't available right now as they\n        // can only be available when the reply callback is invoked.\n        if (typeof replyOptionsCallbackOrStatusCode === 'function') {\n            // We'll first wrap the provided callback in another function,\n            // this function will properly resolve the data from the callback\n            // when invoked.\n            const wrappedDefaultsCallback = (opts)=>{\n                // Our reply options callback contains the parameter for statusCode, data and options.\n                const resolvedData = replyOptionsCallbackOrStatusCode(opts);\n                // Check if it is in the right format\n                if (typeof resolvedData !== 'object' || resolvedData === null) {\n                    throw new InvalidArgumentError('reply options callback must return an object');\n                }\n                const replyParameters = {\n                    data: '',\n                    responseOptions: {},\n                    ...resolvedData\n                };\n                this.validateReplyParameters(replyParameters);\n                // Since the values can be obtained immediately we return them\n                // from this higher order function that will be resolved later.\n                return {\n                    ...this.createMockScopeDispatchData(replyParameters)\n                };\n            };\n            // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n            return new MockScope(newMockDispatch);\n        }\n        // We can have either one or three parameters, if we get here,\n        // we should have 1-3 parameters. So we spread the arguments of\n        // this function to obtain the parameters, since replyData will always\n        // just be the statusCode.\n        const replyParameters = {\n            statusCode: replyOptionsCallbackOrStatusCode,\n            data: arguments[1] === undefined ? '' : arguments[1],\n            responseOptions: arguments[2] === undefined ? {} : arguments[2]\n        };\n        this.validateReplyParameters(replyParameters);\n        // Send in-already provided data like usual\n        const dispatchData = this.createMockScopeDispatchData(replyParameters);\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Mock an undici request with a defined error.\n   */ replyWithError(error) {\n        if (typeof error === 'undefined') {\n            throw new InvalidArgumentError('error must be defined');\n        }\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {\n            error\n        });\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */ defaultReplyHeaders(headers) {\n        if (typeof headers === 'undefined') {\n            throw new InvalidArgumentError('headers must be defined');\n        }\n        this[kDefaultHeaders] = headers;\n        return this;\n    }\n    /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */ defaultReplyTrailers(trailers) {\n        if (typeof trailers === 'undefined') {\n            throw new InvalidArgumentError('trailers must be defined');\n        }\n        this[kDefaultTrailers] = trailers;\n        return this;\n    }\n    /**\n   * Set reply content length header for replies on the interceptor\n   */ replyContentLength() {\n        this[kContentLength] = true;\n        return this;\n    }\n}\nmodule.exports.MockInterceptor = MockInterceptor;\nmodule.exports.MockScope = MockScope;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLGVBQWUsRUFBRUMsUUFBUSxFQUFFQyxlQUFlLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsd0VBQWM7QUFDN0UsTUFBTSxFQUNKQyxXQUFXLEVBQ1hDLFlBQVksRUFDWkMsZUFBZSxFQUNmQyxnQkFBZ0IsRUFDaEJDLGNBQWMsRUFDZEMsYUFBYSxFQUNkLEdBQUdOLG1CQUFPQSxDQUFDLDRFQUFnQjtBQUM1QixNQUFNLEVBQUVPLG9CQUFvQixFQUFFLEdBQUdQLG1CQUFPQSxDQUFDLHNFQUFnQjtBQUN6RCxNQUFNLEVBQUVRLFFBQVEsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQyxrRUFBYztBQUUzQzs7Q0FFQyxHQUNELE1BQU1TO0lBQ0osWUFBYUMsWUFBWSxDQUFFO1FBQ3pCLElBQUksQ0FBQ0osY0FBYyxHQUFHSTtJQUN4QjtJQUVBOztHQUVDLEdBQ0RDLE1BQU9DLFFBQVEsRUFBRTtRQUNmLElBQUksT0FBT0EsYUFBYSxZQUFZLENBQUNDLE9BQU9DLFNBQVMsQ0FBQ0YsYUFBYUEsWUFBWSxHQUFHO1lBQ2hGLE1BQU0sSUFBSUwscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxDQUFDRCxjQUFjLENBQUNLLEtBQUssR0FBR0M7UUFDNUIsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7R0FFQyxHQUNERyxVQUFXO1FBQ1QsSUFBSSxDQUFDVCxjQUFjLENBQUNTLE9BQU8sR0FBRztRQUM5QixPQUFPLElBQUk7SUFDYjtJQUVBOztHQUVDLEdBQ0RDLE1BQU9DLFdBQVcsRUFBRTtRQUNsQixJQUFJLE9BQU9BLGdCQUFnQixZQUFZLENBQUNKLE9BQU9DLFNBQVMsQ0FBQ0csZ0JBQWdCQSxlQUFlLEdBQUc7WUFDekYsTUFBTSxJQUFJVixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNELGNBQWMsQ0FBQ1UsS0FBSyxHQUFHQztR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UUFFQSxJQUFJLENBQUNKLGdCQUFnQixHQUFHaUM7UUFDeEIsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7R0FFQyxHQUNEZSxxQkFBc0JkLFFBQVEsRUFBRTtRQUM5QixJQUFJLE9BQU9BLGFBQWEsYUFBYTtZQUNuQyxNQUFNLElBQUk5QixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNILGlCQUFpQixHQUFHaUM7UUFDekIsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7R0FFQyxHQUNEZSxxQkFBc0I7UUFDcEIsSUFBSSxDQUFDL0MsZUFBZSxHQUFHO1FBQ3ZCLE9BQU8sSUFBSTtJQUNiO0FBQ0Y7QUFFQWdELDhCQUE4QixHQUFHbkM7QUFDakNtQyx3QkFBd0IsR0FBRzVDIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2staW50ZXJjZXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZ2V0UmVzcG9uc2VEYXRhLCBidWlsZEtleSwgYWRkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga0Rpc3BhdGNoS2V5LFxuICBrRGVmYXVsdEhlYWRlcnMsXG4gIGtEZWZhdWx0VHJhaWxlcnMsXG4gIGtDb250ZW50TGVuZ3RoLFxuICBrTW9ja0Rpc3BhdGNoXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBidWlsZFVSTCB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzY29wZSBBUEkgZm9yIGFuIGludGVyY2VwdG9yIHJlcGx5XG4gKi9cbmNsYXNzIE1vY2tTY29wZSB7XG4gIGNvbnN0cnVjdG9yIChtb2NrRGlzcGF0Y2gpIHtcbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdID0gbW9ja0Rpc3BhdGNoXG4gIH1cblxuICAvKipcbiAgICogRGVsYXkgYSByZXBseSBieSBhIHNldCBhbW91bnQgaW4gbXMuXG4gICAqL1xuICBkZWxheSAod2FpdEluTXMpIHtcbiAgICBpZiAodHlwZW9mIHdhaXRJbk1zICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcih3YWl0SW5NcykgfHwgd2FpdEluTXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd3YWl0SW5NcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDAnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tEaXNwYXRjaF0uZGVsYXkgPSB3YWl0SW5Nc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZGVmaW5lZCByZXBseSwgbmV2ZXIgbWFyayBhcyBjb25zdW1lZC5cbiAgICovXG4gIHBlcnNpc3QgKCkge1xuICAgIHRoaXNba01vY2tEaXNwYXRjaF0ucGVyc2lzdCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IG9uZSB0byBkZWZpbmUgYSByZXBseSBmb3IgYSBzZXQgYW1vdW50IG9mIG1hdGNoaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgdGltZXMgKHJlcGVhdFRpbWVzKSB7XG4gICAgaWYgKHR5cGVvZiByZXBlYXRUaW1lcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIocmVwZWF0VGltZXMpIHx8IHJlcGVhdFRpbWVzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwZWF0VGltZXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwJylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnRpbWVzID0gcmVwZWF0VGltZXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyBhbiBpbnRlcmNlcHRvciBmb3IgYSBNb2NrXG4gKi9cbmNsYXNzIE1vY2tJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2NrRGlzcGF0Y2hlcykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLnBhdGggbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLm1ldGhvZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICB9XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMjQ1XG4gICAgLy8gQXMgcGVyIFJGQyAzOTg2LCBjbGllbnRzIGFyZSBub3Qgc3VwcG9zZWQgdG8gc2VuZCBVUklcbiAgICAvLyBmcmFnbWVudHMgdG8gc2VydmVycyB3aGVuIHRoZXkgcmV0cmlldmUgYSBkb2N1bWVudCxcbiAgICBpZiAodHlwZW9mIG9wdHMucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChvcHRzLnF1ZXJ5KSB7XG4gICAgICAgIG9wdHMucGF0aCA9IGJ1aWxkVVJMKG9wdHMucGF0aCwgb3B0cy5xdWVyeSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1hdGNoZXMgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvYmxvYi9tYWluL2xpYi93ZWIvZmV0Y2gvaW5kZXguanMjTDE4MTFcbiAgICAgICAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTChvcHRzLnBhdGgsICdkYXRhOi8vJylcbiAgICAgICAgb3B0cy5wYXRoID0gcGFyc2VkVVJMLnBhdGhuYW1lICsgcGFyc2VkVVJMLnNlYXJjaFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMubWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0cy5tZXRob2QgPSBvcHRzLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgfVxuXG4gICAgdGhpc1trRGlzcGF0Y2hLZXldID0gYnVpbGRLZXkob3B0cylcbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IG1vY2tEaXNwYXRjaGVzXG4gICAgdGhpc1trRGVmYXVsdEhlYWRlcnNdID0ge31cbiAgICB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdID0ge31cbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IGZhbHNlXG4gIH1cblxuICBjcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEgKHsgc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zIH0pIHtcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBnZXRSZXNwb25zZURhdGEoZGF0YSlcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gdGhpc1trQ29udGVudExlbmd0aF0gPyB7ICdjb250ZW50LWxlbmd0aCc6IHJlc3BvbnNlRGF0YS5sZW5ndGggfSA6IHt9XG4gICAgY29uc3QgaGVhZGVycyA9IHsgLi4udGhpc1trRGVmYXVsdEhlYWRlcnNdLCAuLi5jb250ZW50TGVuZ3RoLCAuLi5yZXNwb25zZU9wdGlvbnMuaGVhZGVycyB9XG4gICAgY29uc3QgdHJhaWxlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRUcmFpbGVyc10sIC4uLnJlc3BvbnNlT3B0aW9ucy50cmFpbGVycyB9XG5cbiAgICByZXR1cm4geyBzdGF0dXNDb2RlLCBkYXRhLCBoZWFkZXJzLCB0cmFpbGVycyB9XG4gIH1cblxuICB2YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyAocmVwbHlQYXJhbWV0ZXJzKSB7XG4gICAgaWYgKHR5cGVvZiByZXBseVBhcmFtZXRlcnMuc3RhdHVzQ29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc3RhdHVzQ29kZSBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlcGx5UGFyYW1ldGVycy5yZXNwb25zZU9wdGlvbnMgIT09ICdvYmplY3QnIHx8IHJlcGx5UGFyYW1ldGVycy5yZXNwb25zZU9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVzcG9uc2VPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9jayBhbiB1bmRpY2kgcmVxdWVzdCB3aXRoIGEgZGVmaW5lZCByZXBseS5cbiAgICovXG4gIHJlcGx5IChyZXBseU9wdGlvbnNDYWxsYmFja09yU3RhdHVzQ29kZSkge1xuICAgIC8vIFZhbHVlcyBvZiByZXBseSBhcmVuJ3QgYXZhaWxhYmxlIHJpZ2h0IG5vdyBhcyB0aGV5XG4gICAgLy8gY2FuIG9ubHkgYmUgYXZhaWxhYmxlIHdoZW4gdGhlIHJlcGx5IGNhbGxiYWNrIGlzIGludm9rZWQuXG4gICAgaWYgKHR5cGVvZiByZXBseU9wdGlvbnNDYWxsYmFja09yU3RhdHVzQ29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UnbGwgZmlyc3Qgd3JhcCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgaW4gYW5vdGhlciBmdW5jdGlvbixcbiAgICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBwcm9wZXJseSByZXNvbHZlIHRoZSBkYXRhIGZyb20gdGhlIGNhbGxiYWNrXG4gICAgICAvLyB3aGVuIGludm9rZWQuXG4gICAgICBjb25zdCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjayA9IChvcHRzKSA9PiB7XG4gICAgICAgIC8vIE91ciByZXBseSBvcHRpb25zIGNhbGxiYWNrIGNvbnRhaW5zIHRoZSBwYXJhbWV0ZXIgZm9yIHN0YXR1c0NvZGUsIGRhdGEgYW5kIG9wdGlvbnMuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRGF0YSA9IHJlcGx5T3B0aW9uc0NhbGxiYWNrT3JTdGF0dXNDb2RlKG9wdHMpXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgaW4gdGhlIHJpZ2h0IGZvcm1hdFxuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVkRGF0YSAhPT0gJ29iamVjdCcgfHwgcmVzb2x2ZWREYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdyZXBseSBvcHRpb25zIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIG9iamVjdCcpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXBseVBhcmFtZXRlcnMgPSB7IGRhdGE6ICcnLCByZXNwb25zZU9wdGlvbnM6IHt9LCAuLi5yZXNvbHZlZERhdGEgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHJlcGx5UGFyYW1ldGVycylcbiAgICAgICAgLy8gU2luY2UgdGhlIHZhbHVlcyBjYW4gYmUgb2J0YWluZWQgaW1tZWRpYXRlbHkgd2UgcmV0dXJuIHRoZW1cbiAgICAgICAgLy8gZnJvbSB0aGlzIGhpZ2hlciBvcmRlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEocmVwbHlQYXJhbWV0ZXJzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB1c3VhbCBkaXNwYXRjaCBkYXRhLCBidXQgdGhpcyB0aW1lIHNldCB0aGUgZGF0YSBwYXJhbWV0ZXIgdG8gZnVuY3Rpb24gdGhhdCB3aWxsIGV2ZW50dWFsbHkgcHJvdmlkZSBkYXRhLlxuICAgICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIHdyYXBwZWREZWZhdWx0c0NhbGxiYWNrKVxuICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICAgIH1cblxuICAgIC8vIFdlIGNhbiBoYXZlIGVpdGhlciBvbmUgb3IgdGhyZWUgcGFyYW1ldGVycywgaWYgd2UgZ2V0IGhlcmUsXG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgMS0zIHBhcmFtZXRlcnMuIFNvIHdlIHNwcmVhZCB0aGUgYXJndW1lbnRzIG9mXG4gICAgLy8gdGhpcyBmdW5jdGlvbiB0byBvYnRhaW4gdGhlIHBhcmFtZXRlcnMsIHNpbmNlIHJlcGx5RGF0YSB3aWxsIGFsd2F5c1xuICAgIC8vIGp1c3QgYmUgdGhlIHN0YXR1c0NvZGUuXG4gICAgY29uc3QgcmVwbHlQYXJhbWV0ZXJzID0ge1xuICAgICAgc3RhdHVzQ29kZTogcmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUsXG4gICAgICBkYXRhOiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzFdLFxuICAgICAgcmVzcG9uc2VPcHRpb25zOiBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdXG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVSZXBseVBhcmFtZXRlcnMocmVwbHlQYXJhbWV0ZXJzKVxuXG4gICAgLy8gU2VuZCBpbi1hbHJlYWR5IHByb3ZpZGVkIGRhdGEgbGlrZSB1c3VhbFxuICAgIGNvbnN0IGRpc3BhdGNoRGF0YSA9IHRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHJlcGx5UGFyYW1ldGVycylcbiAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgZGlzcGF0Y2hEYXRhKVxuICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2NrIGFuIHVuZGljaSByZXF1ZXN0IHdpdGggYSBkZWZpbmVkIGVycm9yLlxuICAgKi9cbiAgcmVwbHlXaXRoRXJyb3IgKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZXJyb3IgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG5cbiAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgeyBlcnJvciB9KVxuICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCByZXBseSBoZWFkZXJzIG9uIHRoZSBpbnRlcmNlcHRvciBmb3Igc3Vic2VxdWVudCByZXBsaWVzXG4gICAqL1xuICBkZWZhdWx0UmVwbHlIZWFkZXJzIChoZWFkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgdGhpc1trRGVmYXVsdEhlYWRlcnNdID0gaGVhZGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcmVwbHkgdHJhaWxlcnMgb24gdGhlIGludGVyY2VwdG9yIGZvciBzdWJzZXF1ZW50IHJlcGxpZXNcbiAgICovXG4gIGRlZmF1bHRSZXBseVRyYWlsZXJzICh0cmFpbGVycykge1xuICAgIGlmICh0eXBlb2YgdHJhaWxlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3RyYWlsZXJzIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHRyYWlsZXJzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcmVwbHkgY29udGVudCBsZW5ndGggaGVhZGVyIGZvciByZXBsaWVzIG9uIHRoZSBpbnRlcmNlcHRvclxuICAgKi9cbiAgcmVwbHlDb250ZW50TGVuZ3RoICgpIHtcbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLk1vY2tJbnRlcmNlcHRvciA9IE1vY2tJbnRlcmNlcHRvclxubW9kdWxlLmV4cG9ydHMuTW9ja1Njb3BlID0gTW9ja1Njb3BlXG4iXSwibmFtZXMiOlsiZ2V0UmVzcG9uc2VEYXRhIiwiYnVpbGRLZXkiLCJhZGRNb2NrRGlzcGF0Y2giLCJyZXF1aXJlIiwia0Rpc3BhdGNoZXMiLCJrRGlzcGF0Y2hLZXkiLCJrRGVmYXVsdEhlYWRlcnMiLCJrRGVmYXVsdFRyYWlsZXJzIiwia0NvbnRlbnRMZW5ndGgiLCJrTW9ja0Rpc3BhdGNoIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJidWlsZFVSTCIsIk1vY2tTY29wZSIsIm1vY2tEaXNwYXRjaCIsImRlbGF5Iiwid2FpdEluTXMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJwZXJzaXN0IiwidGltZXMiLCJyZXBlYXRUaW1lcyIsIk1vY2tJbnRlcmNlcHRvciIsIm9wdHMiLCJtb2NrRGlzcGF0Y2hlcyIsInBhdGgiLCJtZXRob2QiLCJxdWVyeSIsInBhcnNlZFVSTCIsIlVSTCIsInBhdGhuYW1lIiwic2VhcmNoIiwidG9VcHBlckNhc2UiLCJjcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEiLCJzdGF0dXNDb2RlIiwiZGF0YSIsInJlc3BvbnNlT3B0aW9ucyIsInJlc3BvbnNlRGF0YSIsImNvbnRlbnRMZW5ndGgiLCJsZW5ndGgiLCJoZWFkZXJzIiwidHJhaWxlcnMiLCJ2YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyIsInJlcGx5UGFyYW1ldGVycyIsInJlcGx5IiwicmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUiLCJ3cmFwcGVkRGVmYXVsdHNDYWxsYmFjayIsInJlc29sdmVkRGF0YSIsIm5ld01vY2tEaXNwYXRjaCIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsImRpc3BhdGNoRGF0YSIsInJlcGx5V2l0aEVycm9yIiwiZXJyb3IiLCJkZWZhdWx0UmVwbHlIZWFkZXJzIiwiZGVmYXVsdFJlcGx5VHJhaWxlcnMiLCJyZXBseUNvbnRlbnRMZW5ndGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\");\nconst Pool = __webpack_require__(/*! ../dispatcher/pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */ class MockPool extends Pool {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n            throw new InvalidArgumentError('Argument opts.agent must implement Agent');\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLDRCQUFXO0FBQ3pDLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDLDhFQUFvQjtBQUN6QyxNQUFNLEVBQUVFLGlCQUFpQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDLHdFQUFjO0FBQ3BELE1BQU0sRUFDSkcsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTkMsY0FBYyxFQUNkQyxPQUFPLEVBQ1BDLGlCQUFpQixFQUNqQkMsVUFBVSxFQUNYLEdBQUdULG1CQUFPQSxDQUFDLDRFQUFnQjtBQUM1QixNQUFNLEVBQUVVLGVBQWUsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQyxvRkFBb0I7QUFDeEQsTUFBTVcsVUFBVVgsbUJBQU9BLENBQUMsd0VBQWlCO0FBQ3pDLE1BQU0sRUFBRVksb0JBQW9CLEVBQUUsR0FBR1osbUJBQU9BLENBQUMsc0VBQWdCO0FBRXpEOztDQUVDLEdBQ0QsTUFBTWEsaUJBQWlCWjtJQUNyQixZQUFhYSxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUN6QixLQUFLLENBQUNELFFBQVFDO1FBRWQsSUFBSSxDQUFDQSxRQUFRLENBQUNBLEtBQUtDLEtBQUssSUFBSSxPQUFPRCxLQUFLQyxLQUFLLENBQUNDLFFBQVEsS0FBSyxZQUFZO1lBQ3JFLE1BQU0sSUFBSUwscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxDQUFDUixXQUFXLEdBQUdXLEtBQUtDLEtBQUs7UUFDN0IsSUFBSSxDQUFDVCxRQUFRLEdBQUdPO1FBQ2hCLElBQUksQ0FBQ1gsWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDTSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRCxrQkFBa0IsR0FBRyxJQUFJLENBQUNTLFFBQVE7UUFDdkMsSUFBSSxDQUFDWCxlQUFlLEdBQUcsSUFBSSxDQUFDWSxLQUFLLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBRTNDLElBQUksQ0FBQ0YsUUFBUSxHQUFHZixrQkFBa0JrQixJQUFJLENBQUMsSUFBSTtRQUMzQyxJQUFJLENBQUNGLEtBQUssR0FBRyxJQUFJLENBQUNiLE9BQU87SUFDM0I7SUFFQSxJQUFJLENBQUNNLFFBQVFGLFVBQVUsQ0FBQyxHQUFJO1FBQzFCLE9BQU8sSUFBSSxDQUFDQSxXQUFXO0lBQ3pCO0lBRUE7O0dBRUMsR0FDRFksVUFBV04sSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJTCxnQkFBZ0JLLE1BQU0sSUFBSSxDQUFDWixZQUFZO0lBQ3BEO0lBRUEsTUFBTSxDQUFDRSxPQUFPLEdBQUk7UUFDaEIsTUFBTU4sVUFBVSxJQUFJLENBQUNPLGVBQWU7UUFDcEMsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDTCxXQUFXLENBQUNPLFFBQVFXLFFBQVEsQ0FBQyxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDaEIsUUFBUTtJQUN6RDtBQUNGO0FBRUFpQixPQUFPQyxPQUFPLEdBQUdaIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stcG9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9wb29sJylcbmNvbnN0IHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrQ2xvc2UsXG4gIGtPcmlnaW5hbENsb3NlLFxuICBrT3JpZ2luLFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga0Nvbm5lY3RlZFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgTW9ja0ludGVyY2VwdG9yIH0gPSByZXF1aXJlKCcuL21vY2staW50ZXJjZXB0b3InKVxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbi8qKlxuICogTW9ja1Bvb2wgcHJvdmlkZXMgYW4gQVBJIHRoYXQgZXh0ZW5kcyB0aGUgUG9vbCB0byBpbmZsdWVuY2UgdGhlIG1vY2tEaXNwYXRjaGVzLlxuICovXG5jbGFzcyBNb2NrUG9vbCBleHRlbmRzIFBvb2wge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCBvcHRzKSB7XG4gICAgc3VwZXIob3JpZ2luLCBvcHRzKVxuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50XG4gICAgdGhpc1trT3JpZ2luXSA9IG9yaWdpblxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gW11cbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMVxuICAgIHRoaXNba09yaWdpbmFsRGlzcGF0Y2hdID0gdGhpcy5kaXNwYXRjaFxuICAgIHRoaXNba09yaWdpbmFsQ2xvc2VdID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gYnVpbGRNb2NrRGlzcGF0Y2guY2FsbCh0aGlzKVxuICAgIHRoaXMuY2xvc2UgPSB0aGlzW2tDbG9zZV1cbiAgfVxuXG4gIGdldCBbU3ltYm9scy5rQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nvbm5lY3RlZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBiYXNlIGludGVyY2VwdG9yIGZvciBtb2NraW5nIHJlcGxpZXMgZnJvbSB1bmRpY2kuXG4gICAqL1xuICBpbnRlcmNlcHQgKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IE1vY2tJbnRlcmNlcHRvcihvcHRzLCB0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkodGhpc1trT3JpZ2luYWxDbG9zZV0pKClcbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMFxuICAgIHRoaXNba01vY2tBZ2VudF1bU3ltYm9scy5rQ2xpZW50c10uZGVsZXRlKHRoaXNba09yaWdpbl0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrUG9vbFxuIl0sIm5hbWVzIjpbInByb21pc2lmeSIsInJlcXVpcmUiLCJQb29sIiwiYnVpbGRNb2NrRGlzcGF0Y2giLCJrRGlzcGF0Y2hlcyIsImtNb2NrQWdlbnQiLCJrQ2xvc2UiLCJrT3JpZ2luYWxDbG9zZSIsImtPcmlnaW4iLCJrT3JpZ2luYWxEaXNwYXRjaCIsImtDb25uZWN0ZWQiLCJNb2NrSW50ZXJjZXB0b3IiLCJTeW1ib2xzIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJNb2NrUG9vbCIsIm9yaWdpbiIsIm9wdHMiLCJhZ2VudCIsImRpc3BhdGNoIiwiY2xvc2UiLCJiaW5kIiwiY2FsbCIsImludGVyY2VwdCIsImtDbGllbnRzIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kAgent: Symbol('agent'),\n    kOptions: Symbol('options'),\n    kFactory: Symbol('factory'),\n    kDispatches: Symbol('dispatches'),\n    kDispatchKey: Symbol('dispatch key'),\n    kDefaultHeaders: Symbol('default headers'),\n    kDefaultTrailers: Symbol('default trailers'),\n    kContentLength: Symbol('content length'),\n    kMockAgent: Symbol('mock agent'),\n    kMockAgentSet: Symbol('mock agent set'),\n    kMockAgentGet: Symbol('mock agent get'),\n    kMockDispatch: Symbol('mock dispatch'),\n    kClose: Symbol('close'),\n    kOriginalClose: Symbol('original agent close'),\n    kOrigin: Symbol('origin'),\n    kIsMockActive: Symbol('is mock active'),\n    kNetConnect: Symbol('net connect'),\n    kGetNetConnect: Symbol('get net connect'),\n    kConnected: Symbol('connected')\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsUUFBUUMsT0FBTztJQUNmQyxVQUFVRCxPQUFPO0lBQ2pCRSxVQUFVRixPQUFPO0lBQ2pCRyxhQUFhSCxPQUFPO0lBQ3BCSSxjQUFjSixPQUFPO0lBQ3JCSyxpQkFBaUJMLE9BQU87SUFDeEJNLGtCQUFrQk4sT0FBTztJQUN6Qk8sZ0JBQWdCUCxPQUFPO0lBQ3ZCUSxZQUFZUixPQUFPO0lBQ25CUyxlQUFlVCxPQUFPO0lBQ3RCVSxlQUFlVixPQUFPO0lBQ3RCVyxlQUFlWCxPQUFPO0lBQ3RCWSxRQUFRWixPQUFPO0lBQ2ZhLGdCQUFnQmIsT0FBTztJQUN2QmMsU0FBU2QsT0FBTztJQUNoQmUsZUFBZWYsT0FBTztJQUN0QmdCLGFBQWFoQixPQUFPO0lBQ3BCaUIsZ0JBQWdCakIsT0FBTztJQUN2QmtCLFlBQVlsQixPQUFPO0FBQ3JCIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtBZ2VudDogU3ltYm9sKCdhZ2VudCcpLFxuICBrT3B0aW9uczogU3ltYm9sKCdvcHRpb25zJyksXG4gIGtGYWN0b3J5OiBTeW1ib2woJ2ZhY3RvcnknKSxcbiAga0Rpc3BhdGNoZXM6IFN5bWJvbCgnZGlzcGF0Y2hlcycpLFxuICBrRGlzcGF0Y2hLZXk6IFN5bWJvbCgnZGlzcGF0Y2gga2V5JyksXG4gIGtEZWZhdWx0SGVhZGVyczogU3ltYm9sKCdkZWZhdWx0IGhlYWRlcnMnKSxcbiAga0RlZmF1bHRUcmFpbGVyczogU3ltYm9sKCdkZWZhdWx0IHRyYWlsZXJzJyksXG4gIGtDb250ZW50TGVuZ3RoOiBTeW1ib2woJ2NvbnRlbnQgbGVuZ3RoJyksXG4gIGtNb2NrQWdlbnQ6IFN5bWJvbCgnbW9jayBhZ2VudCcpLFxuICBrTW9ja0FnZW50U2V0OiBTeW1ib2woJ21vY2sgYWdlbnQgc2V0JyksXG4gIGtNb2NrQWdlbnRHZXQ6IFN5bWJvbCgnbW9jayBhZ2VudCBnZXQnKSxcbiAga01vY2tEaXNwYXRjaDogU3ltYm9sKCdtb2NrIGRpc3BhdGNoJyksXG4gIGtDbG9zZTogU3ltYm9sKCdjbG9zZScpLFxuICBrT3JpZ2luYWxDbG9zZTogU3ltYm9sKCdvcmlnaW5hbCBhZ2VudCBjbG9zZScpLFxuICBrT3JpZ2luOiBTeW1ib2woJ29yaWdpbicpLFxuICBrSXNNb2NrQWN0aXZlOiBTeW1ib2woJ2lzIG1vY2sgYWN0aXZlJyksXG4gIGtOZXRDb25uZWN0OiBTeW1ib2woJ25ldCBjb25uZWN0JyksXG4gIGtHZXROZXRDb25uZWN0OiBTeW1ib2woJ2dldCBuZXQgY29ubmVjdCcpLFxuICBrQ29ubmVjdGVkOiBTeW1ib2woJ2Nvbm5lY3RlZCcpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtBZ2VudCIsIlN5bWJvbCIsImtPcHRpb25zIiwia0ZhY3RvcnkiLCJrRGlzcGF0Y2hlcyIsImtEaXNwYXRjaEtleSIsImtEZWZhdWx0SGVhZGVycyIsImtEZWZhdWx0VHJhaWxlcnMiLCJrQ29udGVudExlbmd0aCIsImtNb2NrQWdlbnQiLCJrTW9ja0FnZW50U2V0Iiwia01vY2tBZ2VudEdldCIsImtNb2NrRGlzcGF0Y2giLCJrQ2xvc2UiLCJrT3JpZ2luYWxDbG9zZSIsImtPcmlnaW4iLCJrSXNNb2NrQWN0aXZlIiwia05ldENvbm5lY3QiLCJrR2V0TmV0Q29ubmVjdCIsImtDb25uZWN0ZWQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(ssr)/./node_modules/undici/lib/mock/mock-errors.js\");\nconst { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\");\nconst { types: { isPromise } } = __webpack_require__(/*! node:util */ \"node:util\");\nfunction matchValue(match, value) {\n    if (typeof match === 'string') {\n        return match === value;\n    }\n    if (match instanceof RegExp) {\n        return match.test(value);\n    }\n    if (typeof match === 'function') {\n        return match(value) === true;\n    }\n    return false;\n}\nfunction lowerCaseEntries(headers) {\n    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue])=>{\n        return [\n            headerName.toLocaleLowerCase(),\n            headerValue\n        ];\n    }));\n}\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */ function getHeaderByName(headers, key) {\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n                return headers[i + 1];\n            }\n        }\n        return undefined;\n    } else if (typeof headers.get === 'function') {\n        return headers.get(key);\n    } else {\n        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n    }\n}\n/** @param {string[]} headers */ function buildHeadersFromArray(headers) {\n    const clone = headers.slice();\n    const entries = [];\n    for(let index = 0; index < clone.length; index += 2){\n        entries.push([\n            clone[index],\n            clone[index + 1]\n        ]);\n    }\n    return Object.fromEntries(entries);\n}\nfunction matchHeaders(mockDispatch, headers) {\n    if (typeof mockDispatch.headers === 'function') {\n        if (Array.isArray(headers)) {\n            headers = buildHeadersFromArray(headers);\n        }\n        return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});\n    }\n    if (typeof mockDispatch.headers === 'undefined') {\n        return true;\n    }\n    if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n        return false;\n    }\n    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)){\n        const headerValue = getHeaderByName(headers, matchHeaderName);\n        if (!matchValue(matchHeaderValue, headerValue)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction safeUrl(path) {\n    if (typeof path !== 'string') {\n        return path;\n    }\n    const pathSegments = path.split('?');\n    if (pathSegments.length !== 2) {\n        return path;\n    }\n    const qp = new URLSearchParams(pathSegments.pop());\n    qp.sort();\n    return [\n        ...pathSegments,\n        qp.toString()\n    ].join('?');\n}\nfunction matchKey(mockDispatch, { path, method, body, headers }) {\n    const pathMatch = matchValue(mockDispatch.path, path);\n    const methodMatch = matchValue(mockDispatch.method, method);\n    const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true;\n    const headersMatch = matchHeaders(mockDispatch, headers);\n    return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\nfunction getResponseData(data) {\n    if (Buffer.isBuffer(data)) {\n        return data;\n    } else if (typeof data === 'object') {\n        return JSON.stringify(data);\n    } else {\n        return data.toString();\n    }\n}\nfunction getMockDispatch(mockDispatches, key) {\n    const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n    const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath;\n    // Match path\n    let matchedMockDispatches = mockDispatches.filter(({ consumed })=>!consumed).filter(({ path })=>matchValue(safeUrl(path), resolvedPath));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n    }\n    // Match method\n    matchedMockDispatches = matchedMockDispatches.filter(({ method })=>matchValue(method, key.method));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);\n    }\n    // Match body\n    matchedMockDispatches = matchedMockDispatches.filter(({ body })=>typeof body !== 'undefined' ? matchValue(body, key.body) : true);\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);\n    }\n    // Match headers\n    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch)=>matchHeaders(mockDispatch, key.headers));\n    if (matchedMockDispatches.length === 0) {\n        const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers;\n        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);\n    }\n    return matchedMockDispatches[0];\n}\nfunction addMockDispatch(mockDispatches, key, data) {\n    const baseData = {\n        timesInvoked: 0,\n        times: 1,\n        persist: false,\n        consumed: false\n    };\n    const replyData = typeof data === 'function' ? {\n        callback: data\n    } : {\n        ...data\n    };\n    const newMockDispatch = {\n        ...baseData,\n        ...key,\n        pending: true,\n        data: {\n            error: null,\n            ...replyData\n        }\n    };\n    mockDispatches.push(newMockDispatch);\n    return newMockDispatch;\n}\nfunction deleteMockDispatch(mockDispatches, key) {\n    const index = mockDispatches.findIndex((dispatch)=>{\n        if (!dispatch.consumed) {\n            return false;\n        }\n        return matchKey(dispatch, key);\n    });\n    if (index !== -1) {\n        mockDispatches.splice(index, 1);\n    }\n}\nfunction buildKey(opts) {\n    const { path, method, body, headers, query } = opts;\n    return {\n        path,\n        method,\n        body,\n        headers,\n        query\n    };\n}\nfunction generateKeyValues(data) {\n    const keys = Object.keys(data);\n    const result = [];\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        const value = data[key];\n        const name = Buffer.from(`${key}`);\n        if (Array.isArray(value)) {\n            for(let j = 0; j < value.length; ++j){\n                result.push(name, Buffer.from(`${value[j]}`));\n            }\n        } else {\n            result.push(name, Buffer.from(`${value}`));\n        }\n    }\n    return result;\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */ function getStatusText(statusCode) {\n    return STATUS_CODES[statusCode] || 'unknown';\n}\nasync function getResponse(body) {\n    const buffers = [];\n    for await (const data of body){\n        buffers.push(data);\n    }\n    return Buffer.concat(buffers).toString('utf8');\n}\n/**\n * Mock dispatch function used to simulate undici dispatches\n */ function mockDispatch(opts, handler) {\n    // Get mock dispatch from built key\n    const key = buildKey(opts);\n    const mockDispatch = getMockDispatch(this[kDispatches], key);\n    mockDispatch.timesInvoked++;\n    // Here's where we resolve a callback if a callback is present for the dispatch data.\n    if (mockDispatch.data.callback) {\n        mockDispatch.data = {\n            ...mockDispatch.data,\n            ...mockDispatch.data.callback(opts)\n        };\n    }\n    // Parse mockDispatch data\n    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;\n    const { timesInvoked, times } = mockDispatch;\n    // If it's used up and not persistent, mark as consumed\n    mockDispatch.consumed = !persist && timesInvoked >= times;\n    mockDispatch.pending = timesInvoked < times;\n    // If specified, trigger dispatch error\n    if (error !== null) {\n        deleteMockDispatch(this[kDispatches], key);\n        handler.onError(error);\n        return true;\n    }\n    // Handle the request with a delay if necessary\n    if (typeof delay === 'number' && delay > 0) {\n        setTimeout(()=>{\n            handleReply(this[kDispatches]);\n        }, delay);\n    } else {\n        handleReply(this[kDispatches]);\n    }\n    function handleReply(mockDispatches, _data = data) {\n        // fetch's HeadersList is a 1D string array\n        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n        const body = typeof _data === 'function' ? _data({\n            ...opts,\n            headers: optsHeaders\n        }) : _data;\n        // util.types.isPromise is likely needed for jest.\n        if (isPromise(body)) {\n            // If handleReply is asynchronous, throwing an error\n            // in the callback will reject the promise, rather than\n            // synchronously throw the error, which breaks some tests.\n            // Rather, we wait for the callback to resolve if it is a\n            // promise, and then re-run handleReply with the new body.\n            body.then((newData)=>handleReply(mockDispatches, newData));\n            return;\n        }\n        const responseData = getResponseData(body);\n        const responseHeaders = generateKeyValues(headers);\n        const responseTrailers = generateKeyValues(trailers);\n        handler.onConnect?.((err)=>handler.onError(err), null);\n        handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));\n        handler.onData?.(Buffer.from(responseData));\n        handler.onComplete?.(responseTrailers);\n        deleteMockDispatch(mockDispatches, key);\n    }\n    function resume() {}\n    return true;\n}\nfunction buildMockDispatch() {\n    const agent = this[kMockAgent];\n    const origin = this[kOrigin];\n    const originalDispatch = this[kOriginalDispatch];\n    return function dispatch(opts, handler) {\n        if (agent.isMockActive) {\n            try {\n                mockDispatch.call(this, opts, handler);\n            } catch (error) {\n                if (error instanceof MockNotMatchedError) {\n                    const netConnect = agent[kGetNetConnect]();\n                    if (netConnect === false) {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n                    }\n                    if (checkNetConnect(netConnect, origin)) {\n                        originalDispatch.call(this, opts, handler);\n                    } else {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n                    }\n                } else {\n                    throw error;\n                }\n            }\n        } else {\n            originalDispatch.call(this, opts, handler);\n        }\n    };\n}\nfunction checkNetConnect(netConnect, origin) {\n    const url = new URL(origin);\n    if (netConnect === true) {\n        return true;\n    } else if (Array.isArray(netConnect) && netConnect.some((matcher)=>matchValue(matcher, url.host))) {\n        return true;\n    }\n    return false;\n}\nfunction buildMockOptions(opts) {\n    if (opts) {\n        const { agent, ...mockOptions } = opts;\n        return mockOptions;\n    }\n}\nmodule.exports = {\n    getResponseData,\n    getMockDispatch,\n    addMockDispatch,\n    deleteMockDispatch,\n    buildKey,\n    generateKeyValues,\n    matchValue,\n    getResponse,\n    getStatusText,\n    mockDispatch,\n    buildMockDispatch,\n    checkNetConnect,\n    buildMockOptions,\n    getHeaderByName,\n    buildHeadersFromArray\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG1CQUFtQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLDBFQUFlO0FBQ3ZELE1BQU0sRUFDSkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLGlCQUFpQixFQUNqQkMsT0FBTyxFQUNQQyxjQUFjLEVBQ2YsR0FBR0wsbUJBQU9BLENBQUMsNEVBQWdCO0FBQzVCLE1BQU0sRUFBRU0sUUFBUSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDLGtFQUFjO0FBQzNDLE1BQU0sRUFBRU8sWUFBWSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDLDRCQUFXO0FBQzVDLE1BQU0sRUFDSlEsT0FBTyxFQUNMQyxTQUFTLEVBQ1YsRUFDRixHQUFHVCxtQkFBT0EsQ0FBQyw0QkFBVztBQUV2QixTQUFTVSxXQUFZQyxLQUFLLEVBQUVDLEtBQUs7SUFDL0IsSUFBSSxPQUFPRCxVQUFVLFVBQVU7UUFDN0IsT0FBT0EsVUFBVUM7SUFDbkI7SUFDQSxJQUFJRCxpQkFBaUJFLFFBQVE7UUFDM0IsT0FBT0YsTUFBTUcsSUFBSSxDQUFDRjtJQUNwQjtJQUNBLElBQUksT0FBT0QsVUFBVSxZQUFZO1FBQy9CLE9BQU9BLE1BQU1DLFdBQVc7SUFDMUI7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTRyxpQkFBa0JDLE9BQU87SUFDaEMsT0FBT0MsT0FBT0MsV0FBVyxDQUN2QkQsT0FBT0UsT0FBTyxDQUFDSCxTQUFTSSxHQUFHLENBQUMsQ0FBQyxDQUFDQyxZQUFZQyxZQUFZO1FBQ3BELE9BQU87WUFBQ0QsV0FBV0UsaUJBQWlCO1lBQUlEO1NBQVk7SUFDdEQ7QUFFSjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNFLGdCQUFpQlIsT0FBTyxFQUFFUyxHQUFHO0lBQ3BDLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ1gsVUFBVTtRQUMxQixJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSVos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RzlDO1FBQ2xDLE9BQU84QztJQUNUO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y3RTtJQUNBTTtJQUNBUTtJQUNBVTtJQUNBSTtJQUNBRTtJQUNBOUU7SUFDQXNGO0lBQ0FGO0lBQ0F4RDtJQUNBZ0Y7SUFDQVE7SUFDQU07SUFDQTVHO0lBQ0FRO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBNb2NrTm90TWF0Y2hlZEVycm9yIH0gPSByZXF1aXJlKCcuL21vY2stZXJyb3JzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrT3JpZ2luLFxuICBrR2V0TmV0Q29ubmVjdFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgYnVpbGRVUkwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IHtcbiAgdHlwZXM6IHtcbiAgICBpc1Byb21pc2VcbiAgfVxufSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5cbmZ1bmN0aW9uIG1hdGNoVmFsdWUgKG1hdGNoLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG1hdGNoID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtYXRjaCA9PT0gdmFsdWVcbiAgfVxuICBpZiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gbWF0Y2gudGVzdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1hdGNoKHZhbHVlKSA9PT0gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBsb3dlckNhc2VFbnRyaWVzIChoZWFkZXJzKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykubWFwKChbaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gW2hlYWRlck5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSwgaGVhZGVyVmFsdWVdXG4gICAgfSlcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9pbmRleCcpLkhlYWRlcnN8c3RyaW5nW118UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJCeU5hbWUgKGhlYWRlcnMsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGhlYWRlcnNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0ga2V5LnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBoZWFkZXJzLmdldChrZXkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycylba2V5LnRvTG9jYWxlTG93ZXJDYXNlKCldXG4gIH1cbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlcnMgKi9cbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyc0Zyb21BcnJheSAoaGVhZGVycykgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICBjb25zdCBjbG9uZSA9IGhlYWRlcnMuc2xpY2UoKVxuICBjb25zdCBlbnRyaWVzID0gW11cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsb25lLmxlbmd0aDsgaW5kZXggKz0gMikge1xuICAgIGVudHJpZXMucHVzaChbY2xvbmVbaW5kZXhdLCBjbG9uZVtpbmRleCArIDFdXSlcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpXG59XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVycyAobW9ja0Rpc3BhdGNoLCBoZWFkZXJzKSB7XG4gIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICAgICAgaGVhZGVycyA9IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShoZWFkZXJzKVxuICAgIH1cbiAgICByZXR1cm4gbW9ja0Rpc3BhdGNoLmhlYWRlcnMoaGVhZGVycyA/IGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycykgOiB7fSlcbiAgfVxuICBpZiAodHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHR5cGVvZiBoZWFkZXJzICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IFttYXRjaEhlYWRlck5hbWUsIG1hdGNoSGVhZGVyVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1vY2tEaXNwYXRjaC5oZWFkZXJzKSkge1xuICAgIGNvbnN0IGhlYWRlclZhbHVlID0gZ2V0SGVhZGVyQnlOYW1lKGhlYWRlcnMsIG1hdGNoSGVhZGVyTmFtZSlcblxuICAgIGlmICghbWF0Y2hWYWx1ZShtYXRjaEhlYWRlclZhbHVlLCBoZWFkZXJWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzYWZlVXJsIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcGF0aFNlZ21lbnRzID0gcGF0aC5zcGxpdCgnPycpXG5cbiAgaWYgKHBhdGhTZWdtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGhTZWdtZW50cy5wb3AoKSlcbiAgcXAuc29ydCgpXG4gIHJldHVybiBbLi4ucGF0aFNlZ21lbnRzLCBxcC50b1N0cmluZygpXS5qb2luKCc/Jylcbn1cblxuZnVuY3Rpb24gbWF0Y2hLZXkgKG1vY2tEaXNwYXRjaCwgeyBwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMgfSkge1xuICBjb25zdCBwYXRoTWF0Y2ggPSBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5wYXRoLCBwYXRoKVxuICBjb25zdCBtZXRob2RNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLm1ldGhvZCwgbWV0aG9kKVxuICBjb25zdCBib2R5TWF0Y2ggPSB0eXBlb2YgbW9ja0Rpc3BhdGNoLmJvZHkgIT09ICd1bmRlZmluZWQnID8gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2guYm9keSwgYm9keSkgOiB0cnVlXG4gIGNvbnN0IGhlYWRlcnNNYXRjaCA9IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGhlYWRlcnMpXG4gIHJldHVybiBwYXRoTWF0Y2ggJiYgbWV0aG9kTWF0Y2ggJiYgYm9keU1hdGNoICYmIGhlYWRlcnNNYXRjaFxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZURhdGEgKGRhdGEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICBjb25zdCBiYXNlUGF0aCA9IGtleS5xdWVyeSA/IGJ1aWxkVVJMKGtleS5wYXRoLCBrZXkucXVlcnkpIDoga2V5LnBhdGhcbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gdHlwZW9mIGJhc2VQYXRoID09PSAnc3RyaW5nJyA/IHNhZmVVcmwoYmFzZVBhdGgpIDogYmFzZVBhdGhcblxuICAvLyBNYXRjaCBwYXRoXG4gIGxldCBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgY29uc3VtZWQgfSkgPT4gIWNvbnN1bWVkKS5maWx0ZXIoKHsgcGF0aCB9KSA9PiBtYXRjaFZhbHVlKHNhZmVVcmwocGF0aCksIHJlc29sdmVkUGF0aCkpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggbWV0aG9kXG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgbWV0aG9kIH0pID0+IG1hdGNoVmFsdWUobWV0aG9kLCBrZXkubWV0aG9kKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgbWV0aG9kICcke2tleS5tZXRob2R9JyBvbiBwYXRoICcke3Jlc29sdmVkUGF0aH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGJvZHlcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBib2R5IH0pID0+IHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyA/IG1hdGNoVmFsdWUoYm9keSwga2V5LmJvZHkpIDogdHJ1ZSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgYm9keSAnJHtrZXkuYm9keX0nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggaGVhZGVyc1xuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKChtb2NrRGlzcGF0Y2gpID0+IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGtleS5oZWFkZXJzKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdHlwZW9mIGtleS5oZWFkZXJzID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGtleS5oZWFkZXJzKSA6IGtleS5oZWFkZXJzXG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGhlYWRlcnMgJyR7aGVhZGVyc30nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRNb2NrRGlzcGF0Y2hlc1swXVxufVxuXG5mdW5jdGlvbiBhZGRNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXksIGRhdGEpIHtcbiAgY29uc3QgYmFzZURhdGEgPSB7IHRpbWVzSW52b2tlZDogMCwgdGltZXM6IDEsIHBlcnNpc3Q6IGZhbHNlLCBjb25zdW1lZDogZmFsc2UgfVxuICBjb25zdCByZXBseURhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IHsgY2FsbGJhY2s6IGRhdGEgfSA6IHsgLi4uZGF0YSB9XG4gIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IHsgLi4uYmFzZURhdGEsIC4uLmtleSwgcGVuZGluZzogdHJ1ZSwgZGF0YTogeyBlcnJvcjogbnVsbCwgLi4ucmVwbHlEYXRhIH0gfVxuICBtb2NrRGlzcGF0Y2hlcy5wdXNoKG5ld01vY2tEaXNwYXRjaClcbiAgcmV0dXJuIG5ld01vY2tEaXNwYXRjaFxufVxuXG5mdW5jdGlvbiBkZWxldGVNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgY29uc3QgaW5kZXggPSBtb2NrRGlzcGF0Y2hlcy5maW5kSW5kZXgoZGlzcGF0Y2ggPT4ge1xuICAgIGlmICghZGlzcGF0Y2guY29uc3VtZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hLZXkoZGlzcGF0Y2gsIGtleSlcbiAgfSlcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIG1vY2tEaXNwYXRjaGVzLnNwbGljZShpbmRleCwgMSlcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEtleSAob3B0cykge1xuICBjb25zdCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgcXVlcnkgfSA9IG9wdHNcbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVZhbHVlcyAoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldXG4gICAgY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKGAke2tleX1gKVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7ICsraikge1xuICAgICAgICByZXN1bHQucHVzaChuYW1lLCBCdWZmZXIuZnJvbShgJHt2YWx1ZVtqXX1gKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobmFtZSwgQnVmZmVyLmZyb20oYCR7dmFsdWV9YCkpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICovXG5mdW5jdGlvbiBnZXRTdGF0dXNUZXh0IChzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0gfHwgJ3Vua25vd24nXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlIChib2R5KSB7XG4gIGNvbnN0IGJ1ZmZlcnMgPSBbXVxuICBmb3IgYXdhaXQgKGNvbnN0IGRhdGEgb2YgYm9keSkge1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLnRvU3RyaW5nKCd1dGY4Jylcbn1cblxuLyoqXG4gKiBNb2NrIGRpc3BhdGNoIGZ1bmN0aW9uIHVzZWQgdG8gc2ltdWxhdGUgdW5kaWNpIGRpc3BhdGNoZXNcbiAqL1xuZnVuY3Rpb24gbW9ja0Rpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gIC8vIEdldCBtb2NrIGRpc3BhdGNoIGZyb20gYnVpbHQga2V5XG4gIGNvbnN0IGtleSA9IGJ1aWxkS2V5KG9wdHMpXG4gIGNvbnN0IG1vY2tEaXNwYXRjaCA9IGdldE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuXG4gIG1vY2tEaXNwYXRjaC50aW1lc0ludm9rZWQrK1xuXG4gIC8vIEhlcmUncyB3aGVyZSB3ZSByZXNvbHZlIGEgY2FsbGJhY2sgaWYgYSBjYWxsYmFjayBpcyBwcmVzZW50IGZvciB0aGUgZGlzcGF0Y2ggZGF0YS5cbiAgaWYgKG1vY2tEaXNwYXRjaC5kYXRhLmNhbGxiYWNrKSB7XG4gICAgbW9ja0Rpc3BhdGNoLmRhdGEgPSB7IC4uLm1vY2tEaXNwYXRjaC5kYXRhLCAuLi5tb2NrRGlzcGF0Y2guZGF0YS5jYWxsYmFjayhvcHRzKSB9XG4gIH1cblxuICAvLyBQYXJzZSBtb2NrRGlzcGF0Y2ggZGF0YVxuICBjb25zdCB7IGRhdGE6IHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMsIGVycm9yIH0sIGRlbGF5LCBwZXJzaXN0IH0gPSBtb2NrRGlzcGF0Y2hcbiAgY29uc3QgeyB0aW1lc0ludm9rZWQsIHRpbWVzIH0gPSBtb2NrRGlzcGF0Y2hcblxuICAvLyBJZiBpdCdzIHVzZWQgdXAgYW5kIG5vdCBwZXJzaXN0ZW50LCBtYXJrIGFzIGNvbnN1bWVkXG4gIG1vY2tEaXNwYXRjaC5jb25zdW1lZCA9ICFwZXJzaXN0ICYmIHRpbWVzSW52b2tlZCA+PSB0aW1lc1xuICBtb2NrRGlzcGF0Y2gucGVuZGluZyA9IHRpbWVzSW52b2tlZCA8IHRpbWVzXG5cbiAgLy8gSWYgc3BlY2lmaWVkLCB0cmlnZ2VyIGRpc3BhdGNoIGVycm9yXG4gIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuICAgIGhhbmRsZXIub25FcnJvcihlcnJvcilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSByZXF1ZXN0IHdpdGggYSBkZWxheSBpZiBuZWNlc3NhcnlcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgICB9LCBkZWxheSlcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlcGx5IChtb2NrRGlzcGF0Y2hlcywgX2RhdGEgPSBkYXRhKSB7XG4gICAgLy8gZmV0Y2gncyBIZWFkZXJzTGlzdCBpcyBhIDFEIHN0cmluZyBhcnJheVxuICAgIGNvbnN0IG9wdHNIZWFkZXJzID0gQXJyYXkuaXNBcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA/IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA6IG9wdHMuaGVhZGVyc1xuICAgIGNvbnN0IGJvZHkgPSB0eXBlb2YgX2RhdGEgPT09ICdmdW5jdGlvbidcbiAgICAgID8gX2RhdGEoeyAuLi5vcHRzLCBoZWFkZXJzOiBvcHRzSGVhZGVycyB9KVxuICAgICAgOiBfZGF0YVxuXG4gICAgLy8gdXRpbC50eXBlcy5pc1Byb21pc2UgaXMgbGlrZWx5IG5lZWRlZCBmb3IgamVzdC5cbiAgICBpZiAoaXNQcm9taXNlKGJvZHkpKSB7XG4gICAgICAvLyBJZiBoYW5kbGVSZXBseSBpcyBhc3luY2hyb25vdXMsIHRocm93aW5nIGFuIGVycm9yXG4gICAgICAvLyBpbiB0aGUgY2FsbGJhY2sgd2lsbCByZWplY3QgdGhlIHByb21pc2UsIHJhdGhlciB0aGFuXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IHRocm93IHRoZSBlcnJvciwgd2hpY2ggYnJlYWtzIHNvbWUgdGVzdHMuXG4gICAgICAvLyBSYXRoZXIsIHdlIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byByZXNvbHZlIGlmIGl0IGlzIGFcbiAgICAgIC8vIHByb21pc2UsIGFuZCB0aGVuIHJlLXJ1biBoYW5kbGVSZXBseSB3aXRoIHRoZSBuZXcgYm9keS5cbiAgICAgIGJvZHkudGhlbigobmV3RGF0YSkgPT4gaGFuZGxlUmVwbHkobW9ja0Rpc3BhdGNoZXMsIG5ld0RhdGEpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGJvZHkpXG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXMoaGVhZGVycylcbiAgICBjb25zdCByZXNwb25zZVRyYWlsZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXModHJhaWxlcnMpXG5cbiAgICBoYW5kbGVyLm9uQ29ubmVjdD8uKGVyciA9PiBoYW5kbGVyLm9uRXJyb3IoZXJyKSwgbnVsbClcbiAgICBoYW5kbGVyLm9uSGVhZGVycz8uKHN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgcmVzdW1lLCBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpKVxuICAgIGhhbmRsZXIub25EYXRhPy4oQnVmZmVyLmZyb20ocmVzcG9uc2VEYXRhKSlcbiAgICBoYW5kbGVyLm9uQ29tcGxldGU/LihyZXNwb25zZVRyYWlsZXJzKVxuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaChtb2NrRGlzcGF0Y2hlcywga2V5KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lICgpIHt9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrRGlzcGF0Y2ggKCkge1xuICBjb25zdCBhZ2VudCA9IHRoaXNba01vY2tBZ2VudF1cbiAgY29uc3Qgb3JpZ2luID0gdGhpc1trT3JpZ2luXVxuICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gdGhpc1trT3JpZ2luYWxEaXNwYXRjaF1cblxuICByZXR1cm4gZnVuY3Rpb24gZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoYWdlbnQuaXNNb2NrQWN0aXZlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtb2NrRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTW9ja05vdE1hdGNoZWRFcnJvcikge1xuICAgICAgICAgIGNvbnN0IG5ldENvbm5lY3QgPSBhZ2VudFtrR2V0TmV0Q29ubmVjdF0oKVxuICAgICAgICAgIGlmIChuZXRDb25uZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgZGlzYWJsZWQpYClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrTmV0Q29ubmVjdChuZXRDb25uZWN0LCBvcmlnaW4pKSB7XG4gICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgb3JpZ2luKWApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTmV0Q29ubmVjdCAobmV0Q29ubmVjdCwgb3JpZ2luKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwob3JpZ2luKVxuICBpZiAobmV0Q29ubmVjdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXRDb25uZWN0KSAmJiBuZXRDb25uZWN0LnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoVmFsdWUobWF0Y2hlciwgdXJsLmhvc3QpKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGJ1aWxkTW9ja09wdGlvbnMgKG9wdHMpIHtcbiAgaWYgKG9wdHMpIHtcbiAgICBjb25zdCB7IGFnZW50LCAuLi5tb2NrT3B0aW9ucyB9ID0gb3B0c1xuICAgIHJldHVybiBtb2NrT3B0aW9uc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZXNwb25zZURhdGEsXG4gIGdldE1vY2tEaXNwYXRjaCxcbiAgYWRkTW9ja0Rpc3BhdGNoLFxuICBkZWxldGVNb2NrRGlzcGF0Y2gsXG4gIGJ1aWxkS2V5LFxuICBnZW5lcmF0ZUtleVZhbHVlcyxcbiAgbWF0Y2hWYWx1ZSxcbiAgZ2V0UmVzcG9uc2UsXG4gIGdldFN0YXR1c1RleHQsXG4gIG1vY2tEaXNwYXRjaCxcbiAgYnVpbGRNb2NrRGlzcGF0Y2gsXG4gIGNoZWNrTmV0Q29ubmVjdCxcbiAgYnVpbGRNb2NrT3B0aW9ucyxcbiAgZ2V0SGVhZGVyQnlOYW1lLFxuICBidWlsZEhlYWRlcnNGcm9tQXJyYXlcbn1cbiJdLCJuYW1lcyI6WyJNb2NrTm90TWF0Y2hlZEVycm9yIiwicmVxdWlyZSIsImtEaXNwYXRjaGVzIiwia01vY2tBZ2VudCIsImtPcmlnaW5hbERpc3BhdGNoIiwia09yaWdpbiIsImtHZXROZXRDb25uZWN0IiwiYnVpbGRVUkwiLCJTVEFUVVNfQ09ERVMiLCJ0eXBlcyIsImlzUHJvbWlzZSIsIm1hdGNoVmFsdWUiLCJtYXRjaCIsInZhbHVlIiwiUmVnRXhwIiwidGVzdCIsImxvd2VyQ2FzZUVudHJpZXMiLCJoZWFkZXJzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwiaGVhZGVyTmFtZSIsImhlYWRlclZhbHVlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJnZXRIZWFkZXJCeU5hbWUiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZ2V0IiwiYnVpbGRIZWFkZXJzRnJvbUFycmF5IiwiY2xvbmUiLCJzbGljZSIsImluZGV4IiwicHVzaCIsIm1hdGNoSGVhZGVycyIsIm1vY2tEaXNwYXRjaCIsIm1hdGNoSGVhZGVyTmFtZSIsIm1hdGNoSGVhZGVyVmFsdWUiLCJzYWZlVXJsIiwicGF0aCIsInBhdGhTZWdtZW50cyIsInNwbGl0IiwicXAiLCJVUkxTZWFyY2hQYXJhbXMiLCJwb3AiLCJzb3J0IiwidG9TdHJpbmciLCJqb2luIiwibWF0Y2hLZXkiLCJtZXRob2QiLCJib2R5IiwicGF0aE1hdGNoIiwibWV0aG9kTWF0Y2giLCJib2R5TWF0Y2giLCJoZWFkZXJzTWF0Y2giLCJnZXRSZXNwb25zZURhdGEiLCJkYXRhIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0TW9ja0Rpc3BhdGNoIiwibW9ja0Rpc3BhdGNoZXMiLCJiYXNlUGF0aCIsInF1ZXJ5IiwicmVzb2x2ZWRQYXRoIiwibWF0Y2hlZE1vY2tEaXNwYXRjaGVzIiwiZmlsdGVyIiwiY29uc3VtZWQiLCJhZGRNb2NrRGlzcGF0Y2giLCJiYXNlRGF0YSIsInRpbWVzSW52b2tlZCIsInRpbWVzIiwicGVyc2lzdCIsInJlcGx5RGF0YSIsImNhbGxiYWNrIiwibmV3TW9ja0Rpc3BhdGNoIiwicGVuZGluZyIsImVycm9yIiwiZGVsZXRlTW9ja0Rpc3BhdGNoIiwiZmluZEluZGV4IiwiZGlzcGF0Y2giLCJzcGxpY2UiLCJidWlsZEtleSIsIm9wdHMiLCJnZW5lcmF0ZUtleVZhbHVlcyIsImtleXMiLCJyZXN1bHQiLCJuYW1lIiwiZnJvbSIsImoiLCJnZXRTdGF0dXNUZXh0Iiwic3RhdHVzQ29kZSIsImdldFJlc3BvbnNlIiwiYnVmZmVycyIsImNvbmNhdCIsImhhbmRsZXIiLCJ0cmFpbGVycyIsImRlbGF5Iiwib25FcnJvciIsInNldFRpbWVvdXQiLCJoYW5kbGVSZXBseSIsIl9kYXRhIiwib3B0c0hlYWRlcnMiLCJ0aGVuIiwibmV3RGF0YSIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVHJhaWxlcnMiLCJvbkNvbm5lY3QiLCJlcnIiLCJvbkhlYWRlcnMiLCJyZXN1bWUiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwiYnVpbGRNb2NrRGlzcGF0Y2giLCJhZ2VudCIsIm9yaWdpbiIsIm9yaWdpbmFsRGlzcGF0Y2giLCJpc01vY2tBY3RpdmUiLCJjYWxsIiwibmV0Q29ubmVjdCIsIm1lc3NhZ2UiLCJjaGVja05ldENvbm5lY3QiLCJ1cmwiLCJVUkwiLCJzb21lIiwibWF0Y2hlciIsImhvc3QiLCJidWlsZE1vY2tPcHRpb25zIiwibW9ja09wdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { Console } = __webpack_require__(/*! node:console */ \"node:console\");\nconst PERSISTENT = process.versions.icu ? '✅' : 'Y ';\nconst NOT_PERSISTENT = process.versions.icu ? '❌' : 'N ';\n/**\n * Gets the output of `console.table(…)` as a string.\n */ module.exports = class PendingInterceptorsFormatter {\n    constructor({ disableColors } = {}){\n        this.transform = new Transform({\n            transform (chunk, _enc, cb) {\n                cb(null, chunk);\n            }\n        });\n        this.logger = new Console({\n            stdout: this.transform,\n            inspectOptions: {\n                colors: !disableColors && !process.env.CI\n            }\n        });\n    }\n    format(pendingInterceptors) {\n        const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin })=>({\n                Method: method,\n                Origin: origin,\n                Path: path,\n                'Status code': statusCode,\n                Persistent: persist ? PERSISTENT : NOT_PERSISTENT,\n                Invocations: timesInvoked,\n                Remaining: persist ? Infinity : times - timesInvoked\n            }));\n        this.logger.table(withPrettyHeaders);\n        return this.transform.read().toString();\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQzNDLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDLGtDQUFjO0FBRTFDLE1BQU1FLGFBQWFDLFFBQVFDLFFBQVEsQ0FBQ0MsR0FBRyxHQUFHLE1BQU07QUFDaEQsTUFBTUMsaUJBQWlCSCxRQUFRQyxRQUFRLENBQUNDLEdBQUcsR0FBRyxNQUFNO0FBRXBEOztDQUVDLEdBQ0RFLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQixZQUFhLEVBQUVDLGFBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ25DLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUlaLFVBQVU7WUFDN0JZLFdBQVdDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxFQUFFO2dCQUN4QkEsR0FBRyxNQUFNRjtZQUNYO1FBQ0Y7UUFFQSxJQUFJLENBQUNHLE1BQU0sR0FBRyxJQUFJZCxRQUFRO1lBQ3hCZSxRQUFRLElBQUksQ0FBQ0wsU0FBUztZQUN0Qk0sZ0JBQWdCO2dCQUNkQyxRQUFRLENBQUNSLGlCQUFpQixDQUFDUCxRQUFRZ0IsR0FBRyxDQUFDQyxFQUFFO1lBQzNDO1FBQ0Y7SUFDRjtJQUVBQyxPQUFRQyxtQkFBbUIsRUFBRTtRQUMzQixNQUFNQyxvQkFBb0JELG9CQUFvQkUsR0FBRyxDQUMvQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsRUFBRSxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsWUFBWSxFQUFFQyxNQUFNLEVBQUUsR0FBTTtnQkFDakZDLFFBQVFSO2dCQUNSUyxRQUFRRjtnQkFDUkcsTUFBTVQ7Z0JBQ04sZUFBZUU7Z0JBQ2ZRLFlBQVlQLFVBQVUzQixhQUFhSTtnQkFDbkMrQixhQUFhTjtnQkFDYk8sV0FBV1QsVUFBVVUsV0FBV1QsUUFBUUM7WUFDMUM7UUFFRixJQUFJLENBQUNoQixNQUFNLENBQUN5QixLQUFLLENBQUNqQjtRQUNsQixPQUFPLElBQUksQ0FBQ1osU0FBUyxDQUFDOEIsSUFBSSxHQUFHQyxRQUFRO0lBQ3ZDO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xccGVuZGluZy1pbnRlcmNlcHRvcnMtZm9ybWF0dGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBDb25zb2xlIH0gPSByZXF1aXJlKCdub2RlOmNvbnNvbGUnKVxuXG5jb25zdCBQRVJTSVNURU5UID0gcHJvY2Vzcy52ZXJzaW9ucy5pY3UgPyAn4pyFJyA6ICdZICdcbmNvbnN0IE5PVF9QRVJTSVNURU5UID0gcHJvY2Vzcy52ZXJzaW9ucy5pY3UgPyAn4p2MJyA6ICdOICdcblxuLyoqXG4gKiBHZXRzIHRoZSBvdXRwdXQgb2YgYGNvbnNvbGUudGFibGUo4oCmKWAgYXMgYSBzdHJpbmcuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yICh7IGRpc2FibGVDb2xvcnMgfSA9IHt9KSB7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKHtcbiAgICAgIHRyYW5zZm9ybSAoY2h1bmssIF9lbmMsIGNiKSB7XG4gICAgICAgIGNiKG51bGwsIGNodW5rKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmxvZ2dlciA9IG5ldyBDb25zb2xlKHtcbiAgICAgIHN0ZG91dDogdGhpcy50cmFuc2Zvcm0sXG4gICAgICBpbnNwZWN0T3B0aW9uczoge1xuICAgICAgICBjb2xvcnM6ICFkaXNhYmxlQ29sb3JzICYmICFwcm9jZXNzLmVudi5DSVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmb3JtYXQgKHBlbmRpbmdJbnRlcmNlcHRvcnMpIHtcbiAgICBjb25zdCB3aXRoUHJldHR5SGVhZGVycyA9IHBlbmRpbmdJbnRlcmNlcHRvcnMubWFwKFxuICAgICAgKHsgbWV0aG9kLCBwYXRoLCBkYXRhOiB7IHN0YXR1c0NvZGUgfSwgcGVyc2lzdCwgdGltZXMsIHRpbWVzSW52b2tlZCwgb3JpZ2luIH0pID0+ICh7XG4gICAgICAgIE1ldGhvZDogbWV0aG9kLFxuICAgICAgICBPcmlnaW46IG9yaWdpbixcbiAgICAgICAgUGF0aDogcGF0aCxcbiAgICAgICAgJ1N0YXR1cyBjb2RlJzogc3RhdHVzQ29kZSxcbiAgICAgICAgUGVyc2lzdGVudDogcGVyc2lzdCA/IFBFUlNJU1RFTlQgOiBOT1RfUEVSU0lTVEVOVCxcbiAgICAgICAgSW52b2NhdGlvbnM6IHRpbWVzSW52b2tlZCxcbiAgICAgICAgUmVtYWluaW5nOiBwZXJzaXN0ID8gSW5maW5pdHkgOiB0aW1lcyAtIHRpbWVzSW52b2tlZFxuICAgICAgfSkpXG5cbiAgICB0aGlzLmxvZ2dlci50YWJsZSh3aXRoUHJldHR5SGVhZGVycylcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucmVhZCgpLnRvU3RyaW5nKClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlRyYW5zZm9ybSIsInJlcXVpcmUiLCJDb25zb2xlIiwiUEVSU0lTVEVOVCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsImljdSIsIk5PVF9QRVJTSVNURU5UIiwibW9kdWxlIiwiZXhwb3J0cyIsIlBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIiLCJkaXNhYmxlQ29sb3JzIiwidHJhbnNmb3JtIiwiY2h1bmsiLCJfZW5jIiwiY2IiLCJsb2dnZXIiLCJzdGRvdXQiLCJpbnNwZWN0T3B0aW9ucyIsImNvbG9ycyIsImVudiIsIkNJIiwiZm9ybWF0IiwicGVuZGluZ0ludGVyY2VwdG9ycyIsIndpdGhQcmV0dHlIZWFkZXJzIiwibWFwIiwibWV0aG9kIiwicGF0aCIsImRhdGEiLCJzdGF0dXNDb2RlIiwicGVyc2lzdCIsInRpbWVzIiwidGltZXNJbnZva2VkIiwib3JpZ2luIiwiTWV0aG9kIiwiT3JpZ2luIiwiUGF0aCIsIlBlcnNpc3RlbnQiLCJJbnZvY2F0aW9ucyIsIlJlbWFpbmluZyIsIkluZmluaXR5IiwidGFibGUiLCJyZWFkIiwidG9TdHJpbmciXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/pluralizer.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/pluralizer.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nconst singulars = {\n    pronoun: 'it',\n    is: 'is',\n    was: 'was',\n    this: 'this'\n};\nconst plurals = {\n    pronoun: 'they',\n    is: 'are',\n    was: 'were',\n    this: 'these'\n};\nmodule.exports = class Pluralizer {\n    constructor(singular, plural){\n        this.singular = singular;\n        this.plural = plural;\n    }\n    pluralize(count) {\n        const one = count === 1;\n        const keys = one ? singulars : plurals;\n        const noun = one ? this.singular : this.plural;\n        return {\n            ...keys,\n            count,\n            noun\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZO0lBQ2hCQyxTQUFTO0lBQ1RDLElBQUk7SUFDSkMsS0FBSztJQUNMQyxNQUFNO0FBQ1I7QUFFQSxNQUFNQyxVQUFVO0lBQ2RKLFNBQVM7SUFDVEMsSUFBSTtJQUNKQyxLQUFLO0lBQ0xDLE1BQU07QUFDUjtBQUVBRSxPQUFPQyxPQUFPLEdBQUcsTUFBTUM7SUFDckIsWUFBYUMsUUFBUSxFQUFFQyxNQUFNLENBQUU7UUFDN0IsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNoQjtJQUVBQyxVQUFXQyxLQUFLLEVBQUU7UUFDaEIsTUFBTUMsTUFBTUQsVUFBVTtRQUN0QixNQUFNRSxPQUFPRCxNQUFNYixZQUFZSztRQUMvQixNQUFNVSxPQUFPRixNQUFNLElBQUksQ0FBQ0osUUFBUSxHQUFHLElBQUksQ0FBQ0MsTUFBTTtRQUM5QyxPQUFPO1lBQUUsR0FBR0ksSUFBSTtZQUFFRjtZQUFPRztRQUFLO0lBQ2hDO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xccGx1cmFsaXplci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgc2luZ3VsYXJzID0ge1xuICBwcm9ub3VuOiAnaXQnLFxuICBpczogJ2lzJyxcbiAgd2FzOiAnd2FzJyxcbiAgdGhpczogJ3RoaXMnXG59XG5cbmNvbnN0IHBsdXJhbHMgPSB7XG4gIHByb25vdW46ICd0aGV5JyxcbiAgaXM6ICdhcmUnLFxuICB3YXM6ICd3ZXJlJyxcbiAgdGhpczogJ3RoZXNlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBsdXJhbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoc2luZ3VsYXIsIHBsdXJhbCkge1xuICAgIHRoaXMuc2luZ3VsYXIgPSBzaW5ndWxhclxuICAgIHRoaXMucGx1cmFsID0gcGx1cmFsXG4gIH1cblxuICBwbHVyYWxpemUgKGNvdW50KSB7XG4gICAgY29uc3Qgb25lID0gY291bnQgPT09IDFcbiAgICBjb25zdCBrZXlzID0gb25lID8gc2luZ3VsYXJzIDogcGx1cmFsc1xuICAgIGNvbnN0IG5vdW4gPSBvbmUgPyB0aGlzLnNpbmd1bGFyIDogdGhpcy5wbHVyYWxcbiAgICByZXR1cm4geyAuLi5rZXlzLCBjb3VudCwgbm91biB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJzaW5ndWxhcnMiLCJwcm9ub3VuIiwiaXMiLCJ3YXMiLCJ0aGlzIiwicGx1cmFscyIsIm1vZHVsZSIsImV4cG9ydHMiLCJQbHVyYWxpemVyIiwic2luZ3VsYXIiLCJwbHVyYWwiLCJwbHVyYWxpemUiLCJjb3VudCIsIm9uZSIsImtleXMiLCJub3VuIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/pluralizer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/util/timers.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/util/timers.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nconst TICK_MS = 499;\nlet fastNow = Date.now();\nlet fastNowTimeout;\nconst fastTimers = [];\nfunction onTimeout() {\n    fastNow = Date.now();\n    let len = fastTimers.length;\n    let idx = 0;\n    while(idx < len){\n        const timer = fastTimers[idx];\n        if (timer.state === 0) {\n            timer.state = fastNow + timer.delay - TICK_MS;\n        } else if (timer.state > 0 && fastNow >= timer.state) {\n            timer.state = -1;\n            timer.callback(timer.opaque);\n        }\n        if (timer.state === -1) {\n            timer.state = -2;\n            if (idx !== len - 1) {\n                fastTimers[idx] = fastTimers.pop();\n            } else {\n                fastTimers.pop();\n            }\n            len -= 1;\n        } else {\n            idx += 1;\n        }\n    }\n    if (fastTimers.length > 0) {\n        refreshTimeout();\n    }\n}\nfunction refreshTimeout() {\n    if (fastNowTimeout?.refresh) {\n        fastNowTimeout.refresh();\n    } else {\n        clearTimeout(fastNowTimeout);\n        fastNowTimeout = setTimeout(onTimeout, TICK_MS);\n        if (fastNowTimeout.unref) {\n            fastNowTimeout.unref();\n        }\n    }\n}\nclass Timeout {\n    constructor(callback, delay, opaque){\n        this.callback = callback;\n        this.delay = delay;\n        this.opaque = opaque;\n        //  -2 not in timer list\n        //  -1 in timer list but inactive\n        //   0 in timer list waiting for time\n        // > 0 in timer list waiting for time to expire\n        this.state = -2;\n        this.refresh();\n    }\n    refresh() {\n        if (this.state === -2) {\n            fastTimers.push(this);\n            if (!fastNowTimeout || fastTimers.length === 1) {\n                refreshTimeout();\n            }\n        }\n        this.state = 0;\n    }\n    clear() {\n        this.state = -1;\n    }\n}\nmodule.exports = {\n    setTimeout (callback, delay, opaque) {\n        return delay <= 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);\n    },\n    clearTimeout (timeout) {\n        if (timeout instanceof Timeout) {\n            timeout.clear();\n        } else {\n            clearTimeout(timeout);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFVBQVU7QUFFaEIsSUFBSUMsVUFBVUMsS0FBS0MsR0FBRztBQUN0QixJQUFJQztBQUVKLE1BQU1DLGFBQWEsRUFBRTtBQUVyQixTQUFTQztJQUNQTCxVQUFVQyxLQUFLQyxHQUFHO0lBRWxCLElBQUlJLE1BQU1GLFdBQVdHLE1BQU07SUFDM0IsSUFBSUMsTUFBTTtJQUNWLE1BQU9BLE1BQU1GLElBQUs7UUFDaEIsTUFBTUcsUUFBUUwsVUFBVSxDQUFDSSxJQUFJO1FBRTdCLElBQUlDLE1BQU1DLEtBQUssS0FBSyxHQUFHO1lBQ3JCRCxNQUFNQyxLQUFLLEdBQUdWLFVBQVVTLE1BQU1FLEtBQUssR0FBR1o7UUFDeEMsT0FBTyxJQUFJVSxNQUFNQyxLQUFLLEdBQUcsS0FBS1YsV0FBV1MsTUFBTUMsS0FBSyxFQUFFO1lBQ3BERCxNQUFNQyxLQUFLLEdBQUcsQ0FBQztZQUNmRCxNQUFNRyxRQUFRLENBQUNILE1BQU1JLE1BQU07UUFDN0I7UUFFQSxJQUFJSixNQUFNQyxLQUFLLEtBQUssQ0FBQyxHQUFHO1lBQ3RCRCxNQUFNQyxLQUFLLEdBQUcsQ0FBQztZQUNmLElBQUlGLFFBQVFGLE1BQU0sR0FBRztnQkFDbkJGLFVBQVUsQ0FBQ0ksSUFBSSxHQUFHSixXQUFXVSxHQUFHO1lBQ2xDLE9BQU87Z0JBQ0xWLFdBQVdVLEdBQUc7WUFDaEI7WUFDQVIsT0FBTztRQUNULE9BQU87WUFDTEUsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJSixXQUFXRyxNQUFNLEdBQUcsR0FBRztRQUN6QlE7SUFDRjtBQUNGO0FBRUEsU0FBU0E7SUFDUCxJQUFJWixnQkFBZ0JhLFNBQVM7UUFDM0JiLGVBQWVhLE9BQU87SUFDeEIsT0FBTztRQUNMQyxhQUFhZDtRQUNiQSxpQkFBaUJlLFdBQVdiLFdBQVdOO1FBQ3ZDLElBQUlJLGVBQWVnQixLQUFLLEVBQUU7WUFDeEJoQixlQUFlZ0IsS0FBSztRQUN0QjtJQUNGO0FBQ0Y7QUFFQSxNQUFNQztJQUNKLFlBQWFSLFFBQVEsRUFBRUQsS0FBSyxFQUFFRSxNQUFNLENBQUU7UUFDcEMsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0UsTUFBTSxHQUFHQTtRQUVkLHdCQUF3QjtRQUN4QixpQ0FBaUM7UUFDakMscUNBQXFDO1FBQ3JDLCtDQUErQztRQUMvQyxJQUFJLENBQUNILEtBQUssR0FBRyxDQUFDO1FBRWQsSUFBSSxDQUFDTSxPQUFPO0lBQ2Q7SUFFQUEsVUFBVztRQUNULElBQUksSUFBSSxDQUFDTixLQUFLLEtBQUssQ0FBQyxHQUFHO1lBQ3JCTixXQUFXaUIsSUFBSSxDQUFDLElBQUk7WUFDcEIsSUFBSSxDQUFDbEIsa0JBQWtCQyxXQUFXRyxNQUFNLEtBQUssR0FBRztnQkFDOUNRO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ0wsS0FBSyxHQUFHO0lBQ2Y7SUFFQVksUUFBUztRQUNQLElBQUksQ0FBQ1osS0FBSyxHQUFHLENBQUM7SUFDaEI7QUFDRjtBQUVBYSxPQUFPQyxPQUFPLEdBQUc7SUFDZk4sWUFBWU4sUUFBUSxFQUFFRCxLQUFLLEVBQUVFLE1BQU07UUFDakMsT0FBT0YsU0FBUyxNQUNaTyxXQUFXTixVQUFVRCxPQUFPRSxVQUM1QixJQUFJTyxRQUFRUixVQUFVRCxPQUFPRTtJQUNuQztJQUNBSSxjQUFjUSxPQUFPO1FBQ25CLElBQUlBLG1CQUFtQkwsU0FBUztZQUM5QkssUUFBUUgsS0FBSztRQUNmLE9BQU87WUFDTEwsYUFBYVE7UUFDZjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcdXRpbFxcdGltZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUSUNLX01TID0gNDk5XG5cbmxldCBmYXN0Tm93ID0gRGF0ZS5ub3coKVxubGV0IGZhc3ROb3dUaW1lb3V0XG5cbmNvbnN0IGZhc3RUaW1lcnMgPSBbXVxuXG5mdW5jdGlvbiBvblRpbWVvdXQgKCkge1xuICBmYXN0Tm93ID0gRGF0ZS5ub3coKVxuXG4gIGxldCBsZW4gPSBmYXN0VGltZXJzLmxlbmd0aFxuICBsZXQgaWR4ID0gMFxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgY29uc3QgdGltZXIgPSBmYXN0VGltZXJzW2lkeF1cblxuICAgIGlmICh0aW1lci5zdGF0ZSA9PT0gMCkge1xuICAgICAgdGltZXIuc3RhdGUgPSBmYXN0Tm93ICsgdGltZXIuZGVsYXkgLSBUSUNLX01TXG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGF0ZSA+IDAgJiYgZmFzdE5vdyA+PSB0aW1lci5zdGF0ZSkge1xuICAgICAgdGltZXIuc3RhdGUgPSAtMVxuICAgICAgdGltZXIuY2FsbGJhY2sodGltZXIub3BhcXVlKVxuICAgIH1cblxuICAgIGlmICh0aW1lci5zdGF0ZSA9PT0gLTEpIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gLTJcbiAgICAgIGlmIChpZHggIT09IGxlbiAtIDEpIHtcbiAgICAgICAgZmFzdFRpbWVyc1tpZHhdID0gZmFzdFRpbWVycy5wb3AoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFzdFRpbWVycy5wb3AoKVxuICAgICAgfVxuICAgICAgbGVuIC09IDFcbiAgICB9IGVsc2Uge1xuICAgICAgaWR4ICs9IDFcbiAgICB9XG4gIH1cblxuICBpZiAoZmFzdFRpbWVycy5sZW5ndGggPiAwKSB7XG4gICAgcmVmcmVzaFRpbWVvdXQoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hUaW1lb3V0ICgpIHtcbiAgaWYgKGZhc3ROb3dUaW1lb3V0Py5yZWZyZXNoKSB7XG4gICAgZmFzdE5vd1RpbWVvdXQucmVmcmVzaCgpXG4gIH0gZWxzZSB7XG4gICAgY2xlYXJUaW1lb3V0KGZhc3ROb3dUaW1lb3V0KVxuICAgIGZhc3ROb3dUaW1lb3V0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIFRJQ0tfTVMpXG4gICAgaWYgKGZhc3ROb3dUaW1lb3V0LnVucmVmKSB7XG4gICAgICBmYXN0Tm93VGltZW91dC51bnJlZigpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFRpbWVvdXQge1xuICBjb25zdHJ1Y3RvciAoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXlcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZVxuXG4gICAgLy8gIC0yIG5vdCBpbiB0aW1lciBsaXN0XG4gICAgLy8gIC0xIGluIHRpbWVyIGxpc3QgYnV0IGluYWN0aXZlXG4gICAgLy8gICAwIGluIHRpbWVyIGxpc3Qgd2FpdGluZyBmb3IgdGltZVxuICAgIC8vID4gMCBpbiB0aW1lciBsaXN0IHdhaXRpbmcgZm9yIHRpbWUgdG8gZXhwaXJlXG4gICAgdGhpcy5zdGF0ZSA9IC0yXG5cbiAgICB0aGlzLnJlZnJlc2goKVxuICB9XG5cbiAgcmVmcmVzaCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IC0yKSB7XG4gICAgICBmYXN0VGltZXJzLnB1c2godGhpcylcbiAgICAgIGlmICghZmFzdE5vd1RpbWVvdXQgfHwgZmFzdFRpbWVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmVmcmVzaFRpbWVvdXQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSAwXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IC0xXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldFRpbWVvdXQgKGNhbGxiYWNrLCBkZWxheSwgb3BhcXVlKSB7XG4gICAgcmV0dXJuIGRlbGF5IDw9IDFlM1xuICAgICAgPyBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSwgb3BhcXVlKVxuICAgICAgOiBuZXcgVGltZW91dChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSlcbiAgfSxcbiAgY2xlYXJUaW1lb3V0ICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgaW5zdGFuY2VvZiBUaW1lb3V0KSB7XG4gICAgICB0aW1lb3V0LmNsZWFyKClcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiVElDS19NUyIsImZhc3ROb3ciLCJEYXRlIiwibm93IiwiZmFzdE5vd1RpbWVvdXQiLCJmYXN0VGltZXJzIiwib25UaW1lb3V0IiwibGVuIiwibGVuZ3RoIiwiaWR4IiwidGltZXIiLCJzdGF0ZSIsImRlbGF5IiwiY2FsbGJhY2siLCJvcGFxdWUiLCJwb3AiLCJyZWZyZXNoVGltZW91dCIsInJlZnJlc2giLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidW5yZWYiLCJUaW1lb3V0IiwicHVzaCIsImNsZWFyIiwibW9kdWxlIiwiZXhwb3J0cyIsInRpbWVvdXQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/util/timers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/cache.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cache.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\");\nconst { urlEquals, getFieldValues } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cache/util.js\");\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { Response, cloneResponse, fromInnerResponse } = __webpack_require__(/*! ../fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\");\nconst { Request, fromInnerRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\");\nconst { kState } = __webpack_require__(/*! ../fetch/symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\");\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */ /**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */ class Cache {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */ #relevantRequestResponseList;\n    constructor(){\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n        this.#relevantRequestResponseList = arguments[1];\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        const prefix = 'Cache.match';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        request = webidl.converters.RequestInfo(request, prefix, 'request');\n        options = webidl.converters.CacheQueryOptions(options, prefix, 'options');\n        const p = this.#internalMatchAll(request, options, 1);\n        if (p.length === 0) {\n            return;\n        }\n        return p[0];\n    }\n    async matchAll(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        const prefix = 'Cache.matchAll';\n        if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request');\n        options = webidl.converters.CacheQueryOptions(options, prefix, 'options');\n        return this.#internalMatchAll(request, options);\n    }\n    async add(request) {\n        webidl.brandCheck(this, Cache);\n        const prefix = 'Cache.add';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        request = webidl.converters.RequestInfo(request, prefix, 'request');\n        // 1.\n        const requests = [\n            request\n        ];\n        // 2.\n        const responseArrayPromise = this.addAll(requests);\n        // 3.\n        return await responseArrayPromise;\n    }\n    async addAll(requests) {\n        webidl.brandCheck(this, Cache);\n        const prefix = 'Cache.addAll';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        // 1.\n        const responsePromises = [];\n        // 2.\n        const requestList = [];\n        // 3.\n        for (let request of requests){\n            if (request === undefined) {\n                throw webidl.errors.conversionFailed({\n                    prefix,\n                    argument: 'Argument 1',\n                    types: [\n                        'undefined is not allowed'\n                    ]\n                });\n            }\n            request = webidl.converters.RequestInfo(request);\n            if (typeof request === 'string') {\n                continue;\n            }\n            // 3.1\n            const r = request[kState];\n            // 3.2\n            if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n                throw webidl.errors.exception({\n                    header: prefix,\n                    message: 'Expected http/s scheme when method is not GET.'\n                });\n            }\n        }\n        // 4.\n        /** @type {ReturnType<typeof fetching>[]} */ const fetchControllers = [];\n        // 5.\n        for (const request of requests){\n            // 5.1\n            const r = new Request(request)[kState];\n            // 5.2\n            if (!urlIsHttpHttpsScheme(r.url)) {\n                throw webidl.errors.exception({\n                    header: prefix,\n                    message: 'Expected http/s scheme.'\n                });\n            }\n            // 5.4\n            r.initiator = 'fetch';\n            r.destination = 'subresource';\n            // 5.5\n            requestList.push(r);\n            // 5.6\n            const responsePromise = createDeferredPromise();\n            // 5.7\n            fetchControllers.push(fetching({\n                request: r,\n                processResponse (response) {\n                    // 1.\n                    if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n                        responsePromise.reject(webidl.errors.exception({\n                            header: 'Cache.addAll',\n                            message: 'Received an invalid status code or the request failed.'\n                        }));\n                    } else if (response.headersList.contains('vary')) {\n                        // 2.1\n                        const fieldValues = getFieldValues(response.headersList.get('vary'));\n                        // 2.2\n                        for (const fieldValue of fieldValues){\n                            // 2.2.1\n                            if (fieldValue === '*') {\n                                responsePromise.reject(webidl.errors.exception({\n                                    header: 'Cache.addAll',\n                                    message: 'invalid vary field value'\n                                }));\n                                for (const controller of fetchControllers){\n                                    controller.abort();\n                                }\n                                return;\n                            }\n                        }\n                    }\n                },\n                processResponseEndOfBody (response) {\n                    // 1.\n                    if (response.aborted) {\n                        responsePromise.reject(new DOMException('aborted', 'AbortError'));\n                        return;\n                    }\n                    // 2.\n                    responsePromise.resolve(response);\n                }\n            }));\n            // 5.8\n            responsePromises.push(responsePromise.promise);\n        }\n        // 6.\n        const p = Promise.all(responsePromises);\n        // 7.\n        const responses = await p;\n        // 7.1\n        const operations = [];\n        // 7.2\n        let index = 0;\n        // 7.3\n        for (const response of responses){\n            // 7.3.1\n            /** @type {CacheBatchOperation} */ const operation = {\n                type: 'put',\n                request: requestList[index],\n                response\n            };\n            operations.push(operation); // 7.3.5\n            index++; // 7.3.6\n        }\n        // 7.5\n        const cacheJobPromise = createDeferredPromise();\n        // 7.6.1\n        let errorData = null;\n        // 7.6.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 7.6.3\n        queueMicrotask(()=>{\n            // 7.6.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve(undefined);\n            } else {\n                // 7.6.3.2\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        // 7.7\n        return cacheJobPromise.promise;\n    }\n    async put(request, response) {\n        webidl.brandCheck(this, Cache);\n        const prefix = 'Cache.put';\n        webidl.argumentLengthCheck(arguments, 2, prefix);\n        request = webidl.converters.RequestInfo(request, prefix, 'request');\n        response = webidl.converters.Response(response, prefix, 'response');\n        // 1.\n        let innerRequest = null;\n        // 2.\n        if (request instanceof Request) {\n            innerRequest = request[kState];\n        } else {\n            innerRequest = new Request(request)[kState];\n        }\n        // 4.\n        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: 'Expected an http/s scheme when method is not GET'\n            });\n        }\n        // 5.\n        const innerResponse = response[kState];\n        // 6.\n        if (innerResponse.status === 206) {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: 'Got 206 status'\n            });\n        }\n        // 7.\n        if (innerResponse.headersList.contains('vary')) {\n            // 7.1.\n            const fieldValues = getFieldValues(innerResponse.headersList.get('vary'));\n            // 7.2.\n            for (const fieldValue of fieldValues){\n                // 7.2.1\n                if (fieldValue === '*') {\n                    throw webidl.errors.exception({\n                        header: prefix,\n                        message: 'Got * vary field value'\n                    });\n                }\n            }\n        }\n        // 8.\n        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: 'Response body is locked or disturbed'\n            });\n        }\n        // 9.\n        const clonedResponse = cloneResponse(innerResponse);\n        // 10.\n        const bodyReadPromise = createDeferredPromise();\n        // 11.\n        if (innerResponse.body != null) {\n            // 11.1\n            const stream = innerResponse.body.stream;\n            // 11.2\n            const reader = stream.getReader();\n            // 11.3\n            readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);\n        } else {\n            bodyReadPromise.resolve(undefined);\n        }\n        // 12.\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        // 13.\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: 'put',\n            request: innerRequest,\n            response: clonedResponse // 16.\n        };\n        // 17.\n        operations.push(operation);\n        // 19.\n        const bytes = await bodyReadPromise.promise;\n        if (clonedResponse.body != null) {\n            clonedResponse.body.source = bytes;\n        }\n        // 19.1\n        const cacheJobPromise = createDeferredPromise();\n        // 19.2.1\n        let errorData = null;\n        // 19.2.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 19.2.3\n        queueMicrotask(()=>{\n            // 19.2.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve();\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    async delete(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        const prefix = 'Cache.delete';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        request = webidl.converters.RequestInfo(request, prefix, 'request');\n        options = webidl.converters.CacheQueryOptions(options, prefix, 'options');\n        /**\n     * @type {Request}\n     */ let r = null;\n        if (request instanceof Request) {\n            r = request[kState];\n            if (r.method !== 'GET' && !options.ignoreMethod) {\n                return false;\n            }\n        } else {\n            assert(typeof request === 'string');\n            r = new Request(request)[kState];\n        }\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: 'delete',\n            request: r,\n            options\n        };\n        operations.push(operation);\n        const cacheJobPromise = createDeferredPromise();\n        let errorData = null;\n        let requestResponses;\n        try {\n            requestResponses = this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        queueMicrotask(()=>{\n            if (errorData === null) {\n                cacheJobPromise.resolve(!!requestResponses?.length);\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {Promise<readonly Request[]>}\n   */ async keys(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        const prefix = 'Cache.keys';\n        if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request');\n        options = webidl.converters.CacheQueryOptions(options, prefix, 'options');\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            // 2.1\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== 'GET' && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === 'string') {\n                r = new Request(request)[kState];\n            }\n        }\n        // 4.\n        const promise = createDeferredPromise();\n        // 5.\n        // 5.1\n        const requests = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                // 5.2.1.1\n                requests.push(requestResponse[0]);\n            }\n        } else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                // 5.3.2.1\n                requests.push(requestResponse[0]);\n            }\n        }\n        // 5.4\n        queueMicrotask(()=>{\n            // 5.4.1\n            const requestList = [];\n            // 5.4.2\n            for (const request of requests){\n                const requestObject = fromInnerRequest(request, new AbortController().signal, 'immutable');\n                // 5.4.2.1\n                requestList.push(requestObject);\n            }\n            // 5.4.3\n            promise.resolve(Object.freeze(requestList));\n        });\n        return promise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */ #batchCacheOperations(operations) {\n        // 1.\n        const cache = this.#relevantRequestResponseList;\n        // 2.\n        const backupCache = [\n            ...cache\n        ];\n        // 3.\n        const addedItems = [];\n        // 4.1\n        const resultList = [];\n        try {\n            // 4.2\n            for (const operation of operations){\n                // 4.2.1\n                if (operation.type !== 'delete' && operation.type !== 'put') {\n                    throw webidl.errors.exception({\n                        header: 'Cache.#batchCacheOperations',\n                        message: 'operation type does not match \"delete\" or \"put\"'\n                    });\n                }\n                // 4.2.2\n                if (operation.type === 'delete' && operation.response != null) {\n                    throw webidl.errors.exception({\n                        header: 'Cache.#batchCacheOperations',\n                        message: 'delete operation should not have an associated response'\n                    });\n                }\n                // 4.2.3\n                if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n                    throw new DOMException('???', 'InvalidStateError');\n                }\n                // 4.2.4\n                let requestResponses;\n                // 4.2.5\n                if (operation.type === 'delete') {\n                    // 4.2.5.1\n                    requestResponses = this.#queryCache(operation.request, operation.options);\n                    // TODO: the spec is wrong, this is needed to pass WPTs\n                    if (requestResponses.length === 0) {\n                        return [];\n                    }\n                    // 4.2.5.2\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.5.2.1\n                        cache.splice(idx, 1);\n                    }\n                } else if (operation.type === 'put') {\n                    // 4.2.6.1\n                    if (operation.response == null) {\n                        throw webidl.errors.exception({\n                            header: 'Cache.#batchCacheOperations',\n                            message: 'put operation should have an associated response'\n                        });\n                    }\n                    // 4.2.6.2\n                    const r = operation.request;\n                    // 4.2.6.3\n                    if (!urlIsHttpHttpsScheme(r.url)) {\n                        throw webidl.errors.exception({\n                            header: 'Cache.#batchCacheOperations',\n                            message: 'expected http or https scheme'\n                        });\n                    }\n                    // 4.2.6.4\n                    if (r.method !== 'GET') {\n                        throw webidl.errors.exception({\n                            header: 'Cache.#batchCacheOperations',\n                            message: 'not get method'\n                        });\n                    }\n                    // 4.2.6.5\n                    if (operation.options != null) {\n                        throw webidl.errors.exception({\n                            header: 'Cache.#batchCacheOperations',\n                            message: 'options must not be defined'\n                        });\n                    }\n                    // 4.2.6.6\n                    requestResponses = this.#queryCache(operation.request);\n                    // 4.2.6.7\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.6.7.1\n                        cache.splice(idx, 1);\n                    }\n                    // 4.2.6.8\n                    cache.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                    // 4.2.6.10\n                    addedItems.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                }\n                // 4.2.7\n                resultList.push([\n                    operation.request,\n                    operation.response\n                ]);\n            }\n            // 4.3\n            return resultList;\n        } catch (e) {\n            // 5.1\n            this.#relevantRequestResponseList.length = 0;\n            // 5.2\n            this.#relevantRequestResponseList = backupCache;\n            // 5.3\n            throw e;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */ #queryCache(requestQuery, options, targetStorage) {\n        /** @type {requestResponseList} */ const resultList = [];\n        const storage = targetStorage ?? this.#relevantRequestResponseList;\n        for (const requestResponse of storage){\n            const [cachedRequest, cachedResponse] = requestResponse;\n            if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n                resultList.push(requestResponse);\n            }\n        }\n        return resultList;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */ #requestMatchesCachedItem(requestQuery, request, response = null, options) {\n        // if (options?.ignoreMethod === false && request.method === 'GET') {\n        //   return false\n        // }\n        const queryURL = new URL(requestQuery.url);\n        const cachedURL = new URL(request.url);\n        if (options?.ignoreSearch) {\n            cachedURL.search = '';\n            queryURL.search = '';\n        }\n        if (!urlEquals(queryURL, cachedURL, true)) {\n            return false;\n        }\n        if (response == null || options?.ignoreVary || !response.headersList.contains('vary')) {\n            return true;\n        }\n        const fieldValues = getFieldValues(response.headersList.get('vary'));\n        for (const fieldValue of fieldValues){\n            if (fieldValue === '*') {\n                return false;\n            }\n            const requestValue = request.headersList.get(fieldValue);\n            const queryValue = requestQuery.headersList.get(fieldValue);\n            // If one has the header and the other doesn't, or one has\n            // a different value than the other, return false\n            if (requestValue !== queryValue) {\n                return false;\n            }\n        }\n        return true;\n    }\n    #internalMatchAll(request, options, maxResponses = Infinity) {\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== 'GET' && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === 'string') {\n                // 2.2.1\n                r = new Request(request)[kState];\n            }\n        }\n        // 5.\n        // 5.1\n        const responses = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                responses.push(requestResponse[1]);\n            }\n        } else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                responses.push(requestResponse[1]);\n            }\n        }\n        // 5.4\n        // We don't implement CORs so we don't need to loop over the responses, yay!\n        // 5.5.1\n        const responseList = [];\n        // 5.5.2\n        for (const response of responses){\n            // 5.5.2.1\n            const responseObject = fromInnerResponse(response, 'immutable');\n            responseList.push(responseObject.clone());\n            if (responseList.length >= maxResponses) {\n                break;\n            }\n        }\n        // 6.\n        return Object.freeze(responseList);\n    }\n}\nObject.defineProperties(Cache.prototype, {\n    [Symbol.toStringTag]: {\n        value: 'Cache',\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    matchAll: kEnumerableProperty,\n    add: kEnumerableProperty,\n    addAll: kEnumerableProperty,\n    put: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nconst cacheQueryOptionConverters = [\n    {\n        key: 'ignoreSearch',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'ignoreMethod',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'ignoreVary',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    }\n];\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n    ...cacheQueryOptionConverters,\n    {\n        key: 'cacheName',\n        converter: webidl.converters.DOMString\n    }\n]);\nwebidl.converters.Response = webidl.interfaceConverter(Response);\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(webidl.converters.RequestInfo);\nmodule.exports = {\n    Cache\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyx1RUFBVztBQUMxQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsY0FBYyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDLGlFQUFRO0FBQ3RELE1BQU0sRUFBRUcsbUJBQW1CLEVBQUVDLFdBQVcsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQyxxRUFBaUI7QUFDdEUsTUFBTSxFQUFFSyxNQUFNLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMsNEVBQWlCO0FBQzVDLE1BQU0sRUFBRU0sUUFBUSxFQUFFQyxhQUFhLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdSLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUNsRixNQUFNLEVBQUVTLE9BQU8sRUFBRUMsZ0JBQWdCLEVBQUUsR0FBR1YsbUJBQU9BLENBQUMsOEVBQWtCO0FBQ2hFLE1BQU0sRUFBRVcsTUFBTSxFQUFFLEdBQUdYLG1CQUFPQSxDQUFDLDhFQUFrQjtBQUM3QyxNQUFNLEVBQUVZLFFBQVEsRUFBRSxHQUFHWixtQkFBT0EsQ0FBQywwRUFBZ0I7QUFDN0MsTUFBTSxFQUFFYSxvQkFBb0IsRUFBRUMscUJBQXFCLEVBQUVDLFlBQVksRUFBRSxHQUFHZixtQkFBT0EsQ0FBQyx3RUFBZTtBQUM3RixNQUFNZ0IsU0FBU2hCLG1CQUFPQSxDQUFDLGdDQUFhO0FBRXBDOzs7Ozs7O0NBT0MsR0FFRDs7O0NBR0MsR0FFRCxNQUFNaUI7SUFDSjs7O0dBR0MsR0FDRCw0QkFBNEI7SUFFNUIsYUFBZTtRQUNiLElBQUlDLFNBQVMsQ0FBQyxFQUFFLEtBQUtuQixZQUFZO1lBQy9CTSxPQUFPYyxrQkFBa0I7UUFDM0I7UUFFQSxJQUFJLENBQUMsNEJBQTRCLEdBQUdELFNBQVMsQ0FBQyxFQUFFO0lBQ2xEO0lBRUEsTUFBTUUsTUFBT0MsT0FBTyxFQUFFQyxVQUFV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QUFtQixDQUFDTDtBQUVqRWxJLE9BQU9xQixVQUFVLENBQUNtSCxzQkFBc0IsR0FBR3hJLE9BQU91SSxtQkFBbUIsQ0FBQztPQUNqRUw7SUFDSDtRQUNFQyxLQUFLO1FBQ0xDLFdBQVdwSSxPQUFPcUIsVUFBVSxDQUFDb0gsU0FBUztJQUN4QztDQUNEO0FBRUR6SSxPQUFPcUIsVUFBVSxDQUFDcEIsUUFBUSxHQUFHRCxPQUFPMEksa0JBQWtCLENBQUN6STtBQUV2REQsT0FBT3FCLFVBQVUsQ0FBQyx3QkFBd0IsR0FBR3JCLE9BQU8ySSxpQkFBaUIsQ0FDbkUzSSxPQUFPcUIsVUFBVSxDQUFDQyxXQUFXO0FBRy9Cc0gsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZqSTtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY2FjaGVcXGNhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHVybEVxdWFscywgZ2V0RmllbGRWYWx1ZXMgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIGlzRGlzdHVyYmVkIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IFJlc3BvbnNlLCBjbG9uZVJlc3BvbnNlLCBmcm9tSW5uZXJSZXNwb25zZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVzcG9uc2UnKVxuY29uc3QgeyBSZXF1ZXN0LCBmcm9tSW5uZXJSZXF1ZXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXF1ZXN0JylcbmNvbnN0IHsga1N0YXRlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9zeW1ib2xzJylcbmNvbnN0IHsgZmV0Y2hpbmcgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2luZGV4JylcbmNvbnN0IHsgdXJsSXNIdHRwSHR0cHNTY2hlbWUsIGNyZWF0ZURlZmVycmVkUHJvbWlzZSwgcmVhZEFsbEJ5dGVzIH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tY2FjaGUtYmF0Y2gtb3BlcmF0aW9uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYWNoZUJhdGNoT3BlcmF0aW9uXG4gKiBAcHJvcGVydHkgeydkZWxldGUnIHwgJ3B1dCd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7YW55fSByZXF1ZXN0XG4gKiBAcHJvcGVydHkge2FueX0gcmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVxdWVzdC1yZXNwb25zZS1saXN0XG4gKiBAdHlwZWRlZiB7W2FueSwgYW55XVtdfSByZXF1ZXN0UmVzcG9uc2VMaXN0XG4gKi9cblxuY2xhc3MgQ2FjaGUge1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlbGV2YW50LXJlcXVlc3QtcmVzcG9uc2UtbGlzdFxuICAgKiBAdHlwZSB7cmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3RcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAhPT0ga0NvbnN0cnVjdCkge1xuICAgICAgd2ViaWRsLmlsbGVnYWxDb25zdHJ1Y3RvcigpXG4gICAgfVxuXG4gICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0ID0gYXJndW1lbnRzWzFdXG4gIH1cblxuICBhc3luYyBtYXRjaCAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUubWF0Y2gnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgY29uc3QgcCA9IHRoaXMuI2ludGVybmFsTWF0Y2hBbGwocmVxdWVzdCwgb3B0aW9ucywgMSlcblxuICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHBbMF1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoQWxsIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5tYXRjaEFsbCdcbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsTWF0Y2hBbGwocmVxdWVzdCwgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGFkZCAocmVxdWVzdCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLmFkZCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0LCBwcmVmaXgsICdyZXF1ZXN0JylcblxuICAgIC8vIDEuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBbcmVxdWVzdF1cblxuICAgIC8vIDIuXG4gICAgY29uc3QgcmVzcG9uc2VBcnJheVByb21pc2UgPSB0aGlzLmFkZEFsbChyZXF1ZXN0cylcblxuICAgIC8vIDMuXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlQXJyYXlQcm9taXNlXG4gIH1cblxuICBhc3luYyBhZGRBbGwgKHJlcXVlc3RzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUuYWRkQWxsJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgLy8gMS5cbiAgICBjb25zdCByZXNwb25zZVByb21pc2VzID0gW11cblxuICAgIC8vIDIuXG4gICAgY29uc3QgcmVxdWVzdExpc3QgPSBbXVxuXG4gICAgLy8gMy5cbiAgICBmb3IgKGxldCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgICAgcHJlZml4LFxuICAgICAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICAgICAgdHlwZXM6IFsndW5kZWZpbmVkIGlzIG5vdCBhbGxvd2VkJ11cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG5cbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMy4xXG4gICAgICBjb25zdCByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgIC8vIDMuMlxuICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkgfHwgci5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VULidcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgZmV0Y2hpbmc+W119ICovXG4gICAgY29uc3QgZmV0Y2hDb250cm9sbGVycyA9IFtdXG5cbiAgICAvLyA1LlxuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgLy8gNS4xXG4gICAgICBjb25zdCByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuXG4gICAgICAvLyA1LjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgaHR0cC9zIHNjaGVtZS4nXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDUuNFxuICAgICAgci5pbml0aWF0b3IgPSAnZmV0Y2gnXG4gICAgICByLmRlc3RpbmF0aW9uID0gJ3N1YnJlc291cmNlJ1xuXG4gICAgICAvLyA1LjVcbiAgICAgIHJlcXVlc3RMaXN0LnB1c2gocilcblxuICAgICAgLy8gNS42XG4gICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgICAvLyA1LjdcbiAgICAgIGZldGNoQ29udHJvbGxlcnMucHVzaChmZXRjaGluZyh7XG4gICAgICAgIHJlcXVlc3Q6IHIsXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICAgICAgICAvLyAxLlxuICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2IHx8IHJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPiAyOTkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3Qod2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVjZWl2ZWQgYW4gaW52YWxpZCBzdGF0dXMgY29kZSBvciB0aGUgcmVxdWVzdCBmYWlsZWQuJ1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpKSB7IC8vIDIuXG4gICAgICAgICAgICAvLyAyLjFcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICAgICAgICAgIC8vIDIuMlxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICAgICAgICAgIC8vIDIuMi4xXG4gICAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLmFkZEFsbCcsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCB2YXJ5IGZpZWxkIHZhbHVlJ1xuICAgICAgICAgICAgICAgIH0pKVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIGZldGNoQ29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdhYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDIuXG4gICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpXG4gICAgICAgIH1cbiAgICAgIH0pKVxuXG4gICAgICAvLyA1LjhcbiAgICAgIHJlc3BvbnNlUHJvbWlzZXMucHVzaChyZXNwb25zZVByb21pc2UucHJvbWlzZSlcbiAgICB9XG5cbiAgICAvLyA2LlxuICAgIGNvbnN0IHAgPSBQcm9taXNlLmFsbChyZXNwb25zZVByb21pc2VzKVxuXG4gICAgLy8gNy5cbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBwXG5cbiAgICAvLyA3LjFcbiAgICBjb25zdCBvcGVyYXRpb25zID0gW11cblxuICAgIC8vIDcuMlxuICAgIGxldCBpbmRleCA9IDBcblxuICAgIC8vIDcuM1xuICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAvLyA3LjMuMVxuICAgICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgICB0eXBlOiAncHV0JywgLy8gNy4zLjJcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdExpc3RbaW5kZXhdLCAvLyA3LjMuM1xuICAgICAgICByZXNwb25zZSAvLyA3LjMuNFxuICAgICAgfVxuXG4gICAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKSAvLyA3LjMuNVxuXG4gICAgICBpbmRleCsrIC8vIDcuMy42XG4gICAgfVxuXG4gICAgLy8gNy41XG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDcuNi4xXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcblxuICAgIC8vIDcuNi4yXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuI2JhdGNoQ2FjaGVPcGVyYXRpb25zKG9wZXJhdGlvbnMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JEYXRhID0gZVxuICAgIH1cblxuICAgIC8vIDcuNi4zXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gNy42LjMuMVxuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyA3LjYuMy4yXG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyA3LjdcbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIGFzeW5jIHB1dCAocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5wdXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgcmVzcG9uc2UgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZShyZXNwb25zZSwgcHJlZml4LCAncmVzcG9uc2UnKVxuXG4gICAgLy8gMS5cbiAgICBsZXQgaW5uZXJSZXF1ZXN0ID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlubmVyUmVxdWVzdCA9IHJlcXVlc3Rba1N0YXRlXVxuICAgIH0gZWxzZSB7IC8vIDMuXG4gICAgICBpbm5lclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKGlubmVyUmVxdWVzdC51cmwpIHx8IGlubmVyUmVxdWVzdC5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgYW4gaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VUJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA1LlxuICAgIGNvbnN0IGlubmVyUmVzcG9uc2UgPSByZXNwb25zZVtrU3RhdGVdXG5cbiAgICAvLyA2LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiAnR290IDIwNiBzdGF0dXMnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDcuXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkge1xuICAgICAgLy8gNy4xLlxuICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlcyhpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAvLyA3LjIuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgICAgLy8gNy4yLjFcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICcqJykge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICAgICAgbWVzc2FnZTogJ0dvdCAqIHZhcnkgZmllbGQgdmFsdWUnXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuYm9keSAmJiAoaXNEaXN0dXJiZWQoaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbSkgfHwgaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbS5sb2NrZWQpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiAnUmVzcG9uc2UgYm9keSBpcyBsb2NrZWQgb3IgZGlzdHVyYmVkJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA5LlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZShpbm5lclJlc3BvbnNlKVxuXG4gICAgLy8gMTAuXG4gICAgY29uc3QgYm9keVJlYWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDExLlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMTEuMVxuICAgICAgY29uc3Qgc3RyZWFtID0gaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbVxuXG4gICAgICAvLyAxMS4yXG4gICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcblxuICAgICAgLy8gMTEuM1xuICAgICAgcmVhZEFsbEJ5dGVzKHJlYWRlcikudGhlbihib2R5UmVhZFByb21pc2UucmVzb2x2ZSwgYm9keVJlYWRQcm9taXNlLnJlamVjdClcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVJlYWRQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgIH1cblxuICAgIC8vIDEyLlxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLy8gMTMuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdwdXQnLCAvLyAxNC5cbiAgICAgIHJlcXVlc3Q6IGlubmVyUmVxdWVzdCwgLy8gMTUuXG4gICAgICByZXNwb25zZTogY2xvbmVkUmVzcG9uc2UgLy8gMTYuXG4gICAgfVxuXG4gICAgLy8gMTcuXG4gICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbilcblxuICAgIC8vIDE5LlxuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgYm9keVJlYWRQcm9taXNlLnByb21pc2VcblxuICAgIGlmIChjbG9uZWRSZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIGNsb25lZFJlc3BvbnNlLmJvZHkuc291cmNlID0gYnl0ZXNcbiAgICB9XG5cbiAgICAvLyAxOS4xXG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDE5LjIuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyAxOS4yLjJcbiAgICB0cnkge1xuICAgICAgdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgLy8gMTkuMi4zXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gMTkuMi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfSBlbHNlIHsgLy8gMTkuMi4zLjJcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5kZWxldGUnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1JlcXVlc3R9XG4gICAgICovXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpXG5cbiAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119ICovXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICByZXF1ZXN0OiByLFxuICAgICAgb3B0aW9uc1xuICAgIH1cblxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pXG5cbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcbiAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKCEhcmVxdWVzdFJlc3BvbnNlcz8ubGVuZ3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZS1rZXlzXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHJlYWRvbmx5IFJlcXVlc3RbXT59XG4gICAqL1xuICBhc3luYyBrZXlzIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5rZXlzJ1xuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIC8vIDEuXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDIuMVxuICAgICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykgeyAvLyAyLjJcbiAgICAgICAgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gNS5cbiAgICAvLyA1LjFcbiAgICBjb25zdCByZXF1ZXN0cyA9IFtdXG5cbiAgICAvLyA1LjJcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyA1LjIuMVxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0KSB7XG4gICAgICAgIC8vIDUuMi4xLjFcbiAgICAgICAgcmVxdWVzdHMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMF0pXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gNS4zXG4gICAgICAvLyA1LjMuMVxuICAgICAgY29uc3QgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUociwgb3B0aW9ucylcblxuICAgICAgLy8gNS4zLjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgLy8gNS4zLjIuMVxuICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcXVlc3RSZXNwb25zZVswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyA1LjQuMVxuICAgICAgY29uc3QgcmVxdWVzdExpc3QgPSBbXVxuXG4gICAgICAvLyA1LjQuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPYmplY3QgPSBmcm9tSW5uZXJSZXF1ZXN0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbCxcbiAgICAgICAgICAnaW1tdXRhYmxlJ1xuICAgICAgICApXG4gICAgICAgIC8vIDUuNC4yLjFcbiAgICAgICAgcmVxdWVzdExpc3QucHVzaChyZXF1ZXN0T2JqZWN0KVxuICAgICAgfVxuXG4gICAgICAvLyA1LjQuM1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKE9iamVjdC5mcmVlemUocmVxdWVzdExpc3QpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jYmF0Y2gtY2FjaGUtb3BlcmF0aW9ucy1hbGdvcml0aG1cbiAgICogQHBhcmFtIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119IG9wZXJhdGlvbnNcbiAgICogQHJldHVybnMge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjYmF0Y2hDYWNoZU9wZXJhdGlvbnMgKG9wZXJhdGlvbnMpIHtcbiAgICAvLyAxLlxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IGJhY2t1cENhY2hlID0gWy4uLmNhY2hlXVxuXG4gICAgLy8gMy5cbiAgICBjb25zdCBhZGRlZEl0ZW1zID0gW11cblxuICAgIC8vIDQuMVxuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIDQuMlxuICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICAvLyA0LjIuMVxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgIT09ICdkZWxldGUnICYmIG9wZXJhdGlvbi50eXBlICE9PSAncHV0Jykge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnb3BlcmF0aW9uIHR5cGUgZG9lcyBub3QgbWF0Y2ggXCJkZWxldGVcIiBvciBcInB1dFwiJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuMlxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnICYmIG9wZXJhdGlvbi5yZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWxldGUgb3BlcmF0aW9uIHNob3VsZCBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuM1xuICAgICAgICBpZiAodGhpcy4jcXVlcnlDYWNoZShvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLm9wdGlvbnMsIGFkZGVkSXRlbXMpLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJz8/PycsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuNFxuICAgICAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgICAgIC8vIDQuMi41XG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAvLyA0LjIuNS4xXG4gICAgICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5vcHRpb25zKVxuXG4gICAgICAgICAgLy8gVE9ETzogdGhlIHNwZWMgaXMgd3JvbmcsIHRoaXMgaXMgbmVlZGVkIHRvIHBhc3MgV1BUc1xuICAgICAgICAgIGlmIChyZXF1ZXN0UmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjUuMlxuICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhY2hlLmluZGV4T2YocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG5cbiAgICAgICAgICAgIC8vIDQuMi41LjIuMVxuICAgICAgICAgICAgY2FjaGUuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdwdXQnKSB7IC8vIDQuMi42XG4gICAgICAgICAgLy8gNC4yLjYuMVxuICAgICAgICAgIGlmIChvcGVyYXRpb24ucmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAncHV0IG9wZXJhdGlvbiBzaG91bGQgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi4yXG4gICAgICAgICAgY29uc3QgciA9IG9wZXJhdGlvbi5yZXF1ZXN0XG5cbiAgICAgICAgICAvLyA0LjIuNi4zXG4gICAgICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGh0dHAgb3IgaHR0cHMgc2NoZW1lJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi40XG4gICAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnbm90IGdldCBtZXRob2QnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjVcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnb3B0aW9ucyBtdXN0IG5vdCBiZSBkZWZpbmVkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi42XG4gICAgICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QpXG5cbiAgICAgICAgICAvLyA0LjIuNi43XG4gICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gY2FjaGUuaW5kZXhPZihyZXF1ZXN0UmVzcG9uc2UpXG4gICAgICAgICAgICBhc3NlcnQoaWR4ICE9PSAtMSlcblxuICAgICAgICAgICAgLy8gNC4yLjYuNy4xXG4gICAgICAgICAgICBjYWNoZS5zcGxpY2UoaWR4LCAxKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjhcbiAgICAgICAgICBjYWNoZS5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcblxuICAgICAgICAgIC8vIDQuMi42LjEwXG4gICAgICAgICAgYWRkZWRJdGVtcy5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi43XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG4gICAgICB9XG5cbiAgICAgIC8vIDQuM1xuICAgICAgcmV0dXJuIHJlc3VsdExpc3RcbiAgICB9IGNhdGNoIChlKSB7IC8vIDUuXG4gICAgICAvLyA1LjFcbiAgICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdC5sZW5ndGggPSAwXG5cbiAgICAgIC8vIDUuMlxuICAgICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0ID0gYmFja3VwQ2FjaGVcblxuICAgICAgLy8gNS4zXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI3F1ZXJ5LWNhY2hlXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0UXVlcnlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fSB0YXJnZXRTdG9yYWdlXG4gICAqIEByZXR1cm5zIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3F1ZXJ5Q2FjaGUgKHJlcXVlc3RRdWVyeSwgb3B0aW9ucywgdGFyZ2V0U3RvcmFnZSkge1xuICAgIC8qKiBAdHlwZSB7cmVxdWVzdFJlc3BvbnNlTGlzdH0gKi9cbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW11cblxuICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXRTdG9yYWdlID8/IHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2Ygc3RvcmFnZSkge1xuICAgICAgY29uc3QgW2NhY2hlZFJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlXSA9IHJlcXVlc3RSZXNwb25zZVxuICAgICAgaWYgKHRoaXMuI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbShyZXF1ZXN0UXVlcnksIGNhY2hlZFJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlLCBvcHRpb25zKSkge1xuICAgICAgICByZXN1bHRMaXN0LnB1c2gocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRMaXN0XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jcmVxdWVzdC1tYXRjaGVzLWNhY2hlZC1pdGVtLWFsZ29yaXRobVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFF1ZXJ5XG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7YW55IHwgbnVsbH0gcmVzcG9uc2VcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnMgfCB1bmRlZmluZWR9IG9wdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAjcmVxdWVzdE1hdGNoZXNDYWNoZWRJdGVtIChyZXF1ZXN0UXVlcnksIHJlcXVlc3QsIHJlc3BvbnNlID0gbnVsbCwgb3B0aW9ucykge1xuICAgIC8vIGlmIChvcHRpb25zPy5pZ25vcmVNZXRob2QgPT09IGZhbHNlICYmIHJlcXVlc3QubWV0aG9kID09PSAnR0VUJykge1xuICAgIC8vICAgcmV0dXJuIGZhbHNlXG4gICAgLy8gfVxuXG4gICAgY29uc3QgcXVlcnlVUkwgPSBuZXcgVVJMKHJlcXVlc3RRdWVyeS51cmwpXG5cbiAgICBjb25zdCBjYWNoZWRVUkwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKVxuXG4gICAgaWYgKG9wdGlvbnM/Lmlnbm9yZVNlYXJjaCkge1xuICAgICAgY2FjaGVkVVJMLnNlYXJjaCA9ICcnXG5cbiAgICAgIHF1ZXJ5VVJMLnNlYXJjaCA9ICcnXG4gICAgfVxuXG4gICAgaWYgKCF1cmxFcXVhbHMocXVlcnlVUkwsIGNhY2hlZFVSTCwgdHJ1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHJlc3BvbnNlID09IG51bGwgfHxcbiAgICAgIG9wdGlvbnM/Lmlnbm9yZVZhcnkgfHxcbiAgICAgICFyZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RWYWx1ZSA9IHJlcXVlc3QuaGVhZGVyc0xpc3QuZ2V0KGZpZWxkVmFsdWUpXG4gICAgICBjb25zdCBxdWVyeVZhbHVlID0gcmVxdWVzdFF1ZXJ5LmhlYWRlcnNMaXN0LmdldChmaWVsZFZhbHVlKVxuXG4gICAgICAvLyBJZiBvbmUgaGFzIHRoZSBoZWFkZXIgYW5kIHRoZSBvdGhlciBkb2Vzbid0LCBvciBvbmUgaGFzXG4gICAgICAvLyBhIGRpZmZlcmVudCB2YWx1ZSB0aGFuIHRoZSBvdGhlciwgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAocmVxdWVzdFZhbHVlICE9PSBxdWVyeVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAjaW50ZXJuYWxNYXRjaEFsbCAocmVxdWVzdCwgb3B0aW9ucywgbWF4UmVzcG9uc2VzID0gSW5maW5pdHkpIHtcbiAgICAvLyAxLlxuICAgIGxldCByID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgLy8gMi4xLjFcbiAgICAgICAgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAgIC8vIDIuMS4yXG4gICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIDIuMi4xXG4gICAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS5cbiAgICAvLyA1LjFcbiAgICBjb25zdCByZXNwb25zZXMgPSBbXVxuXG4gICAgLy8gNS4yXG4gICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gNS4yLjFcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCkge1xuICAgICAgICByZXNwb25zZXMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gNS4zXG4gICAgICAvLyA1LjMuMVxuICAgICAgY29uc3QgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUociwgb3B0aW9ucylcblxuICAgICAgLy8gNS4zLjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzFdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuNFxuICAgIC8vIFdlIGRvbid0IGltcGxlbWVudCBDT1JzIHNvIHdlIGRvbid0IG5lZWQgdG8gbG9vcCBvdmVyIHRoZSByZXNwb25zZXMsIHlheSFcblxuICAgIC8vIDUuNS4xXG4gICAgY29uc3QgcmVzcG9uc2VMaXN0ID0gW11cblxuICAgIC8vIDUuNS4yXG4gICAgZm9yIChjb25zdCByZXNwb25zZSBvZiByZXNwb25zZXMpIHtcbiAgICAgIC8vIDUuNS4yLjFcbiAgICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UocmVzcG9uc2UsICdpbW11dGFibGUnKVxuXG4gICAgICByZXNwb25zZUxpc3QucHVzaChyZXNwb25zZU9iamVjdC5jbG9uZSgpKVxuXG4gICAgICBpZiAocmVzcG9uc2VMaXN0Lmxlbmd0aCA+PSBtYXhSZXNwb25zZXMpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA2LlxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3BvbnNlTGlzdClcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYWNoZS5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0NhY2hlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWF0Y2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG1hdGNoQWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhZGQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFkZEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcHV0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGtleXM6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbmNvbnN0IGNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzID0gW1xuICB7XG4gICAga2V5OiAnaWdub3JlU2VhcmNoJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnaWdub3JlTWV0aG9kJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnaWdub3JlVmFyeScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfVxuXVxuXG53ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKGNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzKVxuXG53ZWJpZGwuY29udmVydGVycy5NdWx0aUNhY2hlUXVlcnlPcHRpb25zID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5jYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyxcbiAge1xuICAgIGtleTogJ2NhY2hlTmFtZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2UgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFJlc3BvbnNlKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8UmVxdWVzdEluZm8+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvXG4pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYWNoZVxufVxuIl0sIm5hbWVzIjpbImtDb25zdHJ1Y3QiLCJyZXF1aXJlIiwidXJsRXF1YWxzIiwiZ2V0RmllbGRWYWx1ZXMiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiaXNEaXN0dXJiZWQiLCJ3ZWJpZGwiLCJSZXNwb25zZSIsImNsb25lUmVzcG9uc2UiLCJmcm9tSW5uZXJSZXNwb25zZSIsIlJlcXVlc3QiLCJmcm9tSW5uZXJSZXF1ZXN0Iiwia1N0YXRlIiwiZmV0Y2hpbmciLCJ1cmxJc0h0dHBIdHRwc1NjaGVtZSIsImNyZWF0ZURlZmVycmVkUHJvbWlzZSIsInJlYWRBbGxCeXRlcyIsImFzc2VydCIsIkNhY2hlIiwiYXJndW1lbnRzIiwiaWxsZWdhbENvbnN0cnVjdG9yIiwibWF0Y2giLCJyZXF1ZXN0Iiwib3B0aW9ucyIsImJyYW5kQ2hlY2siLCJwcmVmaXgiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiY29udmVydGVycyIsIlJlcXVlc3RJbmZvIiwiQ2FjaGVRdWVyeU9wdGlvbnMiLCJwIiwibGVuZ3RoIiwibWF0Y2hBbGwiLCJ1bmRlZmluZWQiLCJhZGQiLCJyZXF1ZXN0cyIsInJlc3BvbnNlQXJyYXlQcm9taXNlIiwiYWRkQWxsIiwicmVzcG9uc2VQcm9taXNlcyIsInJlcXVlc3RMaXN0IiwiZXJyb3JzIiwiY29udmVyc2lvbkZhaWxlZCIsImFyZ3VtZW50IiwidHlwZXMiLCJyIiwidXJsIiwibWV0aG9kIiwiZXhjZXB0aW9uIiwiaGVhZGVyIiwibWVzc2FnZSIsImZldGNoQ29udHJvbGxlcnMiLCJpbml0aWF0b3IiLCJkZXN0aW5hdGlvbiIsInB1c2giLCJyZXNwb25zZVByb21pc2UiLCJwcm9jZXNzUmVzcG9uc2UiLCJyZXNwb25zZSIsInR5cGUiLCJzdGF0dXMiLCJyZWplY3QiLCJoZWFkZXJzTGlzdCIsImNvbnRhaW5zIiwiZmllbGRWYWx1ZXMiLCJnZXQiLCJmaWVsZFZhbHVlIiwiY29udHJvbGxlciIsImFib3J0IiwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IiwiYWJvcnRlZCIsIkRPTUV4Y2VwdGlvbiIsInJlc29sdmUiLCJwcm9taXNlIiwiUHJvbWlzZSIsImFsbCIsInJlc3BvbnNlcyIsIm9wZXJhdGlvbnMiLCJpbmRleCIsIm9wZXJhdGlvbiIsImNhY2hlSm9iUHJvbWlzZSIsImVycm9yRGF0YSIsImUiLCJxdWV1ZU1pY3JvdGFzayIsInB1dCIsImlubmVyUmVxdWVzdCIsImlubmVyUmVzcG9uc2UiLCJib2R5Iiwic3RyZWFtIiwibG9ja2VkIiwiY2xvbmVkUmVzcG9uc2UiLCJib2R5UmVhZFByb21pc2UiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJ0aGVuIiwiYnl0ZXMiLCJzb3VyY2UiLCJkZWxldGUiLCJpZ25vcmVNZXRob2QiLCJyZXF1ZXN0UmVzcG9uc2VzIiwia2V5cyIsInJlcXVlc3RSZXNwb25zZSIsInJlcXVlc3RPYmplY3QiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJPYmplY3QiLCJmcmVlemUiLCJjYWNoZSIsImJhY2t1cENhY2hlIiwiYWRkZWRJdGVtcyIsInJlc3VsdExpc3QiLCJpZHgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVxdWVzdFF1ZXJ5IiwidGFyZ2V0U3RvcmFnZSIsInN0b3JhZ2UiLCJjYWNoZWRSZXF1ZXN0IiwiY2FjaGVkUmVzcG9uc2UiLCJxdWVyeVVSTCIsIlVSTCIsImNhY2hlZFVSTCIsImlnbm9yZVNlYXJjaCIsInNlYXJjaCIsImlnbm9yZVZhcnkiLCJyZXF1ZXN0VmFsdWUiLCJxdWVyeVZhbHVlIiwibWF4UmVzcG9uc2VzIiwiSW5maW5pdHkiLCJyZXNwb25zZUxpc3QiLCJyZXNwb25zZU9iamVjdCIsImNsb25lIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyIsImtleSIsImNvbnZlcnRlciIsImJvb2xlYW4iLCJkZWZhdWx0VmFsdWUiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwiTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyIsIkRPTVN0cmluZyIsImludGVyZmFjZUNvbnZlcnRlciIsInNlcXVlbmNlQ29udmVydGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cachestorage.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\");\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(ssr)/./node_modules/undici/lib/web/cache/cache.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nclass CacheStorage {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */ #caches;\n    constructor(){\n        this.#caches = new Map();\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, 'CacheStorage.match');\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.MultiCacheQueryOptions(options);\n        // 1.\n        if (options.cacheName != null) {\n            // 1.1.1.1\n            if (this.#caches.has(options.cacheName)) {\n                // 1.1.1.1.1\n                const cacheList = this.#caches.get(options.cacheName);\n                const cache = new Cache(kConstruct, cacheList);\n                return await cache.match(request, options);\n            }\n        } else {\n            // 2.2\n            for (const cacheList of this.#caches.values()){\n                const cache = new Cache(kConstruct, cacheList);\n                // 2.2.1.2\n                const response = await cache.match(request, options);\n                if (response !== undefined) {\n                    return response;\n                }\n            }\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async has(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        const prefix = 'CacheStorage.has';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName');\n        // 2.1.1\n        // 2.2\n        return this.#caches.has(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */ async open(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        const prefix = 'CacheStorage.open';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName');\n        // 2.1\n        if (this.#caches.has(cacheName)) {\n            // await caches.open('v1') !== await caches.open('v1')\n            // 2.1.1\n            const cache = this.#caches.get(cacheName);\n            // 2.1.1.1\n            return new Cache(kConstruct, cache);\n        }\n        // 2.2\n        const cache = [];\n        // 2.3\n        this.#caches.set(cacheName, cache);\n        // 2.4\n        return new Cache(kConstruct, cache);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async delete(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        const prefix = 'CacheStorage.delete';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName');\n        return this.#caches.delete(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {Promise<string[]>}\n   */ async keys() {\n        webidl.brandCheck(this, CacheStorage);\n        // 2.1\n        const keys = this.#caches.keys();\n        // 2.2\n        return [\n            ...keys\n        ];\n    }\n}\nObject.defineProperties(CacheStorage.prototype, {\n    [Symbol.toStringTag]: {\n        value: 'CacheStorage',\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    has: kEnumerableProperty,\n    open: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nmodule.exports = {\n    CacheStorage\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxVQUFVLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsdUVBQVc7QUFDMUMsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR0QsbUJBQU9BLENBQUMsbUVBQVM7QUFDbkMsTUFBTSxFQUFFRSxNQUFNLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsNEVBQWlCO0FBQzVDLE1BQU0sRUFBRUcsbUJBQW1CLEVBQUUsR0FBR0gsbUJBQU9BLENBQUMscUVBQWlCO0FBRXpELE1BQU1JO0lBQ0o7OztHQUdDLEdBQ0QsT0FBTyxDQUFZO0lBRW5CLGFBQWU7YUFGZixPQUFPLEdBQUcsSUFBSUM7UUFHWixJQUFJQyxTQUFTLENBQUMsRUFBRSxLQUFLUCxZQUFZO1lBQy9CRyxPQUFPSyxrQkFBa0I7UUFDM0I7SUFDRjtJQUVBLE1BQU1DLE1BQU9DLE9BQU8sRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUNsQ1IsT0FBT1MsVUFBVSxDQUFDLElBQUksRUFBRVA7UUFDeEJGLE9BQU9VLG1CQUFtQixDQUFDTixXQUFXLEdBQUc7UUFFekNHLFVBQVVQLE9BQU9XLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDTDtRQUN4Q0MsVUFBVVIsT0FBT1csVUFBVSxDQUFDRSxzQkFBc0IsQ0FBQ0w7UUFFbkQsS0FBSztRQUNMLElBQUlBLFFBQVFNLFNBQVMsSUFBSSxNQUFNO1lBQzdCLFVBQVU7WUFDVixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ1AsUUFBUU0sU0FBUyxHQUFHO2dCQUN2QyxZQUFZO2dCQUNaLE1BQU1FLFlBQVksSUFBSSxDQUFDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDVCxRQUFRTSxTQUFTO2dCQUNwRCxNQUFNSSxRQUFRLElBQUluQixNQUFNRixZQUFZbUI7Z0JBRXBDLE9BQU8sTUFBTUUsTUFBTVosS0FBSyxDQUFDQyxTQUFTQztZQUNwQztRQUNGLE9BQU87WUFDTCxNQUFNO1lBQ04sS0FBSyxNQUFNUSxhQUFhLElBQUksQ0FBQyxPQUFPLENBQUNHLE1BQU0sR0FBSTtnQkFDN0MsTUFBTUQsUUFBUSxJQUFJbkIsTUFBTUYsWUFBWW1CO2dCQUVwQyxVQUFVO2dCQUNWLE1BQU1JLFdBQVcsTUFBTUYsTUFBTVosS0FBSyxDQUFDQyxTQUFTQztnQkFFNUMsSUFBSVksYUFBYUMsV0FBVztvQkFDMUIsT0FBT0Q7Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQTs7OztHQUlDLEdBQ0QsTUFBTUwsSUFBS0QsU0FBUyxFQUFFO1FBQ3BCZCxPQUFPUyxVQUFVLENBQUMsSUFBSSxFQUFFUDtRQUV4QixNQUFNb0IsU0FBUztRQUNmdEIsT0FBT1UsbUJBQW1CLENBQUNOLFdBQVcsR0FBR2tCO1FBRXpDUixZQUFZZCxPQUFPVyxVQUFVLENBQUNZLFNBQVMsQ0FBQ1QsV0FBV1EsUUFBUTtRQUUzRCxRQUFRO1FBQ1IsTUFBTTtRQUNOLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQ1AsR0FBRyxDQUFDRDtJQUMxQjtJQUVBOzs7O0dBSUMsR0FDRCxNQUFNVSxLQUFNVixTQUFTLEVBQUU7UUFDckJkLE9BQU9TLFVBQVUsQ0FBQyxJQUFJLEVBQUVQO1FBRXhCLE1BQU1vQixTQUFTO1FBQ2Z0QixPQUFPVSxtQkFBbUIsQ0FBQ04sV0FBVyxHQUFHa0I7UUFFekNSLFlBQVlkLE9BQU9XLFVBQVUsQ0FBQ1ksU0FBUyxDQUFDVCxXQUFXUSxRQUFRO1FBRTNELE1BQU07UUFDTixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUNQLEdBQUcsQ0FBQ0QsWUFBWTtZQUMvQixzREFBc0Q7WUFFdEQsUUFBUTtZQUNSLE1BQU1JLFFBQVEsSUFBSSxDQUFDLE9BQU8sQ0FBQ0QsR0FBRyxDQUFDSDtZQUUvQixVQUFVO1lBQ1YsT0FBTyxJQUFJZixNQUFNRixZQUFZcUI7UUFDL0I7UUFFQSxNQUFNO1FBQ04sTUFBTUEsUUFBUSxFQUFFO1FBRWhCLE1BQU07UUFDTixJQUFJLENBQUMsT0FBTyxDQUFDTyxHQUFHLENBQUNYLFdBQVdJO1FBRTVCLE1BQU07UUFDTixPQUFPLElBQUluQixNQUFNRixZQUFZcUI7SUFDL0I7SUFFQTs7OztHQUlDLEdBQ0QsTUFBTVEsT0FBUVosU0FBUyxFQUFFO1FBQ3ZCZCxPQUFPUyxVQUFVLENBQUMsSUFBSSxFQUFFUDtRQUV4QixNQUFNb0IsU0FBUztRQUNmdEIsT0FBT1UsbUJBQW1CLENBQUNOLFdBQVcsR0FBR2tCO1FBRXpDUixZQUFZZCxPQUFPVyxVQUFVLENBQUNZLFNBQVMsQ0FBQ1QsV0FBV1EsUUFBUTtRQUUzRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUNJLE1BQU0sQ0FBQ1o7SUFDN0I7SUFFQTs7O0dBR0MsR0FDRCxNQUFNYSxPQUFRO1FBQ1ozQixPQUFPUyxVQUFVLENBQUMsSUFBSSxFQUFFUDtRQUV4QixNQUFNO1FBQ04sTUFBTXlCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQ0EsSUFBSTtRQUU5QixNQUFNO1FBQ04sT0FBTztlQUFJQTtTQUFLO0lBQ2xCO0FBQ0Y7QUFFQUMsT0FBT0MsZ0JBQWdCLENBQUMzQixhQUFhNEIsU0FBUyxFQUFFO0lBQzlDLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCQyxPQUFPO1FBQ1BDLGNBQWM7SUFDaEI7SUFDQTVCLE9BQU9MO0lBQ1BjLEtBQUtkO0lBQ0x1QixNQUFNdkI7SUFDTnlCLFFBQVF6QjtJQUNSMEIsTUFBTTFCO0FBQ1I7QUFFQWtDLE9BQU9DLE9BQU8sR0FBRztJQUNmbEM7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNhY2hlXFxjYWNoZXN0b3JhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgQ2FjaGUgfSA9IHJlcXVpcmUoJy4vY2FjaGUnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5cbmNsYXNzIENhY2hlU3RvcmFnZSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVsZXZhbnQtbmFtZS10by1jYWNoZS1tYXBcbiAgICogQHR5cGUge01hcDxzdHJpbmcsIGltcG9ydCgnLi9jYWNoZScpLnJlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjY2FjaGVzID0gbmV3IE1hcCgpXG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gIT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHdlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IoKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnQ2FjaGVTdG9yYWdlLm1hdGNoJylcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5NdWx0aUNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvLyAxLlxuICAgIGlmIChvcHRpb25zLmNhY2hlTmFtZSAhPSBudWxsKSB7XG4gICAgICAvLyAxLjEuMS4xXG4gICAgICBpZiAodGhpcy4jY2FjaGVzLmhhcyhvcHRpb25zLmNhY2hlTmFtZSkpIHtcbiAgICAgICAgLy8gMS4xLjEuMS4xXG4gICAgICAgIGNvbnN0IGNhY2hlTGlzdCA9IHRoaXMuI2NhY2hlcy5nZXQob3B0aW9ucy5jYWNoZU5hbWUpXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlTGlzdClcblxuICAgICAgICByZXR1cm4gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyAyLlxuICAgICAgLy8gMi4yXG4gICAgICBmb3IgKGNvbnN0IGNhY2hlTGlzdCBvZiB0aGlzLiNjYWNoZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGVMaXN0KVxuXG4gICAgICAgIC8vIDIuMi4xLjJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaChyZXF1ZXN0LCBvcHRpb25zKVxuXG4gICAgICAgIGlmIChyZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1oYXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGFzeW5jIGhhcyAoY2FjaGVOYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlU3RvcmFnZS5oYXMnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBjYWNoZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY2FjaGVOYW1lLCBwcmVmaXgsICdjYWNoZU5hbWUnKVxuXG4gICAgLy8gMi4xLjFcbiAgICAvLyAyLjJcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVzLmhhcyhjYWNoZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZG9tLWNhY2hlc3RvcmFnZS1vcGVuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGU+fVxuICAgKi9cbiAgYXN5bmMgb3BlbiAoY2FjaGVOYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlU3RvcmFnZS5vcGVuJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSwgcHJlZml4LCAnY2FjaGVOYW1lJylcblxuICAgIC8vIDIuMVxuICAgIGlmICh0aGlzLiNjYWNoZXMuaGFzKGNhY2hlTmFtZSkpIHtcbiAgICAgIC8vIGF3YWl0IGNhY2hlcy5vcGVuKCd2MScpICE9PSBhd2FpdCBjYWNoZXMub3BlbigndjEnKVxuXG4gICAgICAvLyAyLjEuMVxuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLiNjYWNoZXMuZ2V0KGNhY2hlTmFtZSlcblxuICAgICAgLy8gMi4xLjEuMVxuICAgICAgcmV0dXJuIG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZSlcbiAgICB9XG5cbiAgICAvLyAyLjJcbiAgICBjb25zdCBjYWNoZSA9IFtdXG5cbiAgICAvLyAyLjNcbiAgICB0aGlzLiNjYWNoZXMuc2V0KGNhY2hlTmFtZSwgY2FjaGUpXG5cbiAgICAvLyAyLjRcbiAgICByZXR1cm4gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtZGVsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBkZWxldGUgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZVN0b3JhZ2UuZGVsZXRlJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSwgcHJlZml4LCAnY2FjaGVOYW1lJylcblxuICAgIHJldHVybiB0aGlzLiNjYWNoZXMuZGVsZXRlKGNhY2hlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWtleXNcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fVxuICAgKi9cbiAgYXN5bmMga2V5cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuXG4gICAgLy8gMi4xXG4gICAgY29uc3Qga2V5cyA9IHRoaXMuI2NhY2hlcy5rZXlzKClcblxuICAgIC8vIDIuMlxuICAgIHJldHVybiBbLi4ua2V5c11cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYWNoZVN0b3JhZ2UucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDYWNoZVN0b3JhZ2UnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtYXRjaDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGFzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGtleXM6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYWNoZVN0b3JhZ2Vcbn1cbiJdLCJuYW1lcyI6WyJrQ29uc3RydWN0IiwicmVxdWlyZSIsIkNhY2hlIiwid2ViaWRsIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsIkNhY2hlU3RvcmFnZSIsIk1hcCIsImFyZ3VtZW50cyIsImlsbGVnYWxDb25zdHJ1Y3RvciIsIm1hdGNoIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJicmFuZENoZWNrIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImNvbnZlcnRlcnMiLCJSZXF1ZXN0SW5mbyIsIk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMiLCJjYWNoZU5hbWUiLCJoYXMiLCJjYWNoZUxpc3QiLCJnZXQiLCJjYWNoZSIsInZhbHVlcyIsInJlc3BvbnNlIiwidW5kZWZpbmVkIiwicHJlZml4IiwiRE9NU3RyaW5nIiwib3BlbiIsInNldCIsImRlbGV0ZSIsImtleXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/symbols.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = {\n    kConstruct: (__webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\").kConstruct)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsWUFBWUMsNkdBQXdDO0FBQ3REIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY2FjaGVcXHN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrQ29uc3RydWN0OiByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKS5rQ29uc3RydWN0XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtDb25zdHJ1Y3QiLCJyZXF1aXJlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */ function urlEquals(A, B, excludeFragment = false) {\n    const serializedA = URLSerializer(A, excludeFragment);\n    const serializedB = URLSerializer(B, excludeFragment);\n    return serializedA === serializedB;\n}\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */ function getFieldValues(header) {\n    assert(header !== null);\n    const values = [];\n    for (let value of header.split(',')){\n        value = value.trim();\n        if (isValidHeaderName(value)) {\n            values.push(value);\n        }\n    }\n    return values;\n}\nmodule.exports = {\n    urlEquals,\n    getFieldValues\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3BDLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDLGdGQUFtQjtBQUNyRCxNQUFNLEVBQUVFLGlCQUFpQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDLHdFQUFlO0FBRXJEOzs7Ozs7Q0FNQyxHQUNELFNBQVNHLFVBQVdDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxrQkFBa0IsS0FBSztJQUMvQyxNQUFNQyxjQUFjTixjQUFjRyxHQUFHRTtJQUVyQyxNQUFNRSxjQUFjUCxjQUFjSSxHQUFHQztJQUVyQyxPQUFPQyxnQkFBZ0JDO0FBQ3pCO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0MsZUFBZ0JDLE1BQU07SUFDN0JYLE9BQU9XLFdBQVc7SUFFbEIsTUFBTUMsU0FBUyxFQUFFO0lBRWpCLEtBQUssSUFBSUMsU0FBU0YsT0FBT0csS0FBSyxDQUFDLEtBQU07UUFDbkNELFFBQVFBLE1BQU1FLElBQUk7UUFFbEIsSUFBSVosa0JBQWtCVSxRQUFRO1lBQzVCRCxPQUFPSSxJQUFJLENBQUNIO1FBQ2Q7SUFDRjtJQUVBLE9BQU9EO0FBQ1Q7QUFFQUssT0FBT0MsT0FBTyxHQUFHO0lBQ2ZkO0lBQ0FNO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjYWNoZVxcdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCB7IGlzVmFsaWRIZWFkZXJOYW1lIH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtZXF1YWxzXG4gKiBAcGFyYW0ge1VSTH0gQVxuICogQHBhcmFtIHtVUkx9IEJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gZXhjbHVkZUZyYWdtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdXJsRXF1YWxzIChBLCBCLCBleGNsdWRlRnJhZ21lbnQgPSBmYWxzZSkge1xuICBjb25zdCBzZXJpYWxpemVkQSA9IFVSTFNlcmlhbGl6ZXIoQSwgZXhjbHVkZUZyYWdtZW50KVxuXG4gIGNvbnN0IHNlcmlhbGl6ZWRCID0gVVJMU2VyaWFsaXplcihCLCBleGNsdWRlRnJhZ21lbnQpXG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWRBID09PSBzZXJpYWxpemVkQlxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvNjk0ZDIwZDEzNGNiNTUzZDhkODllNTUwMGI5MTQ4MDEyYjFiYTI5OS9jb250ZW50L2Jyb3dzZXIvY2FjaGVfc3RvcmFnZS9jYWNoZV9zdG9yYWdlX2NhY2hlLmNjI0wyNjAtTDI2MlxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICovXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlcyAoaGVhZGVyKSB7XG4gIGFzc2VydChoZWFkZXIgIT09IG51bGwpXG5cbiAgY29uc3QgdmFsdWVzID0gW11cblxuICBmb3IgKGxldCB2YWx1ZSBvZiBoZWFkZXIuc3BsaXQoJywnKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgICBpZiAoaXNWYWxpZEhlYWRlck5hbWUodmFsdWUpKSB7XG4gICAgICB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1cmxFcXVhbHMsXG4gIGdldEZpZWxkVmFsdWVzXG59XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIlVSTFNlcmlhbGl6ZXIiLCJpc1ZhbGlkSGVhZGVyTmFtZSIsInVybEVxdWFscyIsIkEiLCJCIiwiZXhjbHVkZUZyYWdtZW50Iiwic2VyaWFsaXplZEEiLCJzZXJpYWxpemVkQiIsImdldEZpZWxkVmFsdWVzIiwiaGVhZGVyIiwidmFsdWVzIiwidmFsdWUiLCJzcGxpdCIsInRyaW0iLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024;\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096;\nmodule.exports = {\n    maxAttributeValueSize,\n    maxNameValuePairSize\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSwyRUFBMkU7QUFDM0UsTUFBTUEsd0JBQXdCO0FBRTlCLDJFQUEyRTtBQUMzRSxNQUFNQyx1QkFBdUI7QUFFN0JDLE9BQU9DLE9BQU8sR0FBRztJQUNmSDtJQUNBQztBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY29va2llc1xcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jY29va2llLW1heGltdW0tYXR0cmlidXRlLXZhbHVlLXNpemVcbmNvbnN0IG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSA9IDEwMjRcblxuLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI2Nvb2tpZS1tYXhpbXVtLW5hbWUtdmFsdWUtcGFpci1zaXplXG5jb25zdCBtYXhOYW1lVmFsdWVQYWlyU2l6ZSA9IDQwOTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSxcbiAgbWF4TmFtZVZhbHVlUGFpclNpemVcbn1cbiJdLCJuYW1lcyI6WyJtYXhBdHRyaWJ1dGVWYWx1ZVNpemUiLCJtYXhOYW1lVmFsdWVQYWlyU2l6ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/index.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/undici/lib/web/cookies/parse.js\");\nconst { stringify } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cookies/util.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number|undefined} expires\n * @property {number|undefined} maxAge\n * @property {string|undefined} domain\n * @property {string|undefined} path\n * @property {boolean|undefined} secure\n * @property {boolean|undefined} httpOnly\n * @property {'Strict'|'Lax'|'None'} sameSite\n * @property {string[]} unparsed\n */ /**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */ function getCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, 'getCookies');\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookie = headers.get('cookie');\n    const out = {};\n    if (!cookie) {\n        return out;\n    }\n    for (const piece of cookie.split(';')){\n        const [name, ...value] = piece.split('=');\n        out[name.trim()] = value.join('=');\n    }\n    return out;\n}\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */ function deleteCookie(headers, name, attributes) {\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const prefix = 'deleteCookie';\n    webidl.argumentLengthCheck(arguments, 2, prefix);\n    name = webidl.converters.DOMString(name, prefix, 'name');\n    attributes = webidl.converters.DeleteCookieAttributes(attributes);\n    // Matches behavior of\n    // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n    setCookie(headers, {\n        name,\n        value: '',\n        expires: new Date(0),\n        ...attributes\n    });\n}\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */ function getSetCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, 'getSetCookies');\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookies = headers.getSetCookie();\n    if (!cookies) {\n        return [];\n    }\n    return cookies.map((pair)=>parseSetCookie(pair));\n}\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */ function setCookie(headers, cookie) {\n    webidl.argumentLengthCheck(arguments, 2, 'setCookie');\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    cookie = webidl.converters.Cookie(cookie);\n    const str = stringify(cookie);\n    if (str) {\n        headers.append('Set-Cookie', str);\n    }\n}\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: 'path',\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: 'domain',\n        defaultValue: ()=>null\n    }\n]);\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n    {\n        converter: webidl.converters.DOMString,\n        key: 'name'\n    },\n    {\n        converter: webidl.converters.DOMString,\n        key: 'value'\n    },\n    {\n        converter: webidl.nullableConverter((value)=>{\n            if (typeof value === 'number') {\n                return webidl.converters['unsigned long long'](value);\n            }\n            return new Date(value);\n        }),\n        key: 'expires',\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters['long long']),\n        key: 'maxAge',\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: 'domain',\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: 'path',\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: 'secure',\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: 'httpOnly',\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.converters.USVString,\n        key: 'sameSite',\n        allowedValues: [\n            'Strict',\n            'Lax',\n            'None'\n        ]\n    },\n    {\n        converter: webidl.sequenceConverter(webidl.converters.DOMString),\n        key: 'unparsed',\n        defaultValue: ()=>new Array(0)\n    }\n]);\nmodule.exports = {\n    getCookies,\n    deleteCookie,\n    getSetCookies,\n    setCookie\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsY0FBYyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLHFFQUFTO0FBQzVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDLG1FQUFRO0FBQ3RDLE1BQU0sRUFBRUUsTUFBTSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDLDRFQUFpQjtBQUM1QyxNQUFNLEVBQUVHLE9BQU8sRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQyw4RUFBa0I7QUFFOUM7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQ7OztDQUdDLEdBQ0QsU0FBU0ksV0FBWUMsT0FBTztJQUMxQkgsT0FBT0ksbUJBQW1CLENBQUNDLFdBQVcsR0FBRztJQUV6Q0wsT0FBT00sVUFBVSxDQUFDSCxTQUFTRixTQUFTO1FBQUVNLFFBQVE7SUFBTTtJQUVwRCxNQUFNQyxTQUFTTCxRQUFRTSxHQUFHLENBQUM7SUFDM0IsTUFBTUMsTUFBTSxDQUFDO0lBRWIsSUFBSSxDQUFDRixRQUFRO1FBQ1gsT0FBT0U7SUFDVDtJQUVBLEtBQUssTUFBTUMsU0FBU0gsT0FBT0ksS0FBSyxDQUFDLEtBQU07UUFDckMsTUFBTSxDQUFDQyxNQUFNLEdBQUdDLE1BQU0sR0FBR0gsTUFBTUMsS0FBSyxDQUFDO1FBRXJDRixHQUFHLENBQUNHLEtBQUtFLElBQUksR0FBRyxHQUFHRCxNQUFNRSxJQUFJLENBQUM7SUFDaEM7SUFFQSxPQUFPTjtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTTyxhQUFjZCxPQUFPLEVBQUVVLElBQUksRUFBRUssVUFBVTtJQUM5Q2xCLE9BQU9NLFVBQVUsQ0FBQ0gsU0FBU0YsU0FBUztRQUFFTSxRQUFRO0lBQU07SUFFcEQsTUFBTVksU0FBUztJQUNmbkIsT0FBT0ksbUJBQW1CLENBQUNDLFdBQVcsR0FBR2M7SUFFekNOLE9BQU9iLE9BQU9vQixVQUFVLENB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Q0VILFdBQVduQyxPQUFPb0IsVUFBVSxDQUFDb0IsU0FBUztRQUN0Q0gsS0FBSztRQUNMSSxlQUFlO1lBQUM7WUFBVTtZQUFPO1NBQU87SUFDMUM7SUFDQTtRQUNFTixXQUFXbkMsT0FBTzBDLGlCQUFpQixDQUFDMUMsT0FBT29CLFVBQVUsQ0FBQ0MsU0FBUztRQUMvRGdCLEtBQUs7UUFDTEMsY0FBYyxJQUFNLElBQUlLLE1BQU07SUFDaEM7Q0FDRDtBQUVEQyxPQUFPQyxPQUFPLEdBQUc7SUFDZjNDO0lBQ0FlO0lBQ0FTO0lBQ0FIO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjb29raWVzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwYXJzZVNldENvb2tpZSB9ID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBIZWFkZXJzIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb29raWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7RGF0ZXxudW1iZXJ8dW5kZWZpbmVkfSBleHBpcmVzXG4gKiBAcHJvcGVydHkge251bWJlcnx1bmRlZmluZWR9IG1heEFnZVxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBkb21haW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gcGF0aFxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gc2VjdXJlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBodHRwT25seVxuICogQHByb3BlcnR5IHsnU3RyaWN0J3wnTGF4J3wnTm9uZSd9IHNhbWVTaXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB1bnBhcnNlZFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29va2llcyAoaGVhZGVycykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdnZXRDb29raWVzJylcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb25zdCBjb29raWUgPSBoZWFkZXJzLmdldCgnY29va2llJylcbiAgY29uc3Qgb3V0ID0ge31cblxuICBpZiAoIWNvb2tpZSkge1xuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIGZvciAoY29uc3QgcGllY2Ugb2YgY29va2llLnNwbGl0KCc7JykpIHtcbiAgICBjb25zdCBbbmFtZSwgLi4udmFsdWVdID0gcGllY2Uuc3BsaXQoJz0nKVxuXG4gICAgb3V0W25hbWUudHJpbSgpXSA9IHZhbHVlLmpvaW4oJz0nKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBwYXRoPzogc3RyaW5nLCBkb21haW4/OiBzdHJpbmcgfXx1bmRlZmluZWR9IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWxldGVDb29raWUgKGhlYWRlcnMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgY29uc3QgcHJlZml4ID0gJ2RlbGV0ZUNvb2tpZSdcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgYXR0cmlidXRlcyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMoYXR0cmlidXRlcylcblxuICAvLyBNYXRjaGVzIGJlaGF2aW9yIG9mXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vX3N0ZC9ibG9iLzYzODI3YjE2MzMwYjgyNDg5YTA0NjE0MDI3YzMzYjc5MDRlMDhiZTUvaHR0cC9jb29raWUudHMjTDI3OFxuICBzZXRDb29raWUoaGVhZGVycywge1xuICAgIG5hbWUsXG4gICAgdmFsdWU6ICcnLFxuICAgIGV4cGlyZXM6IG5ldyBEYXRlKDApLFxuICAgIC4uLmF0dHJpYnV0ZXNcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtDb29raWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2V0Q29va2llcyAoaGVhZGVycykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdnZXRTZXRDb29raWVzJylcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb25zdCBjb29raWVzID0gaGVhZGVycy5nZXRTZXRDb29raWUoKVxuXG4gIGlmICghY29va2llcykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmV0dXJuIGNvb2tpZXMubWFwKChwYWlyKSA9PiBwYXJzZVNldENvb2tpZShwYWlyKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEBwYXJhbSB7Q29va2llfSBjb29raWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzZXRDb29raWUgKGhlYWRlcnMsIGNvb2tpZSkge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsICdzZXRDb29raWUnKVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvb2tpZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZShjb29raWUpXG5cbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGNvb2tpZSlcblxuICBpZiAoc3RyKSB7XG4gICAgaGVhZGVycy5hcHBlbmQoJ1NldC1Db29raWUnLCBzdHIpXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuRGVsZXRlQ29va2llQXR0cmlidXRlcyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAncGF0aCcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ2RvbWFpbicsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZSA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGtleTogJ25hbWUnXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBrZXk6ICd2YWx1ZSdcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSh2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKVxuICAgIH0pLFxuICAgIGtleTogJ2V4cGlyZXMnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddKSxcbiAgICBrZXk6ICdtYXhBZ2UnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdkb21haW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdwYXRoJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4pLFxuICAgIGtleTogJ3NlY3VyZScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ib29sZWFuKSxcbiAgICBrZXk6ICdodHRwT25seScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBrZXk6ICdzYW1lU2l0ZScsXG4gICAgYWxsb3dlZFZhbHVlczogWydTdHJpY3QnLCAnTGF4JywgJ05vbmUnXVxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICd1bnBhcnNlZCcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBuZXcgQXJyYXkoMClcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvb2tpZXMsXG4gIGRlbGV0ZUNvb2tpZSxcbiAgZ2V0U2V0Q29va2llcyxcbiAgc2V0Q29va2llXG59XG4iXSwibmFtZXMiOlsicGFyc2VTZXRDb29raWUiLCJyZXF1aXJlIiwic3RyaW5naWZ5Iiwid2ViaWRsIiwiSGVhZGVycyIsImdldENvb2tpZXMiLCJoZWFkZXJzIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImJyYW5kQ2hlY2siLCJzdHJpY3QiLCJjb29raWUiLCJnZXQiLCJvdXQiLCJwaWVjZSIsInNwbGl0IiwibmFtZSIsInZhbHVlIiwidHJpbSIsImpvaW4iLCJkZWxldGVDb29raWUiLCJhdHRyaWJ1dGVzIiwicHJlZml4IiwiY29udmVydGVycyIsIkRPTVN0cmluZyIsIkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMiLCJzZXRDb29raWUiLCJleHBpcmVzIiwiRGF0ZSIsImdldFNldENvb2tpZXMiLCJjb29raWVzIiwiZ2V0U2V0Q29va2llIiwibWFwIiwicGFpciIsIkNvb2tpZSIsInN0ciIsImFwcGVuZCIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJjb252ZXJ0ZXIiLCJudWxsYWJsZUNvbnZlcnRlciIsImtleSIsImRlZmF1bHRWYWx1ZSIsImJvb2xlYW4iLCJVU1ZTdHJpbmciLCJhbGxvd2VkVmFsdWVzIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJBcnJheSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/cookies/constants.js\");\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cookies/util.js\");\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */ function parseSetCookie(header) {\n    // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n    //    character (CTL characters excluding HTAB): Abort these steps and\n    //    ignore the set-cookie-string entirely.\n    if (isCTLExcludingHtab(header)) {\n        return null;\n    }\n    let nameValuePair = '';\n    let unparsedAttributes = '';\n    let name = '';\n    let value = '';\n    // 2. If the set-cookie-string contains a %x3B (\";\") character:\n    if (header.includes(';')) {\n        // 1. The name-value-pair string consists of the characters up to,\n        //    but not including, the first %x3B (\";\"), and the unparsed-\n        //    attributes consist of the remainder of the set-cookie-string\n        //    (including the %x3B (\";\") in question).\n        const position = {\n            position: 0\n        };\n        nameValuePair = collectASequenceOfCodePointsFast(';', header, position);\n        unparsedAttributes = header.slice(position.position);\n    } else {\n        // Otherwise:\n        // 1. The name-value-pair string consists of all the characters\n        //    contained in the set-cookie-string, and the unparsed-\n        //    attributes is the empty string.\n        nameValuePair = header;\n    }\n    // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n    //    the name string is empty, and the value string is the value of\n    //    name-value-pair.\n    if (!nameValuePair.includes('=')) {\n        value = nameValuePair;\n    } else {\n        //    Otherwise, the name string consists of the characters up to, but\n        //    not including, the first %x3D (\"=\") character, and the (possibly\n        //    empty) value string consists of the characters after the first\n        //    %x3D (\"=\") character.\n        const position = {\n            position: 0\n        };\n        name = collectASequenceOfCodePointsFast('=', nameValuePair, position);\n        value = nameValuePair.slice(position.position + 1);\n    }\n    // 4. Remove any leading or trailing WSP characters from the name\n    //    string and the value string.\n    name = name.trim();\n    value = value.trim();\n    // 5. If the sum of the lengths of the name string and the value string\n    //    is more than 4096 octets, abort these steps and ignore the set-\n    //    cookie-string entirely.\n    if (name.length + value.length > maxNameValuePairSize) {\n        return null;\n    }\n    // 6. The cookie-name is the name string, and the cookie-value is the\n    //    value string.\n    return {\n        name,\n        value,\n        ...parseUnparsedAttributes(unparsedAttributes)\n    };\n}\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */ function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {\n    // 1. If the unparsed-attributes string is empty, skip the rest of\n    //    these steps.\n    if (unparsedAttributes.length === 0) {\n        return cookieAttributeList;\n    }\n    // 2. Discard the first character of the unparsed-attributes (which\n    //    will be a %x3B (\";\") character).\n    assert(unparsedAttributes[0] === ';');\n    unparsedAttributes = unparsedAttributes.slice(1);\n    let cookieAv = '';\n    // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n    //    character:\n    if (unparsedAttributes.includes(';')) {\n        // 1. Consume the characters of the unparsed-attributes up to, but\n        //    not including, the first %x3B (\";\") character.\n        cookieAv = collectASequenceOfCodePointsFast(';', unparsedAttributes, {\n            position: 0\n        });\n        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);\n    } else {\n        // Otherwise:\n        // 1. Consume the remainder of the unparsed-attributes.\n        cookieAv = unparsedAttributes;\n        unparsedAttributes = '';\n    }\n    // Let the cookie-av string be the characters consumed in this step.\n    let attributeName = '';\n    let attributeValue = '';\n    // 4. If the cookie-av string contains a %x3D (\"=\") character:\n    if (cookieAv.includes('=')) {\n        // 1. The (possibly empty) attribute-name string consists of the\n        //    characters up to, but not including, the first %x3D (\"=\")\n        //    character, and the (possibly empty) attribute-value string\n        //    consists of the characters after the first %x3D (\"=\")\n        //    character.\n        const position = {\n            position: 0\n        };\n        attributeName = collectASequenceOfCodePointsFast('=', cookieAv, position);\n        attributeValue = cookieAv.slice(position.position + 1);\n    } else {\n        // Otherwise:\n        // 1. The attribute-name string consists of the entire cookie-av\n        //    string, and the attribute-value string is empty.\n        attributeName = cookieAv;\n    }\n    // 5. Remove any leading or trailing WSP characters from the attribute-\n    //    name string and the attribute-value string.\n    attributeName = attributeName.trim();\n    attributeValue = attributeValue.trim();\n    // 6. If the attribute-value is longer than 1024 octets, ignore the\n    //    cookie-av string and return to Step 1 of this algorithm.\n    if (attributeValue.length > maxAttributeValueSize) {\n        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n    }\n    // 7. Process the attribute-name and attribute-value according to the\n    //    requirements in the following subsections.  (Notice that\n    //    attributes with unrecognized attribute-names are ignored.)\n    const attributeNameLowercase = attributeName.toLowerCase();\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n    // If the attribute-name case-insensitively matches the string\n    // \"Expires\", the user agent MUST process the cookie-av as follows.\n    if (attributeNameLowercase === 'expires') {\n        // 1. Let the expiry-time be the result of parsing the attribute-value\n        //    as cookie-date (see Section 5.1.1).\n        const expiryTime = new Date(attributeValue);\n        // 2. If the attribute-value failed to parse as a cookie date, ignore\n        //    the cookie-av.\n        cookieAttributeList.expires = expiryTime;\n    } else if (attributeNameLowercase === 'max-age') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n        // If the attribute-name case-insensitively matches the string \"Max-\n        // Age\", the user agent MUST process the cookie-av as follows.\n        // 1. If the first character of the attribute-value is not a DIGIT or a\n        //    \"-\" character, ignore the cookie-av.\n        const charCode = attributeValue.charCodeAt(0);\n        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 2. If the remainder of attribute-value contains a non-DIGIT\n        //    character, ignore the cookie-av.\n        if (!/^\\d+$/.test(attributeValue)) {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 3. Let delta-seconds be the attribute-value converted to an integer.\n        const deltaSeconds = Number(attributeValue);\n        // 4. Let cookie-age-limit be the maximum age of the cookie (which\n        //    SHOULD be 400 days or less, see Section 4.1.2.2).\n        // 5. Set delta-seconds to the smaller of its present value and cookie-\n        //    age-limit.\n        // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n        // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n        //    time be the earliest representable date and time.  Otherwise, let\n        //    the expiry-time be the current date and time plus delta-seconds\n        //    seconds.\n        // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n        // 7. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Max-Age and an attribute-value of expiry-time.\n        cookieAttributeList.maxAge = deltaSeconds;\n    } else if (attributeNameLowercase === 'domain') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n        // If the attribute-name case-insensitively matches the string \"Domain\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. Let cookie-domain be the attribute-value.\n        let cookieDomain = attributeValue;\n        // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n        //    cookie-domain without its leading %x2E (\".\").\n        if (cookieDomain[0] === '.') {\n            cookieDomain = cookieDomain.slice(1);\n        }\n        // 3. Convert the cookie-domain to lower case.\n        cookieDomain = cookieDomain.toLowerCase();\n        // 4. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Domain and an attribute-value of cookie-domain.\n        cookieAttributeList.domain = cookieDomain;\n    } else if (attributeNameLowercase === 'path') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n        // If the attribute-name case-insensitively matches the string \"Path\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. If the attribute-value is empty or if the first character of the\n        //    attribute-value is not %x2F (\"/\"):\n        let cookiePath = '';\n        if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n            // 1. Let cookie-path be the default-path.\n            cookiePath = '/';\n        } else {\n            // Otherwise:\n            // 1. Let cookie-path be the attribute-value.\n            cookiePath = attributeValue;\n        }\n        // 2. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Path and an attribute-value of cookie-path.\n        cookieAttributeList.path = cookiePath;\n    } else if (attributeNameLowercase === 'secure') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n        // If the attribute-name case-insensitively matches the string \"Secure\",\n        // the user agent MUST append an attribute to the cookie-attribute-list\n        // with an attribute-name of Secure and an empty attribute-value.\n        cookieAttributeList.secure = true;\n    } else if (attributeNameLowercase === 'httponly') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n        // If the attribute-name case-insensitively matches the string\n        // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n        // attribute-list with an attribute-name of HttpOnly and an empty\n        // attribute-value.\n        cookieAttributeList.httpOnly = true;\n    } else if (attributeNameLowercase === 'samesite') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n        // If the attribute-name case-insensitively matches the string\n        // \"SameSite\", the user agent MUST process the cookie-av as follows:\n        // 1. Let enforcement be \"Default\".\n        let enforcement = 'Default';\n        const attributeValueLowercase = attributeValue.toLowerCase();\n        // 2. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"None\", set enforcement to \"None\".\n        if (attributeValueLowercase.includes('none')) {\n            enforcement = 'None';\n        }\n        // 3. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Strict\", set enforcement to \"Strict\".\n        if (attributeValueLowercase.includes('strict')) {\n            enforcement = 'Strict';\n        }\n        // 4. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Lax\", set enforcement to \"Lax\".\n        if (attributeValueLowercase.includes('lax')) {\n            enforcement = 'Lax';\n        }\n        // 5. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of \"SameSite\" and an attribute-value of\n        //    enforcement.\n        cookieAttributeList.sameSite = enforcement;\n    } else {\n        cookieAttributeList.unparsed ??= [];\n        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);\n    }\n    // 8. Return to Step 1 of this algorithm.\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n}\nmodule.exports = {\n    parseSetCookie,\n    parseUnparsedAttributes\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsb0JBQW9CLEVBQUVDLHFCQUFxQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLDZFQUFhO0FBQzdFLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUUsR0FBR0QsbUJBQU9BLENBQUMsbUVBQVE7QUFDL0MsTUFBTSxFQUFFRSxnQ0FBZ0MsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQyxnRkFBbUI7QUFDeEUsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsZ0NBQWE7QUFFcEM7Ozs7O0NBS0MsR0FDRCxTQUFTSSxlQUFnQkMsTUFBTTtJQUM3QixrRUFBa0U7SUFDbEUsc0VBQXNFO0lBQ3RFLDRDQUE0QztJQUM1QyxJQUFJSixtQkFBbUJJLFNBQVM7UUFDOUIsT0FBTztJQUNUO0lBRUEsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDLHFCQUFxQjtJQUN6QixJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsUUFBUTtJQUVaLCtEQUErRDtJQUMvRCxJQUFJSixPQUFPSyxRQUFRLENBQUMsTUFBTTtRQUN4QixrRUFBa0U7UUFDbEUsZ0VBQWdFO1FBQ2hFLGtFQUFrRTtRQUNsRSw2Q0FBNkM7UUFDN0MsTUFBTUMsV0FBVztZQUFFQSxVQUFVO1FBQUU7UUFFL0JMLGdCQUFnQkosaUNBQWlDLEtBQUtHLFFBQVFNO1FBQzlESixxQkFBcUJGLE9BQU9PLEtBQUssQ0FBQ0QsU0FBU0EsUUFBUTtJQUNyRCxPQUFPO1FBQ0wsYUFBYTtRQUViLCtEQUErRDtRQUMvRCwyREFBMkQ7UUFDM0QscUNBQXFDO1FBQ3JDTCxnQkFBZ0JEO0lBQ2xCO0lBRUEsc0VBQXNFO0lBQ3RFLG9FQUFvRTtJQUNwRSxzQkFBc0I7SUFDdEIsSUFBSSxDQUFDQyxjQUFjSSxRQUFRLENBQUMsTUFBTTtRQUNoQ0QsUUFBUUg7SUFDVixPQUFPO1FBQ0wsc0VBQXNFO1FBQ3RFLHNFQUFzRTtR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LG9CQUFvQlM7QUFDckQ7QUFFQTBCLE9BQU9DLE9BQU8sR0FBRztJQUNmdkM7SUFDQVc7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNvb2tpZXNcXHBhcnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG1heE5hbWVWYWx1ZVBhaXJTaXplLCBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgaXNDVExFeGNsdWRpbmdIdGFiIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBQYXJzZXMgdGhlIGZpZWxkLXZhbHVlIGF0dHJpYnV0ZXMgb2YgYSBzZXQtY29va2llIGhlYWRlciBzdHJpbmcuXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjRcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJcbiAqIEByZXR1cm5zIGlmIHRoZSBoZWFkZXIgaXMgaW52YWxpZCwgbnVsbCB3aWxsIGJlIHJldHVybmVkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2V0Q29va2llIChoZWFkZXIpIHtcbiAgLy8gMS4gSWYgdGhlIHNldC1jb29raWUtc3RyaW5nIGNvbnRhaW5zIGEgJXgwMC0wOCAvICV4MEEtMUYgLyAleDdGXG4gIC8vICAgIGNoYXJhY3RlciAoQ1RMIGNoYXJhY3RlcnMgZXhjbHVkaW5nIEhUQUIpOiBBYm9ydCB0aGVzZSBzdGVwcyBhbmRcbiAgLy8gICAgaWdub3JlIHRoZSBzZXQtY29va2llLXN0cmluZyBlbnRpcmVseS5cbiAgaWYgKGlzQ1RMRXhjbHVkaW5nSHRhYihoZWFkZXIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxldCBuYW1lVmFsdWVQYWlyID0gJydcbiAgbGV0IHVucGFyc2VkQXR0cmlidXRlcyA9ICcnXG4gIGxldCBuYW1lID0gJydcbiAgbGV0IHZhbHVlID0gJydcblxuICAvLyAyLiBJZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgY29udGFpbnMgYSAleDNCIChcIjtcIikgY2hhcmFjdGVyOlxuICBpZiAoaGVhZGVyLmluY2x1ZGVzKCc7JykpIHtcbiAgICAvLyAxLiBUaGUgbmFtZS12YWx1ZS1wYWlyIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyB1cCB0byxcbiAgICAvLyAgICBidXQgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0IgKFwiO1wiKSwgYW5kIHRoZSB1bnBhcnNlZC1cbiAgICAvLyAgICBhdHRyaWJ1dGVzIGNvbnNpc3Qgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmdcbiAgICAvLyAgICAoaW5jbHVkaW5nIHRoZSAleDNCIChcIjtcIikgaW4gcXVlc3Rpb24pLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgICBuYW1lVmFsdWVQYWlyID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoJzsnLCBoZWFkZXIsIHBvc2l0aW9uKVxuICAgIHVucGFyc2VkQXR0cmlidXRlcyA9IGhlYWRlci5zbGljZShwb3NpdGlvbi5wb3NpdGlvbilcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBUaGUgbmFtZS12YWx1ZS1wYWlyIHN0cmluZyBjb25zaXN0cyBvZiBhbGwgdGhlIGNoYXJhY3RlcnNcbiAgICAvLyAgICBjb250YWluZWQgaW4gdGhlIHNldC1jb29raWUtc3RyaW5nLCBhbmQgdGhlIHVucGFyc2VkLVxuICAgIC8vICAgIGF0dHJpYnV0ZXMgaXMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICBuYW1lVmFsdWVQYWlyID0gaGVhZGVyXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgbmFtZS12YWx1ZS1wYWlyIHN0cmluZyBsYWNrcyBhICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXIsIHRoZW5cbiAgLy8gICAgdGhlIG5hbWUgc3RyaW5nIGlzIGVtcHR5LCBhbmQgdGhlIHZhbHVlIHN0cmluZyBpcyB0aGUgdmFsdWUgb2ZcbiAgLy8gICAgbmFtZS12YWx1ZS1wYWlyLlxuICBpZiAoIW5hbWVWYWx1ZVBhaXIuaW5jbHVkZXMoJz0nKSkge1xuICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpclxuICB9IGVsc2Uge1xuICAgIC8vICAgIE90aGVyd2lzZSwgdGhlIG5hbWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIHVwIHRvLCBidXRcbiAgICAvLyAgICBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpIGNoYXJhY3RlciwgYW5kIHRoZSAocG9zc2libHlcbiAgICAvLyAgICBlbXB0eSkgdmFsdWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIGFmdGVyIHRoZSBmaXJzdFxuICAgIC8vICAgICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXIuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cbiAgICBuYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnPScsXG4gICAgICBuYW1lVmFsdWVQYWlyLFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyLnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uICsgMSlcbiAgfVxuXG4gIC8vIDQuIFJlbW92ZSBhbnkgbGVhZGluZyBvciB0cmFpbGluZyBXU1AgY2hhcmFjdGVycyBmcm9tIHRoZSBuYW1lXG4gIC8vICAgIHN0cmluZyBhbmQgdGhlIHZhbHVlIHN0cmluZy5cbiAgbmFtZSA9IG5hbWUudHJpbSgpXG4gIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgLy8gNS4gSWYgdGhlIHN1bSBvZiB0aGUgbGVuZ3RocyBvZiB0aGUgbmFtZSBzdHJpbmcgYW5kIHRoZSB2YWx1ZSBzdHJpbmdcbiAgLy8gICAgaXMgbW9yZSB0aGFuIDQwOTYgb2N0ZXRzLCBhYm9ydCB0aGVzZSBzdGVwcyBhbmQgaWdub3JlIHRoZSBzZXQtXG4gIC8vICAgIGNvb2tpZS1zdHJpbmcgZW50aXJlbHkuXG4gIGlmIChuYW1lLmxlbmd0aCArIHZhbHVlLmxlbmd0aCA+IG1heE5hbWVWYWx1ZVBhaXJTaXplKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDYuIFRoZSBjb29raWUtbmFtZSBpcyB0aGUgbmFtZSBzdHJpbmcsIGFuZCB0aGUgY29va2llLXZhbHVlIGlzIHRoZVxuICAvLyAgICB2YWx1ZSBzdHJpbmcuXG4gIHJldHVybiB7XG4gICAgbmFtZSwgdmFsdWUsIC4uLnBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcylcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgcmVtYWluaW5nIGF0dHJpYnV0ZXMgb2YgYSBzZXQtY29va2llIGhlYWRlclxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40XG4gKiBAcGFyYW0ge3N0cmluZ30gdW5wYXJzZWRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge1tPYmplY3QuPHN0cmluZywgdW5rbm93bj5dPXt9fSBjb29raWVBdHRyaWJ1dGVMaXN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzICh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QgPSB7fSkge1xuICAvLyAxLiBJZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyBzdHJpbmcgaXMgZW1wdHksIHNraXAgdGhlIHJlc3Qgb2ZcbiAgLy8gICAgdGhlc2Ugc3RlcHMuXG4gIGlmICh1bnBhcnNlZEF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvb2tpZUF0dHJpYnV0ZUxpc3RcbiAgfVxuXG4gIC8vIDIuIERpc2NhcmQgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyAod2hpY2hcbiAgLy8gICAgd2lsbCBiZSBhICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXIpLlxuICBhc3NlcnQodW5wYXJzZWRBdHRyaWJ1dGVzWzBdID09PSAnOycpXG4gIHVucGFyc2VkQXR0cmlidXRlcyA9IHVucGFyc2VkQXR0cmlidXRlcy5zbGljZSgxKVxuXG4gIGxldCBjb29raWVBdiA9ICcnXG5cbiAgLy8gMy4gSWYgdGhlIHJlbWFpbmluZyB1bnBhcnNlZC1hdHRyaWJ1dGVzIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpXG4gIC8vICAgIGNoYXJhY3RlcjpcbiAgaWYgKHVucGFyc2VkQXR0cmlidXRlcy5pbmNsdWRlcygnOycpKSB7XG4gICAgLy8gMS4gQ29uc3VtZSB0aGUgY2hhcmFjdGVycyBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyB1cCB0bywgYnV0XG4gICAgLy8gICAgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXIuXG4gICAgY29va2llQXYgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc7JyxcbiAgICAgIHVucGFyc2VkQXR0cmlidXRlcyxcbiAgICAgIHsgcG9zaXRpb246IDAgfVxuICAgIClcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSB1bnBhcnNlZEF0dHJpYnV0ZXMuc2xpY2UoY29va2llQXYubGVuZ3RoKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIENvbnN1bWUgdGhlIHJlbWFpbmRlciBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcy5cbiAgICBjb29raWVBdiA9IHVucGFyc2VkQXR0cmlidXRlc1xuICAgIHVucGFyc2VkQXR0cmlidXRlcyA9ICcnXG4gIH1cblxuICAvLyBMZXQgdGhlIGNvb2tpZS1hdiBzdHJpbmcgYmUgdGhlIGNoYXJhY3RlcnMgY29uc3VtZWQgaW4gdGhpcyBzdGVwLlxuXG4gIGxldCBhdHRyaWJ1dGVOYW1lID0gJydcbiAgbGV0IGF0dHJpYnV0ZVZhbHVlID0gJydcblxuICAvLyA0LiBJZiB0aGUgY29va2llLWF2IHN0cmluZyBjb250YWlucyBhICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXI6XG4gIGlmIChjb29raWVBdi5pbmNsdWRlcygnPScpKSB7XG4gICAgLy8gMS4gVGhlIChwb3NzaWJseSBlbXB0eSkgYXR0cmlidXRlLW5hbWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZVxuICAgIC8vICAgIGNoYXJhY3RlcnMgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpXG4gICAgLy8gICAgY2hhcmFjdGVyLCBhbmQgdGhlIChwb3NzaWJseSBlbXB0eSkgYXR0cmlidXRlLXZhbHVlIHN0cmluZ1xuICAgIC8vICAgIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIGFmdGVyIHRoZSBmaXJzdCAleDNEIChcIj1cIilcbiAgICAvLyAgICBjaGFyYWN0ZXIuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAgIGF0dHJpYnV0ZU5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc9JyxcbiAgICAgIGNvb2tpZUF2LFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gICAgYXR0cmlidXRlVmFsdWUgPSBjb29raWVBdi5zbGljZShwb3NpdGlvbi5wb3NpdGlvbiArIDEpXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gVGhlIGF0dHJpYnV0ZS1uYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgZW50aXJlIGNvb2tpZS1hdlxuICAgIC8vICAgIHN0cmluZywgYW5kIHRoZSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nIGlzIGVtcHR5LlxuICAgIGF0dHJpYnV0ZU5hbWUgPSBjb29raWVBdlxuICB9XG5cbiAgLy8gNS4gUmVtb3ZlIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIFdTUCBjaGFyYWN0ZXJzIGZyb20gdGhlIGF0dHJpYnV0ZS1cbiAgLy8gICAgbmFtZSBzdHJpbmcgYW5kIHRoZSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nLlxuICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZS50cmltKClcbiAgYXR0cmlidXRlVmFsdWUgPSBhdHRyaWJ1dGVWYWx1ZS50cmltKClcblxuICAvLyA2LiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGxvbmdlciB0aGFuIDEwMjQgb2N0ZXRzLCBpZ25vcmUgdGhlXG4gIC8vICAgIGNvb2tpZS1hdiBzdHJpbmcgYW5kIHJldHVybiB0byBTdGVwIDEgb2YgdGhpcyBhbGdvcml0aG0uXG4gIGlmIChhdHRyaWJ1dGVWYWx1ZS5sZW5ndGggPiBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUpIHtcbiAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICB9XG5cbiAgLy8gNy4gUHJvY2VzcyB0aGUgYXR0cmlidXRlLW5hbWUgYW5kIGF0dHJpYnV0ZS12YWx1ZSBhY2NvcmRpbmcgdG8gdGhlXG4gIC8vICAgIHJlcXVpcmVtZW50cyBpbiB0aGUgZm9sbG93aW5nIHN1YnNlY3Rpb25zLiAgKE5vdGljZSB0aGF0XG4gIC8vICAgIGF0dHJpYnV0ZXMgd2l0aCB1bnJlY29nbml6ZWQgYXR0cmlidXRlLW5hbWVzIGFyZSBpZ25vcmVkLilcbiAgY29uc3QgYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuMVxuICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAvLyBcIkV4cGlyZXNcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cbiAgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdleHBpcmVzJykge1xuICAgIC8vIDEuIExldCB0aGUgZXhwaXJ5LXRpbWUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSBhdHRyaWJ1dGUtdmFsdWVcbiAgICAvLyAgICBhcyBjb29raWUtZGF0ZSAoc2VlIFNlY3Rpb24gNS4xLjEpLlxuICAgIGNvbnN0IGV4cGlyeVRpbWUgPSBuZXcgRGF0ZShhdHRyaWJ1dGVWYWx1ZSlcblxuICAgIC8vIDIuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgZmFpbGVkIHRvIHBhcnNlIGFzIGEgY29va2llIGRhdGUsIGlnbm9yZVxuICAgIC8vICAgIHRoZSBjb29raWUtYXYuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LmV4cGlyZXMgPSBleHBpcnlUaW1lXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ21heC1hZ2UnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4yXG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJNYXgtXG4gICAgLy8gQWdlXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90IGEgRElHSVQgb3IgYVxuICAgIC8vICAgIFwiLVwiIGNoYXJhY3RlciwgaWdub3JlIHRoZSBjb29raWUtYXYuXG4gICAgY29uc3QgY2hhckNvZGUgPSBhdHRyaWJ1dGVWYWx1ZS5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoKGNoYXJDb2RlIDwgNDggfHwgY2hhckNvZGUgPiA1NykgJiYgYXR0cmlidXRlVmFsdWVbMF0gIT09ICctJykge1xuICAgICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGUgcmVtYWluZGVyIG9mIGF0dHJpYnV0ZS12YWx1ZSBjb250YWlucyBhIG5vbi1ESUdJVFxuICAgIC8vICAgIGNoYXJhY3RlciwgaWdub3JlIHRoZSBjb29raWUtYXYuXG4gICAgaWYgKCEvXlxcZCskLy50ZXN0KGF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgZGVsdGEtc2Vjb25kcyBiZSB0aGUgYXR0cmlidXRlLXZhbHVlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyLlxuICAgIGNvbnN0IGRlbHRhU2Vjb25kcyA9IE51bWJlcihhdHRyaWJ1dGVWYWx1ZSlcblxuICAgIC8vIDQuIExldCBjb29raWUtYWdlLWxpbWl0IGJlIHRoZSBtYXhpbXVtIGFnZSBvZiB0aGUgY29va2llICh3aGljaFxuICAgIC8vICAgIFNIT1VMRCBiZSA0MDAgZGF5cyBvciBsZXNzLCBzZWUgU2VjdGlvbiA0LjEuMi4yKS5cblxuICAgIC8vIDUuIFNldCBkZWx0YS1zZWNvbmRzIHRvIHRoZSBzbWFsbGVyIG9mIGl0cyBwcmVzZW50IHZhbHVlIGFuZCBjb29raWUtXG4gICAgLy8gICAgYWdlLWxpbWl0LlxuICAgIC8vIGRlbHRhU2Vjb25kcyA9IE1hdGgubWluKGRlbHRhU2Vjb25kcyAqIDEwMDAsIG1heEV4cGlyZXNNcylcblxuICAgIC8vIDYuIElmIGRlbHRhLXNlY29uZHMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gKDApLCBsZXQgZXhwaXJ5LVxuICAgIC8vICAgIHRpbWUgYmUgdGhlIGVhcmxpZXN0IHJlcHJlc2VudGFibGUgZGF0ZSBhbmQgdGltZS4gIE90aGVyd2lzZSwgbGV0XG4gICAgLy8gICAgdGhlIGV4cGlyeS10aW1lIGJlIHRoZSBjdXJyZW50IGRhdGUgYW5kIHRpbWUgcGx1cyBkZWx0YS1zZWNvbmRzXG4gICAgLy8gICAgc2Vjb25kcy5cbiAgICAvLyBjb25zdCBleHBpcnlUaW1lID0gZGVsdGFTZWNvbmRzIDw9IDAgPyBEYXRlLm5vdygpIDogRGF0ZS5ub3coKSArIGRlbHRhU2Vjb25kc1xuXG4gICAgLy8gNy4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBNYXgtQWdlIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgZXhwaXJ5LXRpbWUuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5tYXhBZ2UgPSBkZWx0YVNlY29uZHNcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnZG9tYWluJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuM1xuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiRG9tYWluXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIExldCBjb29raWUtZG9tYWluIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUuXG4gICAgbGV0IGNvb2tpZURvbWFpbiA9IGF0dHJpYnV0ZVZhbHVlXG5cbiAgICAvLyAyLiBJZiBjb29raWUtZG9tYWluIHN0YXJ0cyB3aXRoICV4MkUgKFwiLlwiKSwgbGV0IGNvb2tpZS1kb21haW4gYmVcbiAgICAvLyAgICBjb29raWUtZG9tYWluIHdpdGhvdXQgaXRzIGxlYWRpbmcgJXgyRSAoXCIuXCIpLlxuICAgIGlmIChjb29raWVEb21haW5bMF0gPT09ICcuJykge1xuICAgICAgY29va2llRG9tYWluID0gY29va2llRG9tYWluLnNsaWNlKDEpXG4gICAgfVxuXG4gICAgLy8gMy4gQ29udmVydCB0aGUgY29va2llLWRvbWFpbiB0byBsb3dlciBjYXNlLlxuICAgIGNvb2tpZURvbWFpbiA9IGNvb2tpZURvbWFpbi50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA0LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIERvbWFpbiBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGNvb2tpZS1kb21haW4uXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5kb21haW4gPSBjb29raWVEb21haW5cbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAncGF0aCcpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjRcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlBhdGhcIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuICAgIC8vICAgIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgJXgyRiAoXCIvXCIpOlxuICAgIGxldCBjb29raWVQYXRoID0gJydcbiAgICBpZiAoYXR0cmlidXRlVmFsdWUubGVuZ3RoID09PSAwIHx8IGF0dHJpYnV0ZVZhbHVlWzBdICE9PSAnLycpIHtcbiAgICAgIC8vIDEuIExldCBjb29raWUtcGF0aCBiZSB0aGUgZGVmYXVsdC1wYXRoLlxuICAgICAgY29va2llUGF0aCA9ICcvJ1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDEuIExldCBjb29raWUtcGF0aCBiZSB0aGUgYXR0cmlidXRlLXZhbHVlLlxuICAgICAgY29va2llUGF0aCA9IGF0dHJpYnV0ZVZhbHVlXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBQYXRoIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgY29va2llLXBhdGguXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5wYXRoID0gY29va2llUGF0aFxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdzZWN1cmUnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC41XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJTZWN1cmVcIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdFxuICAgIC8vIHdpdGggYW4gYXR0cmlidXRlLW5hbWUgb2YgU2VjdXJlIGFuZCBhbiBlbXB0eSBhdHRyaWJ1dGUtdmFsdWUuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnNlY3VyZSA9IHRydWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnaHR0cG9ubHknKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC42XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgICAvLyBcIkh0dHBPbmx5XCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgYXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLVxuICAgIC8vIGF0dHJpYnV0ZS1saXN0IHdpdGggYW4gYXR0cmlidXRlLW5hbWUgb2YgSHR0cE9ubHkgYW5kIGFuIGVtcHR5XG4gICAgLy8gYXR0cmlidXRlLXZhbHVlLlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5odHRwT25seSA9IHRydWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnc2FtZXNpdGUnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC43XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgICAvLyBcIlNhbWVTaXRlXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3M6XG5cbiAgICAvLyAxLiBMZXQgZW5mb3JjZW1lbnQgYmUgXCJEZWZhdWx0XCIuXG4gICAgbGV0IGVuZm9yY2VtZW50ID0gJ0RlZmF1bHQnXG5cbiAgICBjb25zdCBhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZSA9IGF0dHJpYnV0ZVZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAvLyAyLiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiTm9uZVwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJOb25lXCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdub25lJykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ05vbmUnXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIlN0cmljdFwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJTdHJpY3RcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ3N0cmljdCcpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdTdHJpY3QnXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIkxheFwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJMYXhcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ2xheCcpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdMYXgnXG4gICAgfVxuXG4gICAgLy8gNS4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBcIlNhbWVTaXRlXCIgYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZlxuICAgIC8vICAgIGVuZm9yY2VtZW50LlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3Quc2FtZVNpdGUgPSBlbmZvcmNlbWVudFxuICB9IGVsc2Uge1xuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QudW5wYXJzZWQgPz89IFtdXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnVucGFyc2VkLnB1c2goYCR7YXR0cmlidXRlTmFtZX09JHthdHRyaWJ1dGVWYWx1ZX1gKVxuICB9XG5cbiAgLy8gOC4gUmV0dXJuIHRvIFN0ZXAgMSBvZiB0aGlzIGFsZ29yaXRobS5cbiAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlU2V0Q29va2llLFxuICBwYXJzZVVucGFyc2VkQXR0cmlidXRlc1xufVxuIl0sIm5hbWVzIjpbIm1heE5hbWVWYWx1ZVBhaXJTaXplIiwibWF4QXR0cmlidXRlVmFsdWVTaXplIiwicmVxdWlyZSIsImlzQ1RMRXhjbHVkaW5nSHRhYiIsImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IiwiYXNzZXJ0IiwicGFyc2VTZXRDb29raWUiLCJoZWFkZXIiLCJuYW1lVmFsdWVQYWlyIiwidW5wYXJzZWRBdHRyaWJ1dGVzIiwibmFtZSIsInZhbHVlIiwiaW5jbHVkZXMiLCJwb3NpdGlvbiIsInNsaWNlIiwidHJpbSIsImxlbmd0aCIsInBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzIiwiY29va2llQXR0cmlidXRlTGlzdCIsImNvb2tpZUF2IiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVZhbHVlIiwiYXR0cmlidXRlTmFtZUxvd2VyY2FzZSIsInRvTG93ZXJDYXNlIiwiZXhwaXJ5VGltZSIsIkRhdGUiLCJleHBpcmVzIiwiY2hhckNvZGUiLCJjaGFyQ29kZUF0IiwidGVzdCIsImRlbHRhU2Vjb25kcyIsIk51bWJlciIsIm1heEFnZSIsImNvb2tpZURvbWFpbiIsImRvbWFpbiIsImNvb2tpZVBhdGgiLCJwYXRoIiwic2VjdXJlIiwiaHR0cE9ubHkiLCJlbmZvcmNlbWVudCIsImF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlIiwic2FtZVNpdGUiLCJ1bnBhcnNlZCIsInB1c2giLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/util.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n/**\n * @param {string} value\n * @returns {boolean}\n */ function isCTLExcludingHtab(value) {\n    for(let i = 0; i < value.length; ++i){\n        const code = value.charCodeAt(i);\n        if (code >= 0x00 && code <= 0x08 || code >= 0x0A && code <= 0x1F || code === 0x7F) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */ function validateCookieName(name) {\n    for(let i = 0; i < name.length; ++i){\n        const code = name.charCodeAt(i);\n        if (code < 0x21 || // exclude CTLs (0-31), SP and HT\n        code > 0x7E || // exclude non-ascii and DEL\n        code === 0x22 || // \"\n        code === 0x28 || // (\n        code === 0x29 || // )\n        code === 0x3C || // <\n        code === 0x3E || // >\n        code === 0x40 || // @\n        code === 0x2C || // ,\n        code === 0x3B || // ;\n        code === 0x3A || // :\n        code === 0x5C || // \\\n        code === 0x2F || // /\n        code === 0x5B || // [\n        code === 0x5D || // ]\n        code === 0x3F || // ?\n        code === 0x3D || // =\n        code === 0x7B || // {\n        code === 0x7D // }\n        ) {\n            throw new Error('Invalid cookie name');\n        }\n    }\n}\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */ function validateCookieValue(value) {\n    let len = value.length;\n    let i = 0;\n    // if the value is wrapped in DQUOTE\n    if (value[0] === '\"') {\n        if (len === 1 || value[len - 1] !== '\"') {\n            throw new Error('Invalid cookie value');\n        }\n        --len;\n        ++i;\n    }\n    while(i < len){\n        const code = value.charCodeAt(i++);\n        if (code < 0x21 || // exclude CTLs (0-31)\n        code > 0x7E || // non-ascii and DEL (127)\n        code === 0x22 || // \"\n        code === 0x2C || // ,\n        code === 0x3B || // ;\n        code === 0x5C // \\\n        ) {\n            throw new Error('Invalid cookie value');\n        }\n    }\n}\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */ function validateCookiePath(path) {\n    for(let i = 0; i < path.length; ++i){\n        const code = path.charCodeAt(i);\n        if (code < 0x20 || // exclude CTLs (0-31)\n        code === 0x7F || // DEL\n        code === 0x3B // ;\n        ) {\n            throw new Error('Invalid cookie path');\n        }\n    }\n}\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */ function validateCookieDomain(domain) {\n    if (domain.startsWith('-') || domain.endsWith('.') || domain.endsWith('-')) {\n        throw new Error('Invalid cookie domain');\n    }\n}\nconst IMFDays = [\n    'Sun',\n    'Mon',\n    'Tue',\n    'Wed',\n    'Thu',\n    'Fri',\n    'Sat'\n];\nconst IMFMonths = [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec'\n];\nconst IMFPaddedNumbers = Array(61).fill(0).map((_, i)=>i.toString().padStart(2, '0'));\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */ function toIMFDate(date) {\n    if (typeof date === 'number') {\n        date = new Date(date);\n    }\n    return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;\n}\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */ function validateCookieMaxAge(maxAge) {\n    if (maxAge < 0) {\n        throw new Error('Invalid cookie max-age');\n    }\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */ function stringify(cookie) {\n    if (cookie.name.length === 0) {\n        return null;\n    }\n    validateCookieName(cookie.name);\n    validateCookieValue(cookie.value);\n    const out = [\n        `${cookie.name}=${cookie.value}`\n    ];\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n    if (cookie.name.startsWith('__Secure-')) {\n        cookie.secure = true;\n    }\n    if (cookie.name.startsWith('__Host-')) {\n        cookie.secure = true;\n        cookie.domain = null;\n        cookie.path = '/';\n    }\n    if (cookie.secure) {\n        out.push('Secure');\n    }\n    if (cookie.httpOnly) {\n        out.push('HttpOnly');\n    }\n    if (typeof cookie.maxAge === 'number') {\n        validateCookieMaxAge(cookie.maxAge);\n        out.push(`Max-Age=${cookie.maxAge}`);\n    }\n    if (cookie.domain) {\n        validateCookieDomain(cookie.domain);\n        out.push(`Domain=${cookie.domain}`);\n    }\n    if (cookie.path) {\n        validateCookiePath(cookie.path);\n        out.push(`Path=${cookie.path}`);\n    }\n    if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {\n        out.push(`Expires=${toIMFDate(cookie.expires)}`);\n    }\n    if (cookie.sameSite) {\n        out.push(`SameSite=${cookie.sameSite}`);\n    }\n    for (const part of cookie.unparsed){\n        if (!part.includes('=')) {\n            throw new Error('Invalid unparsed');\n        }\n        const [key, ...value] = part.split('=');\n        out.push(`${key.trim()}=${value.join('=')}`);\n    }\n    return out.join('; ');\n}\nmodule.exports = {\n    isCTLExcludingHtab,\n    validateCookieName,\n    validateCookiePath,\n    validateCookieValue,\n    toIMFDate,\n    stringify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0EsbUJBQW9CQyxLQUFLO0lBQ2hDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUNyQyxNQUFNRSxPQUFPSCxNQUFNSSxVQUFVLENBQUNIO1FBRTlCLElBQ0UsUUFBUyxRQUFRRSxRQUFRLFFBQ3hCQSxRQUFRLFFBQVFBLFFBQVEsUUFDekJBLFNBQVMsTUFDVDtZQUNBLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRSxtQkFBb0JDLElBQUk7SUFDL0IsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUlLLEtBQUtKLE1BQU0sRUFBRSxFQUFFRCxFQUFHO1FBQ3BDLE1BQU1FLE9BQU9HLEtBQUtGLFVBQVUsQ0FBQ0g7UUFFN0IsSUFDRUUsT0FBTyxRQUFRLGlDQUFpQztRQUNoREEsT0FBTyxRQUFRLDRCQUE0QjtRQUMzQ0EsU0FBUyxRQUFRLElBQUk7UUFDckJBLFNBQVMsUUFBUSxJQUFJO1FBQ3JCQSxTQUFTLFFBQVEsSUFBSTtRQUNyQkEsU0FBUyxRQUFRLElBQUk7UUFDckJBLFNBQVMsUUFBUSxJQUFJO1FBQ3JCQSxTQUFTLFFBQVEsSUFBSTtRQUNyQkEsU0FBUyxRQUFRLElBQUk7UUFDckJBLFNBQVMsUUFBUSxJQUFJO1FBQ3JCQSxTQUFTLFFBQVEsSUFBSTtRQUNyQkEsU0FBUyxRQUFRLElBQUk7UUFDckJBLFNBQVMsUUFBUSxJQUFJO1FBQ3JCQSxTQUFTLFFBQVEsSUFBSTtRQUNyQkEsU0FBUyxRQUFRLElBQUk7UUFDckJBLFNBQVMsUUFBUSxJQUFJO1FBQ3JCQSxTQUFTLFFBQVEsSUFBSTtRQUNyQkEsU0FBUyxRQUFRLElBQUk7UUFDckJBLFNBQVMsS0FBSyxJQUFJO1VBQ2xCO1lBQ0Es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LElBQUlFLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRWhCLFVBQVVhLE9BQU9LLE9BQU8sR0FBRztJQUNqRDtJQUVBLElBQUlMLE9BQU9NLFFBQVEsRUFBRTtRQUNuQkwsSUFBSUUsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFSCxPQUFPTSxRQUFRLEVBQUU7SUFDeEM7SUFFQSxLQUFLLE1BQU1DLFFBQVFQLE9BQU9RLFFBQVEsQ0FBRTtRQUNsQyxJQUFJLENBQUNELEtBQUtFLFFBQVEsQ0FBQyxNQUFNO1lBQ3ZCLE1BQU0sSUFBSXhDLE1BQU07UUFDbEI7UUFFQSxNQUFNLENBQUN5QyxLQUFLLEdBQUdoRCxNQUFNLEdBQUc2QyxLQUFLSSxLQUFLLENBQUM7UUFFbkNWLElBQUlFLElBQUksQ0FBQyxHQUFHTyxJQUFJRSxJQUFJLEdBQUcsQ0FBQyxFQUFFbEQsTUFBTW1ELElBQUksQ0FBQyxNQUFNO0lBQzdDO0lBRUEsT0FBT1osSUFBSVksSUFBSSxDQUFDO0FBQ2xCO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUNmdEQ7SUFDQU07SUFDQUs7SUFDQUY7SUFDQWlCO0lBQ0FZO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjb29raWVzXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ1RMRXhjbHVkaW5nSHRhYiAodmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoXG4gICAgICAoY29kZSA+PSAweDAwICYmIGNvZGUgPD0gMHgwOCkgfHxcbiAgICAgIChjb2RlID49IDB4MEEgJiYgY29kZSA8PSAweDFGKSB8fFxuICAgICAgY29kZSA9PT0gMHg3RlxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuIENIQVIgICAgICAgICAgID0gPGFueSBVUy1BU0NJSSBjaGFyYWN0ZXIgKG9jdGV0cyAwIC0gMTI3KT5cbiB0b2tlbiAgICAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gc2VwYXJhdG9ycyAgICAgPSBcIihcIiB8IFwiKVwiIHwgXCI8XCIgfCBcIj5cIiB8IFwiQFwiXG4gICAgICAgICAgICAgICAgfCBcIixcIiB8IFwiO1wiIHwgXCI6XCIgfCBcIlxcXCIgfCA8XCI+XG4gICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gICAgICAgICAgICAgICAgfCBcIntcIiB8IFwifVwiIHwgU1AgfCBIVFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVOYW1lIChuYW1lKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBuYW1lLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIxIHx8IC8vIGV4Y2x1ZGUgQ1RMcyAoMC0zMSksIFNQIGFuZCBIVFxuICAgICAgY29kZSA+IDB4N0UgfHwgLy8gZXhjbHVkZSBub24tYXNjaWkgYW5kIERFTFxuICAgICAgY29kZSA9PT0gMHgyMiB8fCAvLyBcIlxuICAgICAgY29kZSA9PT0gMHgyOCB8fCAvLyAoXG4gICAgICBjb2RlID09PSAweDI5IHx8IC8vIClcbiAgICAgIGNvZGUgPT09IDB4M0MgfHwgLy8gPFxuICAgICAgY29kZSA9PT0gMHgzRSB8fCAvLyA+XG4gICAgICBjb2RlID09PSAweDQwIHx8IC8vIEBcbiAgICAgIGNvZGUgPT09IDB4MkMgfHwgLy8gLFxuICAgICAgY29kZSA9PT0gMHgzQiB8fCAvLyA7XG4gICAgICBjb2RlID09PSAweDNBIHx8IC8vIDpcbiAgICAgIGNvZGUgPT09IDB4NUMgfHwgLy8gXFxcbiAgICAgIGNvZGUgPT09IDB4MkYgfHwgLy8gL1xuICAgICAgY29kZSA9PT0gMHg1QiB8fCAvLyBbXG4gICAgICBjb2RlID09PSAweDVEIHx8IC8vIF1cbiAgICAgIGNvZGUgPT09IDB4M0YgfHwgLy8gP1xuICAgICAgY29kZSA9PT0gMHgzRCB8fCAvLyA9XG4gICAgICBjb2RlID09PSAweDdCIHx8IC8vIHtcbiAgICAgIGNvZGUgPT09IDB4N0QgLy8gfVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBuYW1lJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gY29va2llLXZhbHVlICAgICAgPSAqY29va2llLW9jdGV0IC8gKCBEUVVPVEUgKmNvb2tpZS1vY3RldCBEUVVPVEUgKVxuIGNvb2tpZS1vY3RldCAgICAgID0gJXgyMSAvICV4MjMtMkIgLyAleDJELTNBIC8gJXgzQy01QiAvICV4NUQtN0VcbiAgICAgICAgICAgICAgICAgICAgICAgOyBVUy1BU0NJSSBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBDVExzLFxuICAgICAgICAgICAgICAgICAgICAgICA7IHdoaXRlc3BhY2UgRFFVT1RFLCBjb21tYSwgc2VtaWNvbG9uLFxuICAgICAgICAgICAgICAgICAgICAgICA7IGFuZCBiYWNrc2xhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZVZhbHVlICh2YWx1ZSkge1xuICBsZXQgbGVuID0gdmFsdWUubGVuZ3RoXG4gIGxldCBpID0gMFxuXG4gIC8vIGlmIHRoZSB2YWx1ZSBpcyB3cmFwcGVkIGluIERRVU9URVxuICBpZiAodmFsdWVbMF0gPT09ICdcIicpIHtcbiAgICBpZiAobGVuID09PSAxIHx8IHZhbHVlW2xlbiAtIDFdICE9PSAnXCInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIHZhbHVlJylcbiAgICB9XG4gICAgLS1sZW5cbiAgICArK2lcbiAgfVxuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgY29uc3QgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHwgLy8gZXhjbHVkZSBDVExzICgwLTMxKVxuICAgICAgY29kZSA+IDB4N0UgfHwgLy8gbm9uLWFzY2lpIGFuZCBERUwgKDEyNylcbiAgICAgIGNvZGUgPT09IDB4MjIgfHwgLy8gXCJcbiAgICAgIGNvZGUgPT09IDB4MkMgfHwgLy8gLFxuICAgICAgY29kZSA9PT0gMHgzQiB8fCAvLyA7XG4gICAgICBjb2RlID09PSAweDVDIC8vIFxcXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIHZhbHVlJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBwYXRoLXZhbHVlICAgICAgICA9IDxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBcIjtcIj5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llUGF0aCAocGF0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMCB8fCAvLyBleGNsdWRlIENUTHMgKDAtMzEpXG4gICAgICBjb2RlID09PSAweDdGIHx8IC8vIERFTFxuICAgICAgY29kZSA9PT0gMHgzQiAvLyA7XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIHBhdGgnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEkgaGF2ZSBubyBpZGVhIHdoeSB0aGVzZSB2YWx1ZXMgYXJlbid0IGFsbG93ZWQgdG8gYmUgaG9uZXN0LFxuICogYnV0IERlbm8gdGVzdHMgdGhlc2UuIC0gS2hhZnJhXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llRG9tYWluIChkb21haW4pIHtcbiAgaWYgKFxuICAgIGRvbWFpbi5zdGFydHNXaXRoKCctJykgfHxcbiAgICBkb21haW4uZW5kc1dpdGgoJy4nKSB8fFxuICAgIGRvbWFpbi5lbmRzV2l0aCgnLScpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgZG9tYWluJylcbiAgfVxufVxuXG5jb25zdCBJTUZEYXlzID0gW1xuICAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJyxcbiAgJ1RodScsICdGcmknLCAnU2F0J1xuXVxuXG5jb25zdCBJTUZNb250aHMgPSBbXG4gICdKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsXG4gICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYydcbl1cblxuY29uc3QgSU1GUGFkZGVkTnVtYmVycyA9IEFycmF5KDYxKS5maWxsKDApLm1hcCgoXywgaSkgPT4gaS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJykpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMSNzZWN0aW9uLTcuMS4xLjFcbiAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGRhdGVcbiAgSU1GLWZpeGRhdGUgID0gZGF5LW5hbWUgXCIsXCIgU1AgZGF0ZTEgU1AgdGltZS1vZi1kYXkgU1AgR01UXG4gIDsgZml4ZWQgbGVuZ3RoL3pvbmUvY2FwaXRhbGl6YXRpb24gc3Vic2V0IG9mIHRoZSBmb3JtYXRcbiAgOyBzZWUgU2VjdGlvbiAzLjMgb2YgW1JGQzUzMjJdXG5cbiAgZGF5LW5hbWUgICAgID0gJXg0RC42Ri42RSA7IFwiTW9uXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1NC43NS42NSA7IFwiVHVlXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1Ny42NS42NCA7IFwiV2VkXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1NC42OC43NSA7IFwiVGh1XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ni43Mi42OSA7IFwiRnJpXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My42MS43NCA7IFwiU2F0XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My43NS42RSA7IFwiU3VuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gIGRhdGUxICAgICAgICA9IGRheSBTUCBtb250aCBTUCB5ZWFyXG4gICAgICAgICAgICAgICAgICA7IGUuZy4sIDAyIEp1biAxOTgyXG5cbiAgZGF5ICAgICAgICAgID0gMkRJR0lUXG4gIG1vbnRoICAgICAgICA9ICV4NEEuNjEuNkUgOyBcIkphblwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDYuNjUuNjIgOyBcIkZlYlwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEQuNjEuNzIgOyBcIk1hclwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDEuNzAuNzIgOyBcIkFwclwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEQuNjEuNzkgOyBcIk1heVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEEuNzUuNkUgOyBcIkp1blwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEEuNzUuNkMgOyBcIkp1bFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDEuNzUuNjcgOyBcIkF1Z1wiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTMuNjUuNzAgOyBcIlNlcFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEYuNjMuNzQgOyBcIk9jdFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEUuNkYuNzYgOyBcIk5vdlwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDQuNjUuNjMgOyBcIkRlY1wiLCBjYXNlLXNlbnNpdGl2ZVxuICB5ZWFyICAgICAgICAgPSA0RElHSVRcblxuICBHTVQgICAgICAgICAgPSAleDQ3LjRELjU0IDsgXCJHTVRcIiwgY2FzZS1zZW5zaXRpdmVcblxuICB0aW1lLW9mLWRheSAgPSBob3VyIFwiOlwiIG1pbnV0ZSBcIjpcIiBzZWNvbmRcbiAgICAgICAgICAgICAgOyAwMDowMDowMCAtIDIzOjU5OjYwIChsZWFwIHNlY29uZClcblxuICBob3VyICAgICAgICAgPSAyRElHSVRcbiAgbWludXRlICAgICAgID0gMkRJR0lUXG4gIHNlY29uZCAgICAgICA9IDJESUdJVFxuICovXG5mdW5jdGlvbiB0b0lNRkRhdGUgKGRhdGUpIHtcbiAgaWYgKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKVxuICB9XG5cbiAgcmV0dXJuIGAke0lNRkRheXNbZGF0ZS5nZXRVVENEYXkoKV19LCAke0lNRlBhZGRlZE51bWJlcnNbZGF0ZS5nZXRVVENEYXRlKCldfSAke0lNRk1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldfSAke2RhdGUuZ2V0VVRDRnVsbFllYXIoKX0gJHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDSG91cnMoKV19OiR7SU1GUGFkZGVkTnVtYmVyc1tkYXRlLmdldFVUQ01pbnV0ZXMoKV19OiR7SU1GUGFkZGVkTnVtYmVyc1tkYXRlLmdldFVUQ1NlY29uZHMoKV19IEdNVGBcbn1cblxuLyoqXG4gbWF4LWFnZS1hdiAgICAgICAgPSBcIk1heC1BZ2U9XCIgbm9uLXplcm8tZGlnaXQgKkRJR0lUXG4gICAgICAgICAgICAgICAgICAgICAgIDsgSW4gcHJhY3RpY2UsIGJvdGggZXhwaXJlcy1hdiBhbmQgbWF4LWFnZS1hdlxuICAgICAgICAgICAgICAgICAgICAgICA7IGFyZSBsaW1pdGVkIHRvIGRhdGVzIHJlcHJlc2VudGFibGUgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgIDsgdXNlciBhZ2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBZ2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVNYXhBZ2UgKG1heEFnZSkge1xuICBpZiAobWF4QWdlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgbWF4LWFnZScpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2MjY1I3NlY3Rpb24tNC4xLjFcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuQ29va2llfSBjb29raWVcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5IChjb29raWUpIHtcbiAgaWYgKGNvb2tpZS5uYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YWxpZGF0ZUNvb2tpZU5hbWUoY29va2llLm5hbWUpXG4gIHZhbGlkYXRlQ29va2llVmFsdWUoY29va2llLnZhbHVlKVxuXG4gIGNvbnN0IG91dCA9IFtgJHtjb29raWUubmFtZX09JHtjb29raWUudmFsdWV9YF1cblxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1jb29raWUtcHJlZml4ZXMtMDAjc2VjdGlvbi0zLjFcbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtY29va2llLXByZWZpeGVzLTAwI3NlY3Rpb24tMy4yXG4gIGlmIChjb29raWUubmFtZS5zdGFydHNXaXRoKCdfX1NlY3VyZS0nKSkge1xuICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlXG4gIH1cblxuICBpZiAoY29va2llLm5hbWUuc3RhcnRzV2l0aCgnX19Ib3N0LScpKSB7XG4gICAgY29va2llLnNlY3VyZSA9IHRydWVcbiAgICBjb29raWUuZG9tYWluID0gbnVsbFxuICAgIGNvb2tpZS5wYXRoID0gJy8nXG4gIH1cblxuICBpZiAoY29va2llLnNlY3VyZSkge1xuICAgIG91dC5wdXNoKCdTZWN1cmUnKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5odHRwT25seSkge1xuICAgIG91dC5wdXNoKCdIdHRwT25seScpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvb2tpZS5tYXhBZ2UgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVDb29raWVNYXhBZ2UoY29va2llLm1heEFnZSlcbiAgICBvdXQucHVzaChgTWF4LUFnZT0ke2Nvb2tpZS5tYXhBZ2V9YClcbiAgfVxuXG4gIGlmIChjb29raWUuZG9tYWluKSB7XG4gICAgdmFsaWRhdGVDb29raWVEb21haW4oY29va2llLmRvbWFpbilcbiAgICBvdXQucHVzaChgRG9tYWluPSR7Y29va2llLmRvbWFpbn1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5wYXRoKSB7XG4gICAgdmFsaWRhdGVDb29raWVQYXRoKGNvb2tpZS5wYXRoKVxuICAgIG91dC5wdXNoKGBQYXRoPSR7Y29va2llLnBhdGh9YClcbiAgfVxuXG4gIGlmIChjb29raWUuZXhwaXJlcyAmJiBjb29raWUuZXhwaXJlcy50b1N0cmluZygpICE9PSAnSW52YWxpZCBEYXRlJykge1xuICAgIG91dC5wdXNoKGBFeHBpcmVzPSR7dG9JTUZEYXRlKGNvb2tpZS5leHBpcmVzKX1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5zYW1lU2l0ZSkge1xuICAgIG91dC5wdXNoKGBTYW1lU2l0ZT0ke2Nvb2tpZS5zYW1lU2l0ZX1gKVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIGNvb2tpZS51bnBhcnNlZCkge1xuICAgIGlmICghcGFydC5pbmNsdWRlcygnPScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5wYXJzZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IFtrZXksIC4uLnZhbHVlXSA9IHBhcnQuc3BsaXQoJz0nKVxuXG4gICAgb3V0LnB1c2goYCR7a2V5LnRyaW0oKX09JHt2YWx1ZS5qb2luKCc9Jyl9YClcbiAgfVxuXG4gIHJldHVybiBvdXQuam9pbignOyAnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNDVExFeGNsdWRpbmdIdGFiLFxuICB2YWxpZGF0ZUNvb2tpZU5hbWUsXG4gIHZhbGlkYXRlQ29va2llUGF0aCxcbiAgdmFsaWRhdGVDb29raWVWYWx1ZSxcbiAgdG9JTUZEYXRlLFxuICBzdHJpbmdpZnlcbn1cbiJdLCJuYW1lcyI6WyJpc0NUTEV4Y2x1ZGluZ0h0YWIiLCJ2YWx1ZSIsImkiLCJsZW5ndGgiLCJjb2RlIiwiY2hhckNvZGVBdCIsInZhbGlkYXRlQ29va2llTmFtZSIsIm5hbWUiLCJFcnJvciIsInZhbGlkYXRlQ29va2llVmFsdWUiLCJsZW4iLCJ2YWxpZGF0ZUNvb2tpZVBhdGgiLCJwYXRoIiwidmFsaWRhdGVDb29raWVEb21haW4iLCJkb21haW4iLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJJTUZEYXlzIiwiSU1GTW9udGhzIiwiSU1GUGFkZGVkTnVtYmVycyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsIl8iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwidG9JTUZEYXRlIiwiZGF0ZSIsIkRhdGUiLCJnZXRVVENEYXkiLCJnZXRVVENEYXRlIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJ2YWxpZGF0ZUNvb2tpZU1heEFnZSIsIm1heEFnZSIsInN0cmluZ2lmeSIsImNvb2tpZSIsIm91dCIsInNlY3VyZSIsInB1c2giLCJodHRwT25seSIsImV4cGlyZXMiLCJzYW1lU2l0ZSIsInBhcnQiLCJ1bnBhcnNlZCIsImluY2x1ZGVzIiwia2V5Iiwic3BsaXQiLCJ0cmltIiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource-stream.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { isASCIINumber, isValidLastEventId } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/eventsource/util.js\");\n/**\n * @type {number[]} BOM\n */ const BOM = [\n    0xEF,\n    0xBB,\n    0xBF\n];\n/**\n * @type {10} LF\n */ const LF = 0x0A;\n/**\n * @type {13} CR\n */ const CR = 0x0D;\n/**\n * @type {58} COLON\n */ const COLON = 0x3A;\n/**\n * @type {32} SPACE\n */ const SPACE = 0x20;\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */ /**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} lastEventId The last event ID received from the server.\n * @property {string} origin The origin of the event source.\n * @property {number} reconnectionTime The reconnection time, in milliseconds.\n */ class EventSourceStream extends Transform {\n    /**\n   * @param {object} options\n   * @param {eventSourceSettings} options.eventSourceSettings\n   * @param {Function} [options.push]\n   */ constructor(options = {}){\n        // Enable object mode as EventSourceStream emits objects of shape\n        // EventSourceStreamEvent\n        options.readableObjectMode = true;\n        super(options), /**\n   * @type {eventSourceSettings}\n   */ this.state = null, /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */ this.checkBOM = true, /**\n   * @type {boolean}\n   */ this.crlfCheck = false, /**\n   * @type {boolean}\n   */ this.eventEndCheck = false, /**\n   * @type {Buffer}\n   */ this.buffer = null, this.pos = 0, this.event = {\n            data: undefined,\n            event: undefined,\n            id: undefined,\n            retry: undefined\n        };\n        this.state = options.eventSourceSettings || {};\n        if (options.push) {\n            this.push = options.push;\n        }\n    }\n    /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */ _transform(chunk, _encoding, callback) {\n        if (chunk.length === 0) {\n            callback();\n            return;\n        }\n        // Cache the chunk in the buffer, as the data might not be complete while\n        // processing it\n        // TODO: Investigate if there is a more performant way to handle\n        // incoming chunks\n        // see: https://github.com/nodejs/undici/issues/2630\n        if (this.buffer) {\n            this.buffer = Buffer.concat([\n                this.buffer,\n                chunk\n            ]);\n        } else {\n            this.buffer = chunk;\n        }\n        // Strip leading byte-order-mark if we opened the stream and started\n        // the processing of the incoming data\n        if (this.checkBOM) {\n            switch(this.buffer.length){\n                case 1:\n                    // Check if the first byte is the same as the first byte of the BOM\n                    if (this.buffer[0] === BOM[0]) {\n                        // If it is, we need to wait for more data\n                        callback();\n                        return;\n                    }\n                    // Set the checkBOM flag to false as we don't need to check for the\n                    // BOM anymore\n                    this.checkBOM = false;\n                    // The buffer only contains one byte so we need to wait for more data\n                    callback();\n                    return;\n                case 2:\n                    // Check if the first two bytes are the same as the first two bytes\n                    // of the BOM\n                    if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {\n                        // If it is, we need to wait for more data, because the third byte\n                        // is needed to determine if it is the BOM or not\n                        callback();\n                        return;\n                    }\n                    // Set the checkBOM flag to false as we don't need to check for the\n                    // BOM anymore\n                    this.checkBOM = false;\n                    break;\n                case 3:\n                    // Check if the first three bytes are the same as the first three\n                    // bytes of the BOM\n                    if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {\n                        // If it is, we can drop the buffered data, as it is only the BOM\n                        this.buffer = Buffer.alloc(0);\n                        // Set the checkBOM flag to false as we don't need to check for the\n                        // BOM anymore\n                        this.checkBOM = false;\n                        // Await more data\n                        callback();\n                        return;\n                    }\n                    // If it is not the BOM, we can start processing the data\n                    this.checkBOM = false;\n                    break;\n                default:\n                    // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n                    // present\n                    if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {\n                        // Remove the BOM from the buffer\n                        this.buffer = this.buffer.subarray(3);\n                    }\n                    // Set the checkBOM flag to false as we don't need to check for the\n                    this.checkBOM = false;\n                    break;\n            }\n        }\n        while(this.pos < this.buffer.length){\n            // If the previous line ended with an end-of-line, we need to check\n            // if the next character is also an end-of-line.\n            if (this.eventEndCheck) {\n                // If the the current character is an end-of-line, then the event\n                // is finished and we can process it\n                // If the previous line ended with a carriage return, we need to\n                // check if the current character is a line feed and remove it\n                // from the buffer.\n                if (this.crlfCheck) {\n                    // If the current character is a line feed, we can remove it\n                    // from the buffer and reset the crlfCheck flag\n                    if (this.buffer[this.pos] === LF) {\n                        this.buffer = this.buffer.subarray(this.pos + 1);\n                        this.pos = 0;\n                        this.crlfCheck = false;\n                        continue;\n                    }\n                    this.crlfCheck = false;\n                }\n                if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n                    // If the current character is a carriage return, we need to\n                    // set the crlfCheck flag to true, as we need to check if the\n                    // next character is a line feed so we can remove it from the\n                    // buffer\n                    if (this.buffer[this.pos] === CR) {\n                        this.crlfCheck = true;\n                    }\n                    this.buffer = this.buffer.subarray(this.pos + 1);\n                    this.pos = 0;\n                    if (this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {\n                        this.processEvent(this.event);\n                    }\n                    this.clearEvent();\n                    continue;\n                }\n                // If the current character is not an end-of-line, then the event\n                // is not finished and we have to reset the eventEndCheck flag\n                this.eventEndCheck = false;\n                continue;\n            }\n            // If the current character is an end-of-line, we can process the\n            // line\n            if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n                // If the current character is a carriage return, we need to\n                // set the crlfCheck flag to true, as we need to check if the\n                // next character is a line feed\n                if (this.buffer[this.pos] === CR) {\n                    this.crlfCheck = true;\n                }\n                // In any case, we can process the line as we reached an\n                // end-of-line character\n                this.parseLine(this.buffer.subarray(0, this.pos), this.event);\n                // Remove the processed line from the buffer\n                this.buffer = this.buffer.subarray(this.pos + 1);\n                // Reset the position as we removed the processed line from the buffer\n                this.pos = 0;\n                // A line was processed and this could be the end of the event. We need\n                // to check if the next line is empty to determine if the event is\n                // finished.\n                this.eventEndCheck = true;\n                continue;\n            }\n            this.pos++;\n        }\n        callback();\n    }\n    /**\n   * @param {Buffer} line\n   * @param {EventStreamEvent} event\n   */ parseLine(line, event) {\n        // If the line is empty (a blank line)\n        // Dispatch the event, as defined below.\n        // This will be handled in the _transform method\n        if (line.length === 0) {\n            return;\n        }\n        // If the line starts with a U+003A COLON character (:)\n        // Ignore the line.\n        const colonPosition = line.indexOf(COLON);\n        if (colonPosition === 0) {\n            return;\n        }\n        let field = '';\n        let value = '';\n        // If the line contains a U+003A COLON character (:)\n        if (colonPosition !== -1) {\n            // Collect the characters on the line before the first U+003A COLON\n            // character (:), and let field be that string.\n            // TODO: Investigate if there is a more performant way to extract the\n            // field\n            // see: https://github.com/nodejs/undici/issues/2630\n            field = line.subarray(0, colonPosition).toString('utf8');\n            // Collect the characters on the line after the first U+003A COLON\n            // character (:), and let value be that string.\n            // If value starts with a U+0020 SPACE character, remove it from value.\n            let valueStart = colonPosition + 1;\n            if (line[valueStart] === SPACE) {\n                ++valueStart;\n            }\n            // TODO: Investigate if there is a more performant way to extract the\n            // value\n            // see: https://github.com/nodejs/undici/issues/2630\n            value = line.subarray(valueStart).toString('utf8');\n        // Otherwise, the string is not empty but does not contain a U+003A COLON\n        // character (:)\n        } else {\n            // Process the field using the steps described below, using the whole\n            // line as the field name, and the empty string as the field value.\n            field = line.toString('utf8');\n            value = '';\n        }\n        // Modify the event with the field name and value. The value is also\n        // decoded as UTF-8\n        switch(field){\n            case 'data':\n                if (event[field] === undefined) {\n                    event[field] = value;\n                } else {\n                    event[field] += `\\n${value}`;\n                }\n                break;\n            case 'retry':\n                if (isASCIINumber(value)) {\n                    event[field] = value;\n                }\n                break;\n            case 'id':\n                if (isValidLastEventId(value)) {\n                    event[field] = value;\n                }\n                break;\n            case 'event':\n                if (value.length > 0) {\n                    event[field] = value;\n                }\n                break;\n        }\n    }\n    /**\n   * @param {EventSourceStreamEvent} event\n   */ processEvent(event) {\n        if (event.retry && isASCIINumber(event.retry)) {\n            this.state.reconnectionTime = parseInt(event.retry, 10);\n        }\n        if (event.id && isValidLastEventId(event.id)) {\n            this.state.lastEventId = event.id;\n        }\n        // only dispatch event, when data is provided\n        if (event.data !== undefined) {\n            this.push({\n                type: event.event || 'message',\n                options: {\n                    data: event.data,\n                    lastEventId: this.state.lastEventId,\n                    origin: this.state.origin\n                }\n            });\n        }\n    }\n    clearEvent() {\n        this.event = {\n            data: undefined,\n            event: undefined,\n            id: undefined,\n            retry: undefined\n        };\n    }\n}\nmodule.exports = {\n    EventSourceStream\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2Utc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsTUFBTSxFQUFFQSxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDM0MsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLGtCQUFrQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDLHVFQUFRO0FBRTlEOztDQUVDLEdBQ0QsTUFBTUcsTUFBTTtJQUFDO0lBQU07SUFBTTtDQUFLO0FBQzlCOztDQUVDLEdBQ0QsTUFBTUMsS0FBSztBQUNYOztDQUVDLEdBQ0QsTUFBTUMsS0FBSztBQUNYOztDQUVDLEdBQ0QsTUFBTUMsUUFBUTtBQUNkOztDQUVDLEdBQ0QsTUFBTUMsUUFBUTtBQUVkOzs7Ozs7O0NBT0MsR0FFRDs7Ozs7O0NBTUMsR0FFRCxNQUFNQywwQkFBMEJUO0lBb0M5Qjs7OztHQUlDLEdBQ0QsWUFBYVUsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUN6QixpRUFBaUU7UUFDakUseUJBQXlCO1FBQ3pCQSxRQUFRQyxrQkFBa0IsR0FBRztRQUU3QixLQUFLLENBQUNELFVBN0NSOztHQUVDLFFBQ0RFLFFBQVEsTUFFUjs7O0dBR0MsUUFDREMsV0FBVyxNQUVYOztHQUVDLFFBQ0RDLFlBQVksT0FFWjs7R0FFQyxRQUNEQyxnQkFBZ0IsT0FFaEI7O0dBRUMsUUFDREMsU0FBUyxXQUVUQyxNQUFNLFFBRU5DLFFBQVE7WUFDTkMsTUFBTUM7WUFDTkYsT0FBT0U7WUFDUEMsSUFBSUQ7WUFDSkUsT0FBT0Y7UUFDVDtRQWNFLElBQUksQ0FBQ1IsS0FBSyxHQUFHRixRQUFRYSxtQkFBbUIsSUFBSSxDQUFDO1FBQzdDLElBQUliLFFBQVFjLElBQUksRUFBRTtZQUNoQixJQUFJLENBQUNBLElBQUksR0FBR2QsUUFBUWMsSUFBSTtRQUMxQjtJQUNGO0lBRUE7Ozs7O0dBS0MsR0FDREMsV0FBWUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBRTtRQUN0QyxJQUFJRixNQUFNRyxNQUFNLEtBQUssR0FBRztZQUN0QkQ7WUFDQTtRQUNGO1FBRUEseUVBQXlFO1FBQ3pFLGdCQUFnQjtRQUNoQixnRUFBZ0U7UUFDaEUsa0JBQWtCO1FBQ2xCLG9EQUFvRDtRQUNwRCxJQUFJLElBQUksQ0FBQ1osTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDQSxNQUFNLEdBQUdjLE9BQU9DLE1BQU0sQ0FBQztnQkFBQyxJQUFJLENBQUNmLE1BQU07Z0JBQUVVO2FBQU07UUFDbEQsT0FBTztZQUNMLElBQUksQ0FBQ1YsTUFBTSxHQUFHVTtRQUNoQjtRQUVBLG9FQUFvRTtRQUNwRSxzQ0FBc0M7UUFDdEMsSUFBSSxJQUFJLENBQUNiLFFBQVEsRUFBRTtZQUNqQixPQUFRLElBQUksQ0FBQ0csTUFBTSxDQUFDYSxNQUFNO2dCQUN4QixLQUFLO29CQUNILG1FQUFtRTtvQkFDbkUsSUFBSSxJQUFJLENBQUNiLE1BQU0sQ0FBQyxFQUFFLEtBQUtaLEdBQUcsQ0FBQyxFQUFFLEVBQUU7d0JBQzdCLDBDQUEwQzt3QkFDMUN3Qjt3QkFDQTtvQkFDRjtvQkFDQSxtRUFBbUU7b0JBQ25FLGNBQWM7b0JBQ2QsSUFBSSxDQUFDZixRQUFRLEdBQUc7b0JBRWhCLHFFQUFxRTtvQkFDckVlO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0gsbUVBQW1FO29CQUNuRSxhQUFhO29CQUNiLElBQ0UsSUFBSSxDQUFDWixNQUFNLENBQUMsRUFBRSxLQUFLWixHQUFHLENBQUMsRUFBRSxJQUN6QixJQUFJLENBQUNZLE1BQU0sQ0FBQyxFQUFFLEtBQUtaLEdBQUcsQ0FBQyxFQUFFLEVBQ3pCO3dCQUNBLGtFQUFrRTt3QkFDbEUsaURBQWlEO3dCQUNqRHdCO3dCQUNBO29CQUNGO29CQUVBLG1FQUFtRTtvQkFDbkUsY0FBYztvQkFDZCxJQUFJLENBQUNmLFFBQVEsR0FBRztvQkFDaEI7Z0JBQ0YsS0FBSztvQkFDSCxpRUFBaUU7b0JBQ2pFLG1CQUFtQjtvQkFDbkIsSUFDRSxJQUFJLENBQUNHLE1BQU0sQ0FBQyxFQUFFLEtBQUtaLEdBQUcsQ0FBQyxFQUFFLElBQ3pCLElBQUksQ0FBQ1ksTUFBTSxDQUFDLEVBQUUsS0FBS1osR0FBRyxDQUFDLEVBQUUsSUFDekIsSUFBSSxDQUFDWSxNQUFNLENBQUMsRUFBRSxLQUFLWixHQUFHLENBQUMsRUFBRSxFQUN6Qjt3QkFDQSxpRUFBaUU7d0JBQ2pFLElBQUksQ0FBQ1ksTUFBTSxHQUFHYyxPQUFPRSxLQUFLLENBQUM7d0JBQzNCLG1FQUFtRTt3QkFDbkUsY0FBYzt3QkFDZCxJQUFJLENBQUNuQixRQUFRLEdBQUc7d0JBRWhCLGtCQUFrQjt3QkFDbEJlO3dCQUNBO29CQUNGO29CQUNBLHlEQUF5RDtvQkFDekQsSUFBSSxDQUFDZixRQUFRLEdBQUc7b0JBQ2hCO2dCQUNGO29CQUNFLHFFQUFxRTtvQkFDckUsVUFBVTtvQkFDVixJQUNFLElBQUksQ0FBQ0csTUFBTSxDQUFDLEVBQUUsS0FBS1osR0FBRyxDQUFDLEVBQUUsSUFDekIsSUFBSSxDQUFDWSxNQUFNLENBQUMsRUFBRSxLQUFLWixHQUFHLENBQUMsRUFBRSxJQUN6QixJQUFJLENBQUNZLE1BQU0sQ0FBQyxFQUFFLEtBQUtaLEdBQUcsQ0FBQyxFQUFFLEVBQ3pCO3dCQUNBLGlDQUFpQzt3QkFDakMsSUFBSSxDQUFDWSxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNpQixRQUFRLENBQUM7b0JBQ3JDO29CQUVBLG1FQUFtRTtvQkFDbkUsSUFBSSxDQUFDcEIsUUFBUSxHQUFHO29CQUNoQjtZQUNKO1FBQ0Y7UUFFQSxNQUFPLElBQUksQ0FBQ0ksR0FBRyxHQUFHLElBQUksQ0FBQ0QsTUFBTSxDQUFDYSxNQUFNLENBQUU7WUFDcEMsbUVBQW1FO1lBQ25FLGdEQUFnRDtZQUNoRCxJQUFJLElBQUksQ0FBQ2QsYUFBYSxFQUFFO2dCQUN0QixpRUFBaUU7Z0JBQ2pFLG9DQUFvQztnQkFFcEMsZ0VBQWdFO2dCQUNoRSw4REFBOEQ7Z0JBQzlELG1CQUFtQjtnQkFDbkIsSUFBSSxJQUFJLENBQUNELFNBQVMsRUFBRTtvQkFDbEIsNERBQTREO29CQUM1RCwrQ0FBK0M7b0JBQy9DLElBQUksSUFBSSxDQUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDQyxHQUFHLENBQUMsS0FBS1osSUFBSTt3QkFDaEMsSUFBSSxDQUFDVyxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNpQixRQUFRLENBQUMsSUFBSSxDQUFDaEIsR0FBRyxHQUFHO3dCQUM5QyxJQUFJLENBQUNBLEdBQUcsR0FBRzt3QkFDWCxJQUFJLENBQUNILFNBQVMsR0FBRzt3QkFXakI7b0JBQ0Y7b0JBQ0EsSUFBSSxDQUFDQSxTQUFTLEdBQUc7Z0JBQ25CO2dCQUVBLElBQUksSUFBSSxDQUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDQyxHQUFHLENBQUMsS0FBS1osTUFBTSxJQUFJLENBQUNXLE1BQU0sQ0FBQyxJQUFJLENBQUNDLEdBQUcsQ0FBQyxLQUFLWCxJQUFJO29CQUNoRSw0REFBNEQ7b0JBQzVELDZEQUE2RDtvQkFDN0QsNkRBQTZEO29CQUM3RCxTQUFTO29CQUNULElBQUksSUFBSSxDQUFDVSxNQUFNLENBQUMsSUFBSSxDQUFDQyxHQUFHLENBQUMsS0FBS1gsSUFBSTt3QkFDaEMsSUFBSSxDQUFDUSxTQUFTLEdBQUc7b0JBQ25CO29CQUVBLElBQUksQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDaUIsUUFBUSxDQUFDLElBQUksQ0FBQ2hCLEdBQUcsR0FBRztvQkFDOUMsSUFBSSxDQUFDQSxHQUFHLEdBQUc7b0JBQ1gsSUFDRSxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxLQUFLQyxhQUFhLElBQUksQ0FBQ0YsS0FBSyxDQUFDQSxLQUFLLElBQUksSUFBSSxDQUFDQSxLQUFLLENBQUNHLEVBQUUsSUFBSSxJQUFJLENBQUNILEtBQUssQ0FBQ0ksS0FBSyxFQUFFO3dCQUN4RixJQUFJLENBQUNZLFlBQVksQ0FBQyxJQUFJLENBQUNoQixLQUFLO29CQUM5QjtvQkFDQSxJQUFJLENBQUNpQixVQUFVO29CQUNmO2dCQUNGO2dCQUNBLGlFQUFpRTtnQkFDakUsOERBQThEO2dCQUM5RCxJQUFJLENBQUNwQixhQUFhLEdBQUc7Z0JBQ3JCO1lBQ0Y7WUFFQSxpRUFBaUU7WUFDakUsT0FBTztZQUNQLElBQUksSUFBSSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDQyxHQUFHLENBQUMsS0FBS1osTUFBTSxJQUFJLENBQUNXLE1BQU0sQ0FBQyxJQUFJLENBQUNDLEdBQUcsQ0FBQyxLQUFLWCxJQUFJO2dCQUNoRSw0REFBNEQ7Z0JBQzVELDZEQUE2RDtnQkFDN0QsZ0NBQWdDO2dCQUNoQyxJQUFJLElBQUksQ0FBQ1UsTUFBTSxDQUFDLElBQUksQ0FBQ0MsR0FBRyxDQUFDLEtBQUtYLElBQUk7b0JBQ2hDLElBQUksQ0FBQ1EsU0FBUyxHQUFHO2dCQUNuQjtnQkFFQSx3REFBd0Q7Z0JBQ3hELHdCQUF3QjtnQkFDeEIsSUFBSSxDQUFDc0IsU0FBUyxDQUFDLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQ2lCLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQ2hCLEdBQUcsR0FBRyxJQUFJLENBQUNDLEtBQUs7Z0JBRTVELDRDQUE0QztnQkFDNUMsSUFBSSxDQUFDRixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNpQixRQUFRLENBQUMsSUFBSSxDQUFDaEIsR0FBRyxHQUFHO2dCQUM5QyxzRUFBc0U7Z0JBQ3RFLElBQUksQ0FBQ0EsR0FBRyxHQUFHO2dCQUNYLHVFQUF1RTtnQkFDdkUsa0VBQWtFO2dCQUNsRSxZQUFZO2dCQUNaLElBQUksQ0FBQ0YsYUFBYSxHQUFHO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDRSxHQUFHO1FBQ1Y7UUFFQVc7SUFDRjtJQUVBOzs7R0FHQyxHQUNEUSxVQUFXQyxJQUFJLEVBQUVuQixLQUFLLEVBQUU7UUFDdEIsc0NBQXNDO1FBQ3RDLHdDQUF3QztRQUN4QyxnREFBZ0Q7UUFDaEQsSUFBSW1CLEtBQUtSLE1BQU0sS0FBSyxHQUFHO1lBQ3JCO1FBQ0Y7UUFFQSx1REFBdUQ7UUFDdkQsbUJBQW1CO1FBQ25CLE1BQU1TLGdCQUFnQkQsS0FBS0UsT0FBTyxDQUFDaEM7UUFDbkMsSUFBSStCLGtCQUFrQixHQUFHO1lBQ3ZCO1FBQ0Y7UUFFQSxJQUFJRSxRQUFRO1FBQ1osSUFBSUMsUUFBUTtRQUVaLG9EQUFvRDtRQUNwRCxJQUFJSCxrQkFBa0IsQ0FBQyxHQUFHO1lBQ3hCLG1FQUFtRTtZQUNuRSwrQ0FBK0M7WUFDL0MscUVBQXFFO1lBQ3JFLFFBQVE7WUFDUixvREFBb0Q7WUFDcERFLFFBQVFILEtBQUtKLFFBQVEsQ0FBQyxHQUFHSyxlQUFlSSxRQUFRLENBQUM7WUFFakQsa0VBQWtFO1lBQ2xFLCtDQUErQztZQUMvQyx1RUFBdUU7WUFDdkUsSUFBSUMsYUFBYUwsZ0JBQWdCO1lBQ2pDLElBQUlELElBQUksQ0FBQ00sV0FBVyxLQUFLbkMsT0FBTztnQkFDOUIsRUFBRW1DO1lBQ0o7WUFDQSxxRUFBcUU7WUFDckUsUUFBUTtZQUNSLG9EQUFvRDtZQUNwREYsUUFBUUosS0FBS0osUUFBUSxDQUFDVSxZQUFZRCxRQUFRLENBQUM7UUFFM0MseUVBQXlFO1FBQ3pFLGdCQUFnQjtRQUNsQixPQUFPO1lBQ0wscUVBQXFFO1lBQ3JFLG1FQUFtRTtZQUNuRUYsUUFBUUgsS0FBS0ssUUFBUSxDQUFDO1lBQ3RCRCxRQUFRO1FBQ1Y7UUFFQSxvRUFBb0U7UUFDcEUsbUJBQW1CO1FBQ25CLE9BQVFEO1lBQ04sS0FBSztnQkFDSCxJQUFJdEIsS0FBSyxDQUFDc0IsTUFBTSxLQUFLcEIsV0FBVztvQkFDOUJGLEtBQUssQ0FBQ3NCLE1BQU0sR0FBR0M7Z0JBQ2pCLE9BQU87b0JBQ0x2QixLQUFLLENBQUNzQixNQUFNLElBQUksQ0FBQyxFQUFFLEVBQUVDLE9BQU87Z0JBQzlCO2dCQUNBO1lBQ0YsS0FBSztnQkFDSCxJQUFJdkMsY0FBY3VDLFFBQVE7b0JBQ3hCdkIsS0FBSyxDQUFDc0IsTUFBTSxHQUFHQztnQkFDakI7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILElBQUl0QyxtQkFBbUJzQyxRQUFRO29CQUM3QnZCLEtBQUssQ0FBQ3NCLE1BQU0sR0FBR0M7Z0JBQ2pCO2dCQUNBO1lBQ0YsS0FBSztnQkFDSCxJQUFJQSxNQUFNWixNQUFNLEdBQUcsR0FBRztvQkFDcEJYLEtBQUssQ0FBQ3NCLE1BQU0sR0FBR0M7Z0JBQ2pCO2dCQUNBO1FBQ0o7SUFDRjtJQUVBOztHQUVDLEdBQ0RQLGFBQWNoQixLQUFLLEVBQUU7UUFDbkIsSUFBSUEsTUFBTUksS0FBSyxJQUFJcEIsY0FBY2dCLE1BQU1JLEtBQUssR0FBRztZQUM3QyxJQUFJLENBQUNWLEtBQUssQ0FBQ2dDLGdCQUFnQixHQUFHQyxTQUFTM0IsTUFBTUksS0FBSyxFQUFFO1FBQ3REO1FBRUEsSUFBSUosTUFBTUcsRUFBRSxJQUFJbEIsbUJBQW1CZSxNQUFNRyxFQUFFLEdBQUc7WUFDNUMsSUFBSSxDQUFDVCxLQUFLLENBQUNrQyxXQUFXLEdBQUc1QixNQUFNRyxFQUFFO1FBQ25DO1FBRUEsNkNBQTZDO1FBQzdDLElBQUlILE1BQU1DLElBQUksS0FBS0MsV0FBVztZQUM1QixJQUFJLENBQUNJLElBQUksQ0FBQztnQkFDUnVCLE1BQU03QixNQUFNQSxLQUFLLElBQUk7Z0JBQ3JCUixTQUFTO29CQUNQUyxNQUFNRCxNQUFNQyxJQUFJO29CQUNoQjJCLGFBQWEsSUFBSSxDQUFDbEMsS0FBSyxDQUFDa0MsV0FBVztvQkFDbkNFLFFBQVEsSUFBSSxDQUFDcEMsS0FBSyxDQUFDb0MsTUFBTTtnQkFDM0I7WUFDRjtRQUNGO0lBQ0Y7SUFFQWIsYUFBYztRQUNaLElBQUksQ0FBQ2pCLEtBQUssR0FBRztZQUNYQyxNQUFNQztZQUNORixPQUFPRTtZQUNQQyxJQUFJRDtZQUNKRSxPQUFPRjtRQUNUO0lBQ0Y7QUFDRjtBQUVBNkIsT0FBT0MsT0FBTyxHQUFHO0lBQ2Z6QztBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZXZlbnRzb3VyY2VcXGV2ZW50c291cmNlLXN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IGlzQVNDSUlOdW1iZXIsIGlzVmFsaWRMYXN0RXZlbnRJZCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyW119IEJPTVxuICovXG5jb25zdCBCT00gPSBbMHhFRiwgMHhCQiwgMHhCRl1cbi8qKlxuICogQHR5cGUgezEwfSBMRlxuICovXG5jb25zdCBMRiA9IDB4MEFcbi8qKlxuICogQHR5cGUgezEzfSBDUlxuICovXG5jb25zdCBDUiA9IDB4MERcbi8qKlxuICogQHR5cGUgezU4fSBDT0xPTlxuICovXG5jb25zdCBDT0xPTiA9IDB4M0Fcbi8qKlxuICogQHR5cGUgezMyfSBTUEFDRVxuICovXG5jb25zdCBTUEFDRSA9IDB4MjBcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBFdmVudFNvdXJjZVN0cmVhbUV2ZW50XG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtldmVudF0gVGhlIGV2ZW50IHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2RhdGFdIFRoZSBkYXRhIG9mIHRoZSBtZXNzYWdlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF0gQSB1bmlxdWUgSUQgZm9yIHRoZSBldmVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmV0cnldIFRoZSByZWNvbm5lY3Rpb24gdGltZSwgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgZXZlbnRTb3VyY2VTZXR0aW5nc1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYXN0RXZlbnRJZCBUaGUgbGFzdCBldmVudCBJRCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIGV2ZW50IHNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWNvbm5lY3Rpb25UaW1lIFRoZSByZWNvbm5lY3Rpb24gdGltZSwgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbmNsYXNzIEV2ZW50U291cmNlU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtldmVudFNvdXJjZVNldHRpbmdzfVxuICAgKi9cbiAgc3RhdGUgPSBudWxsXG5cbiAgLyoqXG4gICAqIExlYWRpbmcgYnl0ZS1vcmRlci1tYXJrIGNoZWNrLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGNoZWNrQk9NID0gdHJ1ZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGNybGZDaGVjayA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZXZlbnRFbmRDaGVjayA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAqL1xuICBidWZmZXIgPSBudWxsXG5cbiAgcG9zID0gMFxuXG4gIGV2ZW50ID0ge1xuICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICBldmVudDogdW5kZWZpbmVkLFxuICAgIGlkOiB1bmRlZmluZWQsXG4gICAgcmV0cnk6IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7ZXZlbnRTb3VyY2VTZXR0aW5nc30gb3B0aW9ucy5ldmVudFNvdXJjZVNldHRpbmdzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnB1c2hdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gRW5hYmxlIG9iamVjdCBtb2RlIGFzIEV2ZW50U291cmNlU3RyZWFtIGVtaXRzIG9iamVjdHMgb2Ygc2hhcGVcbiAgICAvLyBFdmVudFNvdXJjZVN0cmVhbUV2ZW50XG4gICAgb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgPSB0cnVlXG5cbiAgICBzdXBlcihvcHRpb25zKVxuXG4gICAgdGhpcy5zdGF0ZSA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTZXR0aW5ncyB8fCB7fVxuICAgIGlmIChvcHRpb25zLnB1c2gpIHtcbiAgICAgIHRoaXMucHVzaCA9IG9wdGlvbnMucHVzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9lbmNvZGluZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF90cmFuc2Zvcm0gKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgdGhlIGNodW5rIGluIHRoZSBidWZmZXIsIGFzIHRoZSBkYXRhIG1pZ2h0IG5vdCBiZSBjb21wbGV0ZSB3aGlsZVxuICAgIC8vIHByb2Nlc3NpbmcgaXRcbiAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gaGFuZGxlXG4gICAgLy8gaW5jb21pbmcgY2h1bmtzXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjYzMFxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlciwgY2h1bmtdKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGNodW5rXG4gICAgfVxuXG4gICAgLy8gU3RyaXAgbGVhZGluZyBieXRlLW9yZGVyLW1hcmsgaWYgd2Ugb3BlbmVkIHRoZSBzdHJlYW0gYW5kIHN0YXJ0ZWRcbiAgICAvLyB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgaW5jb21pbmcgZGF0YVxuICAgIGlmICh0aGlzLmNoZWNrQk9NKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IGJ5dGUgaXMgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIEJPTVxuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclswXSA9PT0gQk9NWzBdKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcywgd2UgbmVlZCB0byB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcblxuICAgICAgICAgIC8vIFRoZSBidWZmZXIgb25seSBjb250YWlucyBvbmUgYnl0ZSBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0d28gYnl0ZXMgYXJlIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCB0d28gYnl0ZXNcbiAgICAgICAgICAvLyBvZiB0aGUgQk9NXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMV0gPT09IEJPTVsxXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIG5lZWQgdG8gd2FpdCBmb3IgbW9yZSBkYXRhLCBiZWNhdXNlIHRoZSB0aGlyZCBieXRlXG4gICAgICAgICAgICAvLyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIHRoZSBCT00gb3Igbm90XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IHRocmVlIGJ5dGVzIGFyZSB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgdGhyZWVcbiAgICAgICAgICAvLyBieXRlcyBvZiB0aGUgQk9NXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMV0gPT09IEJPTVsxXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMl0gPT09IEJPTVsyXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIGNhbiBkcm9wIHRoZSBidWZmZXJlZCBkYXRhLCBhcyBpdCBpcyBvbmx5IHRoZSBCT01cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgICAvLyBCT00gYW55bW9yZVxuICAgICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vIEF3YWl0IG1vcmUgZGF0YVxuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIGl0IGlzIG5vdCB0aGUgQk9NLCB3ZSBjYW4gc3RhcnQgcHJvY2Vzc2luZyB0aGUgZGF0YVxuICAgICAgICAgIHRoaXMuY2hlY2tCT00gPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gVGhlIGJ1ZmZlciBpcyBsb25nZXIgdGhhbiAzIGJ5dGVzLCBzbyB3ZSBjYW4gZHJvcCB0aGUgQk9NIGlmIGl0IGlzXG4gICAgICAgICAgLy8gcHJlc2VudFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzJdID09PSBCT01bMl1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgQk9NIGZyb20gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSgzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCB0aGUgY2hlY2tCT00gZmxhZyB0byBmYWxzZSBhcyB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciB0aGVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGxpbmUgZW5kZWQgd2l0aCBhbiBlbmQtb2YtbGluZSwgd2UgbmVlZCB0byBjaGVja1xuICAgICAgLy8gaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFsc28gYW4gZW5kLW9mLWxpbmUuXG4gICAgICBpZiAodGhpcy5ldmVudEVuZENoZWNrKSB7XG4gICAgICAgIC8vIElmIHRoZSB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYW4gZW5kLW9mLWxpbmUsIHRoZW4gdGhlIGV2ZW50XG4gICAgICAgIC8vIGlzIGZpbmlzaGVkIGFuZCB3ZSBjYW4gcHJvY2VzcyBpdFxuXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBsaW5lIGVuZGVkIHdpdGggYSBjYXJyaWFnZSByZXR1cm4sIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgbGluZSBmZWVkIGFuZCByZW1vdmUgaXRcbiAgICAgICAgLy8gZnJvbSB0aGUgYnVmZmVyLlxuICAgICAgICBpZiAodGhpcy5jcmxmQ2hlY2spIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWQsIHdlIGNhbiByZW1vdmUgaXRcbiAgICAgICAgICAvLyBmcm9tIHRoZSBidWZmZXIgYW5kIHJlc2V0IHRoZSBjcmxmQ2hlY2sgZmxhZ1xuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zICsgMSlcbiAgICAgICAgICAgIHRoaXMucG9zID0gMFxuICAgICAgICAgICAgdGhpcy5jcmxmQ2hlY2sgPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBsaW5lIGZlZWQgaXMgbm90IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAvLyBldmVudC4gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYW5cbiAgICAgICAgICAgIC8vIGVuZC1vZi1saW5lIGNoYXJhY3RlciB0byBkZXRlcm1pbmUgaWYgdGhlIGV2ZW50IGlzXG4gICAgICAgICAgICAvLyBmaW5pc2hlZC4gV2Ugc2ltcGx5IGNvbnRpbnVlIHRoZSBsb29wIHRvIGNoZWNrIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBjaGFyYWN0ZXIuXG5cbiAgICAgICAgICAgIC8vIEFzIHdlIHJlbW92ZWQgdGhlIGxpbmUgZmVlZCBmcm9tIHRoZSBidWZmZXIgYW5kIHNldCB0aGVcbiAgICAgICAgICAgIC8vIGNybGZDaGVjayBmbGFnIHRvIGZhbHNlLCB3ZSBiYXNpY2FsbHkgZG9uJ3QgbWFrZSBhbnlcbiAgICAgICAgICAgIC8vIGRpc3RpbmN0aW9uIGJldHdlZW4gYSBsaW5lIGZlZWQgYW5kIGEgY2FycmlhZ2UgcmV0dXJuLlxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jcmxmQ2hlY2sgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gTEYgfHwgdGhpcy5idWZmZXJbdGhpcy5wb3NdID09PSBDUikge1xuICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGNhcnJpYWdlIHJldHVybiwgd2UgbmVlZCB0b1xuICAgICAgICAgIC8vIHNldCB0aGUgY3JsZkNoZWNrIGZsYWcgdG8gdHJ1ZSwgYXMgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgICAvLyBuZXh0IGNoYXJhY3RlciBpcyBhIGxpbmUgZmVlZCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGZyb20gdGhlXG4gICAgICAgICAgLy8gYnVmZmVyXG4gICAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MgKyAxKVxuICAgICAgICAgIHRoaXMucG9zID0gMFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuZXZlbnQuZXZlbnQgfHwgdGhpcy5ldmVudC5pZCB8fCB0aGlzLmV2ZW50LnJldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFdmVudCh0aGlzLmV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNsZWFyRXZlbnQoKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIG5vdCBhbiBlbmQtb2YtbGluZSwgdGhlbiB0aGUgZXZlbnRcbiAgICAgICAgLy8gaXMgbm90IGZpbmlzaGVkIGFuZCB3ZSBoYXZlIHRvIHJlc2V0IHRoZSBldmVudEVuZENoZWNrIGZsYWdcbiAgICAgICAgdGhpcy5ldmVudEVuZENoZWNrID0gZmFsc2VcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGFuIGVuZC1vZi1saW5lLCB3ZSBjYW4gcHJvY2VzcyB0aGVcbiAgICAgIC8vIGxpbmVcbiAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGIHx8IHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgY2FycmlhZ2UgcmV0dXJuLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHNldCB0aGUgY3JsZkNoZWNrIGZsYWcgdG8gdHJ1ZSwgYXMgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgLy8gbmV4dCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWRcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICB0aGlzLmNybGZDaGVjayA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIGFueSBjYXNlLCB3ZSBjYW4gcHJvY2VzcyB0aGUgbGluZSBhcyB3ZSByZWFjaGVkIGFuXG4gICAgICAgIC8vIGVuZC1vZi1saW5lIGNoYXJhY3RlclxuICAgICAgICB0aGlzLnBhcnNlTGluZSh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvcyksIHRoaXMuZXZlbnQpXG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcm9jZXNzZWQgbGluZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLnBvcyArIDEpXG4gICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBhcyB3ZSByZW1vdmVkIHRoZSBwcm9jZXNzZWQgbGluZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgdGhpcy5wb3MgPSAwXG4gICAgICAgIC8vIEEgbGluZSB3YXMgcHJvY2Vzc2VkIGFuZCB0aGlzIGNvdWxkIGJlIHRoZSBlbmQgb2YgdGhlIGV2ZW50LiBXZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIGlmIHRoZSBuZXh0IGxpbmUgaXMgZW1wdHkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBldmVudCBpc1xuICAgICAgICAvLyBmaW5pc2hlZC5cbiAgICAgICAgdGhpcy5ldmVudEVuZENoZWNrID0gdHJ1ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcysrXG4gICAgfVxuXG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBsaW5lXG4gICAqIEBwYXJhbSB7RXZlbnRTdHJlYW1FdmVudH0gZXZlbnRcbiAgICovXG4gIHBhcnNlTGluZSAobGluZSwgZXZlbnQpIHtcbiAgICAvLyBJZiB0aGUgbGluZSBpcyBlbXB0eSAoYSBibGFuayBsaW5lKVxuICAgIC8vIERpc3BhdGNoIHRoZSBldmVudCwgYXMgZGVmaW5lZCBiZWxvdy5cbiAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgX3RyYW5zZm9ybSBtZXRob2RcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOilcbiAgICAvLyBJZ25vcmUgdGhlIGxpbmUuXG4gICAgY29uc3QgY29sb25Qb3NpdGlvbiA9IGxpbmUuaW5kZXhPZihDT0xPTilcbiAgICBpZiAoY29sb25Qb3NpdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZpZWxkID0gJydcbiAgICBsZXQgdmFsdWUgPSAnJ1xuXG4gICAgLy8gSWYgdGhlIGxpbmUgY29udGFpbnMgYSBVKzAwM0EgQ09MT04gY2hhcmFjdGVyICg6KVxuICAgIGlmIChjb2xvblBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgLy8gQ29sbGVjdCB0aGUgY2hhcmFjdGVycyBvbiB0aGUgbGluZSBiZWZvcmUgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KSwgYW5kIGxldCBmaWVsZCBiZSB0aGF0IHN0cmluZy5cbiAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIGlmIHRoZXJlIGlzIGEgbW9yZSBwZXJmb3JtYW50IHdheSB0byBleHRyYWN0IHRoZVxuICAgICAgLy8gZmllbGRcbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2MzBcbiAgICAgIGZpZWxkID0gbGluZS5zdWJhcnJheSgwLCBjb2xvblBvc2l0aW9uKS50b1N0cmluZygndXRmOCcpXG5cbiAgICAgIC8vIENvbGxlY3QgdGhlIGNoYXJhY3RlcnMgb24gdGhlIGxpbmUgYWZ0ZXIgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KSwgYW5kIGxldCB2YWx1ZSBiZSB0aGF0IHN0cmluZy5cbiAgICAgIC8vIElmIHZhbHVlIHN0YXJ0cyB3aXRoIGEgVSswMDIwIFNQQUNFIGNoYXJhY3RlciwgcmVtb3ZlIGl0IGZyb20gdmFsdWUuXG4gICAgICBsZXQgdmFsdWVTdGFydCA9IGNvbG9uUG9zaXRpb24gKyAxXG4gICAgICBpZiAobGluZVt2YWx1ZVN0YXJ0XSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgKyt2YWx1ZVN0YXJ0XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gZXh0cmFjdCB0aGVcbiAgICAgIC8vIHZhbHVlXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yNjMwXG4gICAgICB2YWx1ZSA9IGxpbmUuc3ViYXJyYXkodmFsdWVTdGFydCkudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBzdHJpbmcgaXMgbm90IGVtcHR5IGJ1dCBkb2VzIG5vdCBjb250YWluIGEgVSswMDNBIENPTE9OXG4gICAgICAvLyBjaGFyYWN0ZXIgKDopXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhlIGZpZWxkIHVzaW5nIHRoZSBzdGVwcyBkZXNjcmliZWQgYmVsb3csIHVzaW5nIHRoZSB3aG9sZVxuICAgICAgLy8gbGluZSBhcyB0aGUgZmllbGQgbmFtZSwgYW5kIHRoZSBlbXB0eSBzdHJpbmcgYXMgdGhlIGZpZWxkIHZhbHVlLlxuICAgICAgZmllbGQgPSBsaW5lLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgIHZhbHVlID0gJydcbiAgICB9XG5cbiAgICAvLyBNb2RpZnkgdGhlIGV2ZW50IHdpdGggdGhlIGZpZWxkIG5hbWUgYW5kIHZhbHVlLiBUaGUgdmFsdWUgaXMgYWxzb1xuICAgIC8vIGRlY29kZWQgYXMgVVRGLThcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgaWYgKGV2ZW50W2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gKz0gYFxcbiR7dmFsdWV9YFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdyZXRyeSc6XG4gICAgICAgIGlmIChpc0FTQ0lJTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgaWYgKGlzVmFsaWRMYXN0RXZlbnRJZCh2YWx1ZSkpIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdldmVudCc6XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50U291cmNlU3RyZWFtRXZlbnR9IGV2ZW50XG4gICAqL1xuICBwcm9jZXNzRXZlbnQgKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJldHJ5ICYmIGlzQVNDSUlOdW1iZXIoZXZlbnQucmV0cnkpKSB7XG4gICAgICB0aGlzLnN0YXRlLnJlY29ubmVjdGlvblRpbWUgPSBwYXJzZUludChldmVudC5yZXRyeSwgMTApXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmlkICYmIGlzVmFsaWRMYXN0RXZlbnRJZChldmVudC5pZCkpIHtcbiAgICAgIHRoaXMuc3RhdGUubGFzdEV2ZW50SWQgPSBldmVudC5pZFxuICAgIH1cblxuICAgIC8vIG9ubHkgZGlzcGF0Y2ggZXZlbnQsIHdoZW4gZGF0YSBpcyBwcm92aWRlZFxuICAgIGlmIChldmVudC5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGV2ZW50LmV2ZW50IHx8ICdtZXNzYWdlJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgbGFzdEV2ZW50SWQ6IHRoaXMuc3RhdGUubGFzdEV2ZW50SWQsXG4gICAgICAgICAgb3JpZ2luOiB0aGlzLnN0YXRlLm9yaWdpblxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyRXZlbnQgKCkge1xuICAgIHRoaXMuZXZlbnQgPSB7XG4gICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogdW5kZWZpbmVkLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIHJldHJ5OiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEV2ZW50U291cmNlU3RyZWFtXG59XG4iXSwibmFtZXMiOlsiVHJhbnNmb3JtIiwicmVxdWlyZSIsImlzQVNDSUlOdW1iZXIiLCJpc1ZhbGlkTGFzdEV2ZW50SWQiLCJCT00iLCJMRiIsIkNSIiwiQ09MT04iLCJTUEFDRSIsIkV2ZW50U291cmNlU3RyZWFtIiwib3B0aW9ucyIsInJlYWRhYmxlT2JqZWN0TW9kZSIsInN0YXRlIiwiY2hlY2tCT00iLCJjcmxmQ2hlY2siLCJldmVudEVuZENoZWNrIiwiYnVmZmVyIiwicG9zIiwiZXZlbnQiLCJkYXRhIiwidW5kZWZpbmVkIiwiaWQiLCJyZXRyeSIsImV2ZW50U291cmNlU2V0dGluZ3MiLCJwdXNoIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiX2VuY29kaW5nIiwiY2FsbGJhY2siLCJsZW5ndGgiLCJCdWZmZXIiLCJjb25jYXQiLCJhbGxvYyIsInN1YmFycmF5IiwicHJvY2Vzc0V2ZW50IiwiY2xlYXJFdmVudCIsInBhcnNlTGluZSIsImxpbmUiLCJjb2xvblBvc2l0aW9uIiwiaW5kZXhPZiIsImZpZWxkIiwidmFsdWUiLCJ0b1N0cmluZyIsInZhbHVlU3RhcnQiLCJyZWNvbm5lY3Rpb25UaW1lIiwicGFyc2VJbnQiLCJsYXN0RXZlbnRJZCIsInR5cGUiLCJvcmlnaW4iLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js":
/*!****************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { fetching } = __webpack_require__(/*! ../fetch */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\");\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { EventSourceStream } = __webpack_require__(/*! ./eventsource-stream */ \"(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\");\nconst { parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { createFastMessageEvent } = __webpack_require__(/*! ../websocket/events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nconst { isNetworkError } = __webpack_require__(/*! ../fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\");\nconst { delay } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/eventsource/util.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nlet experimentalWarned = false;\n/**\n * A reconnection time, in milliseconds. This must initially be an implementation-defined value,\n * probably in the region of a few seconds.\n *\n * In Comparison:\n * - Chrome uses 3000ms.\n * - Deno uses 5000ms.\n *\n * @type {3000}\n */ const defaultReconnectionTime = 3000;\n/**\n * The readyState attribute represents the state of the connection.\n * @enum\n * @readonly\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev\n */ /**\n * The connection has not yet been established, or it was closed and the user\n * agent is reconnecting.\n * @type {0}\n */ const CONNECTING = 0;\n/**\n * The user agent has an open connection and is dispatching events as it\n * receives them.\n * @type {1}\n */ const OPEN = 1;\n/**\n * The connection is not open, and the user agent is not trying to reconnect.\n * @type {2}\n */ const CLOSED = 2;\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"same-origin\".\n * @type {'anonymous'}\n */ const ANONYMOUS = 'anonymous';\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"include\".\n * @type {'use-credentials'}\n */ const USE_CREDENTIALS = 'use-credentials';\n/**\n * The EventSource interface is used to receive server-sent events. It\n * connects to a server over HTTP and receives events in text/event-stream\n * format without closing the connection.\n * @extends {EventTarget}\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events\n * @api public\n */ class EventSource extends EventTarget {\n    #events;\n    #url;\n    #withCredentials;\n    #readyState;\n    #request;\n    #controller;\n    #dispatcher;\n    /**\n   * @type {import('./eventsource-stream').eventSourceSettings}\n   */ #state;\n    /**\n   * Creates a new EventSource object.\n   * @param {string} url\n   * @param {EventSourceInit} [eventSourceInitDict]\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n   */ constructor(url, eventSourceInitDict = {}){\n        // 1. Let ev be a new EventSource object.\n        super(), this.#events = {\n            open: null,\n            error: null,\n            message: null\n        }, this.#url = null, this.#withCredentials = false, this.#readyState = CONNECTING, this.#request = null, this.#controller = null;\n        const prefix = 'EventSource constructor';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        if (!experimentalWarned) {\n            experimentalWarned = true;\n            process.emitWarning('EventSource is experimental, expect them to change at any time.', {\n                code: 'UNDICI-ES'\n            });\n        }\n        url = webidl.converters.USVString(url, prefix, 'url');\n        eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, 'eventSourceInitDict');\n        this.#dispatcher = eventSourceInitDict.dispatcher;\n        this.#state = {\n            lastEventId: '',\n            reconnectionTime: defaultReconnectionTime\n        };\n        // 2. Let settings be ev's relevant settings object.\n        // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n        const settings = environmentSettingsObject;\n        let urlRecord;\n        try {\n            // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.\n            urlRecord = new URL(url, settings.settingsObject.baseUrl);\n            this.#state.origin = urlRecord.origin;\n        } catch (e) {\n            // 4. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n            throw new DOMException(e, 'SyntaxError');\n        }\n        // 5. Set ev's url to urlRecord.\n        this.#url = urlRecord.href;\n        // 6. Let corsAttributeState be Anonymous.\n        let corsAttributeState = ANONYMOUS;\n        // 7. If the value of eventSourceInitDict's withCredentials member is true,\n        // then set corsAttributeState to Use Credentials and set ev's\n        // withCredentials attribute to true.\n        if (eventSourceInitDict.withCredentials) {\n            corsAttributeState = USE_CREDENTIALS;\n            this.#withCredentials = true;\n        }\n        // 8. Let request be the result of creating a potential-CORS request given\n        // urlRecord, the empty string, and corsAttributeState.\n        const initRequest = {\n            redirect: 'follow',\n            keepalive: true,\n            // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes\n            mode: 'cors',\n            credentials: corsAttributeState === 'anonymous' ? 'same-origin' : 'omit',\n            referrer: 'no-referrer'\n        };\n        // 9. Set request's client to settings.\n        initRequest.client = environmentSettingsObject.settingsObject;\n        // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.\n        initRequest.headersList = [\n            [\n                'accept',\n                {\n                    name: 'accept',\n                    value: 'text/event-stream'\n                }\n            ]\n        ];\n        // 11. Set request's cache mode to \"no-store\".\n        initRequest.cache = 'no-store';\n        // 12. Set request's initiator type to \"other\".\n        initRequest.initiator = 'other';\n        initRequest.urlList = [\n            new URL(this.#url)\n        ];\n        // 13. Set ev's request to request.\n        this.#request = makeRequest(initRequest);\n        this.#connect();\n    }\n    /**\n   * Returns the state of this EventSource object's connection. It can have the\n   * values described below.\n   * @returns {0|1|2}\n   * @readonly\n   */ get readyState() {\n        return this.#readyState;\n    }\n    /**\n   * Returns the URL providing the event stream.\n   * @readonly\n   * @returns {string}\n   */ get url() {\n        return this.#url;\n    }\n    /**\n   * Returns a boolean indicating whether the EventSource object was\n   * instantiated with CORS credentials set (true), or not (false, the default).\n   */ get withCredentials() {\n        return this.#withCredentials;\n    }\n    #connect() {\n        if (this.#readyState === CLOSED) return;\n        this.#readyState = CONNECTING;\n        const fetchParams = {\n            request: this.#request,\n            dispatcher: this.#dispatcher\n        };\n        // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.\n        const processEventSourceEndOfBody = (response)=>{\n            if (isNetworkError(response)) {\n                this.dispatchEvent(new Event('error'));\n                this.close();\n            }\n            this.#reconnect();\n        };\n        // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...\n        fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;\n        // and processResponse set to the following steps given response res:\n        fetchParams.processResponse = (response)=>{\n            // 1. If res is an aborted network error, then fail the connection.\n            if (isNetworkError(response)) {\n                // 1. When a user agent is to fail the connection, the user agent\n                // must queue a task which, if the readyState attribute is set to a\n                // value other than CLOSED, sets the readyState attribute to CLOSED\n                // and fires an event named error at the EventSource object. Once the\n                // user agent has failed the connection, it does not attempt to\n                // reconnect.\n                if (response.aborted) {\n                    this.close();\n                    this.dispatchEvent(new Event('error'));\n                    return;\n                // 2. Otherwise, if res is a network error, then reestablish the\n                // connection, unless the user agent knows that to be futile, in\n                // which case the user agent may fail the connection.\n                } else {\n                    this.#reconnect();\n                    return;\n                }\n            }\n            // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`\n            // is not `text/event-stream`, then fail the connection.\n            const contentType = response.headersList.get('content-type', true);\n            const mimeType = contentType !== null ? parseMIMEType(contentType) : 'failure';\n            const contentTypeValid = mimeType !== 'failure' && mimeType.essence === 'text/event-stream';\n            if (response.status !== 200 || contentTypeValid === false) {\n                this.close();\n                this.dispatchEvent(new Event('error'));\n                return;\n            }\n            // 4. Otherwise, announce the connection and interpret res's body\n            // line by line.\n            // When a user agent is to announce the connection, the user agent\n            // must queue a task which, if the readyState attribute is set to a\n            // value other than CLOSED, sets the readyState attribute to OPEN\n            // and fires an event named open at the EventSource object.\n            // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n            this.#readyState = OPEN;\n            this.dispatchEvent(new Event('open'));\n            // If redirected to a different origin, set the origin to the new origin.\n            this.#state.origin = response.urlList[response.urlList.length - 1].origin;\n            const eventSourceStream = new EventSourceStream({\n                eventSourceSettings: this.#state,\n                push: (event)=>{\n                    this.dispatchEvent(createFastMessageEvent(event.type, event.options));\n                }\n            });\n            pipeline(response.body.stream, eventSourceStream, (error)=>{\n                if (error?.aborted === false) {\n                    this.close();\n                    this.dispatchEvent(new Event('error'));\n                }\n            });\n        };\n        this.#controller = fetching(fetchParams);\n    }\n    /**\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n   * @returns {Promise<void>}\n   */ async #reconnect() {\n        // When a user agent is to reestablish the connection, the user agent must\n        // run the following steps. These steps are run in parallel, not as part of\n        // a task. (The tasks that it queues, of course, are run like normal tasks\n        // and not themselves in parallel.)\n        // 1. Queue a task to run the following steps:\n        //   1. If the readyState attribute is set to CLOSED, abort the task.\n        if (this.#readyState === CLOSED) return;\n        //   2. Set the readyState attribute to CONNECTING.\n        this.#readyState = CONNECTING;\n        //   3. Fire an event named error at the EventSource object.\n        this.dispatchEvent(new Event('error'));\n        // 2. Wait a delay equal to the reconnection time of the event source.\n        await delay(this.#state.reconnectionTime);\n        // 5. Queue a task to run the following steps:\n        //   1. If the EventSource object's readyState attribute is not set to\n        //      CONNECTING, then return.\n        if (this.#readyState !== CONNECTING) return;\n        //   2. Let request be the EventSource object's request.\n        //   3. If the EventSource object's last event ID string is not the empty\n        //      string, then:\n        //      1. Let lastEventIDValue be the EventSource object's last event ID\n        //         string, encoded as UTF-8.\n        //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header\n        //         list.\n        if (this.#state.lastEventId.length) {\n            this.#request.headersList.set('last-event-id', this.#state.lastEventId, true);\n        }\n        //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.\n        this.#connect();\n    }\n    /**\n   * Closes the connection, if any, and sets the readyState attribute to\n   * CLOSED.\n   */ close() {\n        webidl.brandCheck(this, EventSource);\n        if (this.#readyState === CLOSED) return;\n        this.#readyState = CLOSED;\n        this.#controller.abort();\n        this.#request = null;\n    }\n    get onopen() {\n        return this.#events.open;\n    }\n    set onopen(fn) {\n        if (this.#events.open) {\n            this.removeEventListener('open', this.#events.open);\n        }\n        if (typeof fn === 'function') {\n            this.#events.open = fn;\n            this.addEventListener('open', fn);\n        } else {\n            this.#events.open = null;\n        }\n    }\n    get onmessage() {\n        return this.#events.message;\n    }\n    set onmessage(fn) {\n        if (this.#events.message) {\n            this.removeEventListener('message', this.#events.message);\n        }\n        if (typeof fn === 'function') {\n            this.#events.message = fn;\n            this.addEventListener('message', fn);\n        } else {\n            this.#events.message = null;\n        }\n    }\n    get onerror() {\n        return this.#events.error;\n    }\n    set onerror(fn) {\n        if (this.#events.error) {\n            this.removeEventListener('error', this.#events.error);\n        }\n        if (typeof fn === 'function') {\n            this.#events.error = fn;\n            this.addEventListener('error', fn);\n        } else {\n            this.#events.error = null;\n        }\n    }\n}\nconst constantsPropertyDescriptors = {\n    CONNECTING: {\n        __proto__: null,\n        configurable: false,\n        enumerable: true,\n        value: CONNECTING,\n        writable: false\n    },\n    OPEN: {\n        __proto__: null,\n        configurable: false,\n        enumerable: true,\n        value: OPEN,\n        writable: false\n    },\n    CLOSED: {\n        __proto__: null,\n        configurable: false,\n        enumerable: true,\n        value: CLOSED,\n        writable: false\n    }\n};\nObject.defineProperties(EventSource, constantsPropertyDescriptors);\nObject.defineProperties(EventSource.prototype, constantsPropertyDescriptors);\nObject.defineProperties(EventSource.prototype, {\n    close: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onmessage: kEnumerableProperty,\n    onopen: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    url: kEnumerableProperty,\n    withCredentials: kEnumerableProperty\n});\nwebidl.converters.EventSourceInitDict = webidl.dictionaryConverter([\n    {\n        key: 'withCredentials',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'dispatcher',\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    EventSource,\n    defaultReconnectionTime\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQVEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUMxQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxvRUFBVTtBQUN2QyxNQUFNLEVBQUVFLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQyw4RUFBa0I7QUFDbEQsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR0gsbUJBQU9BLENBQUMsNEVBQWlCO0FBQzVDLE1BQU0sRUFBRUksaUJBQWlCLEVBQUUsR0FBR0osbUJBQU9BLENBQUMsbUdBQXNCO0FBQzVELE1BQU0sRUFBRUssYUFBYSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUNyRCxNQUFNLEVBQUVNLHNCQUFzQixFQUFFLEdBQUdOLG1CQUFPQSxDQUFDLG9GQUFxQjtBQUNoRSxNQUFNLEVBQUVPLGNBQWMsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQyxnRkFBbUI7QUFDdEQsTUFBTSxFQUFFUSxLQUFLLEVBQUUsR0FBR1IsbUJBQU9BLENBQUMsdUVBQVE7QUFDbEMsTUFBTSxFQUFFUyxtQkFBbUIsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQyxxRUFBaUI7QUFDekQsTUFBTSxFQUFFVSx5QkFBeUIsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQyx3RUFBZTtBQUU3RCxJQUFJVyxxQkFBcUI7QUFFekI7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUMsMEJBQTBCO0FBRWhDOzs7OztDQUtDLEdBRUQ7Ozs7Q0FJQyxHQUNELE1BQU1DLGFBQWE7QUFFbkI7Ozs7Q0FJQyxHQUNELE1BQU1DLE9BQU87QUFFYjs7O0NBR0MsR0FDRCxNQUFNQyxTQUFTO0FBRWY7OztDQUdDLEdBQ0QsTUFBTUMsWUFBWTtBQUVsQjs7O0NBR0MsR0FDRCxNQUFNQyxrQkFBa0I7QUFFeEI7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RjtBQUNGO0FBRUEsTUFBTXlFLCtCQUErQjtJQUNuQ25GLFlBQVk7UUFDVm9GLFdBQVc7UUFDWEMsY0FBYztRQUNkQyxZQUFZO1FBQ1oxQyxPQUFPNUM7UUFDUHVGLFVBQVU7SUFDWjtJQUNBdEYsTUFBTTtRQUNKbUYsV0FBVztRQUNYQyxjQUFjO1FBQ2RDLFlBQVk7UUFDWjFDLE9BQU8zQztRQUNQc0YsVUFBVTtJQUNaO0lBQ0FyRixRQUFRO1FBQ05rRixXQUFXO1FBQ1hDLGNBQWM7UUFDZEMsWUFBWTtRQUNaMUMsT0FBTzFDO1FBQ1BxRixVQUFVO0lBQ1o7QUFDRjtBQUVBQyxPQUFPQyxnQkFBZ0IsQ0FBQ3BGLGFBQWE4RTtBQUNyQ0ssT0FBT0MsZ0JBQWdCLENBQUNwRixZQUFZcUYsU0FBUyxFQUFFUDtBQUUvQ0ssT0FBT0MsZ0JBQWdCLENBQUNwRixZQUFZcUYsU0FBUyxFQUFFO0lBQzdDbkMsT0FBTzNEO0lBQ1BzRixTQUFTdEY7SUFDVHFGLFdBQVdyRjtJQUNYaUYsUUFBUWpGO0lBQ1JvRCxZQUFZcEQ7SUFDWlcsS0FBS1g7SUFDTHNDLGlCQUFpQnRDO0FBQ25CO0FBRUFOLE9BQU80QixVQUFVLENBQUNFLG1CQUFtQixHQUFHOUIsT0FBT3FHLG1CQUFtQixDQUFDO0lBQ2pFO1FBQ0VDLEtBQUs7UUFDTEMsV0FBV3ZHLE9BQU80QixVQUFVLENBQUM0RSxPQUFPO1FBQ3BDQyxjQUFjLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVd2RyxPQUFPNEIsVUFBVSxDQUFDOEUsR0FBRztJQUNsQztDQUNEO0FBRURDLE9BQU9DLE9BQU8sR0FBRztJQUNmN0Y7SUFDQU47QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGV2ZW50c291cmNlXFxldmVudHNvdXJjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBmZXRjaGluZyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gnKVxuY29uc3QgeyBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsgRXZlbnRTb3VyY2VTdHJlYW0gfSA9IHJlcXVpcmUoJy4vZXZlbnRzb3VyY2Utc3RyZWFtJylcbmNvbnN0IHsgcGFyc2VNSU1FVHlwZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuY29uc3QgeyBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50IH0gPSByZXF1aXJlKCcuLi93ZWJzb2NrZXQvZXZlbnRzJylcbmNvbnN0IHsgaXNOZXR3b3JrRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3Jlc3BvbnNlJylcbmNvbnN0IHsgZGVsYXkgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuXG5sZXQgZXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuLyoqXG4gKiBBIHJlY29ubmVjdGlvbiB0aW1lLCBpbiBtaWxsaXNlY29uZHMuIFRoaXMgbXVzdCBpbml0aWFsbHkgYmUgYW4gaW1wbGVtZW50YXRpb24tZGVmaW5lZCB2YWx1ZSxcbiAqIHByb2JhYmx5IGluIHRoZSByZWdpb24gb2YgYSBmZXcgc2Vjb25kcy5cbiAqXG4gKiBJbiBDb21wYXJpc29uOlxuICogLSBDaHJvbWUgdXNlcyAzMDAwbXMuXG4gKiAtIERlbm8gdXNlcyA1MDAwbXMuXG4gKlxuICogQHR5cGUgezMwMDB9XG4gKi9cbmNvbnN0IGRlZmF1bHRSZWNvbm5lY3Rpb25UaW1lID0gMzAwMFxuXG4vKipcbiAqIFRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAqIEBlbnVtXG4gKiBAcmVhZG9ubHlcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjZG9tLWV2ZW50c291cmNlLXJlYWR5c3RhdGUtZGV2XG4gKi9cblxuLyoqXG4gKiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IHlldCBiZWVuIGVzdGFibGlzaGVkLCBvciBpdCB3YXMgY2xvc2VkIGFuZCB0aGUgdXNlclxuICogYWdlbnQgaXMgcmVjb25uZWN0aW5nLlxuICogQHR5cGUgezB9XG4gKi9cbmNvbnN0IENPTk5FQ1RJTkcgPSAwXG5cbi8qKlxuICogVGhlIHVzZXIgYWdlbnQgaGFzIGFuIG9wZW4gY29ubmVjdGlvbiBhbmQgaXMgZGlzcGF0Y2hpbmcgZXZlbnRzIGFzIGl0XG4gKiByZWNlaXZlcyB0aGVtLlxuICogQHR5cGUgezF9XG4gKi9cbmNvbnN0IE9QRU4gPSAxXG5cbi8qKlxuICogVGhlIGNvbm5lY3Rpb24gaXMgbm90IG9wZW4sIGFuZCB0aGUgdXNlciBhZ2VudCBpcyBub3QgdHJ5aW5nIHRvIHJlY29ubmVjdC5cbiAqIEB0eXBlIHsyfVxuICovXG5jb25zdCBDTE9TRUQgPSAyXG5cbi8qKlxuICogUmVxdWVzdHMgZm9yIHRoZSBlbGVtZW50IHdpbGwgaGF2ZSB0aGVpciBtb2RlIHNldCB0byBcImNvcnNcIiBhbmQgdGhlaXIgY3JlZGVudGlhbHMgbW9kZSBzZXQgdG8gXCJzYW1lLW9yaWdpblwiLlxuICogQHR5cGUgeydhbm9ueW1vdXMnfVxuICovXG5jb25zdCBBTk9OWU1PVVMgPSAnYW5vbnltb3VzJ1xuXG4vKipcbiAqIFJlcXVlc3RzIGZvciB0aGUgZWxlbWVudCB3aWxsIGhhdmUgdGhlaXIgbW9kZSBzZXQgdG8gXCJjb3JzXCIgYW5kIHRoZWlyIGNyZWRlbnRpYWxzIG1vZGUgc2V0IHRvIFwiaW5jbHVkZVwiLlxuICogQHR5cGUgeyd1c2UtY3JlZGVudGlhbHMnfVxuICovXG5jb25zdCBVU0VfQ1JFREVOVElBTFMgPSAndXNlLWNyZWRlbnRpYWxzJ1xuXG4vKipcbiAqIFRoZSBFdmVudFNvdXJjZSBpbnRlcmZhY2UgaXMgdXNlZCB0byByZWNlaXZlIHNlcnZlci1zZW50IGV2ZW50cy4gSXRcbiAqIGNvbm5lY3RzIHRvIGEgc2VydmVyIG92ZXIgSFRUUCBhbmQgcmVjZWl2ZXMgZXZlbnRzIGluIHRleHQvZXZlbnQtc3RyZWFtXG4gKiBmb3JtYXQgd2l0aG91dCBjbG9zaW5nIHRoZSBjb25uZWN0aW9uLlxuICogQGV4dGVuZHMge0V2ZW50VGFyZ2V0fVxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNzZXJ2ZXItc2VudC1ldmVudHNcbiAqIEBhcGkgcHVibGljXG4gKi9cbmNsYXNzIEV2ZW50U291cmNlIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjZXZlbnRzID0ge1xuICAgIG9wZW46IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgbWVzc2FnZTogbnVsbFxuICB9XG5cbiAgI3VybCA9IG51bGxcbiAgI3dpdGhDcmVkZW50aWFscyA9IGZhbHNlXG5cbiAgI3JlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG5cbiAgI3JlcXVlc3QgPSBudWxsXG4gICNjb250cm9sbGVyID0gbnVsbFxuXG4gICNkaXNwYXRjaGVyXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4vZXZlbnRzb3VyY2Utc3RyZWFtJykuZXZlbnRTb3VyY2VTZXR0aW5nc31cbiAgICovXG4gICNzdGF0ZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEV2ZW50U291cmNlIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge0V2ZW50U291cmNlSW5pdH0gW2V2ZW50U291cmNlSW5pdERpY3RdXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjdGhlLWV2ZW50c291cmNlLWludGVyZmFjZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVybCwgZXZlbnRTb3VyY2VJbml0RGljdCA9IHt9KSB7XG4gICAgLy8gMS4gTGV0IGV2IGJlIGEgbmV3IEV2ZW50U291cmNlIG9iamVjdC5cbiAgICBzdXBlcigpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRXZlbnRTb3VyY2UgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBpZiAoIWV4cGVyaW1lbnRhbFdhcm5lZCkge1xuICAgICAgZXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnRXZlbnRTb3VyY2UgaXMgZXhwZXJpbWVudGFsLCBleHBlY3QgdGhlbSB0byBjaGFuZ2UgYXQgYW55IHRpbWUuJywge1xuICAgICAgICBjb2RlOiAnVU5ESUNJLUVTJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsLCBwcmVmaXgsICd1cmwnKVxuICAgIGV2ZW50U291cmNlSW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5FdmVudFNvdXJjZUluaXREaWN0KGV2ZW50U291cmNlSW5pdERpY3QsIHByZWZpeCwgJ2V2ZW50U291cmNlSW5pdERpY3QnKVxuXG4gICAgdGhpcy4jZGlzcGF0Y2hlciA9IGV2ZW50U291cmNlSW5pdERpY3QuZGlzcGF0Y2hlclxuICAgIHRoaXMuI3N0YXRlID0ge1xuICAgICAgbGFzdEV2ZW50SWQ6ICcnLFxuICAgICAgcmVjb25uZWN0aW9uVGltZTogZGVmYXVsdFJlY29ubmVjdGlvblRpbWVcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgc2V0dGluZ3MgYmUgZXYncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI2Vudmlyb25tZW50LXNldHRpbmdzLW9iamVjdFxuICAgIGNvbnN0IHNldHRpbmdzID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdFxuXG4gICAgbGV0IHVybFJlY29yZFxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIDMuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBlbmNvZGluZy1wYXJzaW5nIGEgVVJMIGdpdmVuIHVybCwgcmVsYXRpdmUgdG8gc2V0dGluZ3MuXG4gICAgICB1cmxSZWNvcmQgPSBuZXcgVVJMKHVybCwgc2V0dGluZ3Muc2V0dGluZ3NPYmplY3QuYmFzZVVybClcbiAgICAgIHRoaXMuI3N0YXRlLm9yaWdpbiA9IHVybFJlY29yZC5vcmlnaW5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyA0LiBJZiB1cmxSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGUsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNS4gU2V0IGV2J3MgdXJsIHRvIHVybFJlY29yZC5cbiAgICB0aGlzLiN1cmwgPSB1cmxSZWNvcmQuaHJlZlxuXG4gICAgLy8gNi4gTGV0IGNvcnNBdHRyaWJ1dGVTdGF0ZSBiZSBBbm9ueW1vdXMuXG4gICAgbGV0IGNvcnNBdHRyaWJ1dGVTdGF0ZSA9IEFOT05ZTU9VU1xuXG4gICAgLy8gNy4gSWYgdGhlIHZhbHVlIG9mIGV2ZW50U291cmNlSW5pdERpY3QncyB3aXRoQ3JlZGVudGlhbHMgbWVtYmVyIGlzIHRydWUsXG4gICAgLy8gdGhlbiBzZXQgY29yc0F0dHJpYnV0ZVN0YXRlIHRvIFVzZSBDcmVkZW50aWFscyBhbmQgc2V0IGV2J3NcbiAgICAvLyB3aXRoQ3JlZGVudGlhbHMgYXR0cmlidXRlIHRvIHRydWUuXG4gICAgaWYgKGV2ZW50U291cmNlSW5pdERpY3Qud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICBjb3JzQXR0cmlidXRlU3RhdGUgPSBVU0VfQ1JFREVOVElBTFNcbiAgICAgIHRoaXMuI3dpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyA4LiBMZXQgcmVxdWVzdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgcG90ZW50aWFsLUNPUlMgcmVxdWVzdCBnaXZlblxuICAgIC8vIHVybFJlY29yZCwgdGhlIGVtcHR5IHN0cmluZywgYW5kIGNvcnNBdHRyaWJ1dGVTdGF0ZS5cbiAgICBjb25zdCBpbml0UmVxdWVzdCA9IHtcbiAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgIGtlZXBhbGl2ZTogdHJ1ZSxcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdXJscy1hbmQtZmV0Y2hpbmcuaHRtbCNjb3JzLXNldHRpbmdzLWF0dHJpYnV0ZXNcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGNyZWRlbnRpYWxzOiBjb3JzQXR0cmlidXRlU3RhdGUgPT09ICdhbm9ueW1vdXMnXG4gICAgICAgID8gJ3NhbWUtb3JpZ2luJ1xuICAgICAgICA6ICdvbWl0JyxcbiAgICAgIHJlZmVycmVyOiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gOS4gU2V0IHJlcXVlc3QncyBjbGllbnQgdG8gc2V0dGluZ3MuXG4gICAgaW5pdFJlcXVlc3QuY2xpZW50ID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdFxuXG4gICAgLy8gMTAuIFVzZXIgYWdlbnRzIG1heSBzZXQgKGBBY2NlcHRgLCBgdGV4dC9ldmVudC1zdHJlYW1gKSBpbiByZXF1ZXN0J3MgaGVhZGVyIGxpc3QuXG4gICAgaW5pdFJlcXVlc3QuaGVhZGVyc0xpc3QgPSBbWydhY2NlcHQnLCB7IG5hbWU6ICdhY2NlcHQnLCB2YWx1ZTogJ3RleHQvZXZlbnQtc3RyZWFtJyB9XV1cblxuICAgIC8vIDExLiBTZXQgcmVxdWVzdCdzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICAgIGluaXRSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuXG4gICAgLy8gMTIuIFNldCByZXF1ZXN0J3MgaW5pdGlhdG9yIHR5cGUgdG8gXCJvdGhlclwiLlxuICAgIGluaXRSZXF1ZXN0LmluaXRpYXRvciA9ICdvdGhlcidcblxuICAgIGluaXRSZXF1ZXN0LnVybExpc3QgPSBbbmV3IFVSTCh0aGlzLiN1cmwpXVxuXG4gICAgLy8gMTMuIFNldCBldidzIHJlcXVlc3QgdG8gcmVxdWVzdC5cbiAgICB0aGlzLiNyZXF1ZXN0ID0gbWFrZVJlcXVlc3QoaW5pdFJlcXVlc3QpXG5cbiAgICB0aGlzLiNjb25uZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGlzIEV2ZW50U291cmNlIG9iamVjdCdzIGNvbm5lY3Rpb24uIEl0IGNhbiBoYXZlIHRoZVxuICAgKiB2YWx1ZXMgZGVzY3JpYmVkIGJlbG93LlxuICAgKiBAcmV0dXJucyB7MHwxfDJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkeVN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVVJMIHByb3ZpZGluZyB0aGUgZXZlbnQgc3RyZWFtLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCB1cmwgKCkge1xuICAgIHJldHVybiB0aGlzLiN1cmxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIEV2ZW50U291cmNlIG9iamVjdCB3YXNcbiAgICogaW5zdGFudGlhdGVkIHdpdGggQ09SUyBjcmVkZW50aWFscyBzZXQgKHRydWUpLCBvciBub3QgKGZhbHNlLCB0aGUgZGVmYXVsdCkuXG4gICAqL1xuICBnZXQgd2l0aENyZWRlbnRpYWxzICgpIHtcbiAgICByZXR1cm4gdGhpcy4jd2l0aENyZWRlbnRpYWxzXG4gIH1cblxuICAjY29ubmVjdCAoKSB7XG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgPT09IENMT1NFRCkgcmV0dXJuXG5cbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gQ09OTkVDVElOR1xuXG4gICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICByZXF1ZXN0OiB0aGlzLiNyZXF1ZXN0LFxuICAgICAgZGlzcGF0Y2hlcjogdGhpcy4jZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIDE0LiBMZXQgcHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5IGdpdmVuIHJlc3BvbnNlIHJlcyBiZSB0aGUgZm9sbG93aW5nIHN0ZXA6IGlmIHJlcyBpcyBub3QgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlZXN0YWJsaXNoIHRoZSBjb25uZWN0aW9uLlxuICAgIGNvbnN0IHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKGlzTmV0d29ya0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgIH1cblxuICAgICAgdGhpcy4jcmVjb25uZWN0KClcbiAgICB9XG5cbiAgICAvLyAxNS4gRmV0Y2ggcmVxdWVzdCwgd2l0aCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgc2V0IHRvIHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keS4uLlxuICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSA9IHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keVxuXG4gICAgLy8gYW5kIHByb2Nlc3NSZXNwb25zZSBzZXQgdG8gdGhlIGZvbGxvd2luZyBzdGVwcyBnaXZlbiByZXNwb25zZSByZXM6XG4gICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyAxLiBJZiByZXMgaXMgYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yLCB0aGVuIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG5cbiAgICAgIGlmIChpc05ldHdvcmtFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgLy8gMS4gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gZmFpbCB0aGUgY29ubmVjdGlvbiwgdGhlIHVzZXIgYWdlbnRcbiAgICAgICAgLy8gbXVzdCBxdWV1ZSBhIHRhc2sgd2hpY2gsIGlmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYVxuICAgICAgICAvLyB2YWx1ZSBvdGhlciB0aGFuIENMT1NFRCwgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gQ0xPU0VEXG4gICAgICAgIC8vIGFuZCBmaXJlcyBhbiBldmVudCBuYW1lZCBlcnJvciBhdCB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0LiBPbmNlIHRoZVxuICAgICAgICAvLyB1c2VyIGFnZW50IGhhcyBmYWlsZWQgdGhlIGNvbm5lY3Rpb24sIGl0IGRvZXMgbm90IGF0dGVtcHQgdG9cbiAgICAgICAgLy8gcmVjb25uZWN0LlxuICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiByZXMgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlZXN0YWJsaXNoIHRoZVxuICAgICAgICAgIC8vIGNvbm5lY3Rpb24sIHVubGVzcyB0aGUgdXNlciBhZ2VudCBrbm93cyB0aGF0IHRvIGJlIGZ1dGlsZSwgaW5cbiAgICAgICAgICAvLyB3aGljaCBjYXNlIHRoZSB1c2VyIGFnZW50IG1heSBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI3JlY29ubmVjdCgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiByZXMncyBzdGF0dXMgaXMgbm90IDIwMCwgb3IgaWYgcmVzJ3MgYENvbnRlbnQtVHlwZWBcbiAgICAgIC8vIGlzIG5vdCBgdGV4dC9ldmVudC1zdHJlYW1gLCB0aGVuIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnY29udGVudC10eXBlJywgdHJ1ZSlcbiAgICAgIGNvbnN0IG1pbWVUeXBlID0gY29udGVudFR5cGUgIT09IG51bGwgPyBwYXJzZU1JTUVUeXBlKGNvbnRlbnRUeXBlKSA6ICdmYWlsdXJlJ1xuICAgICAgY29uc3QgY29udGVudFR5cGVWYWxpZCA9IG1pbWVUeXBlICE9PSAnZmFpbHVyZScgJiYgbWltZVR5cGUuZXNzZW5jZSA9PT0gJ3RleHQvZXZlbnQtc3RyZWFtJ1xuICAgICAgaWYgKFxuICAgICAgICByZXNwb25zZS5zdGF0dXMgIT09IDIwMCB8fFxuICAgICAgICBjb250ZW50VHlwZVZhbGlkID09PSBmYWxzZVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBhbm5vdW5jZSB0aGUgY29ubmVjdGlvbiBhbmQgaW50ZXJwcmV0IHJlcydzIGJvZHlcbiAgICAgIC8vIGxpbmUgYnkgbGluZS5cblxuICAgICAgLy8gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gYW5ub3VuY2UgdGhlIGNvbm5lY3Rpb24sIHRoZSB1c2VyIGFnZW50XG4gICAgICAvLyBtdXN0IHF1ZXVlIGEgdGFzayB3aGljaCwgaWYgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIHNldCB0byBhXG4gICAgICAvLyB2YWx1ZSBvdGhlciB0aGFuIENMT1NFRCwgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gT1BFTlxuICAgICAgLy8gYW5kIGZpcmVzIGFuIGV2ZW50IG5hbWVkIG9wZW4gYXQgdGhlIEV2ZW50U291cmNlIG9iamVjdC5cbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjc3NlLXByb2Nlc3NpbmctbW9kZWxcbiAgICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBPUEVOXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpXG5cbiAgICAgIC8vIElmIHJlZGlyZWN0ZWQgdG8gYSBkaWZmZXJlbnQgb3JpZ2luLCBzZXQgdGhlIG9yaWdpbiB0byB0aGUgbmV3IG9yaWdpbi5cbiAgICAgIHRoaXMuI3N0YXRlLm9yaWdpbiA9IHJlc3BvbnNlLnVybExpc3RbcmVzcG9uc2UudXJsTGlzdC5sZW5ndGggLSAxXS5vcmlnaW5cblxuICAgICAgY29uc3QgZXZlbnRTb3VyY2VTdHJlYW0gPSBuZXcgRXZlbnRTb3VyY2VTdHJlYW0oe1xuICAgICAgICBldmVudFNvdXJjZVNldHRpbmdzOiB0aGlzLiNzdGF0ZSxcbiAgICAgICAgcHVzaDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQoXG4gICAgICAgICAgICBldmVudC50eXBlLFxuICAgICAgICAgICAgZXZlbnQub3B0aW9uc1xuICAgICAgICAgICkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHBpcGVsaW5lKHJlc3BvbnNlLmJvZHkuc3RyZWFtLFxuICAgICAgICBldmVudFNvdXJjZVN0cmVhbSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXJyb3I/LmFib3J0ZWQgPT09IGZhbHNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuI2NvbnRyb2xsZXIgPSBmZXRjaGluZyhmZXRjaFBhcmFtcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI3NzZS1wcm9jZXNzaW5nLW1vZGVsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgI3JlY29ubmVjdCAoKSB7XG4gICAgLy8gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gcmVlc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24sIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAvLyBydW4gdGhlIGZvbGxvd2luZyBzdGVwcy4gVGhlc2Ugc3RlcHMgYXJlIHJ1biBpbiBwYXJhbGxlbCwgbm90IGFzIHBhcnQgb2ZcbiAgICAvLyBhIHRhc2suIChUaGUgdGFza3MgdGhhdCBpdCBxdWV1ZXMsIG9mIGNvdXJzZSwgYXJlIHJ1biBsaWtlIG5vcm1hbCB0YXNrc1xuICAgIC8vIGFuZCBub3QgdGhlbXNlbHZlcyBpbiBwYXJhbGxlbC4pXG5cbiAgICAvLyAxLiBRdWV1ZSBhIHRhc2sgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5cbiAgICAvLyAgIDEuIElmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gQ0xPU0VELCBhYm9ydCB0aGUgdGFzay5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gQ0xPU0VEKSByZXR1cm5cblxuICAgIC8vICAgMi4gU2V0IHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0byBDT05ORUNUSU5HLlxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG5cbiAgICAvLyAgIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgZXJyb3IgYXQgdGhlIEV2ZW50U291cmNlIG9iamVjdC5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuXG4gICAgLy8gMi4gV2FpdCBhIGRlbGF5IGVxdWFsIHRvIHRoZSByZWNvbm5lY3Rpb24gdGltZSBvZiB0aGUgZXZlbnQgc291cmNlLlxuICAgIGF3YWl0IGRlbGF5KHRoaXMuI3N0YXRlLnJlY29ubmVjdGlvblRpbWUpXG5cbiAgICAvLyA1LiBRdWV1ZSBhIHRhc2sgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5cbiAgICAvLyAgIDEuIElmIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0IHRvXG4gICAgLy8gICAgICBDT05ORUNUSU5HLCB0aGVuIHJldHVybi5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSAhPT0gQ09OTkVDVElORykgcmV0dXJuXG5cbiAgICAvLyAgIDIuIExldCByZXF1ZXN0IGJlIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyByZXF1ZXN0LlxuICAgIC8vICAgMy4gSWYgdGhlIEV2ZW50U291cmNlIG9iamVjdCdzIGxhc3QgZXZlbnQgSUQgc3RyaW5nIGlzIG5vdCB0aGUgZW1wdHlcbiAgICAvLyAgICAgIHN0cmluZywgdGhlbjpcbiAgICAvLyAgICAgIDEuIExldCBsYXN0RXZlbnRJRFZhbHVlIGJlIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyBsYXN0IGV2ZW50IElEXG4gICAgLy8gICAgICAgICBzdHJpbmcsIGVuY29kZWQgYXMgVVRGLTguXG4gICAgLy8gICAgICAyLiBTZXQgKGBMYXN0LUV2ZW50LUlEYCwgbGFzdEV2ZW50SURWYWx1ZSkgaW4gcmVxdWVzdCdzIGhlYWRlclxuICAgIC8vICAgICAgICAgbGlzdC5cbiAgICBpZiAodGhpcy4jc3RhdGUubGFzdEV2ZW50SWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLiNyZXF1ZXN0LmhlYWRlcnNMaXN0LnNldCgnbGFzdC1ldmVudC1pZCcsIHRoaXMuI3N0YXRlLmxhc3RFdmVudElkLCB0cnVlKVxuICAgIH1cblxuICAgIC8vICAgNC4gRmV0Y2ggcmVxdWVzdCBhbmQgcHJvY2VzcyB0aGUgcmVzcG9uc2Ugb2J0YWluZWQgaW4gdGhpcyBmYXNoaW9uLCBpZiBhbnksIGFzIGRlc2NyaWJlZCBlYXJsaWVyIGluIHRoaXMgc2VjdGlvbi5cbiAgICB0aGlzLiNjb25uZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24sIGlmIGFueSwgYW5kIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvXG4gICAqIENMT1NFRC5cbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFdmVudFNvdXJjZSlcblxuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlID09PSBDTE9TRUQpIHJldHVyblxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBDTE9TRURcbiAgICB0aGlzLiNjb250cm9sbGVyLmFib3J0KClcbiAgICB0aGlzLiNyZXF1ZXN0ID0gbnVsbFxuICB9XG5cbiAgZ2V0IG9ub3BlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5vcGVuXG4gIH1cblxuICBzZXQgb25vcGVuIChmbikge1xuICAgIGlmICh0aGlzLiNldmVudHMub3Blbikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy4jZXZlbnRzLm9wZW4pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbm1lc3NhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLiNldmVudHMubWVzc2FnZVxuICB9XG5cbiAgc2V0IG9ubWVzc2FnZSAoZm4pIHtcbiAgICBpZiAodGhpcy4jZXZlbnRzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuI2V2ZW50cy5tZXNzYWdlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5lcnJvclxuICB9XG5cbiAgc2V0IG9uZXJyb3IgKGZuKSB7XG4gICAgaWYgKHRoaXMuI2V2ZW50cy5lcnJvcikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuI2V2ZW50cy5lcnJvcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGNvbnN0YW50c1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIENPTk5FQ1RJTkc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBDT05ORUNUSU5HLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBPUEVOOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogT1BFTixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgQ0xPU0VEOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogQ0xPU0VELFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2ZW50U291cmNlLCBjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzKVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRTb3VyY2UucHJvdG90eXBlLCBjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudFNvdXJjZS5wcm90b3R5cGUsIHtcbiAgY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25vcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHdpdGhDcmVkZW50aWFsczoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRTb3VyY2VJbml0RGljdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3dpdGhDcmVkZW50aWFscycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLCAvLyB1bmRpY2kgb25seVxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdmVudFNvdXJjZSxcbiAgZGVmYXVsdFJlY29ubmVjdGlvblRpbWVcbn1cbiJdLCJuYW1lcyI6WyJwaXBlbGluZSIsInJlcXVpcmUiLCJmZXRjaGluZyIsIm1ha2VSZXF1ZXN0Iiwid2ViaWRsIiwiRXZlbnRTb3VyY2VTdHJlYW0iLCJwYXJzZU1JTUVUeXBlIiwiY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCIsImlzTmV0d29ya0Vycm9yIiwiZGVsYXkiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCIsImV4cGVyaW1lbnRhbFdhcm5lZCIsImRlZmF1bHRSZWNvbm5lY3Rpb25UaW1lIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TRUQiLCJBTk9OWU1PVVMiLCJVU0VfQ1JFREVOVElBTFMiLCJFdmVudFNvdXJjZSIsIkV2ZW50VGFyZ2V0IiwidXJsIiwiZXZlbnRTb3VyY2VJbml0RGljdCIsIm9wZW4iLCJlcnJvciIsIm1lc3NhZ2UiLCJwcmVmaXgiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiY29kZSIsImNvbnZlcnRlcnMiLCJVU1ZTdHJpbmciLCJFdmVudFNvdXJjZUluaXREaWN0IiwiZGlzcGF0Y2hlciIsImxhc3RFdmVudElkIiwicmVjb25uZWN0aW9uVGltZSIsInNldHRpbmdzIiwidXJsUmVjb3JkIiwiVVJMIiwic2V0dGluZ3NPYmplY3QiLCJiYXNlVXJsIiwib3JpZ2luIiwiZSIsIkRPTUV4Y2VwdGlvbiIsImhyZWYiLCJjb3JzQXR0cmlidXRlU3RhdGUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJpbml0UmVxdWVzdCIsInJlZGlyZWN0Iiwia2VlcGFsaXZlIiwibW9kZSIsImNyZWRlbnRpYWxzIiwicmVmZXJyZXIiLCJjbGllbnQiLCJoZWFkZXJzTGlzdCIsIm5hbWUiLCJ2YWx1ZSIsImNhY2hlIiwiaW5pdGlhdG9yIiwidXJsTGlzdCIsInJlYWR5U3RhdGUiLCJmZXRjaFBhcmFtcyIsInJlcXVlc3QiLCJwcm9jZXNzRXZlbnRTb3VyY2VFbmRPZkJvZHkiLCJyZXNwb25zZSIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsImNsb3NlIiwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IiwicHJvY2Vzc1Jlc3BvbnNlIiwiYWJvcnRlZCIsImNvbnRlbnRUeXBlIiwiZ2V0IiwibWltZVR5cGUiLCJjb250ZW50VHlwZVZhbGlkIiwiZXNzZW5jZSIsInN0YXR1cyIsImxlbmd0aCIsImV2ZW50U291cmNlU3RyZWFtIiwiZXZlbnRTb3VyY2VTZXR0aW5ncyIsInB1c2giLCJldmVudCIsInR5cGUiLCJvcHRpb25zIiwiYm9keSIsInN0cmVhbSIsInNldCIsImJyYW5kQ2hlY2siLCJhYm9ydCIsIm9ub3BlbiIsImZuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbm1lc3NhZ2UiLCJvbmVycm9yIiwiY29uc3RhbnRzUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fcHJvdG9fXyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiYm9vbGVhbiIsImRlZmF1bHRWYWx1ZSIsImFueSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/util.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n/**\n * Checks if the given value is a valid LastEventId.\n * @param {string} value\n * @returns {boolean}\n */ function isValidLastEventId(value) {\n    // LastEventId should not contain U+0000 NULL\n    return value.indexOf('\\u0000') === -1;\n}\n/**\n * Checks if the given value is a base 10 digit.\n * @param {string} value\n * @returns {boolean}\n */ function isASCIINumber(value) {\n    if (value.length === 0) return false;\n    for(let i = 0; i < value.length; i++){\n        if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false;\n    }\n    return true;\n}\n// https://github.com/nodejs/undici/issues/2664\nfunction delay(ms) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms).unref();\n    });\n}\nmodule.exports = {\n    isValidLastEventId,\n    isASCIINumber,\n    delay\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTQSxtQkFBb0JDLEtBQUs7SUFDaEMsNkNBQTZDO0lBQzdDLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQyxjQUFjLENBQUM7QUFDdEM7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0MsY0FBZUYsS0FBSztJQUMzQixJQUFJQSxNQUFNRyxNQUFNLEtBQUssR0FBRyxPQUFPO0lBQy9CLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixNQUFNRyxNQUFNLEVBQUVDLElBQUs7UUFDckMsSUFBSUosTUFBTUssVUFBVSxDQUFDRCxLQUFLLFFBQVFKLE1BQU1LLFVBQVUsQ0FBQ0QsS0FBSyxNQUFNLE9BQU87SUFDdkU7SUFDQSxPQUFPO0FBQ1Q7QUFFQSwrQ0FBK0M7QUFDL0MsU0FBU0UsTUFBT0MsRUFBRTtJQUNoQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0M7UUFDbEJDLFdBQVdELFNBQVNGLElBQUlJLEtBQUs7SUFDL0I7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZmQ7SUFDQUc7SUFDQUk7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGV2ZW50c291cmNlXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBMYXN0RXZlbnRJZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRMYXN0RXZlbnRJZCAodmFsdWUpIHtcbiAgLy8gTGFzdEV2ZW50SWQgc2hvdWxkIG5vdCBjb250YWluIFUrMDAwMCBOVUxMXG4gIHJldHVybiB2YWx1ZS5pbmRleE9mKCdcXHUwMDAwJykgPT09IC0xXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGJhc2UgMTAgZGlnaXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FTQ0lJTnVtYmVyICh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh2YWx1ZS5jaGFyQ29kZUF0KGkpIDwgMHgzMCB8fCB2YWx1ZS5jaGFyQ29kZUF0KGkpID4gMHgzOSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2NjRcbmZ1bmN0aW9uIGRlbGF5IChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKS51bnJlZigpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1ZhbGlkTGFzdEV2ZW50SWQsXG4gIGlzQVNDSUlOdW1iZXIsXG4gIGRlbGF5XG59XG4iXSwibmFtZXMiOlsiaXNWYWxpZExhc3RFdmVudElkIiwidmFsdWUiLCJpbmRleE9mIiwiaXNBU0NJSU51bWJlciIsImxlbmd0aCIsImkiLCJjaGFyQ29kZUF0IiwiZGVsYXkiLCJtcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInVucmVmIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/body.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom, isBlobLike, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody, extractMimeType, utf8DecodeBytes } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { isErrored } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { isArrayBuffer } = __webpack_require__(/*! node:util/types */ \"node:util/types\");\nconst { serializeAMimeType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { multipartFormDataParser } = __webpack_require__(/*! ./formdata-parser */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js\");\nconst textEncoder = new TextEncoder();\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object, keepalive = false) {\n    // 1. Let stream be null.\n    let stream = null;\n    // 2. If object is a ReadableStream object, then set stream to object.\n    if (object instanceof ReadableStream) {\n        stream = object;\n    } else if (isBlobLike(object)) {\n        // 3. Otherwise, if object is a Blob object, set stream to the\n        //    result of running object’s get stream.\n        stream = object.stream();\n    } else {\n        // 4. Otherwise, set stream to a new ReadableStream object, and set\n        //    up stream with byte reading support.\n        stream = new ReadableStream({\n            async pull (controller) {\n                const buffer = typeof source === 'string' ? textEncoder.encode(source) : source;\n                if (buffer.byteLength) {\n                    controller.enqueue(buffer);\n                }\n                queueMicrotask(()=>readableStreamClose(controller));\n            },\n            start () {},\n            type: 'bytes'\n        });\n    }\n    // 5. Assert: stream is a ReadableStream object.\n    assert(isReadableStreamLike(stream));\n    // 6. Let action be null.\n    let action = null;\n    // 7. Let source be null.\n    let source = null;\n    // 8. Let length be null.\n    let length = null;\n    // 9. Let type be null.\n    let type = null;\n    // 10. Switch on object:\n    if (typeof object === 'string') {\n        // Set source to the UTF-8 encoding of object.\n        // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n        source = object;\n        // Set type to `text/plain;charset=UTF-8`.\n        type = 'text/plain;charset=UTF-8';\n    } else if (object instanceof URLSearchParams) {\n        // URLSearchParams\n        // spec says to run application/x-www-form-urlencoded on body.list\n        // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n        // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n        // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n        // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n        source = object.toString();\n        // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n        type = 'application/x-www-form-urlencoded;charset=UTF-8';\n    } else if (isArrayBuffer(object)) {\n        // BufferSource/ArrayBuffer\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.slice());\n    } else if (ArrayBuffer.isView(object)) {\n        // BufferSource/ArrayBufferView\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n    } else if (util.isFormDataLike(object)) {\n        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`;\n        const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n        /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ const escape = (str)=>str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n        const normalizeLinefeeds = (value)=>value.replace(/\\r?\\n|\\r/g, '\\r\\n');\n        // Set action to this step: run the multipart/form-data\n        // encoding algorithm, with object’s entry list and UTF-8.\n        // - This ensures that the body is immutable and can't be changed afterwords\n        // - That the content-length is calculated in advance.\n        // - And that all parts are pre-encoded and ready to be sent.\n        const blobParts = [];\n        const rn = new Uint8Array([\n            13,\n            10\n        ]) // '\\r\\n'\n        ;\n        length = 0;\n        let hasUnknownSizeValue = false;\n        for (const [name, value] of object){\n            if (typeof value === 'string') {\n                const chunk = textEncoder.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n                blobParts.push(chunk);\n                length += chunk.byteLength;\n            } else {\n                const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n                blobParts.push(chunk, value, rn);\n                if (typeof value.size === 'number') {\n                    length += chunk.byteLength + value.size + rn.byteLength;\n                } else {\n                    hasUnknownSizeValue = true;\n                }\n            }\n        }\n        const chunk = textEncoder.encode(`--${boundary}--`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n        if (hasUnknownSizeValue) {\n            length = null;\n        }\n        // Set source to object.\n        source = object;\n        action = async function*() {\n            for (const part of blobParts){\n                if (part.stream) {\n                    yield* part.stream();\n                } else {\n                    yield part;\n                }\n            }\n        };\n        // Set type to `multipart/form-data; boundary=`,\n        // followed by the multipart/form-data boundary string generated\n        // by the multipart/form-data encoding algorithm.\n        type = `multipart/form-data; boundary=${boundary}`;\n    } else if (isBlobLike(object)) {\n        // Blob\n        // Set source to object.\n        source = object;\n        // Set length to object’s size.\n        length = object.size;\n        // If object’s type attribute is not the empty byte sequence, set\n        // type to its value.\n        if (object.type) {\n            type = object.type;\n        }\n    } else if (typeof object[Symbol.asyncIterator] === 'function') {\n        // If keepalive is true, then throw a TypeError.\n        if (keepalive) {\n            throw new TypeError('keepalive');\n        }\n        // If object is disturbed or locked, then throw a TypeError.\n        if (util.isDisturbed(object) || object.locked) {\n            throw new TypeError('Response body object should not be disturbed or locked');\n        }\n        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n    }\n    // 11. If source is a byte sequence, then set action to a\n    // step that returns source and length to source’s length.\n    if (typeof source === 'string' || util.isBuffer(source)) {\n        length = Buffer.byteLength(source);\n    }\n    // 12. If action is non-null, then run these steps in in parallel:\n    if (action != null) {\n        // Run action.\n        let iterator;\n        stream = new ReadableStream({\n            async start () {\n                iterator = action(object)[Symbol.asyncIterator]();\n            },\n            async pull (controller) {\n                const { value, done } = await iterator.next();\n                if (done) {\n                    // When running action is done, close stream.\n                    queueMicrotask(()=>{\n                        controller.close();\n                        controller.byobRequest?.respond(0);\n                    });\n                } else {\n                    // Whenever one or more bytes are available and stream is not errored,\n                    // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n                    // bytes into stream.\n                    if (!isErrored(stream)) {\n                        const buffer = new Uint8Array(value);\n                        if (buffer.byteLength) {\n                            controller.enqueue(buffer);\n                        }\n                    }\n                }\n                return controller.desiredSize > 0;\n            },\n            async cancel (reason) {\n                await iterator.return();\n            },\n            type: 'bytes'\n        });\n    }\n    // 13. Let body be a body whose stream is stream, source is source,\n    // and length is length.\n    const body = {\n        stream,\n        source,\n        length\n    };\n    // 14. Return (body, type).\n    return [\n        body,\n        type\n    ];\n}\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object, keepalive = false) {\n    // To safely extract a body and a `Content-Type` value from\n    // a byte sequence or BodyInit object object, run these steps:\n    // 1. If object is a ReadableStream object, then:\n    if (object instanceof ReadableStream) {\n        // Assert: object is neither disturbed nor locked.\n        // istanbul ignore next\n        assert(!util.isDisturbed(object), 'The body has already been consumed.');\n        // istanbul ignore next\n        assert(!object.locked, 'The stream is locked.');\n    }\n    // 2. Return the results of extracting object.\n    return extractBody(object, keepalive);\n}\nfunction cloneBody(body) {\n    // To clone a body body, run these steps:\n    // https://fetch.spec.whatwg.org/#concept-body-clone\n    // 1. Let « out1, out2 » be the result of teeing body’s stream.\n    const [out1, out2] = body.stream.tee();\n    // 2. Set body’s stream to out1.\n    body.stream = out1;\n    // 3. Return a body whose stream is out2 and other members are copied from body.\n    return {\n        stream: out2,\n        length: body.length,\n        source: body.source\n    };\n}\nfunction throwIfAborted(state) {\n    if (state.aborted) {\n        throw new DOMException('The operation was aborted.', 'AbortError');\n    }\n}\nfunction bodyMixinMethods(instance) {\n    const methods = {\n        blob () {\n            // The blob() method steps are to return the result of\n            // running consume body with this and the following step\n            // given a byte sequence bytes: return a Blob whose\n            // contents are bytes and whose type attribute is this’s\n            // MIME type.\n            return consumeBody(this, (bytes)=>{\n                let mimeType = bodyMimeType(this);\n                if (mimeType === null) {\n                    mimeType = '';\n                } else if (mimeType) {\n                    mimeType = serializeAMimeType(mimeType);\n                }\n                // Return a Blob whose contents are bytes and type attribute\n                // is mimeType.\n                return new Blob([\n                    bytes\n                ], {\n                    type: mimeType\n                });\n            }, instance);\n        },\n        arrayBuffer () {\n            // The arrayBuffer() method steps are to return the result\n            // of running consume body with this and the following step\n            // given a byte sequence bytes: return a new ArrayBuffer\n            // whose contents are bytes.\n            return consumeBody(this, (bytes)=>{\n                return new Uint8Array(bytes).buffer;\n            }, instance);\n        },\n        text () {\n            // The text() method steps are to return the result of running\n            // consume body with this and UTF-8 decode.\n            return consumeBody(this, utf8DecodeBytes, instance);\n        },\n        json () {\n            // The json() method steps are to return the result of running\n            // consume body with this and parse JSON from bytes.\n            return consumeBody(this, parseJSONFromBytes, instance);\n        },\n        formData () {\n            // The formData() method steps are to return the result of running\n            // consume body with this and the following step given a byte sequence bytes:\n            return consumeBody(this, (value)=>{\n                // 1. Let mimeType be the result of get the MIME type with this.\n                const mimeType = bodyMimeType(this);\n                // 2. If mimeType is non-null, then switch on mimeType’s essence and run\n                //    the corresponding steps:\n                if (mimeType !== null) {\n                    switch(mimeType.essence){\n                        case 'multipart/form-data':\n                            {\n                                // 1. ... [long step]\n                                const parsed = multipartFormDataParser(value, mimeType);\n                                // 2. If that fails for some reason, then throw a TypeError.\n                                if (parsed === 'failure') {\n                                    throw new TypeError('Failed to parse body as FormData.');\n                                }\n                                // 3. Return a new FormData object, appending each entry,\n                                //    resulting from the parsing operation, to its entry list.\n                                const fd = new FormData();\n                                fd[kState] = parsed;\n                                return fd;\n                            }\n                        case 'application/x-www-form-urlencoded':\n                            {\n                                // 1. Let entries be the result of parsing bytes.\n                                const entries = new URLSearchParams(value.toString());\n                                // 2. If entries is failure, then throw a TypeError.\n                                // 3. Return a new FormData object whose entry list is entries.\n                                const fd = new FormData();\n                                for (const [name, value] of entries){\n                                    fd.append(name, value);\n                                }\n                                return fd;\n                            }\n                    }\n                }\n                // 3. Throw a TypeError.\n                throw new TypeError('Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".');\n            }, instance);\n        },\n        bytes () {\n            // The bytes() method steps are to return the result of running consume body\n            // with this and the following step given a byte sequence bytes: return the\n            // result of creating a Uint8Array from bytes in this’s relevant realm.\n            return consumeBody(this, (bytes)=>{\n                return new Uint8Array(bytes);\n            }, instance);\n        }\n    };\n    return methods;\n}\nfunction mixinBody(prototype) {\n    Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */ async function consumeBody(object, convertBytesToJSValue, instance) {\n    webidl.brandCheck(object, instance);\n    // 1. If object is unusable, then return a promise rejected\n    //    with a TypeError.\n    if (bodyUnusable(object[kState].body)) {\n        throw new TypeError('Body is unusable: Body has already been read');\n    }\n    throwIfAborted(object[kState]);\n    // 2. Let promise be a new promise.\n    const promise = createDeferredPromise();\n    // 3. Let errorSteps given error be to reject promise with error.\n    const errorSteps = (error)=>promise.reject(error);\n    // 4. Let successSteps given a byte sequence data be to resolve\n    //    promise with the result of running convertBytesToJSValue\n    //    with data. If that threw an exception, then run errorSteps\n    //    with that exception.\n    const successSteps = (data)=>{\n        try {\n            promise.resolve(convertBytesToJSValue(data));\n        } catch (e) {\n            errorSteps(e);\n        }\n    };\n    // 5. If object’s body is null, then run successSteps with an\n    //    empty byte sequence.\n    if (object[kState].body == null) {\n        successSteps(Buffer.allocUnsafe(0));\n        return promise.promise;\n    }\n    // 6. Otherwise, fully read object’s body given successSteps,\n    //    errorSteps, and object’s relevant global object.\n    await fullyReadBody(object[kState].body, successSteps, errorSteps);\n    // 7. Return promise.\n    return promise.promise;\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable(body) {\n    // An object including the Body interface mixin is\n    // said to be unusable if its body is non-null and\n    // its body’s stream is disturbed or locked.\n    return body != null && (body.stream.locked || util.isDisturbed(body.stream));\n}\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */ function parseJSONFromBytes(bytes) {\n    return JSON.parse(utf8DecodeBytes(bytes));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} requestOrResponse\n */ function bodyMimeType(requestOrResponse) {\n    // 1. Let headers be null.\n    // 2. If requestOrResponse is a Request object, then set headers to requestOrResponse’s request’s header list.\n    // 3. Otherwise, set headers to requestOrResponse’s response’s header list.\n    /** @type {import('./headers').HeadersList} */ const headers = requestOrResponse[kState].headersList;\n    // 4. Let mimeType be the result of extracting a MIME type from headers.\n    const mimeType = extractMimeType(headers);\n    // 5. If mimeType is failure, then return null.\n    if (mimeType === 'failure') {\n        return null;\n    }\n    // 6. Return mimeType.\n    return mimeType;\n}\nmodule.exports = {\n    extractBody,\n    safelyExtractBody,\n    cloneBody,\n    mixinBody\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvYm9keS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDLHFFQUFpQjtBQUN0QyxNQUFNLEVBQ0pDLGtCQUFrQixFQUNsQkMsVUFBVSxFQUNWQyxvQkFBb0IsRUFDcEJDLG1CQUFtQixFQUNuQkMscUJBQXFCLEVBQ3JCQyxhQUFhLEVBQ2JDLGVBQWUsRUFDZkMsZUFBZSxFQUNoQixHQUFHUixtQkFBT0EsQ0FBQyxpRUFBUTtBQUNwQixNQUFNLEVBQUVTLFFBQVEsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN6QyxNQUFNLEVBQUVVLE1BQU0sRUFBRSxHQUFHVixtQkFBT0EsQ0FBQyx1RUFBVztBQUN0QyxNQUFNLEVBQUVXLE1BQU0sRUFBRSxHQUFHWCxtQkFBT0EsQ0FBQyxxRUFBVTtBQUNyQyxNQUFNLEVBQUVZLElBQUksRUFBRSxHQUFHWixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUN0QyxNQUFNYSxTQUFTYixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNLEVBQUVjLFNBQVMsRUFBRSxHQUFHZCxtQkFBT0EsQ0FBQyxxRUFBaUI7QUFDL0MsTUFBTSxFQUFFZSxhQUFhLEVBQUUsR0FBR2YsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ25ELE1BQU0sRUFBRWdCLGtCQUFrQixFQUFFLEdBQUdoQixtQkFBT0EsQ0FBQyx5RUFBWTtBQUNuRCxNQUFNLEVBQUVpQix1QkFBdUIsRUFBRSxHQUFHakIsbUJBQU9BLENBQUMsdUZBQW1CO0FBRS9ELE1BQU1rQixjQUFjLElBQUlDO0FBRXhCLDBEQUEwRDtBQUMxRCxTQUFTQyxZQUFhQyxNQUFNLEVBQUVDLFlBQVksS0FBSztJQUM3Qyx5QkFBeUI7SUFDekIsSUFBSUMsU0FBUztJQUViLHNFQUFzRTtJQUN0RSxJQUFJRixrQkFBa0JHLGdCQUFnQjtRQUNwQ0QsU0FBU0Y7SUFDWCxPQUFPLElBQUluQixXQUFX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QjtJQUN0QywwQkFBMEI7SUFDMUIsOEdBQThHO0lBQzlHLDJFQUEyRTtJQUMzRSw0Q0FBNEMsR0FDNUMsTUFBTUMsVUFBVUQsaUJBQWlCLENBQUNySCxPQUFPLENBQUN1SCxXQUFXO0lBRXJELHdFQUF3RTtJQUN4RSxNQUFNaEMsV0FBVzFGLGdCQUFnQnlIO0lBRWpDLCtDQUErQztJQUMvQyxJQUFJL0IsYUFBYSxXQUFXO1FBQzFCLE9BQU87SUFDVDtJQUVBLHNCQUFzQjtJQUN0QixPQUFPQTtBQUNUO0FBRUFpQyxPQUFPQyxPQUFPLEdBQUc7SUFDZi9HO0lBQ0E4RDtJQUNBQztJQUNBMEI7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxib2R5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHtcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICBpc0Jsb2JMaWtlLFxuICBpc1JlYWRhYmxlU3RyZWFtTGlrZSxcbiAgcmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBmdWxseVJlYWRCb2R5LFxuICBleHRyYWN0TWltZVR5cGUsXG4gIHV0ZjhEZWNvZGVCeXRlc1xufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEZvcm1EYXRhIH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IHsga1N0YXRlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgQmxvYiB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBpc0Vycm9yZWQgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGlzQXJyYXlCdWZmZXIgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbC90eXBlcycpXG5jb25zdCB7IHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IG11bHRpcGFydEZvcm1EYXRhUGFyc2VyIH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhLXBhcnNlcicpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuZnVuY3Rpb24gZXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgLy8gMS4gTGV0IHN0cmVhbSBiZSBudWxsLlxuICBsZXQgc3RyZWFtID0gbnVsbFxuXG4gIC8vIDIuIElmIG9iamVjdCBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgdGhlbiBzZXQgc3RyZWFtIHRvIG9iamVjdC5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgc3RyZWFtID0gb2JqZWN0XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShvYmplY3QpKSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgYSBCbG9iIG9iamVjdCwgc2V0IHN0cmVhbSB0byB0aGVcbiAgICAvLyAgICByZXN1bHQgb2YgcnVubmluZyBvYmplY3TigJlzIGdldCBzdHJlYW0uXG4gICAgc3RyZWFtID0gb2JqZWN0LnN0cmVhbSgpXG4gIH0gZWxzZSB7XG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBzZXQgc3RyZWFtIHRvIGEgbmV3IFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgYW5kIHNldFxuICAgIC8vICAgIHVwIHN0cmVhbSB3aXRoIGJ5dGUgcmVhZGluZyBzdXBwb3J0LlxuICAgIHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gdGV4dEVuY29kZXIuZW5jb2RlKHNvdXJjZSkgOiBzb3VyY2VcblxuICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYnVmZmVyKVxuICAgICAgICB9XG5cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyKSlcbiAgICAgIH0sXG4gICAgICBzdGFydCAoKSB7fSxcbiAgICAgIHR5cGU6ICdieXRlcydcbiAgICB9KVxuICB9XG5cbiAgLy8gNS4gQXNzZXJ0OiBzdHJlYW0gaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QuXG4gIGFzc2VydChpc1JlYWRhYmxlU3RyZWFtTGlrZShzdHJlYW0pKVxuXG4gIC8vIDYuIExldCBhY3Rpb24gYmUgbnVsbC5cbiAgbGV0IGFjdGlvbiA9IG51bGxcblxuICAvLyA3LiBMZXQgc291cmNlIGJlIG51bGwuXG4gIGxldCBzb3VyY2UgPSBudWxsXG5cbiAgLy8gOC4gTGV0IGxlbmd0aCBiZSBudWxsLlxuICBsZXQgbGVuZ3RoID0gbnVsbFxuXG4gIC8vIDkuIExldCB0eXBlIGJlIG51bGwuXG4gIGxldCB0eXBlID0gbnVsbFxuXG4gIC8vIDEwLiBTd2l0Y2ggb24gb2JqZWN0OlxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBvYmplY3QuXG4gICAgLy8gTm90ZTogc2V0dGluZyBzb3VyY2UgdG8gYSBVaW50OEFycmF5IGhlcmUgYnJlYWtzIHNvbWUgbW9ja2luZyBhc3N1bXB0aW9ucy5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCB0eXBlIHRvIGB0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04J1xuICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIC8vIFVSTFNlYXJjaFBhcmFtc1xuXG4gICAgLy8gc3BlYyBzYXlzIHRvIHJ1biBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgb24gYm9keS5saXN0XG4gICAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBOb2RlLmpzIGFzIGFwYXJ0IG9mIGFuIFVSTFNlYXJjaFBhcmFtcyBpbnN0YW5jZSB0b1N0cmluZyBtZXRob2RcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMNDkwXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMMTEwMFxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBzZXJpYWxpemVyIHdpdGggb2JqZWN04oCZcyBsaXN0LlxuICAgIHNvdXJjZSA9IG9iamVjdC50b1N0cmluZygpXG5cbiAgICAvLyBTZXQgdHlwZSB0byBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihvYmplY3QpKSB7XG4gICAgLy8gQnVmZmVyU291cmNlL0FycmF5QnVmZmVyXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LnNsaWNlKCkpXG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJWaWV3XG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LmJ1ZmZlci5zbGljZShvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0LmJ5dGVPZmZzZXQgKyBvYmplY3QuYnl0ZUxlbmd0aCkpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0Zvcm1EYXRhTGlrZShvYmplY3QpKSB7XG4gICAgY29uc3QgYm91bmRhcnkgPSBgLS0tLWZvcm1kYXRhLXVuZGljaS0wJHtgJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTExKX1gLnBhZFN0YXJ0KDExLCAnMCcpfWBcbiAgICBjb25zdCBwcmVmaXggPSBgLS0ke2JvdW5kYXJ5fVxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YWBcblxuICAgIC8qISBmb3JtZGF0YS1wb2x5ZmlsbC4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cbiAgICBjb25zdCBlc2NhcGUgPSAoc3RyKSA9PlxuICAgICAgc3RyLnJlcGxhY2UoL1xcbi9nLCAnJTBBJykucmVwbGFjZSgvXFxyL2csICclMEQnKS5yZXBsYWNlKC9cIi9nLCAnJTIyJylcbiAgICBjb25zdCBub3JtYWxpemVMaW5lZmVlZHMgPSAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csICdcXHJcXG4nKVxuXG4gICAgLy8gU2V0IGFjdGlvbiB0byB0aGlzIHN0ZXA6IHJ1biB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YVxuICAgIC8vIGVuY29kaW5nIGFsZ29yaXRobSwgd2l0aCBvYmplY3TigJlzIGVudHJ5IGxpc3QgYW5kIFVURi04LlxuICAgIC8vIC0gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGJvZHkgaXMgaW1tdXRhYmxlIGFuZCBjYW4ndCBiZSBjaGFuZ2VkIGFmdGVyd29yZHNcbiAgICAvLyAtIFRoYXQgdGhlIGNvbnRlbnQtbGVuZ3RoIGlzIGNhbGN1bGF0ZWQgaW4gYWR2YW5jZS5cbiAgICAvLyAtIEFuZCB0aGF0IGFsbCBwYXJ0cyBhcmUgcHJlLWVuY29kZWQgYW5kIHJlYWR5IHRvIGJlIHNlbnQuXG5cbiAgICBjb25zdCBibG9iUGFydHMgPSBbXVxuICAgIGNvbnN0IHJuID0gbmV3IFVpbnQ4QXJyYXkoWzEzLCAxMF0pIC8vICdcXHJcXG4nXG4gICAgbGVuZ3RoID0gMFxuICAgIGxldCBoYXNVbmtub3duU2l6ZVZhbHVlID0gZmFsc2VcblxuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGV4dEVuY29kZXIuZW5jb2RlKHByZWZpeCArXG4gICAgICAgICAgYDsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICBgXFxyXFxuXFxyXFxuJHtub3JtYWxpemVMaW5lZmVlZHModmFsdWUpfVxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYCR7cHJlZml4fTsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICAodmFsdWUubmFtZSA/IGA7IGZpbGVuYW1lPVwiJHtlc2NhcGUodmFsdWUubmFtZSl9XCJgIDogJycpICsgJ1xcclxcbicgK1xuICAgICAgICAgIGBDb250ZW50LVR5cGU6ICR7XG4gICAgICAgICAgICB2YWx1ZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgICAgfVxcclxcblxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rLCB2YWx1ZSwgcm4pXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aCArIHZhbHVlLnNpemUgKyBybi5ieXRlTGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzVW5rbm93blNpemVWYWx1ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNodW5rID0gdGV4dEVuY29kZXIuZW5jb2RlKGAtLSR7Ym91bmRhcnl9LS1gKVxuICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgaWYgKGhhc1Vua25vd25TaXplVmFsdWUpIHtcbiAgICAgIGxlbmd0aCA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBTZXQgc291cmNlIHRvIG9iamVjdC5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIGFjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGJsb2JQYXJ0cykge1xuICAgICAgICBpZiAocGFydC5zdHJlYW0pIHtcbiAgICAgICAgICB5aWVsZCAqIHBhcnQuc3RyZWFtKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBwYXJ0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdHlwZSB0byBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9YCxcbiAgICAvLyBmb2xsb3dlZCBieSB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBib3VuZGFyeSBzdHJpbmcgZ2VuZXJhdGVkXG4gICAgLy8gYnkgdGhlIG11bHRpcGFydC9mb3JtLWRhdGEgZW5jb2RpbmcgYWxnb3JpdGhtLlxuICAgIHR5cGUgPSBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtib3VuZGFyeX1gXG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShvYmplY3QpKSB7XG4gICAgLy8gQmxvYlxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byBvYmplY3QuXG4gICAgc291cmNlID0gb2JqZWN0XG5cbiAgICAvLyBTZXQgbGVuZ3RoIHRvIG9iamVjdOKAmXMgc2l6ZS5cbiAgICBsZW5ndGggPSBvYmplY3Quc2l6ZVxuXG4gICAgLy8gSWYgb2JqZWN04oCZcyB0eXBlIGF0dHJpYnV0ZSBpcyBub3QgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UsIHNldFxuICAgIC8vIHR5cGUgdG8gaXRzIHZhbHVlLlxuICAgIGlmIChvYmplY3QudHlwZSkge1xuICAgICAgdHlwZSA9IG9iamVjdC50eXBlXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYga2VlcGFsaXZlIGlzIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGtlZXBhbGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2VlcGFsaXZlJylcbiAgICB9XG5cbiAgICAvLyBJZiBvYmplY3QgaXMgZGlzdHVyYmVkIG9yIGxvY2tlZCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodXRpbC5pc0Rpc3R1cmJlZChvYmplY3QpIHx8IG9iamVjdC5sb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdSZXNwb25zZSBib2R5IG9iamVjdCBzaG91bGQgbm90IGJlIGRpc3R1cmJlZCBvciBsb2NrZWQnXG4gICAgICApXG4gICAgfVxuXG4gICAgc3RyZWFtID1cbiAgICAgIG9iamVjdCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtID8gb2JqZWN0IDogUmVhZGFibGVTdHJlYW1Gcm9tKG9iamVjdClcbiAgfVxuXG4gIC8vIDExLiBJZiBzb3VyY2UgaXMgYSBieXRlIHNlcXVlbmNlLCB0aGVuIHNldCBhY3Rpb24gdG8gYVxuICAvLyBzdGVwIHRoYXQgcmV0dXJucyBzb3VyY2UgYW5kIGxlbmd0aCB0byBzb3VyY2XigJlzIGxlbmd0aC5cbiAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnIHx8IHV0aWwuaXNCdWZmZXIoc291cmNlKSkge1xuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHNvdXJjZSlcbiAgfVxuXG4gIC8vIDEyLiBJZiBhY3Rpb24gaXMgbm9uLW51bGwsIHRoZW4gcnVuIHRoZXNlIHN0ZXBzIGluIGluIHBhcmFsbGVsOlxuICBpZiAoYWN0aW9uICE9IG51bGwpIHtcbiAgICAvLyBSdW4gYWN0aW9uLlxuICAgIGxldCBpdGVyYXRvclxuICAgIHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydCAoKSB7XG4gICAgICAgIGl0ZXJhdG9yID0gYWN0aW9uKG9iamVjdClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIC8vIFdoZW4gcnVubmluZyBhY3Rpb24gaXMgZG9uZSwgY2xvc2Ugc3RyZWFtLlxuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKVxuICAgICAgICAgICAgY29udHJvbGxlci5ieW9iUmVxdWVzdD8ucmVzcG9uZCgwKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2hlbmV2ZXIgb25lIG9yIG1vcmUgYnl0ZXMgYXJlIGF2YWlsYWJsZSBhbmQgc3RyZWFtIGlzIG5vdCBlcnJvcmVkLFxuICAgICAgICAgIC8vIGVucXVldWUgYSBVaW50OEFycmF5IHdyYXBwaW5nIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIGF2YWlsYWJsZVxuICAgICAgICAgIC8vIGJ5dGVzIGludG8gc3RyZWFtLlxuICAgICAgICAgIGlmICghaXNFcnJvcmVkKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlKVxuICAgICAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShidWZmZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMFxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICB9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH0pXG4gIH1cblxuICAvLyAxMy4gTGV0IGJvZHkgYmUgYSBib2R5IHdob3NlIHN0cmVhbSBpcyBzdHJlYW0sIHNvdXJjZSBpcyBzb3VyY2UsXG4gIC8vIGFuZCBsZW5ndGggaXMgbGVuZ3RoLlxuICBjb25zdCBib2R5ID0geyBzdHJlYW0sIHNvdXJjZSwgbGVuZ3RoIH1cblxuICAvLyAxNC4gUmV0dXJuIChib2R5LCB0eXBlKS5cbiAgcmV0dXJuIFtib2R5LCB0eXBlXVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keWluaXQtc2FmZWx5LWV4dHJhY3RcbmZ1bmN0aW9uIHNhZmVseUV4dHJhY3RCb2R5IChvYmplY3QsIGtlZXBhbGl2ZSA9IGZhbHNlKSB7XG4gIC8vIFRvIHNhZmVseSBleHRyYWN0IGEgYm9keSBhbmQgYSBgQ29udGVudC1UeXBlYCB2YWx1ZSBmcm9tXG4gIC8vIGEgYnl0ZSBzZXF1ZW5jZSBvciBCb2R5SW5pdCBvYmplY3Qgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIGEgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCB0aGVuOlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAvLyBBc3NlcnQ6IG9iamVjdCBpcyBuZWl0aGVyIGRpc3R1cmJlZCBub3IgbG9ja2VkLlxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgYXNzZXJ0KCF1dGlsLmlzRGlzdHVyYmVkKG9iamVjdCksICdUaGUgYm9keSBoYXMgYWxyZWFkeSBiZWVuIGNvbnN1bWVkLicpXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBhc3NlcnQoIW9iamVjdC5sb2NrZWQsICdUaGUgc3RyZWFtIGlzIGxvY2tlZC4nKVxuICB9XG5cbiAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGV4dHJhY3Rpbmcgb2JqZWN0LlxuICByZXR1cm4gZXh0cmFjdEJvZHkob2JqZWN0LCBrZWVwYWxpdmUpXG59XG5cbmZ1bmN0aW9uIGNsb25lQm9keSAoYm9keSkge1xuICAvLyBUbyBjbG9uZSBhIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY2xvbmVcblxuICAvLyAxLiBMZXQgwqsgb3V0MSwgb3V0MiDCuyBiZSB0aGUgcmVzdWx0IG9mIHRlZWluZyBib2R54oCZcyBzdHJlYW0uXG4gIGNvbnN0IFtvdXQxLCBvdXQyXSA9IGJvZHkuc3RyZWFtLnRlZSgpXG5cbiAgLy8gMi4gU2V0IGJvZHnigJlzIHN0cmVhbSB0byBvdXQxLlxuICBib2R5LnN0cmVhbSA9IG91dDFcblxuICAvLyAzLiBSZXR1cm4gYSBib2R5IHdob3NlIHN0cmVhbSBpcyBvdXQyIGFuZCBvdGhlciBtZW1iZXJzIGFyZSBjb3BpZWQgZnJvbSBib2R5LlxuICByZXR1cm4ge1xuICAgIHN0cmVhbTogb3V0MixcbiAgICBsZW5ndGg6IGJvZHkubGVuZ3RoLFxuICAgIHNvdXJjZTogYm9keS5zb3VyY2VcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0lmQWJvcnRlZCAoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJylcbiAgfVxufVxuXG5mdW5jdGlvbiBib2R5TWl4aW5NZXRob2RzIChpbnN0YW5jZSkge1xuICBjb25zdCBtZXRob2RzID0ge1xuICAgIGJsb2IgKCkge1xuICAgICAgLy8gVGhlIGJsb2IoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyBydW5uaW5nIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHRoZSBmb2xsb3dpbmcgc3RlcFxuICAgICAgLy8gZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gYSBCbG9iIHdob3NlXG4gICAgICAvLyBjb250ZW50cyBhcmUgYnl0ZXMgYW5kIHdob3NlIHR5cGUgYXR0cmlidXRlIGlzIHRoaXPigJlzXG4gICAgICAvLyBNSU1FIHR5cGUuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IGJvZHlNaW1lVHlwZSh0aGlzKVxuXG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG1pbWVUeXBlID0gJydcbiAgICAgICAgfSBlbHNlIGlmIChtaW1lVHlwZSkge1xuICAgICAgICAgIG1pbWVUeXBlID0gc2VyaWFsaXplQU1pbWVUeXBlKG1pbWVUeXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgQmxvYiB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMgYW5kIHR5cGUgYXR0cmlidXRlXG4gICAgICAgIC8vIGlzIG1pbWVUeXBlLlxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2J5dGVzXSwgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGFycmF5QnVmZmVyICgpIHtcbiAgICAgIC8vIFRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgIC8vIG9mIHJ1bm5pbmcgY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwXG4gICAgICAvLyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6IHJldHVybiBhIG5ldyBBcnJheUJ1ZmZlclxuICAgICAgLy8gd2hvc2UgY29udGVudHMgYXJlIGJ5dGVzLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlclxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIHRleHQgKCkge1xuICAgICAgLy8gVGhlIHRleHQoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIFVURi04IGRlY29kZS5cbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCB1dGY4RGVjb2RlQnl0ZXMsIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICBqc29uICgpIHtcbiAgICAgIC8vIFRoZSBqc29uKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCBwYXJzZSBKU09OIGZyb20gYnl0ZXMuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgcGFyc2VKU09ORnJvbUJ5dGVzLCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgZm9ybURhdGEgKCkge1xuICAgICAgLy8gVGhlIGZvcm1EYXRhKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXAgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyAxLiBMZXQgbWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBnZXQgdGhlIE1JTUUgdHlwZSB3aXRoIHRoaXMuXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYm9keU1pbWVUeXBlKHRoaXMpXG5cbiAgICAgICAgLy8gMi4gSWYgbWltZVR5cGUgaXMgbm9uLW51bGwsIHRoZW4gc3dpdGNoIG9uIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGFuZCBydW5cbiAgICAgICAgLy8gICAgdGhlIGNvcnJlc3BvbmRpbmcgc3RlcHM6XG4gICAgICAgIGlmIChtaW1lVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAobWltZVR5cGUuZXNzZW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc6IHtcbiAgICAgICAgICAgICAgLy8gMS4gLi4uIFtsb25nIHN0ZXBdXG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IG11bHRpcGFydEZvcm1EYXRhUGFyc2VyKHZhbHVlLCBtaW1lVHlwZSlcblxuICAgICAgICAgICAgICAvLyAyLiBJZiB0aGF0IGZhaWxzIGZvciBzb21lIHJlYXNvbiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlZCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIHBhcnNlIGJvZHkgYXMgRm9ybURhdGEuJylcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIDMuIFJldHVybiBhIG5ldyBGb3JtRGF0YSBvYmplY3QsIGFwcGVuZGluZyBlYWNoIGVudHJ5LFxuICAgICAgICAgICAgICAvLyAgICByZXN1bHRpbmcgZnJvbSB0aGUgcGFyc2luZyBvcGVyYXRpb24sIHRvIGl0cyBlbnRyeSBsaXN0LlxuICAgICAgICAgICAgICBjb25zdCBmZCA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgICAgICAgIGZkW2tTdGF0ZV0gPSBwYXJzZWRcblxuICAgICAgICAgICAgICByZXR1cm4gZmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHtcbiAgICAgICAgICAgICAgLy8gMS4gTGV0IGVudHJpZXMgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGJ5dGVzLlxuICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh2YWx1ZS50b1N0cmluZygpKVxuXG4gICAgICAgICAgICAgIC8vIDIuIElmIGVudHJpZXMgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cblxuICAgICAgICAgICAgICAvLyAzLiBSZXR1cm4gYSBuZXcgRm9ybURhdGEgb2JqZWN0IHdob3NlIGVudHJ5IGxpc3QgaXMgZW50cmllcy5cbiAgICAgICAgICAgICAgY29uc3QgZmQgPSBuZXcgRm9ybURhdGEoKVxuXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZmQuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gVGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSB3YXMgbm90IG9uZSBvZiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiBvciBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLidcbiAgICAgICAgKVxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGJ5dGVzICgpIHtcbiAgICAgIC8vIFRoZSBieXRlcygpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBjb25zdW1lIGJvZHlcbiAgICAgIC8vIHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIHRoZVxuICAgICAgLy8gcmVzdWx0IG9mIGNyZWF0aW5nIGEgVWludDhBcnJheSBmcm9tIGJ5dGVzIGluIHRoaXPigJlzIHJlbGV2YW50IHJlYWxtLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWV0aG9kc1xufVxuXG5mdW5jdGlvbiBtaXhpbkJvZHkgKHByb3RvdHlwZSkge1xuICBPYmplY3QuYXNzaWduKHByb3RvdHlwZS5wcm90b3R5cGUsIGJvZHlNaXhpbk1ldGhvZHMocHJvdG90eXBlKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKiBAcGFyYW0ge1Jlc3BvbnNlfFJlcXVlc3R9IG9iamVjdFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHVua25vd259IGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICogQHBhcmFtIHtSZXNwb25zZXxSZXF1ZXN0fSBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keSAob2JqZWN0LCBjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUsIGluc3RhbmNlKSB7XG4gIHdlYmlkbC5icmFuZENoZWNrKG9iamVjdCwgaW5zdGFuY2UpXG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIHVudXNhYmxlLCB0aGVuIHJldHVybiBhIHByb21pc2UgcmVqZWN0ZWRcbiAgLy8gICAgd2l0aCBhIFR5cGVFcnJvci5cbiAgaWYgKGJvZHlVbnVzYWJsZShvYmplY3Rba1N0YXRlXS5ib2R5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgaXMgdW51c2FibGU6IEJvZHkgaGFzIGFscmVhZHkgYmVlbiByZWFkJylcbiAgfVxuXG4gIHRocm93SWZBYm9ydGVkKG9iamVjdFtrU3RhdGVdKVxuXG4gIC8vIDIuIExldCBwcm9taXNlIGJlIGEgbmV3IHByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGdpdmVuIGVycm9yIGJlIHRvIHJlamVjdCBwcm9taXNlIHdpdGggZXJyb3IuXG4gIGNvbnN0IGVycm9yU3RlcHMgPSAoZXJyb3IpID0+IHByb21pc2UucmVqZWN0KGVycm9yKVxuXG4gIC8vIDQuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGRhdGEgYmUgdG8gcmVzb2x2ZVxuICAvLyAgICBwcm9taXNlIHdpdGggdGhlIHJlc3VsdCBvZiBydW5uaW5nIGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICAvLyAgICB3aXRoIGRhdGEuIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzXG4gIC8vICAgIHdpdGggdGhhdCBleGNlcHRpb24uXG4gIGNvbnN0IHN1Y2Nlc3NTdGVwcyA9IChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UucmVzb2x2ZShjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUoZGF0YSkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JTdGVwcyhlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDUuIElmIG9iamVjdOKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBzdWNjZXNzU3RlcHMgd2l0aCBhblxuICAvLyAgICBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICBpZiAob2JqZWN0W2tTdGF0ZV0uYm9keSA9PSBudWxsKSB7XG4gICAgc3VjY2Vzc1N0ZXBzKEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKSlcbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGZ1bGx5IHJlYWQgb2JqZWN04oCZcyBib2R5IGdpdmVuIHN1Y2Nlc3NTdGVwcyxcbiAgLy8gICAgZXJyb3JTdGVwcywgYW5kIG9iamVjdOKAmXMgcmVsZXZhbnQgZ2xvYmFsIG9iamVjdC5cbiAgYXdhaXQgZnVsbHlSZWFkQm9keShvYmplY3Rba1N0YXRlXS5ib2R5LCBzdWNjZXNzU3RlcHMsIGVycm9yU3RlcHMpXG5cbiAgLy8gNy4gUmV0dXJuIHByb21pc2UuXG4gIHJldHVybiBwcm9taXNlLnByb21pc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHktdW51c2FibGVcbmZ1bmN0aW9uIGJvZHlVbnVzYWJsZSAoYm9keSkge1xuICAvLyBBbiBvYmplY3QgaW5jbHVkaW5nIHRoZSBCb2R5IGludGVyZmFjZSBtaXhpbiBpc1xuICAvLyBzYWlkIHRvIGJlIHVudXNhYmxlIGlmIGl0cyBib2R5IGlzIG5vbi1udWxsIGFuZFxuICAvLyBpdHMgYm9keeKAmXMgc3RyZWFtIGlzIGRpc3R1cmJlZCBvciBsb2NrZWQuXG4gIHJldHVybiBib2R5ICE9IG51bGwgJiYgKGJvZHkuc3RyZWFtLmxvY2tlZCB8fCB1dGlsLmlzRGlzdHVyYmVkKGJvZHkuc3RyZWFtKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNwYXJzZS1qc29uLWJ5dGVzLXRvLWEtamF2YXNjcmlwdC12YWx1ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mdW5jdGlvbiBwYXJzZUpTT05Gcm9tQnl0ZXMgKGJ5dGVzKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHV0ZjhEZWNvZGVCeXRlcyhieXRlcykpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LW1pbWUtdHlwZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcmVzcG9uc2UnKS5SZXNwb25zZXxpbXBvcnQoJy4vcmVxdWVzdCcpLlJlcXVlc3R9IHJlcXVlc3RPclJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGJvZHlNaW1lVHlwZSAocmVxdWVzdE9yUmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IGhlYWRlcnMgYmUgbnVsbC5cbiAgLy8gMi4gSWYgcmVxdWVzdE9yUmVzcG9uc2UgaXMgYSBSZXF1ZXN0IG9iamVjdCwgdGhlbiBzZXQgaGVhZGVycyB0byByZXF1ZXN0T3JSZXNwb25zZeKAmXMgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDMuIE90aGVyd2lzZSwgc2V0IGhlYWRlcnMgdG8gcmVxdWVzdE9yUmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vaGVhZGVycycpLkhlYWRlcnNMaXN0fSAqL1xuICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdE9yUmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdFxuXG4gIC8vIDQuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYSBNSU1FIHR5cGUgZnJvbSBoZWFkZXJzLlxuICBjb25zdCBtaW1lVHlwZSA9IGV4dHJhY3RNaW1lVHlwZShoZWFkZXJzKVxuXG4gIC8vIDUuIElmIG1pbWVUeXBlIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIG51bGwuXG4gIGlmIChtaW1lVHlwZSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDYuIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHRyYWN0Qm9keSxcbiAgc2FmZWx5RXh0cmFjdEJvZHksXG4gIGNsb25lQm9keSxcbiAgbWl4aW5Cb2R5XG59XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJSZWFkYWJsZVN0cmVhbUZyb20iLCJpc0Jsb2JMaWtlIiwiaXNSZWFkYWJsZVN0cmVhbUxpa2UiLCJyZWFkYWJsZVN0cmVhbUNsb3NlIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwiZnVsbHlSZWFkQm9keSIsImV4dHJhY3RNaW1lVHlwZSIsInV0ZjhEZWNvZGVCeXRlcyIsIkZvcm1EYXRhIiwia1N0YXRlIiwid2ViaWRsIiwiQmxvYiIsImFzc2VydCIsImlzRXJyb3JlZCIsImlzQXJyYXlCdWZmZXIiLCJzZXJpYWxpemVBTWltZVR5cGUiLCJtdWx0aXBhcnRGb3JtRGF0YVBhcnNlciIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJleHRyYWN0Qm9keSIsIm9iamVjdCIsImtlZXBhbGl2ZSIsInN0cmVhbSIsIlJlYWRhYmxlU3RyZWFtIiwicHVsbCIsImNvbnRyb2xsZXIiLCJidWZmZXIiLCJzb3VyY2UiLCJlbmNvZGUiLCJieXRlTGVuZ3RoIiwiZW5xdWV1ZSIsInF1ZXVlTWljcm90YXNrIiwic3RhcnQiLCJ0eXBlIiwiYWN0aW9uIiwibGVuZ3RoIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJVaW50OEFycmF5Iiwic2xpY2UiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ5dGVPZmZzZXQiLCJpc0Zvcm1EYXRhTGlrZSIsImJvdW5kYXJ5IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicGFkU3RhcnQiLCJwcmVmaXgiLCJlc2NhcGUiLCJzdHIiLCJyZXBsYWNlIiwibm9ybWFsaXplTGluZWZlZWRzIiwidmFsdWUiLCJibG9iUGFydHMiLCJybiIsImhhc1Vua25vd25TaXplVmFsdWUiLCJuYW1lIiwiY2h1bmsiLCJwdXNoIiwic2l6ZSIsInBhcnQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiVHlwZUVycm9yIiwiaXNEaXN0dXJiZWQiLCJsb2NrZWQiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsIml0ZXJhdG9yIiwiZG9uZSIsIm5leHQiLCJjbG9zZSIsImJ5b2JSZXF1ZXN0IiwicmVzcG9uZCIsImRlc2lyZWRTaXplIiwiY2FuY2VsIiwicmVhc29uIiwicmV0dXJuIiwiYm9keSIsInNhZmVseUV4dHJhY3RCb2R5IiwiY2xvbmVCb2R5Iiwib3V0MSIsIm91dDIiLCJ0ZWUiLCJ0aHJvd0lmQWJvcnRlZCIsInN0YXRlIiwiYWJvcnRlZCIsIkRPTUV4Y2VwdGlvbiIsImJvZHlNaXhpbk1ldGhvZHMiLCJpbnN0YW5jZSIsIm1ldGhvZHMiLCJibG9iIiwiY29uc3VtZUJvZHkiLCJieXRlcyIsIm1pbWVUeXBlIiwiYm9keU1pbWVUeXBlIiwiYXJyYXlCdWZmZXIiLCJ0ZXh0IiwianNvbiIsInBhcnNlSlNPTkZyb21CeXRlcyIsImZvcm1EYXRhIiwiZXNzZW5jZSIsInBhcnNlZCIsImZkIiwiZW50cmllcyIsImFwcGVuZCIsIm1peGluQm9keSIsInByb3RvdHlwZSIsIk9iamVjdCIsImFzc2lnbiIsImNvbnZlcnRCeXRlc1RvSlNWYWx1ZSIsImJyYW5kQ2hlY2siLCJib2R5VW51c2FibGUiLCJwcm9taXNlIiwiZXJyb3JTdGVwcyIsImVycm9yIiwicmVqZWN0Iiwic3VjY2Vzc1N0ZXBzIiwiZGF0YSIsInJlc29sdmUiLCJlIiwiYWxsb2NVbnNhZmUiLCJKU09OIiwicGFyc2UiLCJyZXF1ZXN0T3JSZXNwb25zZSIsImhlYWRlcnMiLCJoZWFkZXJzTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/body.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/constants.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nconst corsSafeListedMethods = [\n    'GET',\n    'HEAD',\n    'POST'\n];\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods);\nconst nullBodyStatus = [\n    101,\n    204,\n    205,\n    304\n];\nconst redirectStatus = [\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst redirectStatusSet = new Set(redirectStatus);\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n    '1',\n    '7',\n    '9',\n    '11',\n    '13',\n    '15',\n    '17',\n    '19',\n    '20',\n    '21',\n    '22',\n    '23',\n    '25',\n    '37',\n    '42',\n    '43',\n    '53',\n    '69',\n    '77',\n    '79',\n    '87',\n    '95',\n    '101',\n    '102',\n    '103',\n    '104',\n    '109',\n    '110',\n    '111',\n    '113',\n    '115',\n    '117',\n    '119',\n    '123',\n    '135',\n    '137',\n    '139',\n    '143',\n    '161',\n    '179',\n    '389',\n    '427',\n    '465',\n    '512',\n    '513',\n    '514',\n    '515',\n    '526',\n    '530',\n    '531',\n    '532',\n    '540',\n    '548',\n    '554',\n    '556',\n    '563',\n    '587',\n    '601',\n    '636',\n    '989',\n    '990',\n    '993',\n    '995',\n    '1719',\n    '1720',\n    '1723',\n    '2049',\n    '3659',\n    '4045',\n    '4190',\n    '5060',\n    '5061',\n    '6000',\n    '6566',\n    '6665',\n    '6666',\n    '6667',\n    '6668',\n    '6669',\n    '6679',\n    '6697',\n    '10080'\n];\nconst badPortsSet = new Set(badPorts);\n// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\nconst referrerPolicy = [\n    '',\n    'no-referrer',\n    'no-referrer-when-downgrade',\n    'same-origin',\n    'origin',\n    'strict-origin',\n    'origin-when-cross-origin',\n    'strict-origin-when-cross-origin',\n    'unsafe-url'\n];\nconst referrerPolicySet = new Set(referrerPolicy);\nconst requestRedirect = [\n    'follow',\n    'manual',\n    'error'\n];\nconst safeMethods = [\n    'GET',\n    'HEAD',\n    'OPTIONS',\n    'TRACE'\n];\nconst safeMethodsSet = new Set(safeMethods);\nconst requestMode = [\n    'navigate',\n    'same-origin',\n    'no-cors',\n    'cors'\n];\nconst requestCredentials = [\n    'omit',\n    'same-origin',\n    'include'\n];\nconst requestCache = [\n    'default',\n    'no-store',\n    'reload',\n    'no-cache',\n    'force-cache',\n    'only-if-cached'\n];\n// https://fetch.spec.whatwg.org/#request-body-header-name\nconst requestBodyHeader = [\n    'content-encoding',\n    'content-language',\n    'content-location',\n    'content-type',\n    // See https://github.com/nodejs/undici/issues/2021\n    // 'Content-Length' is a forbidden header name, which is typically\n    // removed in the Headers implementation. However, undici doesn't\n    // filter out headers, so we add it here.\n    'content-length'\n];\n// https://fetch.spec.whatwg.org/#enumdef-requestduplex\nconst requestDuplex = [\n    'half'\n];\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = [\n    'CONNECT',\n    'TRACE',\n    'TRACK'\n];\nconst forbiddenMethodsSet = new Set(forbiddenMethods);\nconst subresource = [\n    'audio',\n    'audioworklet',\n    'font',\n    'image',\n    'manifest',\n    'paintworklet',\n    'script',\n    'style',\n    'track',\n    'video',\n    'xslt',\n    ''\n];\nconst subresourceSet = new Set(subresource);\nmodule.exports = {\n    subresource,\n    forbiddenMethods,\n    requestBodyHeader,\n    referrerPolicy,\n    requestRedirect,\n    requestMode,\n    requestCredentials,\n    requestCache,\n    redirectStatus,\n    corsSafeListedMethods,\n    nullBodyStatus,\n    safeMethods,\n    badPorts,\n    requestDuplex,\n    subresourceSet,\n    badPortsSet,\n    redirectStatusSet,\n    corsSafeListedMethodsSet,\n    safeMethodsSet,\n    forbiddenMethodsSet,\n    referrerPolicySet\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsd0JBQXdCO0lBQUM7SUFBTztJQUFRO0NBQU87QUFDckQsTUFBTUMsMkJBQTJCLElBQUlDLElBQUlGO0FBRXpDLE1BQU1HLGlCQUFpQjtJQUFDO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFFM0MsTUFBTUMsaUJBQWlCO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztDQUFJO0FBQ2hELE1BQU1DLG9CQUFvQixJQUFJSCxJQUFJRTtBQUVsQyxnREFBZ0Q7QUFDaEQsTUFBTUUsV0FBVztJQUNmO0lBQUs7SUFBSztJQUFLO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDL0c7SUFBTTtJQUFNO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFDdkc7SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQ2xHO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQVE7SUFBUTtJQUNwRztJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQ3hHO0lBQVE7Q0FDVDtBQUVELE1BQU1DLGNBQWMsSUFBSUwsSUFBSUk7QUFFNUIscUVBQXFFO0FBQ3JFLE1BQU1FLGlCQUFpQjtJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELE1BQU1DLG9CQUFvQixJQUFJUCxJQUFJTTtBQUVsQyxNQUFNRSxrQkFBa0I7SUFBQztJQUFVO0lBQVU7Q0FBUTtBQUVyRCxNQUFNQyxjQUFjO0lBQUM7SUFBTztJQUFRO0lBQVc7Q0FBUTtBQUN2RCxNQUFNQyxpQkFBaUIsSUFBSVYsSUFBSVM7QUFFL0IsTUFBTUUsY0FBYztJQUFDO0lBQVk7SUFBZTtJQUFXO0NBQU87QUFFbEUsTUFBTUMscUJBQXFCO0lBQUM7SUFBUTtJQUFlO0NBQVU7QUFFN0QsTUFBTUMsZUFBZTtJQUNuQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELDBEQUEwRDtBQUMxRCxNQUFNQyxvQkFBb0I7SUFDeEI7SUFDQTtJQUNBO0lBQ0E7SUFDQSxtREFBbUQ7SUFDbkQsa0VBQWtFO0lBQ2xFLGlFQUFpRTtJQUNqRSx5Q0FBeUM7SUFDekM7Q0FDRDtBQUVELHVEQUF1RDtBQUN2RCxNQUFNQyxnQkFBZ0I7SUFDcEI7Q0FDRDtBQUVELGlEQUFpRDtBQUNqRCxNQUFNQyxtQkFBbUI7SUFBQztJQUFXO0lBQVM7Q0FBUTtBQUN0RCxNQUFNQyxzQkFBc0IsSUFBSWpCLElBQUlnQjtBQUVwQyxNQUFNRSxjQUFjO0lBQ2xCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsaUJBQWlCLElBQUluQixJQUFJa0I7QUFFL0JFLE9BQU9DLE9BQU8sR0FBRztJQUNmSDtJQUNBRjtJQUNBRjtJQUNBUjtJQUNBRTtJQUNBRztJQUNBQztJQUNBQztJQUNBWDtJQUNBSjtJQUNBRztJQUNBUTtJQUNBTDtJQUNBVztJQUNBSTtJQUNBZDtJQUNBRjtJQUNBSjtJQUNBVztJQUNBTztJQUNBVjtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29yc1NhZmVMaXN0ZWRNZXRob2RzID0gWydHRVQnLCAnSEVBRCcsICdQT1NUJ11cbmNvbnN0IGNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCA9IG5ldyBTZXQoY29yc1NhZmVMaXN0ZWRNZXRob2RzKVxuXG5jb25zdCBudWxsQm9keVN0YXR1cyA9IFsxMDEsIDIwNCwgMjA1LCAzMDRdXG5cbmNvbnN0IHJlZGlyZWN0U3RhdHVzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuY29uc3QgcmVkaXJlY3RTdGF0dXNTZXQgPSBuZXcgU2V0KHJlZGlyZWN0U3RhdHVzKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYmxvY2stYmFkLXBvcnRcbmNvbnN0IGJhZFBvcnRzID0gW1xuICAnMScsICc3JywgJzknLCAnMTEnLCAnMTMnLCAnMTUnLCAnMTcnLCAnMTknLCAnMjAnLCAnMjEnLCAnMjInLCAnMjMnLCAnMjUnLCAnMzcnLCAnNDInLCAnNDMnLCAnNTMnLCAnNjknLCAnNzcnLCAnNzknLFxuICAnODcnLCAnOTUnLCAnMTAxJywgJzEwMicsICcxMDMnLCAnMTA0JywgJzEwOScsICcxMTAnLCAnMTExJywgJzExMycsICcxMTUnLCAnMTE3JywgJzExOScsICcxMjMnLCAnMTM1JywgJzEzNycsXG4gICcxMzknLCAnMTQzJywgJzE2MScsICcxNzknLCAnMzg5JywgJzQyNycsICc0NjUnLCAnNTEyJywgJzUxMycsICc1MTQnLCAnNTE1JywgJzUyNicsICc1MzAnLCAnNTMxJywgJzUzMicsXG4gICc1NDAnLCAnNTQ4JywgJzU1NCcsICc1NTYnLCAnNTYzJywgJzU4NycsICc2MDEnLCAnNjM2JywgJzk4OScsICc5OTAnLCAnOTkzJywgJzk5NScsICcxNzE5JywgJzE3MjAnLCAnMTcyMycsXG4gICcyMDQ5JywgJzM2NTknLCAnNDA0NScsICc0MTkwJywgJzUwNjAnLCAnNTA2MScsICc2MDAwJywgJzY1NjYnLCAnNjY2NScsICc2NjY2JywgJzY2NjcnLCAnNjY2OCcsICc2NjY5JywgJzY2NzknLFxuICAnNjY5NycsICcxMDA4MCdcbl1cblxuY29uc3QgYmFkUG9ydHNTZXQgPSBuZXcgU2V0KGJhZFBvcnRzKVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcmVmZXJyZXItcG9saWNpZXNcbmNvbnN0IHJlZmVycmVyUG9saWN5ID0gW1xuICAnJyxcbiAgJ25vLXJlZmVycmVyJyxcbiAgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcbiAgJ3NhbWUtb3JpZ2luJyxcbiAgJ29yaWdpbicsXG4gICdzdHJpY3Qtb3JpZ2luJyxcbiAgJ29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG4gICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcbiAgJ3Vuc2FmZS11cmwnXG5dXG5jb25zdCByZWZlcnJlclBvbGljeVNldCA9IG5ldyBTZXQocmVmZXJyZXJQb2xpY3kpXG5cbmNvbnN0IHJlcXVlc3RSZWRpcmVjdCA9IFsnZm9sbG93JywgJ21hbnVhbCcsICdlcnJvciddXG5cbmNvbnN0IHNhZmVNZXRob2RzID0gWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1RSQUNFJ11cbmNvbnN0IHNhZmVNZXRob2RzU2V0ID0gbmV3IFNldChzYWZlTWV0aG9kcylcblxuY29uc3QgcmVxdWVzdE1vZGUgPSBbJ25hdmlnYXRlJywgJ3NhbWUtb3JpZ2luJywgJ25vLWNvcnMnLCAnY29ycyddXG5cbmNvbnN0IHJlcXVlc3RDcmVkZW50aWFscyA9IFsnb21pdCcsICdzYW1lLW9yaWdpbicsICdpbmNsdWRlJ11cblxuY29uc3QgcmVxdWVzdENhY2hlID0gW1xuICAnZGVmYXVsdCcsXG4gICduby1zdG9yZScsXG4gICdyZWxvYWQnLFxuICAnbm8tY2FjaGUnLFxuICAnZm9yY2UtY2FjaGUnLFxuICAnb25seS1pZi1jYWNoZWQnXG5dXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWJvZHktaGVhZGVyLW5hbWVcbmNvbnN0IHJlcXVlc3RCb2R5SGVhZGVyID0gW1xuICAnY29udGVudC1lbmNvZGluZycsXG4gICdjb250ZW50LWxhbmd1YWdlJyxcbiAgJ2NvbnRlbnQtbG9jYXRpb24nLFxuICAnY29udGVudC10eXBlJyxcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDIxXG4gIC8vICdDb250ZW50LUxlbmd0aCcgaXMgYSBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHdoaWNoIGlzIHR5cGljYWxseVxuICAvLyByZW1vdmVkIGluIHRoZSBIZWFkZXJzIGltcGxlbWVudGF0aW9uLiBIb3dldmVyLCB1bmRpY2kgZG9lc24ndFxuICAvLyBmaWx0ZXIgb3V0IGhlYWRlcnMsIHNvIHdlIGFkZCBpdCBoZXJlLlxuICAnY29udGVudC1sZW5ndGgnXG5dXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNlbnVtZGVmLXJlcXVlc3RkdXBsZXhcbmNvbnN0IHJlcXVlc3REdXBsZXggPSBbXG4gICdoYWxmJ1xuXVxuXG4vLyBodHRwOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmb3JiaWRkZW4tbWV0aG9kXG5jb25zdCBmb3JiaWRkZW5NZXRob2RzID0gWydDT05ORUNUJywgJ1RSQUNFJywgJ1RSQUNLJ11cbmNvbnN0IGZvcmJpZGRlbk1ldGhvZHNTZXQgPSBuZXcgU2V0KGZvcmJpZGRlbk1ldGhvZHMpXG5cbmNvbnN0IHN1YnJlc291cmNlID0gW1xuICAnYXVkaW8nLFxuICAnYXVkaW93b3JrbGV0JyxcbiAgJ2ZvbnQnLFxuICAnaW1hZ2UnLFxuICAnbWFuaWZlc3QnLFxuICAncGFpbnR3b3JrbGV0JyxcbiAgJ3NjcmlwdCcsXG4gICdzdHlsZScsXG4gICd0cmFjaycsXG4gICd2aWRlbycsXG4gICd4c2x0JyxcbiAgJydcbl1cbmNvbnN0IHN1YnJlc291cmNlU2V0ID0gbmV3IFNldChzdWJyZXNvdXJjZSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN1YnJlc291cmNlLFxuICBmb3JiaWRkZW5NZXRob2RzLFxuICByZXF1ZXN0Qm9keUhlYWRlcixcbiAgcmVmZXJyZXJQb2xpY3ksXG4gIHJlcXVlc3RSZWRpcmVjdCxcbiAgcmVxdWVzdE1vZGUsXG4gIHJlcXVlc3RDcmVkZW50aWFscyxcbiAgcmVxdWVzdENhY2hlLFxuICByZWRpcmVjdFN0YXR1cyxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzLFxuICBudWxsQm9keVN0YXR1cyxcbiAgc2FmZU1ldGhvZHMsXG4gIGJhZFBvcnRzLFxuICByZXF1ZXN0RHVwbGV4LFxuICBzdWJyZXNvdXJjZVNldCxcbiAgYmFkUG9ydHNTZXQsXG4gIHJlZGlyZWN0U3RhdHVzU2V0LFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQsXG4gIHNhZmVNZXRob2RzU2V0LFxuICBmb3JiaWRkZW5NZXRob2RzU2V0LFxuICByZWZlcnJlclBvbGljeVNldFxufVxuIl0sIm5hbWVzIjpbImNvcnNTYWZlTGlzdGVkTWV0aG9kcyIsImNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCIsIlNldCIsIm51bGxCb2R5U3RhdHVzIiwicmVkaXJlY3RTdGF0dXMiLCJyZWRpcmVjdFN0YXR1c1NldCIsImJhZFBvcnRzIiwiYmFkUG9ydHNTZXQiLCJyZWZlcnJlclBvbGljeSIsInJlZmVycmVyUG9saWN5U2V0IiwicmVxdWVzdFJlZGlyZWN0Iiwic2FmZU1ldGhvZHMiLCJzYWZlTWV0aG9kc1NldCIsInJlcXVlc3RNb2RlIiwicmVxdWVzdENyZWRlbnRpYWxzIiwicmVxdWVzdENhY2hlIiwicmVxdWVzdEJvZHlIZWFkZXIiLCJyZXF1ZXN0RHVwbGV4IiwiZm9yYmlkZGVuTWV0aG9kcyIsImZvcmJpZGRlbk1ldGhvZHNTZXQiLCJzdWJyZXNvdXJjZSIsInN1YnJlc291cmNlU2V0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/data-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/data-url.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst encoder = new TextEncoder();\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */ const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\\-.^_|~A-Za-z0-9]+$/;\nconst HTTP_WHITESPACE_REGEX = /[\\u000A\\u000D\\u0009\\u0020]/ // eslint-disable-line\n;\nconst ASCII_WHITESPACE_REPLACE_REGEX = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g // eslint-disable-line\n;\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */ const HTTP_QUOTED_STRING_TOKENS = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/ // eslint-disable-line\n;\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */ function dataURLProcessor(dataURL) {\n    // 1. Assert: dataURL’s scheme is \"data\".\n    assert(dataURL.protocol === 'data:');\n    // 2. Let input be the result of running the URL\n    // serializer on dataURL with exclude fragment\n    // set to true.\n    let input = URLSerializer(dataURL, true);\n    // 3. Remove the leading \"data:\" string from input.\n    input = input.slice(5);\n    // 4. Let position point at the start of input.\n    const position = {\n        position: 0\n    };\n    // 5. Let mimeType be the result of collecting a\n    // sequence of code points that are not equal\n    // to U+002C (,), given position.\n    let mimeType = collectASequenceOfCodePointsFast(',', input, position);\n    // 6. Strip leading and trailing ASCII whitespace\n    // from mimeType.\n    // Undici implementation note: we need to store the\n    // length because if the mimetype has spaces removed,\n    // the wrong amount will be sliced from the input in\n    // step #9\n    const mimeTypeLength = mimeType.length;\n    mimeType = removeASCIIWhitespace(mimeType, true, true);\n    // 7. If position is past the end of input, then\n    // return failure\n    if (position.position >= input.length) {\n        return 'failure';\n    }\n    // 8. Advance position by 1.\n    position.position++;\n    // 9. Let encodedBody be the remainder of input.\n    const encodedBody = input.slice(mimeTypeLength + 1);\n    // 10. Let body be the percent-decoding of encodedBody.\n    let body = stringPercentDecode(encodedBody);\n    // 11. If mimeType ends with U+003B (;), followed by\n    // zero or more U+0020 SPACE, followed by an ASCII\n    // case-insensitive match for \"base64\", then:\n    if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n        // 1. Let stringBody be the isomorphic decode of body.\n        const stringBody = isomorphicDecode(body);\n        // 2. Set body to the forgiving-base64 decode of\n        // stringBody.\n        body = forgivingBase64(stringBody);\n        // 3. If body is failure, then return failure.\n        if (body === 'failure') {\n            return 'failure';\n        }\n        // 4. Remove the last 6 code points from mimeType.\n        mimeType = mimeType.slice(0, -6);\n        // 5. Remove trailing U+0020 SPACE code points from mimeType,\n        // if any.\n        mimeType = mimeType.replace(/(\\u0020)+$/, '');\n        // 6. Remove the last U+003B (;) code point from mimeType.\n        mimeType = mimeType.slice(0, -1);\n    }\n    // 12. If mimeType starts with U+003B (;), then prepend\n    // \"text/plain\" to mimeType.\n    if (mimeType.startsWith(';')) {\n        mimeType = 'text/plain' + mimeType;\n    }\n    // 13. Let mimeTypeRecord be the result of parsing\n    // mimeType.\n    let mimeTypeRecord = parseMIMEType(mimeType);\n    // 14. If mimeTypeRecord is failure, then set\n    // mimeTypeRecord to text/plain;charset=US-ASCII.\n    if (mimeTypeRecord === 'failure') {\n        mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');\n    }\n    // 15. Return a new data: URL struct whose MIME\n    // type is mimeTypeRecord and body is body.\n    // https://fetch.spec.whatwg.org/#data-url-struct\n    return {\n        mimeType: mimeTypeRecord,\n        body\n    };\n}\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */ function URLSerializer(url, excludeFragment = false) {\n    if (!excludeFragment) {\n        return url.href;\n    }\n    const href = url.href;\n    const hashLength = url.hash.length;\n    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);\n    if (!hashLength && href.endsWith('#')) {\n        return serialized.slice(0, -1);\n    }\n    return serialized;\n}\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePoints(condition, input, position) {\n    // 1. Let result be the empty string.\n    let result = '';\n    // 2. While position doesn’t point past the end of input and the\n    // code point at position within input meets the condition condition:\n    while(position.position < input.length && condition(input[position.position])){\n        // 1. Append that code point to the end of result.\n        result += input[position.position];\n        // 2. Advance position by 1.\n        position.position++;\n    }\n    // 3. Return result.\n    return result;\n}\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePointsFast(char, input, position) {\n    const idx = input.indexOf(char, position.position);\n    const start = position.position;\n    if (idx === -1) {\n        position.position = input.length;\n        return input.slice(start);\n    }\n    position.position = idx;\n    return input.slice(start, position.position);\n}\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */ function stringPercentDecode(input) {\n    // 1. Let bytes be the UTF-8 encoding of input.\n    const bytes = encoder.encode(input);\n    // 2. Return the percent-decoding of bytes.\n    return percentDecode(bytes);\n}\n/**\n * @param {number} byte\n */ function isHexCharByte(byte) {\n    // 0-9 A-F a-f\n    return byte >= 0x30 && byte <= 0x39 || byte >= 0x41 && byte <= 0x46 || byte >= 0x61 && byte <= 0x66;\n}\n/**\n * @param {number} byte\n */ function hexByteToNumber(byte) {\n    return(// 0-9\n    byte >= 0x30 && byte <= 0x39 ? byte - 48 : (byte & 0xDF) - 55);\n}\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */ function percentDecode(input) {\n    const length = input.length;\n    // 1. Let output be an empty byte sequence.\n    /** @type {Uint8Array} */ const output = new Uint8Array(length);\n    let j = 0;\n    // 2. For each byte byte in input:\n    for(let i = 0; i < length; ++i){\n        const byte = input[i];\n        // 1. If byte is not 0x25 (%), then append byte to output.\n        if (byte !== 0x25) {\n            output[j++] = byte;\n        // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n        // after byte in input are not in the ranges\n        // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n        // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n        // to output.\n        } else if (byte === 0x25 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {\n            output[j++] = 0x25;\n        // 3. Otherwise:\n        } else {\n            // 1. Let bytePoint be the two bytes after byte in input,\n            // decoded, and then interpreted as hexadecimal number.\n            // 2. Append a byte whose value is bytePoint to output.\n            output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);\n            // 3. Skip the next two bytes in input.\n            i += 2;\n        }\n    }\n    // 3. Return output.\n    return length === j ? output : output.subarray(0, j);\n}\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */ function parseMIMEType(input) {\n    // 1. Remove any leading and trailing HTTP whitespace\n    // from input.\n    input = removeHTTPWhitespace(input, true, true);\n    // 2. Let position be a position variable for input,\n    // initially pointing at the start of input.\n    const position = {\n        position: 0\n    };\n    // 3. Let type be the result of collecting a sequence\n    // of code points that are not U+002F (/) from\n    // input, given position.\n    const type = collectASequenceOfCodePointsFast('/', input, position);\n    // 4. If type is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    // https://mimesniff.spec.whatwg.org/#http-token-code-point\n    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n        return 'failure';\n    }\n    // 5. If position is past the end of input, then return\n    // failure\n    if (position.position > input.length) {\n        return 'failure';\n    }\n    // 6. Advance position by 1. (This skips past U+002F (/).)\n    position.position++;\n    // 7. Let subtype be the result of collecting a sequence of\n    // code points that are not U+003B (;) from input, given\n    // position.\n    let subtype = collectASequenceOfCodePointsFast(';', input, position);\n    // 8. Remove any trailing HTTP whitespace from subtype.\n    subtype = removeHTTPWhitespace(subtype, false, true);\n    // 9. If subtype is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n        return 'failure';\n    }\n    const typeLowercase = type.toLowerCase();\n    const subtypeLowercase = subtype.toLowerCase();\n    // 10. Let mimeType be a new MIME type record whose type\n    // is type, in ASCII lowercase, and subtype is subtype,\n    // in ASCII lowercase.\n    // https://mimesniff.spec.whatwg.org/#mime-type\n    const mimeType = {\n        type: typeLowercase,\n        subtype: subtypeLowercase,\n        /** @type {Map<string, string>} */ parameters: new Map(),\n        // https://mimesniff.spec.whatwg.org/#mime-type-essence\n        essence: `${typeLowercase}/${subtypeLowercase}`\n    };\n    // 11. While position is not past the end of input:\n    while(position.position < input.length){\n        // 1. Advance position by 1. (This skips past U+003B (;).)\n        position.position++;\n        // 2. Collect a sequence of code points that are HTTP\n        // whitespace from input given position.\n        collectASequenceOfCodePoints(// https://fetch.spec.whatwg.org/#http-whitespace\n        (char)=>HTTP_WHITESPACE_REGEX.test(char), input, position);\n        // 3. Let parameterName be the result of collecting a\n        // sequence of code points that are not U+003B (;)\n        // or U+003D (=) from input, given position.\n        let parameterName = collectASequenceOfCodePoints((char)=>char !== ';' && char !== '=', input, position);\n        // 4. Set parameterName to parameterName, in ASCII\n        // lowercase.\n        parameterName = parameterName.toLowerCase();\n        // 5. If position is not past the end of input, then:\n        if (position.position < input.length) {\n            // 1. If the code point at position within input is\n            // U+003B (;), then continue.\n            if (input[position.position] === ';') {\n                continue;\n            }\n            // 2. Advance position by 1. (This skips past U+003D (=).)\n            position.position++;\n        }\n        // 6. If position is past the end of input, then break.\n        if (position.position > input.length) {\n            break;\n        }\n        // 7. Let parameterValue be null.\n        let parameterValue = null;\n        // 8. If the code point at position within input is\n        // U+0022 (\"), then:\n        if (input[position.position] === '\"') {\n            // 1. Set parameterValue to the result of collecting\n            // an HTTP quoted string from input, given position\n            // and the extract-value flag.\n            parameterValue = collectAnHTTPQuotedString(input, position, true);\n            // 2. Collect a sequence of code points that are not\n            // U+003B (;) from input, given position.\n            collectASequenceOfCodePointsFast(';', input, position);\n        // 9. Otherwise:\n        } else {\n            // 1. Set parameterValue to the result of collecting\n            // a sequence of code points that are not U+003B (;)\n            // from input, given position.\n            parameterValue = collectASequenceOfCodePointsFast(';', input, position);\n            // 2. Remove any trailing HTTP whitespace from parameterValue.\n            parameterValue = removeHTTPWhitespace(parameterValue, false, true);\n            // 3. If parameterValue is the empty string, then continue.\n            if (parameterValue.length === 0) {\n                continue;\n            }\n        }\n        // 10. If all of the following are true\n        // - parameterName is not the empty string\n        // - parameterName solely contains HTTP token code points\n        // - parameterValue solely contains HTTP quoted-string token code points\n        // - mimeType’s parameters[parameterName] does not exist\n        // then set mimeType’s parameters[parameterName] to parameterValue.\n        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {\n            mimeType.parameters.set(parameterName, parameterValue);\n        }\n    }\n    // 12. Return mimeType.\n    return mimeType;\n}\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */ function forgivingBase64(data) {\n    // 1. Remove all ASCII whitespace from data.\n    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, ''); // eslint-disable-line\n    let dataLength = data.length;\n    // 2. If data’s code point length divides by 4 leaving\n    // no remainder, then:\n    if (dataLength % 4 === 0) {\n        // 1. If data ends with one or two U+003D (=) code points,\n        // then remove them from data.\n        if (data.charCodeAt(dataLength - 1) === 0x003D) {\n            --dataLength;\n            if (data.charCodeAt(dataLength - 1) === 0x003D) {\n                --dataLength;\n            }\n        }\n    }\n    // 3. If data’s code point length divides by 4 leaving\n    // a remainder of 1, then return failure.\n    if (dataLength % 4 === 1) {\n        return 'failure';\n    }\n    // 4. If data contains a code point that is not one of\n    //  U+002B (+)\n    //  U+002F (/)\n    //  ASCII alphanumeric\n    // then return failure.\n    if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {\n        return 'failure';\n    }\n    const buffer = Buffer.from(data, 'base64');\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */ function collectAnHTTPQuotedString(input, position, extractValue) {\n    // 1. Let positionStart be position.\n    const positionStart = position.position;\n    // 2. Let value be the empty string.\n    let value = '';\n    // 3. Assert: the code point at position within input\n    // is U+0022 (\").\n    assert(input[position.position] === '\"');\n    // 4. Advance position by 1.\n    position.position++;\n    // 5. While true:\n    while(true){\n        // 1. Append the result of collecting a sequence of code points\n        // that are not U+0022 (\") or U+005C (\\) from input, given\n        // position, to value.\n        value += collectASequenceOfCodePoints((char)=>char !== '\"' && char !== '\\\\', input, position);\n        // 2. If position is past the end of input, then break.\n        if (position.position >= input.length) {\n            break;\n        }\n        // 3. Let quoteOrBackslash be the code point at position within\n        // input.\n        const quoteOrBackslash = input[position.position];\n        // 4. Advance position by 1.\n        position.position++;\n        // 5. If quoteOrBackslash is U+005C (\\), then:\n        if (quoteOrBackslash === '\\\\') {\n            // 1. If position is past the end of input, then append\n            // U+005C (\\) to value and break.\n            if (position.position >= input.length) {\n                value += '\\\\';\n                break;\n            }\n            // 2. Append the code point at position within input to value.\n            value += input[position.position];\n            // 3. Advance position by 1.\n            position.position++;\n        // 6. Otherwise:\n        } else {\n            // 1. Assert: quoteOrBackslash is U+0022 (\").\n            assert(quoteOrBackslash === '\"');\n            break;\n        }\n    }\n    // 6. If the extract-value flag is set, then return value.\n    if (extractValue) {\n        return value;\n    }\n    // 7. Return the code points from positionStart to position,\n    // inclusive, within input.\n    return input.slice(positionStart, position.position);\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */ function serializeAMimeType(mimeType) {\n    assert(mimeType !== 'failure');\n    const { parameters, essence } = mimeType;\n    // 1. Let serialization be the concatenation of mimeType’s\n    //    type, U+002F (/), and mimeType’s subtype.\n    let serialization = essence;\n    // 2. For each name → value of mimeType’s parameters:\n    for (let [name, value] of parameters.entries()){\n        // 1. Append U+003B (;) to serialization.\n        serialization += ';';\n        // 2. Append name to serialization.\n        serialization += name;\n        // 3. Append U+003D (=) to serialization.\n        serialization += '=';\n        // 4. If value does not solely contain HTTP token code\n        //    points or value is the empty string, then:\n        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n            // 1. Precede each occurrence of U+0022 (\") or\n            //    U+005C (\\) in value with U+005C (\\).\n            value = value.replace(/(\\\\|\")/g, '\\\\$1');\n            // 2. Prepend U+0022 (\") to value.\n            value = '\"' + value;\n            // 3. Append U+0022 (\") to value.\n            value += '\"';\n        }\n        // 5. Append value to serialization.\n        serialization += value;\n    }\n    // 3. Return serialization.\n    return serialization;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {number} char\n */ function isHTTPWhiteSpace(char) {\n    // \"\\r\\n\\t \"\n    return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */ function removeHTTPWhitespace(str, leading = true, trailing = true) {\n    return removeChars(str, leading, trailing, isHTTPWhiteSpace);\n}\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {number} char\n */ function isASCIIWhitespace(char) {\n    // \"\\r\\n\\t\\f \"\n    return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x00c || char === 0x020;\n}\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */ function removeASCIIWhitespace(str, leading = true, trailing = true) {\n    return removeChars(str, leading, trailing, isASCIIWhitespace);\n}\n/**\n * @param {string} str\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns\n */ function removeChars(str, leading, trailing, predicate) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        while(lead < str.length && predicate(str.charCodeAt(lead)))lead++;\n    }\n    if (trailing) {\n        while(trail > 0 && predicate(str.charCodeAt(trail)))trail--;\n    }\n    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);\n}\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {Uint8Array} input\n * @returns {string}\n */ function isomorphicDecode(input) {\n    // 1. To isomorphic decode a byte sequence input, return a string whose code point\n    //    length is equal to input’s length and whose code points have the same values\n    //    as the values of input’s bytes, in the same order.\n    const length = input.length;\n    if ((2 << 15) - 1 > length) {\n        return String.fromCharCode.apply(null, input);\n    }\n    let result = '';\n    let i = 0;\n    let addition = (2 << 15) - 1;\n    while(i < length){\n        if (i + addition > length) {\n            addition = length - i;\n        }\n        result += String.fromCharCode.apply(null, input.subarray(i, i += addition));\n    }\n    return result;\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type\n * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType\n */ function minimizeSupportedMimeType(mimeType) {\n    switch(mimeType.essence){\n        case 'application/ecmascript':\n        case 'application/javascript':\n        case 'application/x-ecmascript':\n        case 'application/x-javascript':\n        case 'text/ecmascript':\n        case 'text/javascript':\n        case 'text/javascript1.0':\n        case 'text/javascript1.1':\n        case 'text/javascript1.2':\n        case 'text/javascript1.3':\n        case 'text/javascript1.4':\n        case 'text/javascript1.5':\n        case 'text/jscript':\n        case 'text/livescript':\n        case 'text/x-ecmascript':\n        case 'text/x-javascript':\n            // 1. If mimeType is a JavaScript MIME type, then return \"text/javascript\".\n            return 'text/javascript';\n        case 'application/json':\n        case 'text/json':\n            // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n            return 'application/json';\n        case 'image/svg+xml':\n            // 3. If mimeType’s essence is \"image/svg+xml\", then return \"image/svg+xml\".\n            return 'image/svg+xml';\n        case 'text/xml':\n        case 'application/xml':\n            // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n            return 'application/xml';\n    }\n    // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n    if (mimeType.subtype.endsWith('+json')) {\n        return 'application/json';\n    }\n    // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n    if (mimeType.subtype.endsWith('+xml')) {\n        return 'application/xml';\n    }\n    // 5. If mimeType is supported by the user agent, then return mimeType’s essence.\n    // Technically, node doesn't support any mimetypes.\n    // 6. Return the empty string.\n    return '';\n}\nmodule.exports = {\n    dataURLProcessor,\n    URLSerializer,\n    collectASequenceOfCodePoints,\n    collectASequenceOfCodePointsFast,\n    stringPercentDecode,\n    parseMIMEType,\n    collectAnHTTPQuotedString,\n    serializeAMimeType,\n    removeChars,\n    removeHTTPWhitespace,\n    minimizeSupportedMimeType,\n    HTTP_TOKEN_CODEPOINTS,\n    isomorphicDecode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUVwQyxNQUFNQyxVQUFVLElBQUlDO0FBRXBCOztDQUVDLEdBQ0QsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLHdCQUF3Qiw2QkFBNkIsc0JBQXNCOztBQUNqRixNQUFNQyxpQ0FBaUMsb0NBQW9DLHNCQUFzQjs7QUFDakc7O0NBRUMsR0FDRCxNQUFNQyw0QkFBNEIsd0NBQXdDLHNCQUFzQjs7QUFFaEcsb0RBQW9EO0FBQ3BELHlCQUF5QixHQUN6QixTQUFTQyxpQkFBa0JDLE9BQU87SUFDaEMseUNBQXlDO0lBQ3pDVCxPQUFPUyxRQUFRQyxRQUFRLEtBQUs7SUFFNUIsZ0RBQWdEO0lBQ2hELDhDQUE4QztJQUM5QyxlQUFlO0lBQ2YsSUFBSUMsUUFBUUMsY0FBY0gsU0FBUztJQUVuQyxtREFBbUQ7SUFDbkRFLFFBQVFBLE1BQU1FLEtBQUssQ0FBQztJQUVwQiwrQ0FBK0M7SUFDL0MsTUFBTUMsV0FBVztRQUFFQSxVQUFVO0lBQUU7SUFFL0IsZ0RBQWdEO0lBQ2hELDZDQUE2QztJQUM3QyxpQ0FBaUM7SUFDakMsSUFBSUMsV0FBV0MsaUNBQ2IsS0FDQUwsT0FDQUc7SUFHRixpREFBaUQ7SUFDakQsaUJBQWlCO0lBQ2pCLG1EQUFtRDtJQUNuRCxxREFBcUQ7SUFDckQsb0RBQW9EO0lBQ3BELFVBQVU7SUFDVixNQUFNRyxpQkFBaUJGLFNBQVNHLE1BQU07SUFDdENILFdBQVdJLHNCQUFzQkosVUFBVSxNQUFNO0lBRWpELGdEQUFnRDtJQUNoRCxpQkFBaUI7SUFDakIsSUFBSUQsU0FBU0EsUUFBUSxJQUFJSCxNQUFNTyxNQUFNLEVBQUU7UUFDckMsT0FBTztJQUNUO0lBRUEsNEJBQTRCO0lBQzVCSixTQUFTQSxRQUFRO0lBRWpCLGdEQUFnRDtJQUNoRCxNQUFNTSxjQUFjVCxN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M0UsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsc0VBQXNFO1lBQ3RFLE9BQU87UUFDVCxLQUFLO1lBQ0gsNEVBQTRFO1lBQzVFLE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILHFFQUFxRTtZQUNyRSxPQUFPO0lBQ1g7SUFFQSxzRUFBc0U7SUFDdEUsSUFBSWxELFNBQVM0QyxPQUFPLENBQUNyQixRQUFRLENBQUMsVUFBVTtRQUN0QyxPQUFPO0lBQ1Q7SUFFQSxxRUFBcUU7SUFDckUsSUFBSXZCLFNBQVM0QyxPQUFPLENBQUNyQixRQUFRLENBQUMsU0FBUztRQUNyQyxPQUFPO0lBQ1Q7SUFFQSxpRkFBaUY7SUFDakYsbURBQW1EO0lBRW5ELDhCQUE4QjtJQUM5QixPQUFPO0FBQ1Q7QUFFQStELE9BQU9DLE9BQU8sR0FBRztJQUNmOUY7SUFDQUk7SUFDQTJCO0lBQ0F2QjtJQUNBTTtJQUNBUTtJQUNBc0M7SUFDQWU7SUFDQVE7SUFDQWxDO0lBQ0EyQztJQUNBaEc7SUFDQXFCO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcZGF0YS11cmwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtdG9rZW4tY29kZS1wb2ludFxuICovXG5jb25zdCBIVFRQX1RPS0VOX0NPREVQT0lOVFMgPSAvXlshIyQlJicqK1xcLS5eX3x+QS1aYS16MC05XSskL1xuY29uc3QgSFRUUF9XSElURVNQQUNFX1JFR0VYID0gL1tcXHUwMDBBXFx1MDAwRFxcdTAwMDlcXHUwMDIwXS8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuY29uc3QgQVNDSUlfV0hJVEVTUEFDRV9SRVBMQUNFX1JFR0VYID0gL1tcXHUwMDA5XFx1MDAwQVxcdTAwMENcXHUwMDBEXFx1MDAyMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXF1b3RlZC1zdHJpbmctdG9rZW4tY29kZS1wb2ludFxuICovXG5jb25zdCBIVFRQX1FVT1RFRF9TVFJJTkdfVE9LRU5TID0gL15bXFx1MDAwOVxcdTAwMjAtXFx1MDA3RVxcdTAwODAtXFx1MDBGRl0rJC8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZGF0YS11cmwtcHJvY2Vzc29yXG4vKiogQHBhcmFtIHtVUkx9IGRhdGFVUkwgKi9cbmZ1bmN0aW9uIGRhdGFVUkxQcm9jZXNzb3IgKGRhdGFVUkwpIHtcbiAgLy8gMS4gQXNzZXJ0OiBkYXRhVVJM4oCZcyBzY2hlbWUgaXMgXCJkYXRhXCIuXG4gIGFzc2VydChkYXRhVVJMLnByb3RvY29sID09PSAnZGF0YTonKVxuXG4gIC8vIDIuIExldCBpbnB1dCBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIFVSTFxuICAvLyBzZXJpYWxpemVyIG9uIGRhdGFVUkwgd2l0aCBleGNsdWRlIGZyYWdtZW50XG4gIC8vIHNldCB0byB0cnVlLlxuICBsZXQgaW5wdXQgPSBVUkxTZXJpYWxpemVyKGRhdGFVUkwsIHRydWUpXG5cbiAgLy8gMy4gUmVtb3ZlIHRoZSBsZWFkaW5nIFwiZGF0YTpcIiBzdHJpbmcgZnJvbSBpbnB1dC5cbiAgaW5wdXQgPSBpbnB1dC5zbGljZSg1KVxuXG4gIC8vIDQuIExldCBwb3NpdGlvbiBwb2ludCBhdCB0aGUgc3RhcnQgb2YgaW5wdXQuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gNS4gTGV0IG1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhXG4gIC8vIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBlcXVhbFxuICAvLyB0byBVKzAwMkMgKCwpLCBnaXZlbiBwb3NpdGlvbi5cbiAgbGV0IG1pbWVUeXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgJywnLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA2LiBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlXG4gIC8vIGZyb20gbWltZVR5cGUuXG4gIC8vIFVuZGljaSBpbXBsZW1lbnRhdGlvbiBub3RlOiB3ZSBuZWVkIHRvIHN0b3JlIHRoZVxuICAvLyBsZW5ndGggYmVjYXVzZSBpZiB0aGUgbWltZXR5cGUgaGFzIHNwYWNlcyByZW1vdmVkLFxuICAvLyB0aGUgd3JvbmcgYW1vdW50IHdpbGwgYmUgc2xpY2VkIGZyb20gdGhlIGlucHV0IGluXG4gIC8vIHN0ZXAgIzlcbiAgY29uc3QgbWltZVR5cGVMZW5ndGggPSBtaW1lVHlwZS5sZW5ndGhcbiAgbWltZVR5cGUgPSByZW1vdmVBU0NJSVdoaXRlc3BhY2UobWltZVR5cGUsIHRydWUsIHRydWUpXG5cbiAgLy8gNy4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuXG4gIC8vIHJldHVybiBmYWlsdXJlXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA4LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA5LiBMZXQgZW5jb2RlZEJvZHkgYmUgdGhlIHJlbWFpbmRlciBvZiBpbnB1dC5cbiAgY29uc3QgZW5jb2RlZEJvZHkgPSBpbnB1dC5zbGljZShtaW1lVHlwZUxlbmd0aCArIDEpXG5cbiAgLy8gMTAuIExldCBib2R5IGJlIHRoZSBwZXJjZW50LWRlY29kaW5nIG9mIGVuY29kZWRCb2R5LlxuICBsZXQgYm9keSA9IHN0cmluZ1BlcmNlbnREZWNvZGUoZW5jb2RlZEJvZHkpXG5cbiAgLy8gMTEuIElmIG1pbWVUeXBlIGVuZHMgd2l0aCBVKzAwM0IgKDspLCBmb2xsb3dlZCBieVxuICAvLyB6ZXJvIG9yIG1vcmUgVSswMDIwIFNQQUNFLCBmb2xsb3dlZCBieSBhbiBBU0NJSVxuICAvLyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBcImJhc2U2NFwiLCB0aGVuOlxuICBpZiAoLzsoXFx1MDAyMCl7MCx9YmFzZTY0JC9pLnRlc3QobWltZVR5cGUpKSB7XG4gICAgLy8gMS4gTGV0IHN0cmluZ0JvZHkgYmUgdGhlIGlzb21vcnBoaWMgZGVjb2RlIG9mIGJvZHkuXG4gICAgY29uc3Qgc3RyaW5nQm9keSA9IGlzb21vcnBoaWNEZWNvZGUoYm9keSlcblxuICAgIC8vIDIuIFNldCBib2R5IHRvIHRoZSBmb3JnaXZpbmctYmFzZTY0IGRlY29kZSBvZlxuICAgIC8vIHN0cmluZ0JvZHkuXG4gICAgYm9keSA9IGZvcmdpdmluZ0Jhc2U2NChzdHJpbmdCb2R5KVxuXG4gICAgLy8gMy4gSWYgYm9keSBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAgIGlmIChib2R5ID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyA0LiBSZW1vdmUgdGhlIGxhc3QgNiBjb2RlIHBvaW50cyBmcm9tIG1pbWVUeXBlLlxuICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc2xpY2UoMCwgLTYpXG5cbiAgICAvLyA1LiBSZW1vdmUgdHJhaWxpbmcgVSswMDIwIFNQQUNFIGNvZGUgcG9pbnRzIGZyb20gbWltZVR5cGUsXG4gICAgLy8gaWYgYW55LlxuICAgIG1pbWVUeXBlID0gbWltZVR5cGUucmVwbGFjZSgvKFxcdTAwMjApKyQvLCAnJylcblxuICAgIC8vIDYuIFJlbW92ZSB0aGUgbGFzdCBVKzAwM0IgKDspIGNvZGUgcG9pbnQgZnJvbSBtaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC0xKVxuICB9XG5cbiAgLy8gMTIuIElmIG1pbWVUeXBlIHN0YXJ0cyB3aXRoIFUrMDAzQiAoOyksIHRoZW4gcHJlcGVuZFxuICAvLyBcInRleHQvcGxhaW5cIiB0byBtaW1lVHlwZS5cbiAgaWYgKG1pbWVUeXBlLnN0YXJ0c1dpdGgoJzsnKSkge1xuICAgIG1pbWVUeXBlID0gJ3RleHQvcGxhaW4nICsgbWltZVR5cGVcbiAgfVxuXG4gIC8vIDEzLiBMZXQgbWltZVR5cGVSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nXG4gIC8vIG1pbWVUeXBlLlxuICBsZXQgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlKVxuXG4gIC8vIDE0LiBJZiBtaW1lVHlwZVJlY29yZCBpcyBmYWlsdXJlLCB0aGVuIHNldFxuICAvLyBtaW1lVHlwZVJlY29yZCB0byB0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUkuXG4gIGlmIChtaW1lVHlwZVJlY29yZCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKCd0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUknKVxuICB9XG5cbiAgLy8gMTUuIFJldHVybiBhIG5ldyBkYXRhOiBVUkwgc3RydWN0IHdob3NlIE1JTUVcbiAgLy8gdHlwZSBpcyBtaW1lVHlwZVJlY29yZCBhbmQgYm9keSBpcyBib2R5LlxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZGF0YS11cmwtc3RydWN0XG4gIHJldHVybiB7IG1pbWVUeXBlOiBtaW1lVHlwZVJlY29yZCwgYm9keSB9XG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtc2VyaWFsaXplclxuLyoqXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4Y2x1ZGVGcmFnbWVudFxuICovXG5mdW5jdGlvbiBVUkxTZXJpYWxpemVyICh1cmwsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gIGlmICghZXhjbHVkZUZyYWdtZW50KSB7XG4gICAgcmV0dXJuIHVybC5ocmVmXG4gIH1cblxuICBjb25zdCBocmVmID0gdXJsLmhyZWZcbiAgY29uc3QgaGFzaExlbmd0aCA9IHVybC5oYXNoLmxlbmd0aFxuXG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBoYXNoTGVuZ3RoID09PSAwID8gaHJlZiA6IGhyZWYuc3Vic3RyaW5nKDAsIGhyZWYubGVuZ3RoIC0gaGFzaExlbmd0aClcblxuICBpZiAoIWhhc2hMZW5ndGggJiYgaHJlZi5lbmRzV2l0aCgnIycpKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQuc2xpY2UoMCwgLTEpXG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZFxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jY29sbGVjdC1hLXNlcXVlbmNlLW9mLWNvZGUtcG9pbnRzXG4vKipcbiAqIEBwYXJhbSB7KGNoYXI6IHN0cmluZykgPT4gYm9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMgKGNvbmRpdGlvbiwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHJlc3VsdCA9ICcnXG5cbiAgLy8gMi4gV2hpbGUgcG9zaXRpb24gZG9lc27igJl0IHBvaW50IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCBhbmQgdGhlXG4gIC8vIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IG1lZXRzIHRoZSBjb25kaXRpb24gY29uZGl0aW9uOlxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGggJiYgY29uZGl0aW9uKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSkpIHtcbiAgICAvLyAxLiBBcHBlbmQgdGhhdCBjb2RlIHBvaW50IHRvIHRoZSBlbmQgb2YgcmVzdWx0LlxuICAgIHJlc3VsdCArPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgIC8vIDIuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gcmVzdWx0LlxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQSBmYXN0ZXIgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyB0aGF0IG9ubHkgd29ya3Mgd2hlbiBjb21wYXJpbmcgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QgKGNoYXIsIGlucHV0LCBwb3NpdGlvbikge1xuICBjb25zdCBpZHggPSBpbnB1dC5pbmRleE9mKGNoYXIsIHBvc2l0aW9uLnBvc2l0aW9uKVxuICBjb25zdCBzdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICBwb3NpdGlvbi5wb3NpdGlvbiA9IGlucHV0Lmxlbmd0aFxuICAgIHJldHVybiBpbnB1dC5zbGljZShzdGFydClcbiAgfVxuXG4gIHBvc2l0aW9uLnBvc2l0aW9uID0gaWR4XG4gIHJldHVybiBpbnB1dC5zbGljZShzdGFydCwgcG9zaXRpb24ucG9zaXRpb24pXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3RyaW5nLXBlcmNlbnQtZGVjb2RlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICovXG5mdW5jdGlvbiBzdHJpbmdQZXJjZW50RGVjb2RlIChpbnB1dCkge1xuICAvLyAxLiBMZXQgYnl0ZXMgYmUgdGhlIFVURi04IGVuY29kaW5nIG9mIGlucHV0LlxuICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKGlucHV0KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgcGVyY2VudC1kZWNvZGluZyBvZiBieXRlcy5cbiAgcmV0dXJuIHBlcmNlbnREZWNvZGUoYnl0ZXMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAqL1xuZnVuY3Rpb24gaXNIZXhDaGFyQnl0ZSAoYnl0ZSkge1xuICAvLyAwLTkgQS1GIGEtZlxuICByZXR1cm4gKGJ5dGUgPj0gMHgzMCAmJiBieXRlIDw9IDB4MzkpIHx8IChieXRlID49IDB4NDEgJiYgYnl0ZSA8PSAweDQ2KSB8fCAoYnl0ZSA+PSAweDYxICYmIGJ5dGUgPD0gMHg2Nilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZVxuICovXG5mdW5jdGlvbiBoZXhCeXRlVG9OdW1iZXIgKGJ5dGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyAwLTlcbiAgICBieXRlID49IDB4MzAgJiYgYnl0ZSA8PSAweDM5XG4gICAgICA/IChieXRlIC0gNDgpXG4gICAgLy8gQ29udmVydCB0byB1cHBlcmNhc2VcbiAgICAvLyAoKGJ5dGUgJiAweERGKSAtIDY1KSArIDEwXG4gICAgICA6ICgoYnl0ZSAmIDB4REYpIC0gNTUpXG4gIClcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNwZXJjZW50LWRlY29kZVxuLyoqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXQgKi9cbmZ1bmN0aW9uIHBlcmNlbnREZWNvZGUgKGlucHV0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aFxuICAvLyAxLiBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi9cbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBsZXQgaiA9IDBcbiAgLy8gMi4gRm9yIGVhY2ggYnl0ZSBieXRlIGluIGlucHV0OlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYnl0ZSA9IGlucHV0W2ldXG5cbiAgICAvLyAxLiBJZiBieXRlIGlzIG5vdCAweDI1ICglKSwgdGhlbiBhcHBlbmQgYnl0ZSB0byBvdXRwdXQuXG4gICAgaWYgKGJ5dGUgIT09IDB4MjUpIHtcbiAgICAgIG91dHB1dFtqKytdID0gYnl0ZVxuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBieXRlIGlzIDB4MjUgKCUpIGFuZCB0aGUgbmV4dCB0d28gYnl0ZXNcbiAgICAvLyBhZnRlciBieXRlIGluIGlucHV0IGFyZSBub3QgaW4gdGhlIHJhbmdlc1xuICAgIC8vIDB4MzAgKDApIHRvIDB4MzkgKDkpLCAweDQxIChBKSB0byAweDQ2IChGKSxcbiAgICAvLyBhbmQgMHg2MSAoYSkgdG8gMHg2NiAoZiksIGFsbCBpbmNsdXNpdmUsIGFwcGVuZCBieXRlXG4gICAgLy8gdG8gb3V0cHV0LlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBieXRlID09PSAweDI1ICYmXG4gICAgICAhKGlzSGV4Q2hhckJ5dGUoaW5wdXRbaSArIDFdKSAmJiBpc0hleENoYXJCeXRlKGlucHV0W2kgKyAyXSkpXG4gICAgKSB7XG4gICAgICBvdXRwdXRbaisrXSA9IDB4MjVcblxuICAgIC8vIDMuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gTGV0IGJ5dGVQb2ludCBiZSB0aGUgdHdvIGJ5dGVzIGFmdGVyIGJ5dGUgaW4gaW5wdXQsXG4gICAgICAvLyBkZWNvZGVkLCBhbmQgdGhlbiBpbnRlcnByZXRlZCBhcyBoZXhhZGVjaW1hbCBudW1iZXIuXG4gICAgICAvLyAyLiBBcHBlbmQgYSBieXRlIHdob3NlIHZhbHVlIGlzIGJ5dGVQb2ludCB0byBvdXRwdXQuXG4gICAgICBvdXRwdXRbaisrXSA9IChoZXhCeXRlVG9OdW1iZXIoaW5wdXRbaSArIDFdKSA8PCA0KSB8IGhleEJ5dGVUb051bWJlcihpbnB1dFtpICsgMl0pXG5cbiAgICAgIC8vIDMuIFNraXAgdGhlIG5leHQgdHdvIGJ5dGVzIGluIGlucHV0LlxuICAgICAgaSArPSAyXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIG91dHB1dC5cbiAgcmV0dXJuIGxlbmd0aCA9PT0gaiA/IG91dHB1dCA6IG91dHB1dC5zdWJhcnJheSgwLCBqKVxufVxuXG4vLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWEtbWltZS10eXBlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICovXG5mdW5jdGlvbiBwYXJzZU1JTUVUeXBlIChpbnB1dCkge1xuICAvLyAxLiBSZW1vdmUgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZVxuICAvLyBmcm9tIGlucHV0LlxuICBpbnB1dCA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKGlucHV0LCB0cnVlLCB0cnVlKVxuXG4gIC8vIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvc2l0aW9uIHZhcmlhYmxlIGZvciBpbnB1dCxcbiAgLy8gaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyAzLiBMZXQgdHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZVxuICAvLyBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDJGICgvKSBmcm9tXG4gIC8vIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgY29uc3QgdHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICcvJyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gNC4gSWYgdHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC10b2tlbi1jb2RlLXBvaW50XG4gIGlmICh0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QodHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA1LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gcmV0dXJuXG4gIC8vIGZhaWx1cmVcbiAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAyRiAoLykuKVxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gNy4gTGV0IHN1YnR5cGUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2ZcbiAgLy8gY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOykgZnJvbSBpbnB1dCwgZ2l2ZW5cbiAgLy8gcG9zaXRpb24uXG4gIGxldCBzdWJ0eXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgJzsnLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA4LiBSZW1vdmUgYW55IHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZSBmcm9tIHN1YnR5cGUuXG4gIHN1YnR5cGUgPSByZW1vdmVIVFRQV2hpdGVzcGFjZShzdWJ0eXBlLCBmYWxzZSwgdHJ1ZSlcblxuICAvLyA5LiBJZiBzdWJ0eXBlIGlzIHRoZSBlbXB0eSBzdHJpbmcgb3IgZG9lcyBub3Qgc29sZWx5XG4gIC8vIGNvbnRhaW4gSFRUUCB0b2tlbiBjb2RlIHBvaW50cywgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKHN1YnR5cGUubGVuZ3RoID09PSAwIHx8ICFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChzdWJ0eXBlKSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIGNvbnN0IHR5cGVMb3dlcmNhc2UgPSB0eXBlLnRvTG93ZXJDYXNlKClcbiAgY29uc3Qgc3VidHlwZUxvd2VyY2FzZSA9IHN1YnR5cGUudG9Mb3dlckNhc2UoKVxuXG4gIC8vIDEwLiBMZXQgbWltZVR5cGUgYmUgYSBuZXcgTUlNRSB0eXBlIHJlY29yZCB3aG9zZSB0eXBlXG4gIC8vIGlzIHR5cGUsIGluIEFTQ0lJIGxvd2VyY2FzZSwgYW5kIHN1YnR5cGUgaXMgc3VidHlwZSxcbiAgLy8gaW4gQVNDSUkgbG93ZXJjYXNlLlxuICAvLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI21pbWUtdHlwZVxuICBjb25zdCBtaW1lVHlwZSA9IHtcbiAgICB0eXBlOiB0eXBlTG93ZXJjYXNlLFxuICAgIHN1YnR5cGU6IHN1YnR5cGVMb3dlcmNhc2UsXG4gICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgIHBhcmFtZXRlcnM6IG5ldyBNYXAoKSxcbiAgICAvLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI21pbWUtdHlwZS1lc3NlbmNlXG4gICAgZXNzZW5jZTogYCR7dHlwZUxvd2VyY2FzZX0vJHtzdWJ0eXBlTG93ZXJjYXNlfWBcbiAgfVxuXG4gIC8vIDExLiBXaGlsZSBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0OlxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAvLyAxLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuIChUaGlzIHNraXBzIHBhc3QgVSswMDNCICg7KS4pXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gICAgLy8gMi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIEhUVFBcbiAgICAvLyB3aGl0ZXNwYWNlIGZyb20gaW5wdXQgZ2l2ZW4gcG9zaXRpb24uXG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAgICAgIGNoYXIgPT4gSFRUUF9XSElURVNQQUNFX1JFR0VYLnRlc3QoY2hhciksXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gMy4gTGV0IHBhcmFtZXRlck5hbWUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGFcbiAgICAvLyBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDNCICg7KVxuICAgIC8vIG9yIFUrMDAzRCAoPSkgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgbGV0IHBhcmFtZXRlck5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09ICc7JyAmJiBjaGFyICE9PSAnPScsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gNC4gU2V0IHBhcmFtZXRlck5hbWUgdG8gcGFyYW1ldGVyTmFtZSwgaW4gQVNDSUlcbiAgICAvLyBsb3dlcmNhc2UuXG4gICAgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlck5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gNS4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbjpcbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIC8vIDEuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpc1xuICAgICAgLy8gVSswMDNCICg7KSwgdGhlbiBjb250aW51ZS5cbiAgICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICc7Jykge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuIChUaGlzIHNraXBzIHBhc3QgVSswMDNEICg9KS4pXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gICAgfVxuXG4gICAgLy8gNi4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGJyZWFrLlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyA3LiBMZXQgcGFyYW1ldGVyVmFsdWUgYmUgbnVsbC5cbiAgICBsZXQgcGFyYW1ldGVyVmFsdWUgPSBudWxsXG5cbiAgICAvLyA4LiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXNcbiAgICAvLyBVKzAwMjIgKFwiKSwgdGhlbjpcbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnXCInKSB7XG4gICAgICAvLyAxLiBTZXQgcGFyYW1ldGVyVmFsdWUgdG8gdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nXG4gICAgICAvLyBhbiBIVFRQIHF1b3RlZCBzdHJpbmcgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb25cbiAgICAgIC8vIGFuZCB0aGUgZXh0cmFjdC12YWx1ZSBmbGFnLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nKGlucHV0LCBwb3NpdGlvbiwgdHJ1ZSlcblxuICAgICAgLy8gMi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdFxuICAgICAgLy8gVSswMDNCICg7KSBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgICAnOycsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwb3NpdGlvblxuICAgICAgKVxuXG4gICAgLy8gOS4gT3RoZXJ3aXNlOlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAxLiBTZXQgcGFyYW1ldGVyVmFsdWUgdG8gdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nXG4gICAgICAvLyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspXG4gICAgICAvLyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAgICc7JyxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICApXG5cbiAgICAgIC8vIDIuIFJlbW92ZSBhbnkgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGZyb20gcGFyYW1ldGVyVmFsdWUuXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKHBhcmFtZXRlclZhbHVlLCBmYWxzZSwgdHJ1ZSlcblxuICAgICAgLy8gMy4gSWYgcGFyYW1ldGVyVmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBjb250aW51ZS5cbiAgICAgIGlmIChwYXJhbWV0ZXJWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxMC4gSWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgYXJlIHRydWVcbiAgICAvLyAtIHBhcmFtZXRlck5hbWUgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmdcbiAgICAvLyAtIHBhcmFtZXRlck5hbWUgc29sZWx5IGNvbnRhaW5zIEhUVFAgdG9rZW4gY29kZSBwb2ludHNcbiAgICAvLyAtIHBhcmFtZXRlclZhbHVlIHNvbGVseSBjb250YWlucyBIVFRQIHF1b3RlZC1zdHJpbmcgdG9rZW4gY29kZSBwb2ludHNcbiAgICAvLyAtIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdIGRvZXMgbm90IGV4aXN0XG4gICAgLy8gdGhlbiBzZXQgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gdG8gcGFyYW1ldGVyVmFsdWUuXG4gICAgaWYgKFxuICAgICAgcGFyYW1ldGVyTmFtZS5sZW5ndGggIT09IDAgJiZcbiAgICAgIEhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHBhcmFtZXRlck5hbWUpICYmXG4gICAgICAocGFyYW1ldGVyVmFsdWUubGVuZ3RoID09PSAwIHx8IEhUVFBfUVVPVEVEX1NUUklOR19UT0tFTlMudGVzdChwYXJhbWV0ZXJWYWx1ZSkpICYmXG4gICAgICAhbWltZVR5cGUucGFyYW1ldGVycy5oYXMocGFyYW1ldGVyTmFtZSlcbiAgICApIHtcbiAgICAgIG1pbWVUeXBlLnBhcmFtZXRlcnMuc2V0KHBhcmFtZXRlck5hbWUsIHBhcmFtZXRlclZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEyLiBSZXR1cm4gbWltZVR5cGUuXG4gIHJldHVybiBtaW1lVHlwZVxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jZm9yZ2l2aW5nLWJhc2U2NC1kZWNvZGVcbi8qKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAqL1xuZnVuY3Rpb24gZm9yZ2l2aW5nQmFzZTY0IChkYXRhKSB7XG4gIC8vIDEuIFJlbW92ZSBhbGwgQVNDSUkgd2hpdGVzcGFjZSBmcm9tIGRhdGEuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoQVNDSUlfV0hJVEVTUEFDRV9SRVBMQUNFX1JFR0VYLCAnJykgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBsZXQgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gIC8vIDIuIElmIGRhdGHigJlzIGNvZGUgcG9pbnQgbGVuZ3RoIGRpdmlkZXMgYnkgNCBsZWF2aW5nXG4gIC8vIG5vIHJlbWFpbmRlciwgdGhlbjpcbiAgaWYgKGRhdGFMZW5ndGggJSA0ID09PSAwKSB7XG4gICAgLy8gMS4gSWYgZGF0YSBlbmRzIHdpdGggb25lIG9yIHR3byBVKzAwM0QgKD0pIGNvZGUgcG9pbnRzLFxuICAgIC8vIHRoZW4gcmVtb3ZlIHRoZW0gZnJvbSBkYXRhLlxuICAgIGlmIChkYXRhLmNoYXJDb2RlQXQoZGF0YUxlbmd0aCAtIDEpID09PSAweDAwM0QpIHtcbiAgICAgIC0tZGF0YUxlbmd0aFxuICAgICAgaWYgKGRhdGEuY2hhckNvZGVBdChkYXRhTGVuZ3RoIC0gMSkgPT09IDB4MDAzRCkge1xuICAgICAgICAtLWRhdGFMZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAzLiBJZiBkYXRh4oCZcyBjb2RlIHBvaW50IGxlbmd0aCBkaXZpZGVzIGJ5IDQgbGVhdmluZ1xuICAvLyBhIHJlbWFpbmRlciBvZiAxLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YUxlbmd0aCAlIDQgPT09IDEpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA0LiBJZiBkYXRhIGNvbnRhaW5zIGEgY29kZSBwb2ludCB0aGF0IGlzIG5vdCBvbmUgb2ZcbiAgLy8gIFUrMDAyQiAoKylcbiAgLy8gIFUrMDAyRiAoLylcbiAgLy8gIEFTQ0lJIGFscGhhbnVtZXJpY1xuICAvLyB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoL1teKy8wLTlBLVphLXpdLy50ZXN0KGRhdGEubGVuZ3RoID09PSBkYXRhTGVuZ3RoID8gZGF0YSA6IGRhdGEuc3Vic3RyaW5nKDAsIGRhdGFMZW5ndGgpKSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29sbGVjdC1hbi1odHRwLXF1b3RlZC1zdHJpbmdcbi8vIHRlc3RzOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZXhhbXBsZS1odHRwLXF1b3RlZC1zdHJpbmdcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFuP30gZXh0cmFjdFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcgKGlucHV0LCBwb3NpdGlvbiwgZXh0cmFjdFZhbHVlKSB7XG4gIC8vIDEuIExldCBwb3NpdGlvblN0YXJ0IGJlIHBvc2l0aW9uLlxuICBjb25zdCBwb3NpdGlvblN0YXJ0ID0gcG9zaXRpb24ucG9zaXRpb25cblxuICAvLyAyLiBMZXQgdmFsdWUgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHZhbHVlID0gJydcblxuICAvLyAzLiBBc3NlcnQ6IHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dFxuICAvLyBpcyBVKzAwMjIgKFwiKS5cbiAgYXNzZXJ0KGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJ1wiJylcblxuICAvLyA0LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA1LiBXaGlsZSB0cnVlOlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIDEuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50c1xuICAgIC8vIHRoYXQgYXJlIG5vdCBVKzAwMjIgKFwiKSBvciBVKzAwNUMgKFxcKSBmcm9tIGlucHV0LCBnaXZlblxuICAgIC8vIHBvc2l0aW9uLCB0byB2YWx1ZS5cbiAgICB2YWx1ZSArPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09ICdcIicgJiYgY2hhciAhPT0gJ1xcXFwnLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBicmVhay5cbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDMuIExldCBxdW90ZU9yQmFja3NsYXNoIGJlIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpblxuICAgIC8vIGlucHV0LlxuICAgIGNvbnN0IHF1b3RlT3JCYWNrc2xhc2ggPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgIC8vIDQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyA1LiBJZiBxdW90ZU9yQmFja3NsYXNoIGlzIFUrMDA1QyAoXFwpLCB0aGVuOlxuICAgIGlmIChxdW90ZU9yQmFja3NsYXNoID09PSAnXFxcXCcpIHtcbiAgICAgIC8vIDEuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBhcHBlbmRcbiAgICAgIC8vIFUrMDA1QyAoXFwpIHRvIHZhbHVlIGFuZCBicmVhay5cbiAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgKz0gJ1xcXFwnXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFwcGVuZCB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgdG8gdmFsdWUuXG4gICAgICB2YWx1ZSArPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgICAgLy8gMy4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gICAgLy8gNi4gT3RoZXJ3aXNlOlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAxLiBBc3NlcnQ6IHF1b3RlT3JCYWNrc2xhc2ggaXMgVSswMDIyIChcIikuXG4gICAgICBhc3NlcnQocXVvdGVPckJhY2tzbGFzaCA9PT0gJ1wiJylcblxuICAgICAgLy8gMi4gQnJlYWsuXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIDYuIElmIHRoZSBleHRyYWN0LXZhbHVlIGZsYWcgaXMgc2V0LCB0aGVuIHJldHVybiB2YWx1ZS5cbiAgaWYgKGV4dHJhY3RWYWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gNy4gUmV0dXJuIHRoZSBjb2RlIHBvaW50cyBmcm9tIHBvc2l0aW9uU3RhcnQgdG8gcG9zaXRpb24sXG4gIC8vIGluY2x1c2l2ZSwgd2l0aGluIGlucHV0LlxuICByZXR1cm4gaW5wdXQuc2xpY2UocG9zaXRpb25TdGFydCwgcG9zaXRpb24ucG9zaXRpb24pXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI3NlcmlhbGl6ZS1hLW1pbWUtdHlwZVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVBTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIGFzc2VydChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnKVxuICBjb25zdCB7IHBhcmFtZXRlcnMsIGVzc2VuY2UgfSA9IG1pbWVUeXBlXG5cbiAgLy8gMS4gTGV0IHNlcmlhbGl6YXRpb24gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgbWltZVR5cGXigJlzXG4gIC8vICAgIHR5cGUsIFUrMDAyRiAoLyksIGFuZCBtaW1lVHlwZeKAmXMgc3VidHlwZS5cbiAgbGV0IHNlcmlhbGl6YXRpb24gPSBlc3NlbmNlXG5cbiAgLy8gMi4gRm9yIGVhY2ggbmFtZSDihpIgdmFsdWUgb2YgbWltZVR5cGXigJlzIHBhcmFtZXRlcnM6XG4gIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyYW1ldGVycy5lbnRyaWVzKCkpIHtcbiAgICAvLyAxLiBBcHBlbmQgVSswMDNCICg7KSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gJzsnXG5cbiAgICAvLyAyLiBBcHBlbmQgbmFtZSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gbmFtZVxuXG4gICAgLy8gMy4gQXBwZW5kIFUrMDAzRCAoPSkgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9ICc9J1xuXG4gICAgLy8gNC4gSWYgdmFsdWUgZG9lcyBub3Qgc29sZWx5IGNvbnRhaW4gSFRUUCB0b2tlbiBjb2RlXG4gICAgLy8gICAgcG9pbnRzIG9yIHZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW46XG4gICAgaWYgKCFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdCh2YWx1ZSkpIHtcbiAgICAgIC8vIDEuIFByZWNlZGUgZWFjaCBvY2N1cnJlbmNlIG9mIFUrMDAyMiAoXCIpIG9yXG4gICAgICAvLyAgICBVKzAwNUMgKFxcKSBpbiB2YWx1ZSB3aXRoIFUrMDA1QyAoXFwpLlxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oXFxcXHxcIikvZywgJ1xcXFwkMScpXG5cbiAgICAgIC8vIDIuIFByZXBlbmQgVSswMDIyIChcIikgdG8gdmFsdWUuXG4gICAgICB2YWx1ZSA9ICdcIicgKyB2YWx1ZVxuXG4gICAgICAvLyAzLiBBcHBlbmQgVSswMDIyIChcIikgdG8gdmFsdWUuXG4gICAgICB2YWx1ZSArPSAnXCInXG4gICAgfVxuXG4gICAgLy8gNS4gQXBwZW5kIHZhbHVlIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSB2YWx1ZVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHNlcmlhbGl6YXRpb24uXG4gIHJldHVybiBzZXJpYWxpemF0aW9uXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gY2hhclxuICovXG5mdW5jdGlvbiBpc0hUVFBXaGl0ZVNwYWNlIChjaGFyKSB7XG4gIC8vIFwiXFxyXFxuXFx0IFwiXG4gIHJldHVybiBjaGFyID09PSAweDAwZCB8fCBjaGFyID09PSAweDAwYSB8fCBjaGFyID09PSAweDAwOSB8fCBjaGFyID09PSAweDAyMFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtib29sZWFufSBbbGVhZGluZz10cnVlXVxuICogQHBhcmFtIHtib29sZWFufSBbdHJhaWxpbmc9dHJ1ZV1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlSFRUUFdoaXRlc3BhY2UgKHN0ciwgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSkge1xuICByZXR1cm4gcmVtb3ZlQ2hhcnMoc3RyLCBsZWFkaW5nLCB0cmFpbGluZywgaXNIVFRQV2hpdGVTcGFjZSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gY2hhclxuICovXG5mdW5jdGlvbiBpc0FTQ0lJV2hpdGVzcGFjZSAoY2hhcikge1xuICAvLyBcIlxcclxcblxcdFxcZiBcIlxuICByZXR1cm4gY2hhciA9PT0gMHgwMGQgfHwgY2hhciA9PT0gMHgwMGEgfHwgY2hhciA9PT0gMHgwMDkgfHwgY2hhciA9PT0gMHgwMGMgfHwgY2hhciA9PT0gMHgwMjBcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1sZWFkaW5nLWFuZC10cmFpbGluZy1hc2NpaS13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsZWFkaW5nPXRydWVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFpbGluZz10cnVlXVxuICovXG5mdW5jdGlvbiByZW1vdmVBU0NJSVdoaXRlc3BhY2UgKHN0ciwgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSkge1xuICByZXR1cm4gcmVtb3ZlQ2hhcnMoc3RyLCBsZWFkaW5nLCB0cmFpbGluZywgaXNBU0NJSVdoaXRlc3BhY2UpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtib29sZWFufSBsZWFkaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRyYWlsaW5nXG4gKiBAcGFyYW0geyhjaGFyQ29kZTogbnVtYmVyKSA9PiBib29sZWFufSBwcmVkaWNhdGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoYXJzIChzdHIsIGxlYWRpbmcsIHRyYWlsaW5nLCBwcmVkaWNhdGUpIHtcbiAgbGV0IGxlYWQgPSAwXG4gIGxldCB0cmFpbCA9IHN0ci5sZW5ndGggLSAxXG5cbiAgaWYgKGxlYWRpbmcpIHtcbiAgICB3aGlsZSAobGVhZCA8IHN0ci5sZW5ndGggJiYgcHJlZGljYXRlKHN0ci5jaGFyQ29kZUF0KGxlYWQpKSkgbGVhZCsrXG4gIH1cblxuICBpZiAodHJhaWxpbmcpIHtcbiAgICB3aGlsZSAodHJhaWwgPiAwICYmIHByZWRpY2F0ZShzdHIuY2hhckNvZGVBdCh0cmFpbCkpKSB0cmFpbC0tXG4gIH1cblxuICByZXR1cm4gbGVhZCA9PT0gMCAmJiB0cmFpbCA9PT0gc3RyLmxlbmd0aCAtIDEgPyBzdHIgOiBzdHIuc2xpY2UobGVhZCwgdHJhaWwgKyAxKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2lzb21vcnBoaWMtZGVjb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBpc29tb3JwaGljRGVjb2RlIChpbnB1dCkge1xuICAvLyAxLiBUbyBpc29tb3JwaGljIGRlY29kZSBhIGJ5dGUgc2VxdWVuY2UgaW5wdXQsIHJldHVybiBhIHN0cmluZyB3aG9zZSBjb2RlIHBvaW50XG4gIC8vICAgIGxlbmd0aCBpcyBlcXVhbCB0byBpbnB1dOKAmXMgbGVuZ3RoIGFuZCB3aG9zZSBjb2RlIHBvaW50cyBoYXZlIHRoZSBzYW1lIHZhbHVlc1xuICAvLyAgICBhcyB0aGUgdmFsdWVzIG9mIGlucHV04oCZcyBieXRlcywgaW4gdGhlIHNhbWUgb3JkZXIuXG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aFxuICBpZiAoKDIgPDwgMTUpIC0gMSA+IGxlbmd0aCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlucHV0KVxuICB9XG4gIGxldCByZXN1bHQgPSAnJzsgbGV0IGkgPSAwXG4gIGxldCBhZGRpdGlvbiA9ICgyIDw8IDE1KSAtIDFcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoaSArIGFkZGl0aW9uID4gbGVuZ3RoKSB7XG4gICAgICBhZGRpdGlvbiA9IGxlbmd0aCAtIGlcbiAgICB9XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaW5wdXQuc3ViYXJyYXkoaSwgaSArPSBhZGRpdGlvbikpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW5pbWl6ZS1hLXN1cHBvcnRlZC1taW1lLXR5cGVcbiAqIEBwYXJhbSB7RXhjbHVkZTxSZXR1cm5UeXBlPHR5cGVvZiBwYXJzZU1JTUVUeXBlPiwgJ2ZhaWx1cmUnPn0gbWltZVR5cGVcbiAqL1xuZnVuY3Rpb24gbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSAobWltZVR5cGUpIHtcbiAgc3dpdGNoIChtaW1lVHlwZS5lc3NlbmNlKSB7XG4gICAgY2FzZSAnYXBwbGljYXRpb24vZWNtYXNjcmlwdCc6XG4gICAgY2FzZSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6XG4gICAgY2FzZSAnYXBwbGljYXRpb24veC1lY21hc2NyaXB0JzpcbiAgICBjYXNlICdhcHBsaWNhdGlvbi94LWphdmFzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQvZWNtYXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjAnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuMSc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS4yJzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjMnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuNCc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS41JzpcbiAgICBjYXNlICd0ZXh0L2pzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQvbGl2ZXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC94LWVjbWFzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQveC1qYXZhc2NyaXB0JzpcbiAgICAgIC8vIDEuIElmIG1pbWVUeXBlIGlzIGEgSmF2YVNjcmlwdCBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwidGV4dC9qYXZhc2NyaXB0XCIuXG4gICAgICByZXR1cm4gJ3RleHQvamF2YXNjcmlwdCdcbiAgICBjYXNlICdhcHBsaWNhdGlvbi9qc29uJzpcbiAgICBjYXNlICd0ZXh0L2pzb24nOlxuICAgICAgLy8gMi4gSWYgbWltZVR5cGUgaXMgYSBKU09OIE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJhcHBsaWNhdGlvbi9qc29uXCIuXG4gICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgY2FzZSAnaW1hZ2Uvc3ZnK3htbCc6XG4gICAgICAvLyAzLiBJZiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBcImltYWdlL3N2Zyt4bWxcIiwgdGhlbiByZXR1cm4gXCJpbWFnZS9zdmcreG1sXCIuXG4gICAgICByZXR1cm4gJ2ltYWdlL3N2Zyt4bWwnXG4gICAgY2FzZSAndGV4dC94bWwnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3htbCc6XG4gICAgICAvLyA0LiBJZiBtaW1lVHlwZSBpcyBhbiBYTUwgTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcImFwcGxpY2F0aW9uL3htbFwiLlxuICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi94bWwnXG4gIH1cblxuICAvLyAyLiBJZiBtaW1lVHlwZSBpcyBhIEpTT04gTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcImFwcGxpY2F0aW9uL2pzb25cIi5cbiAgaWYgKG1pbWVUeXBlLnN1YnR5cGUuZW5kc1dpdGgoJytqc29uJykpIHtcbiAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2pzb24nXG4gIH1cblxuICAvLyA0LiBJZiBtaW1lVHlwZSBpcyBhbiBYTUwgTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcImFwcGxpY2F0aW9uL3htbFwiLlxuICBpZiAobWltZVR5cGUuc3VidHlwZS5lbmRzV2l0aCgnK3htbCcpKSB7XG4gICAgcmV0dXJuICdhcHBsaWNhdGlvbi94bWwnXG4gIH1cblxuICAvLyA1LiBJZiBtaW1lVHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhlIHVzZXIgYWdlbnQsIHRoZW4gcmV0dXJuIG1pbWVUeXBl4oCZcyBlc3NlbmNlLlxuICAvLyBUZWNobmljYWxseSwgbm9kZSBkb2Vzbid0IHN1cHBvcnQgYW55IG1pbWV0eXBlcy5cblxuICAvLyA2LiBSZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgcmV0dXJuICcnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkYXRhVVJMUHJvY2Vzc29yLFxuICBVUkxTZXJpYWxpemVyLFxuICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzLFxuICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCxcbiAgc3RyaW5nUGVyY2VudERlY29kZSxcbiAgcGFyc2VNSU1FVHlwZSxcbiAgY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyxcbiAgc2VyaWFsaXplQU1pbWVUeXBlLFxuICByZW1vdmVDaGFycyxcbiAgcmVtb3ZlSFRUUFdoaXRlc3BhY2UsXG4gIG1pbmltaXplU3VwcG9ydGVkTWltZVR5cGUsXG4gIEhUVFBfVE9LRU5fQ09ERVBPSU5UUyxcbiAgaXNvbW9ycGhpY0RlY29kZVxufVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJIVFRQX1RPS0VOX0NPREVQT0lOVFMiLCJIVFRQX1dISVRFU1BBQ0VfUkVHRVgiLCJBU0NJSV9XSElURVNQQUNFX1JFUExBQ0VfUkVHRVgiLCJIVFRQX1FVT1RFRF9TVFJJTkdfVE9LRU5TIiwiZGF0YVVSTFByb2Nlc3NvciIsImRhdGFVUkwiLCJwcm90b2NvbCIsImlucHV0IiwiVVJMU2VyaWFsaXplciIsInNsaWNlIiwicG9zaXRpb24iLCJtaW1lVHlwZSIsImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IiwibWltZVR5cGVMZW5ndGgiLCJsZW5ndGgiLCJyZW1vdmVBU0NJSVdoaXRlc3BhY2UiLCJlbmNvZGVkQm9keSIsImJvZHkiLCJzdHJpbmdQZXJjZW50RGVjb2RlIiwidGVzdCIsInN0cmluZ0JvZHkiLCJpc29tb3JwaGljRGVjb2RlIiwiZm9yZ2l2aW5nQmFzZTY0IiwicmVwbGFjZSIsInN0YXJ0c1dpdGgiLCJtaW1lVHlwZVJlY29yZCIsInBhcnNlTUlNRVR5cGUiLCJ1cmwiLCJleGNsdWRlRnJhZ21lbnQiLCJocmVmIiwiaGFzaExlbmd0aCIsImhhc2giLCJzZXJpYWxpemVkIiwic3Vic3RyaW5nIiwiZW5kc1dpdGgiLCJjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzIiwiY29uZGl0aW9uIiwicmVzdWx0IiwiY2hhciIsImlkeCIsImluZGV4T2YiLCJzdGFydCIsImJ5dGVzIiwiZW5jb2RlIiwicGVyY2VudERlY29kZSIsImlzSGV4Q2hhckJ5dGUiLCJieXRlIiwiaGV4Qnl0ZVRvTnVtYmVyIiwib3V0cHV0IiwiVWludDhBcnJheSIsImoiLCJpIiwic3ViYXJyYXkiLCJyZW1vdmVIVFRQV2hpdGVzcGFjZSIsInR5cGUiLCJzdWJ0eXBlIiwidHlwZUxvd2VyY2FzZSIsInRvTG93ZXJDYXNlIiwic3VidHlwZUxvd2VyY2FzZSIsInBhcmFtZXRlcnMiLCJNYXAiLCJlc3NlbmNlIiwicGFyYW1ldGVyTmFtZSIsInBhcmFtZXRlclZhbHVlIiwiY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyIsImhhcyIsInNldCIsImRhdGEiLCJkYXRhTGVuZ3RoIiwiY2hhckNvZGVBdCIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImV4dHJhY3RWYWx1ZSIsInBvc2l0aW9uU3RhcnQiLCJ2YWx1ZSIsInF1b3RlT3JCYWNrc2xhc2giLCJzZXJpYWxpemVBTWltZVR5cGUiLCJzZXJpYWxpemF0aW9uIiwibmFtZSIsImVudHJpZXMiLCJpc0hUVFBXaGl0ZVNwYWNlIiwic3RyIiwibGVhZGluZyIsInRyYWlsaW5nIiwicmVtb3ZlQ2hhcnMiLCJpc0FTQ0lJV2hpdGVzcGFjZSIsInByZWRpY2F0ZSIsImxlYWQiLCJ0cmFpbCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiYWRkaXRpb24iLCJtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js":
/*!*****************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/dispatcher-weakref.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kConnected, kSize } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nclass CompatWeakRef {\n    constructor(value){\n        this.value = value;\n    }\n    deref() {\n        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;\n    }\n}\nclass CompatFinalizer {\n    constructor(finalizer){\n        this.finalizer = finalizer;\n    }\n    register(dispatcher, key) {\n        if (dispatcher.on) {\n            dispatcher.on('disconnect', ()=>{\n                if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n                    this.finalizer(key);\n                }\n            });\n        }\n    }\n    unregister(key) {}\n}\nmodule.exports = function() {\n    // FIXME: remove workaround when the Node bug is backported to v18\n    // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\n    if (process.env.NODE_V8_COVERAGE && process.version.startsWith('v18')) {\n        process._rawDebug('Using compatibility WeakRef and FinalizationRegistry');\n        return {\n            WeakRef: CompatWeakRef,\n            FinalizationRegistry: CompatFinalizer\n        };\n    }\n    return {\n        WeakRef,\n        FinalizationRegistry\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGlzcGF0Y2hlci13ZWFrcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxVQUFVLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQywyRUFBb0I7QUFFMUQsTUFBTUM7SUFDSixZQUFhQyxLQUFLLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2Y7SUFFQUMsUUFBUztRQUNQLE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUNKLFdBQVcsS0FBSyxLQUFLLElBQUksQ0FBQ0ksS0FBSyxDQUFDSCxNQUFNLEtBQUssSUFDekRLLFlBQ0EsSUFBSSxDQUFDRixLQUFLO0lBQ2hCO0FBQ0Y7QUFFQSxNQUFNRztJQUNKLFlBQWFDLFNBQVMsQ0FBRTtRQUN0QixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDbkI7SUFFQUMsU0FBVUMsVUFBVSxFQUFFQyxHQUFHLEVBQUU7UUFDekIsSUFBSUQsV0FBV0UsRUFBRSxFQUFFO1lBQ2pCRixXQUFXRSxFQUFFLENBQUMsY0FBYztnQkFDMUIsSUFBSUYsVUFBVSxDQUFDVixXQUFXLEtBQUssS0FBS1UsVUFBVSxDQUFDVCxNQUFNLEtBQUssR0FBRztvQkFDM0QsSUFBSSxDQUFDTyxTQUFTLENBQUNHO2dCQUNqQjtZQUNGO1FBQ0Y7SUFDRjtJQUVBRSxXQUFZRixHQUFHLEVBQUUsQ0FBQztBQUNwQjtBQUVBRyxPQUFPQyxPQUFPLEdBQUc7SUFDZixrRUFBa0U7SUFDbEUsc0VBQXNFO0lBQ3RFLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsZ0JBQWdCLElBQUlGLFFBQVFHLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLFFBQVE7UUFDckVKLFFBQVFLLFNBQVMsQ0FBQztRQUNsQixPQUFPO1lBQ0xDLFNBQVNuQjtZQUNUb0Isc0JBQXNCaEI7UUFDeEI7SUFDRjtJQUNBLE9BQU87UUFBRWU7UUFBU0M7SUFBcUI7QUFDekMiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcZGlzcGF0Y2hlci13ZWFrcmVmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25uZWN0ZWQsIGtTaXplIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuXG5jbGFzcyBDb21wYXRXZWFrUmVmIHtcbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICBkZXJlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVba0Nvbm5lY3RlZF0gPT09IDAgJiYgdGhpcy52YWx1ZVtrU2l6ZV0gPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMudmFsdWVcbiAgfVxufVxuXG5jbGFzcyBDb21wYXRGaW5hbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoZmluYWxpemVyKSB7XG4gICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXJcbiAgfVxuXG4gIHJlZ2lzdGVyIChkaXNwYXRjaGVyLCBrZXkpIHtcbiAgICBpZiAoZGlzcGF0Y2hlci5vbikge1xuICAgICAgZGlzcGF0Y2hlci5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgaWYgKGRpc3BhdGNoZXJba0Nvbm5lY3RlZF0gPT09IDAgJiYgZGlzcGF0Y2hlcltrU2l6ZV0gPT09IDApIHtcbiAgICAgICAgICB0aGlzLmZpbmFsaXplcihrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdW5yZWdpc3RlciAoa2V5KSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRklYTUU6IHJlbW92ZSB3b3JrYXJvdW5kIHdoZW4gdGhlIE5vZGUgYnVnIGlzIGJhY2twb3J0ZWQgdG8gdjE4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDhcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfVjhfQ09WRVJBR0UgJiYgcHJvY2Vzcy52ZXJzaW9uLnN0YXJ0c1dpdGgoJ3YxOCcpKSB7XG4gICAgcHJvY2Vzcy5fcmF3RGVidWcoJ1VzaW5nIGNvbXBhdGliaWxpdHkgV2Vha1JlZiBhbmQgRmluYWxpemF0aW9uUmVnaXN0cnknKVxuICAgIHJldHVybiB7XG4gICAgICBXZWFrUmVmOiBDb21wYXRXZWFrUmVmLFxuICAgICAgRmluYWxpemF0aW9uUmVnaXN0cnk6IENvbXBhdEZpbmFsaXplclxuICAgIH1cbiAgfVxuICByZXR1cm4geyBXZWFrUmVmLCBGaW5hbGl6YXRpb25SZWdpc3RyeSB9XG59XG4iXSwibmFtZXMiOlsia0Nvbm5lY3RlZCIsImtTaXplIiwicmVxdWlyZSIsIkNvbXBhdFdlYWtSZWYiLCJ2YWx1ZSIsImRlcmVmIiwidW5kZWZpbmVkIiwiQ29tcGF0RmluYWxpemVyIiwiZmluYWxpemVyIiwicmVnaXN0ZXIiLCJkaXNwYXRjaGVyIiwia2V5Iiwib24iLCJ1bnJlZ2lzdGVyIiwibW9kdWxlIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1Y4X0NPVkVSQUdFIiwidmVyc2lvbiIsInN0YXJ0c1dpdGgiLCJfcmF3RGVidWciLCJXZWFrUmVmIiwiRmluYWxpemF0aW9uUmVnaXN0cnkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/file.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Blob, File } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\n// TODO(@KhafraDev): remove\nclass FileLike {\n    constructor(blobLike, fileName, options = {}){\n        // TODO: argument idl type check\n        // The File constructor is invoked with two or three parameters, depending\n        // on whether the optional dictionary parameter is used. When the File()\n        // constructor is invoked, user agents must run the following steps:\n        // 1. Let bytes be the result of processing blob parts given fileBits and\n        // options.\n        // 2. Let n be the fileName argument to the constructor.\n        const n = fileName;\n        // 3. Process FilePropertyBag dictionary argument by running the following\n        // substeps:\n        //    1. If the type member is provided and is not the empty string, let t\n        //    be set to the type dictionary member. If t contains any characters\n        //    outside the range U+0020 to U+007E, then set t to the empty string\n        //    and return from these substeps.\n        //    TODO\n        const t = options.type;\n        //    2. Convert every character in t to ASCII lowercase.\n        //    TODO\n        //    3. If the lastModified member is provided, let d be set to the\n        //    lastModified dictionary member. If it is not provided, set d to the\n        //    current date and time represented as the number of milliseconds since\n        //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n        const d = options.lastModified ?? Date.now();\n        // 4. Return a new File object F such that:\n        // F refers to the bytes byte sequence.\n        // F.size is set to the number of total bytes in bytes.\n        // F.name is set to n.\n        // F.type is set to t.\n        // F.lastModified is set to d.\n        this[kState] = {\n            blobLike,\n            name: n,\n            type: t,\n            lastModified: d\n        };\n    }\n    stream(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.stream(...args);\n    }\n    arrayBuffer(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.arrayBuffer(...args);\n    }\n    slice(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.slice(...args);\n    }\n    text(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.text(...args);\n    }\n    get size() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.size;\n    }\n    get type() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.type;\n    }\n    get name() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].name;\n    }\n    get lastModified() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return 'File';\n    }\n}\nwebidl.converters.Blob = webidl.interfaceConverter(Blob);\n// If this function is moved to ./util.js, some tools (such as\n// rollup) will warn about circular dependencies. See:\n// https://github.com/nodejs/undici/issues/1629\nfunction isFileLike(object) {\n    return object instanceof File || object && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && object[Symbol.toStringTag] === 'File';\n}\nmodule.exports = {\n    FileLike,\n    isFileLike\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsSUFBSSxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDNUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0QsbUJBQU9BLENBQUMsdUVBQVc7QUFDdEMsTUFBTSxFQUFFRSxNQUFNLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMscUVBQVU7QUFFckMsMkJBQTJCO0FBQzNCLE1BQU1HO0lBQ0osWUFBYUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDN0MsZ0NBQWdDO1FBRWhDLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsb0VBQW9FO1FBRXBFLHlFQUF5RTtRQUN6RSxXQUFXO1FBRVgsd0RBQXdEO1FBQ3hELE1BQU1DLElBQUlGO1FBRVYsMEVBQTBFO1FBQzFFLFlBQVk7UUFFWiwwRUFBMEU7UUFDMUUsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RSxxQ0FBcUM7UUFDckMsVUFBVTtRQUNWLE1BQU1HLElBQUlGLFFBQVFHLElBQUk7UUFFdEIseURBQXlEO1FBQ3pELFVBQVU7UUFFVixvRUFBb0U7UUFDcEUseUVBQXlFO1FBQ3pFLDJFQUEyRTtRQUMzRSx3RUFBd0U7UUFDeEUsTUFBTUMsSUFBSUosUUFBUUssWUFBWSxJQUFJQyxLQUFLQyxHQUFHO1FBRTFDLDJDQUEyQztRQUMzQyx1Q0FBdUM7UUFDdkMsdURBQXVEO1FBQ3ZELHNCQUFzQjtRQUN0QixzQkFBc0I7UUFDdEIsOEJBQThCO1FBRTlCLElBQUksQ0FBQ1osT0FBTyxHQUFHO1lBQ2JHO1lBQ0FVLE1BQU1QO1lBQ05FLE1BQU1EO1lBQ05HLGNBQWNEO1FBQ2hCO0lBQ0Y7SUFFQUssT0FBUSxHQUFHQyxJQUFJLEVBQUU7UUFDZmQsT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRWQ7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0csUUFBUSxDQUFDVyxNQUFNLElBQUlDO0lBQ3pDO0lBRUFFLFlBQWEsR0FBR0YsSUFBSSxFQUFFO1FBQ3BCZCxPQUFPZSxVQUFVLENBQUMsSUFBSSxFQUFFZDtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDRyxRQUFRLENBQUNjLFdBQVcsSUFBSUY7SUFDOUM7SUFFQUcsTUFBTyxHQUFHSCxJQUFJLEVBQUU7UUFDZGQsT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRWQ7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0csUUFBUSxDQUFDZSxLQUFLLElBQUlIO0lBQ3hDO0lBRUFJLEtBQU0sR0FBR0osSUFBSSxFQUFFO1FBQ2JkLE9BQU9lLFVBQVUsQ0FBQyxJQUFJLEVBQUVkO1FBRXhCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNHLFFBQVEsQ0FBQ2dCLElBQUksSUFBSUo7SUFDdkM7SUFFQSxJQUFJSyxPQUFRO1FBQ1ZuQixPQUFPZSxVQUFVLENBQUMsSUFBSSxFQUFFZDtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDRyxRQUFRLENBQUNpQixJQUFJO0lBQ25DO0lBRUEsSUFBSVosT0FBUTtRQUNWUCxPQUFPZSxVQUFVLENBQUMsSUFBSSxFQUFFZDtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDRyxRQUFRLENBQUNLLElBQUk7SUFDbkM7SUFFQSxJQUFJSyxPQUFRO1FBQ1ZaLE9BQU9lLFVBQVUsQ0FBQyxJQUFJLEVBQUVkO1FBRXhCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNhLElBQUk7SUFDMUI7SUFFQSxJQUFJSCxlQUFnQjtRQUNsQlQsT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRWQ7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1UsWUFBWTtJQUNsQztJQUVBLElBQUksQ0FBQ1csT0FBT0MsV0FBVyxDQUFDLEdBQUk7UUFDMUIsT0FBTztJQUNUO0FBQ0Y7QUFFQXJCLE9BQU9zQixVQUFVLENBQUMxQixJQUFJLEdBQUdJLE9BQU91QixrQkFBa0IsQ0FBQzNCO0FBRW5ELDhEQUE4RDtBQUM5RCxzREFBc0Q7QUFDdEQsK0NBQStDO0FBQy9DLFNBQVM0QixXQUFZQyxNQUFNO0lBQ3pCLE9BQ0Usa0JBQW1CNUIsUUFFakI0QixVQUNDLFFBQU9BLE9BQU9aLE1BQU0sS0FBSyxjQUMxQixPQUFPWSxPQUFPVCxXQUFXLEtBQUssVUFBUyxLQUN2Q1MsTUFBTSxDQUFDTCxPQUFPQyxXQUFXLENBQUMsS0FBSztBQUdyQztBQUVBSyxPQUFPQyxPQUFPLEdBQUc7SUFBRTFCO0lBQVV1QjtBQUFXIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGZpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQmxvYiwgRmlsZSB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuXG4vLyBUT0RPKEBLaGFmcmFEZXYpOiByZW1vdmVcbmNsYXNzIEZpbGVMaWtlIHtcbiAgY29uc3RydWN0b3IgKGJsb2JMaWtlLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gVE9ETzogYXJndW1lbnQgaWRsIHR5cGUgY2hlY2tcblxuICAgIC8vIFRoZSBGaWxlIGNvbnN0cnVjdG9yIGlzIGludm9rZWQgd2l0aCB0d28gb3IgdGhyZWUgcGFyYW1ldGVycywgZGVwZW5kaW5nXG4gICAgLy8gb24gd2hldGhlciB0aGUgb3B0aW9uYWwgZGljdGlvbmFyeSBwYXJhbWV0ZXIgaXMgdXNlZC4gV2hlbiB0aGUgRmlsZSgpXG4gICAgLy8gY29uc3RydWN0b3IgaXMgaW52b2tlZCwgdXNlciBhZ2VudHMgbXVzdCBydW4gdGhlIGZvbGxvd2luZyBzdGVwczpcblxuICAgIC8vIDEuIExldCBieXRlcyBiZSB0aGUgcmVzdWx0IG9mIHByb2Nlc3NpbmcgYmxvYiBwYXJ0cyBnaXZlbiBmaWxlQml0cyBhbmRcbiAgICAvLyBvcHRpb25zLlxuXG4gICAgLy8gMi4gTGV0IG4gYmUgdGhlIGZpbGVOYW1lIGFyZ3VtZW50IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdCBuID0gZmlsZU5hbWVcblxuICAgIC8vIDMuIFByb2Nlc3MgRmlsZVByb3BlcnR5QmFnIGRpY3Rpb25hcnkgYXJndW1lbnQgYnkgcnVubmluZyB0aGUgZm9sbG93aW5nXG4gICAgLy8gc3Vic3RlcHM6XG5cbiAgICAvLyAgICAxLiBJZiB0aGUgdHlwZSBtZW1iZXIgaXMgcHJvdmlkZWQgYW5kIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgdFxuICAgIC8vICAgIGJlIHNldCB0byB0aGUgdHlwZSBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgdCBjb250YWlucyBhbnkgY2hhcmFjdGVyc1xuICAgIC8vICAgIG91dHNpZGUgdGhlIHJhbmdlIFUrMDAyMCB0byBVKzAwN0UsIHRoZW4gc2V0IHQgdG8gdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vICAgIGFuZCByZXR1cm4gZnJvbSB0aGVzZSBzdWJzdGVwcy5cbiAgICAvLyAgICBUT0RPXG4gICAgY29uc3QgdCA9IG9wdGlvbnMudHlwZVxuXG4gICAgLy8gICAgMi4gQ29udmVydCBldmVyeSBjaGFyYWN0ZXIgaW4gdCB0byBBU0NJSSBsb3dlcmNhc2UuXG4gICAgLy8gICAgVE9ET1xuXG4gICAgLy8gICAgMy4gSWYgdGhlIGxhc3RNb2RpZmllZCBtZW1iZXIgaXMgcHJvdmlkZWQsIGxldCBkIGJlIHNldCB0byB0aGVcbiAgICAvLyAgICBsYXN0TW9kaWZpZWQgZGljdGlvbmFyeSBtZW1iZXIuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgc2V0IGQgdG8gdGhlXG4gICAgLy8gICAgY3VycmVudCBkYXRlIGFuZCB0aW1lIHJlcHJlc2VudGVkIGFzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgLy8gICAgdGhlIFVuaXggRXBvY2ggKHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIERhdGUubm93KCkgW0VDTUEtMjYyXSkuXG4gICAgY29uc3QgZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID8/IERhdGUubm93KClcblxuICAgIC8vIDQuIFJldHVybiBhIG5ldyBGaWxlIG9iamVjdCBGIHN1Y2ggdGhhdDpcbiAgICAvLyBGIHJlZmVycyB0byB0aGUgYnl0ZXMgYnl0ZSBzZXF1ZW5jZS5cbiAgICAvLyBGLnNpemUgaXMgc2V0IHRvIHRoZSBudW1iZXIgb2YgdG90YWwgYnl0ZXMgaW4gYnl0ZXMuXG4gICAgLy8gRi5uYW1lIGlzIHNldCB0byBuLlxuICAgIC8vIEYudHlwZSBpcyBzZXQgdG8gdC5cbiAgICAvLyBGLmxhc3RNb2RpZmllZCBpcyBzZXQgdG8gZC5cblxuICAgIHRoaXNba1N0YXRlXSA9IHtcbiAgICAgIGJsb2JMaWtlLFxuICAgICAgbmFtZTogbixcbiAgICAgIHR5cGU6IHQsXG4gICAgICBsYXN0TW9kaWZpZWQ6IGRcbiAgICB9XG4gIH1cblxuICBzdHJlYW0gKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc3RyZWFtKC4uLmFyZ3MpXG4gIH1cblxuICBhcnJheUJ1ZmZlciAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5hcnJheUJ1ZmZlciguLi5hcmdzKVxuICB9XG5cbiAgc2xpY2UgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc2xpY2UoLi4uYXJncylcbiAgfVxuXG4gIHRleHQgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UudGV4dCguLi5hcmdzKVxuICB9XG5cbiAgZ2V0IHNpemUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zaXplXG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnR5cGVcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubmFtZVxuICB9XG5cbiAgZ2V0IGxhc3RNb2RpZmllZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0ZpbGUnXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuQmxvYiA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoQmxvYilcblxuLy8gSWYgdGhpcyBmdW5jdGlvbiBpcyBtb3ZlZCB0byAuL3V0aWwuanMsIHNvbWUgdG9vbHMgKHN1Y2ggYXNcbi8vIHJvbGx1cCkgd2lsbCB3YXJuIGFib3V0IGNpcmN1bGFyIGRlcGVuZGVuY2llcy4gU2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE2MjlcbmZ1bmN0aW9uIGlzRmlsZUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIChvYmplY3QgaW5zdGFuY2VvZiBGaWxlKSB8fFxuICAgIChcbiAgICAgIG9iamVjdCAmJlxuICAgICAgKHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGaWxlJ1xuICAgIClcbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgRmlsZUxpa2UsIGlzRmlsZUxpa2UgfVxuIl0sIm5hbWVzIjpbIkJsb2IiLCJGaWxlIiwicmVxdWlyZSIsImtTdGF0ZSIsIndlYmlkbCIsIkZpbGVMaWtlIiwiYmxvYkxpa2UiLCJmaWxlTmFtZSIsIm9wdGlvbnMiLCJuIiwidCIsInR5cGUiLCJkIiwibGFzdE1vZGlmaWVkIiwiRGF0ZSIsIm5vdyIsIm5hbWUiLCJzdHJlYW0iLCJhcmdzIiwiYnJhbmRDaGVjayIsImFycmF5QnVmZmVyIiwic2xpY2UiLCJ0ZXh0Iiwic2l6ZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiY29udmVydGVycyIsImludGVyZmFjZUNvbnZlcnRlciIsImlzRmlsZUxpa2UiLCJvYmplY3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata-parser.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isUSVString, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { utf8DecodeBytes } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { isFileLike } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/undici/lib/web/fetch/file.js\");\nconst { makeEntry } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { File: NodeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst File = globalThis.File ?? NodeFile;\nconst formDataNameBuffer = Buffer.from('form-data; name=\"');\nconst filenameBuffer = Buffer.from('; filename');\nconst dd = Buffer.from('--');\nconst ddcrlf = Buffer.from('--\\r\\n');\n/**\n * @param {string} chars\n */ function isAsciiString(chars) {\n    for(let i = 0; i < chars.length; ++i){\n        if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */ function validateBoundary(boundary) {\n    const length = boundary.length;\n    // - its length is greater or equal to 27 and lesser or equal to 70, and\n    if (length < 27 || length > 70) {\n        return false;\n    }\n    // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n    //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n    //   0x2D (-) or 0x5F (_).\n    for(let i = 0; i < length; ++i){\n        const cp = boundary.charCodeAt(i);\n        if (!(cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x5a || cp >= 0x61 && cp <= 0x7a || cp === 0x27 || cp === 0x2d || cp === 0x5f)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */ function multipartFormDataParser(input, mimeType) {\n    // 1. Assert: mimeType’s essence is \"multipart/form-data\".\n    assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data');\n    const boundaryString = mimeType.parameters.get('boundary');\n    // 2. If mimeType’s parameters[\"boundary\"] does not exist, return failure.\n    //    Otherwise, let boundary be the result of UTF-8 decoding mimeType’s\n    //    parameters[\"boundary\"].\n    if (boundaryString === undefined) {\n        return 'failure';\n    }\n    const boundary = Buffer.from(`--${boundaryString}`, 'utf8');\n    // 3. Let entry list be an empty entry list.\n    const entryList = [];\n    // 4. Let position be a pointer to a byte in input, initially pointing at\n    //    the first byte.\n    const position = {\n        position: 0\n    };\n    // Note: undici addition, allow \\r\\n before the body.\n    if (input[0] === 0x0d && input[1] === 0x0a) {\n        position.position += 2;\n    }\n    // 5. While true:\n    while(true){\n        // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n        //      (`--`) followed by boundary, advance position by 2 + the length of\n        //      boundary. Otherwise, return failure.\n        // Note: boundary is padded with 2 dashes already, no need to add 2.\n        if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n            position.position += boundary.length;\n        } else {\n            return 'failure';\n        }\n        // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n        //      (`--` followed by CR LF) followed by the end of input, return entry list.\n        // Note: a body does NOT need to end with CRLF. It can end with --.\n        if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {\n            return entryList;\n        }\n        // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n        //      0x0A (CR LF), return failure.\n        if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n            return 'failure';\n        }\n        // 5.4. Advance position by 2. (This skips past the newline.)\n        position.position += 2;\n        // 5.5. Let name, filename and contentType be the result of parsing\n        //      multipart/form-data headers on input and position, if the result\n        //      is not failure. Otherwise, return failure.\n        const result = parseMultipartFormDataHeaders(input, position);\n        if (result === 'failure') {\n            return 'failure';\n        }\n        let { name, filename, contentType, encoding } = result;\n        // 5.6. Advance position by 2. (This skips past the empty line that marks\n        //      the end of the headers.)\n        position.position += 2;\n        // 5.7. Let body be the empty byte sequence.\n        let body;\n        // 5.8. Body loop: While position is not past the end of input:\n        // TODO: the steps here are completely wrong\n        {\n            const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);\n            if (boundaryIndex === -1) {\n                return 'failure';\n            }\n            body = input.subarray(position.position, boundaryIndex - 4);\n            position.position += body.length;\n            // Note: position must be advanced by the body's length before being\n            // decoded, otherwise the parsing will fail.\n            if (encoding === 'base64') {\n                body = Buffer.from(body.toString(), 'base64');\n            }\n        }\n        // 5.9. If position does not point to a sequence of bytes starting with\n        //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n        if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n            return 'failure';\n        } else {\n            position.position += 2;\n        }\n        // 5.10. If filename is not null:\n        let value;\n        if (filename !== null) {\n            // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n            contentType ??= 'text/plain';\n            // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n            // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n            // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n            if (!isAsciiString(contentType)) {\n                contentType = '';\n            }\n            // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n            value = new File([\n                body\n            ], filename, {\n                type: contentType\n            });\n        } else {\n            // 5.11. Otherwise:\n            // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n            value = utf8DecodeBytes(Buffer.from(body));\n        }\n        // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n        assert(isUSVString(name));\n        assert(typeof value === 'string' && isUSVString(value) || isFileLike(value));\n        // 5.13. Create an entry with name and value, and append it to entry list.\n        entryList.push(makeEntry(name, value, filename));\n    }\n}\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */ function parseMultipartFormDataHeaders(input, position) {\n    // 1. Let name, filename and contentType be null.\n    let name = null;\n    let filename = null;\n    let contentType = null;\n    let encoding = null;\n    // 2. While true:\n    while(true){\n        // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n        if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n            // 2.1.1. If name is null, return failure.\n            if (name === null) {\n                return 'failure';\n            }\n            // 2.1.2. Return name, filename and contentType.\n            return {\n                name,\n                filename,\n                contentType,\n                encoding\n            };\n        }\n        // 2.2. Let header name be the result of collecting a sequence of bytes that are\n        //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n        let headerName = collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d && char !== 0x3a, input, position);\n        // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n        headerName = removeChars(headerName, true, true, (char)=>char === 0x9 || char === 0x20);\n        // 2.4. If header name does not match the field-name token production, return failure.\n        if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n            return 'failure';\n        }\n        // 2.5. If the byte at position is not 0x3A (:), return failure.\n        if (input[position.position] !== 0x3a) {\n            return 'failure';\n        }\n        // 2.6. Advance position by 1.\n        position.position++;\n        // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n        //      (Do nothing with those bytes.)\n        collectASequenceOfBytes((char)=>char === 0x20 || char === 0x09, input, position);\n        // 2.8. Byte-lowercase header name and switch on the result:\n        switch(bufferToLowerCasedHeaderName(headerName)){\n            case 'content-disposition':\n                {\n                    // 1. Set name and filename to null.\n                    name = filename = null;\n                    // 2. If position does not point to a sequence of bytes starting with\n                    //    `form-data; name=\"`, return failure.\n                    if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n                        return 'failure';\n                    }\n                    // 3. Advance position so it points at the byte after the next 0x22 (\")\n                    //    byte (the one in the sequence of bytes matched above).\n                    position.position += 17;\n                    // 4. Set name to the result of parsing a multipart/form-data name given\n                    //    input and position, if the result is not failure. Otherwise, return\n                    //    failure.\n                    name = parseMultipartFormDataName(input, position);\n                    if (name === null) {\n                        return 'failure';\n                    }\n                    // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n                    if (bufferStartsWith(input, filenameBuffer, position)) {\n                        // Note: undici also handles filename*\n                        let check = position.position + filenameBuffer.length;\n                        if (input[check] === 0x2a) {\n                            position.position += 1;\n                            check += 1;\n                        }\n                        if (input[check] !== 0x3d || input[check + 1] !== 0x22) {\n                            return 'failure';\n                        }\n                        // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n                        //    (the one in the sequence of bytes matched above).\n                        position.position += 12;\n                        // 2. Set filename to the result of parsing a multipart/form-data name given\n                        //    input and position, if the result is not failure. Otherwise, return failure.\n                        filename = parseMultipartFormDataName(input, position);\n                        if (filename === null) {\n                            return 'failure';\n                        }\n                    }\n                    break;\n                }\n            case 'content-type':\n                {\n                    // 1. Let header value be the result of collecting a sequence of bytes that are\n                    //    not 0x0A (LF) or 0x0D (CR), given position.\n                    let headerValue = collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d, input, position);\n                    // 2. Remove any HTTP tab or space bytes from the end of header value.\n                    headerValue = removeChars(headerValue, false, true, (char)=>char === 0x9 || char === 0x20);\n                    // 3. Set contentType to the isomorphic decoding of header value.\n                    contentType = isomorphicDecode(headerValue);\n                    break;\n                }\n            case 'content-transfer-encoding':\n                {\n                    let headerValue = collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d, input, position);\n                    headerValue = removeChars(headerValue, false, true, (char)=>char === 0x9 || char === 0x20);\n                    encoding = isomorphicDecode(headerValue);\n                    break;\n                }\n            default:\n                {\n                    // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n                    // (Do nothing with those bytes.)\n                    collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d, input, position);\n                }\n        }\n        // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n        //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n        if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n            return 'failure';\n        } else {\n            position.position += 2;\n        }\n    }\n}\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */ function parseMultipartFormDataName(input, position) {\n    // 1. Assert: The byte at (position - 1) is 0x22 (\").\n    assert(input[position.position - 1] === 0x22);\n    // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n    /** @type {string | Buffer} */ let name = collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d && char !== 0x22, input, position);\n    // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n    if (input[position.position] !== 0x22) {\n        return null // name could be 'failure'\n        ;\n    } else {\n        position.position++;\n    }\n    // 4. Replace any occurrence of the following subsequences in name with the given byte:\n    // - `%0A`: 0x0A (LF)\n    // - `%0D`: 0x0D (CR)\n    // - `%22`: 0x22 (\")\n    name = new TextDecoder().decode(name).replace(/%0A/ig, '\\n').replace(/%0D/ig, '\\r').replace(/%22/g, '\"');\n    // 5. Return the UTF-8 decoding without BOM of name.\n    return name;\n}\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */ function collectASequenceOfBytes(condition, input, position) {\n    let start = position.position;\n    while(start < input.length && condition(input[start])){\n        ++start;\n    }\n    return input.subarray(position.position, position.position = start);\n}\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */ function removeChars(buf, leading, trailing, predicate) {\n    let lead = 0;\n    let trail = buf.length - 1;\n    if (leading) {\n        while(lead < buf.length && predicate(buf[lead]))lead++;\n    }\n    if (trailing) {\n        while(trail > 0 && predicate(buf[trail]))trail--;\n    }\n    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);\n}\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */ function bufferStartsWith(buffer, start, position) {\n    if (buffer.length < start.length) {\n        return false;\n    }\n    for(let i = 0; i < start.length; i++){\n        if (start[i] !== buffer[position.position + i]) {\n            return false;\n        }\n    }\n    return true;\n}\nmodule.exports = {\n    multipartFormDataParser,\n    validateBoundary\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxXQUFXLEVBQUVDLDRCQUE0QixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLHFFQUFpQjtBQUMvRSxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxpRUFBUTtBQUM1QyxNQUFNLEVBQUVFLHFCQUFxQixFQUFFQyxnQkFBZ0IsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN4RSxNQUFNLEVBQUVJLFVBQVUsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQyxpRUFBUTtBQUN2QyxNQUFNLEVBQUVLLFNBQVMsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQyx5RUFBWTtBQUMxQyxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNwQyxNQUFNLEVBQUVPLE1BQU1DLFFBQVEsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUVoRCxNQUFNTyxPQUFPRSxXQUFXRixJQUFJLElBQUlDO0FBRWhDLE1BQU1FLHFCQUFxQkMsT0FBT0MsSUFBSSxDQUFDO0FBQ3ZDLE1BQU1DLGlCQUFpQkYsT0FBT0MsSUFBSSxDQUFDO0FBQ25DLE1BQU1FLEtBQUtILE9BQU9DLElBQUksQ0FBQztBQUN2QixNQUFNRyxTQUFTSixPQUFPQyxJQUFJLENBQUM7QUFFM0I7O0NBRUMsR0FDRCxTQUFTSSxjQUFlQyxLQUFLO0lBQzNCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUNyQyxJQUFJLENBQUNELE1BQU1HLFVBQVUsQ0FBQ0YsS0FBSyxDQUFDLElBQUcsTUFBTyxHQUFHO1lBQ3ZDLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0csaUJBQWtCQyxRQUFRO0lBQ2pDLE1BQU1ILFNBQVNHLFNBQVNI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RCxJQUFJLEdBQUdBLElBQUk0QyxNQUFNM0MsTUFBTSxFQUFFRCxJQUFLO1FBQ3JDLElBQUk0QyxLQUFLLENBQUM1QyxFQUFFLEtBQUttRCxNQUFNLENBQUNwQyxTQUFTQSxRQUFRLEdBQUdmLEVBQUUsRUFBRTtZQUM5QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBb0QsT0FBT0MsT0FBTyxHQUFHO0lBQ2YvQztJQUNBSDtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGZvcm1kYXRhLXBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpc1VTVlN0cmluZywgYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgdXRmOERlY29kZUJ5dGVzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBIVFRQX1RPS0VOX0NPREVQT0lOVFMsIGlzb21vcnBoaWNEZWNvZGUgfSA9IHJlcXVpcmUoJy4vZGF0YS11cmwnKVxuY29uc3QgeyBpc0ZpbGVMaWtlIH0gPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgeyBtYWtlRW50cnkgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBGaWxlOiBOb2RlRmlsZSB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuXG5jb25zdCBGaWxlID0gZ2xvYmFsVGhpcy5GaWxlID8/IE5vZGVGaWxlXG5cbmNvbnN0IGZvcm1EYXRhTmFtZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKCdmb3JtLWRhdGE7IG5hbWU9XCInKVxuY29uc3QgZmlsZW5hbWVCdWZmZXIgPSBCdWZmZXIuZnJvbSgnOyBmaWxlbmFtZScpXG5jb25zdCBkZCA9IEJ1ZmZlci5mcm9tKCctLScpXG5jb25zdCBkZGNybGYgPSBCdWZmZXIuZnJvbSgnLS1cXHJcXG4nKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyc1xuICovXG5mdW5jdGlvbiBpc0FzY2lpU3RyaW5nIChjaGFycykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChjaGFycy5jaGFyQ29kZUF0KGkpICYgfjB4N0YpICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jbXVsdGlwYXJ0LWZvcm0tZGF0YS1ib3VuZGFyeVxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQm91bmRhcnkgKGJvdW5kYXJ5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJvdW5kYXJ5Lmxlbmd0aFxuXG4gIC8vIC0gaXRzIGxlbmd0aCBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIDI3IGFuZCBsZXNzZXIgb3IgZXF1YWwgdG8gNzAsIGFuZFxuICBpZiAobGVuZ3RoIDwgMjcgfHwgbGVuZ3RoID4gNzApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIC0gaXQgaXMgY29tcG9zZWQgYnkgYnl0ZXMgaW4gdGhlIHJhbmdlcyAweDMwIHRvIDB4MzksIDB4NDEgdG8gMHg1QSwgb3JcbiAgLy8gICAweDYxIHRvIDB4N0EsIGluY2x1c2l2ZSAoQVNDSUkgYWxwaGFudW1lcmljKSwgb3Igd2hpY2ggYXJlIDB4MjcgKCcpLFxuICAvLyAgIDB4MkQgKC0pIG9yIDB4NUYgKF8pLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY3AgPSBib3VuZGFyeS5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoIShcbiAgICAgIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XG4gICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDVhKSB8fFxuICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3YSkgfHxcbiAgICAgIGNwID09PSAweDI3IHx8XG4gICAgICBjcCA9PT0gMHgyZCB8fFxuICAgICAgY3AgPT09IDB4NWZcbiAgICApKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9hbmRyZXVib3RlbGxhLmdpdGh1Yi5pby9tdWx0aXBhcnQtZm9ybS1kYXRhLyNtdWx0aXBhcnQtZm9ybS1kYXRhLXBhcnNlclxuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0XG4gKiBAcGFyYW0ge1JldHVyblR5cGU8aW1wb3J0KCcuL2RhdGEtdXJsJylbJ3BhcnNlTUlNRVR5cGUnXT59IG1pbWVUeXBlXG4gKi9cbmZ1bmN0aW9uIG11bHRpcGFydEZvcm1EYXRhUGFyc2VyIChpbnB1dCwgbWltZVR5cGUpIHtcbiAgLy8gMS4gQXNzZXJ0OiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBcIm11bHRpcGFydC9mb3JtLWRhdGFcIi5cbiAgYXNzZXJ0KG1pbWVUeXBlICE9PSAnZmFpbHVyZScgJiYgbWltZVR5cGUuZXNzZW5jZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKVxuXG4gIGNvbnN0IGJvdW5kYXJ5U3RyaW5nID0gbWltZVR5cGUucGFyYW1ldGVycy5nZXQoJ2JvdW5kYXJ5JylcblxuICAvLyAyLiBJZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImJvdW5kYXJ5XCJdIGRvZXMgbm90IGV4aXN0LCByZXR1cm4gZmFpbHVyZS5cbiAgLy8gICAgT3RoZXJ3aXNlLCBsZXQgYm91bmRhcnkgYmUgdGhlIHJlc3VsdCBvZiBVVEYtOCBkZWNvZGluZyBtaW1lVHlwZeKAmXNcbiAgLy8gICAgcGFyYW1ldGVyc1tcImJvdW5kYXJ5XCJdLlxuICBpZiAoYm91bmRhcnlTdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5ID0gQnVmZmVyLmZyb20oYC0tJHtib3VuZGFyeVN0cmluZ31gLCAndXRmOCcpXG5cbiAgLy8gMy4gTGV0IGVudHJ5IGxpc3QgYmUgYW4gZW1wdHkgZW50cnkgbGlzdC5cbiAgY29uc3QgZW50cnlMaXN0ID0gW11cblxuICAvLyA0LiBMZXQgcG9zaXRpb24gYmUgYSBwb2ludGVyIHRvIGEgYnl0ZSBpbiBpbnB1dCwgaW5pdGlhbGx5IHBvaW50aW5nIGF0XG4gIC8vICAgIHRoZSBmaXJzdCBieXRlLlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIE5vdGU6IHVuZGljaSBhZGRpdGlvbiwgYWxsb3cgXFxyXFxuIGJlZm9yZSB0aGUgYm9keS5cbiAgaWYgKGlucHV0WzBdID09PSAweDBkICYmIGlucHV0WzFdID09PSAweDBhKSB7XG4gICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuICB9XG5cbiAgLy8gNS4gV2hpbGUgdHJ1ZTpcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyA1LjEuIElmIHBvc2l0aW9uIHBvaW50cyB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgyRCAweDJEXG4gICAgLy8gICAgICAoYC0tYCkgZm9sbG93ZWQgYnkgYm91bmRhcnksIGFkdmFuY2UgcG9zaXRpb24gYnkgMiArIHRoZSBsZW5ndGggb2ZcbiAgICAvLyAgICAgIGJvdW5kYXJ5LiBPdGhlcndpc2UsIHJldHVybiBmYWlsdXJlLlxuICAgIC8vIE5vdGU6IGJvdW5kYXJ5IGlzIHBhZGRlZCB3aXRoIDIgZGFzaGVzIGFscmVhZHksIG5vIG5lZWQgdG8gYWRkIDIuXG4gICAgaWYgKGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCBwb3NpdGlvbi5wb3NpdGlvbiArIGJvdW5kYXJ5Lmxlbmd0aCkuZXF1YWxzKGJvdW5kYXJ5KSkge1xuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gYm91bmRhcnkubGVuZ3RoXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyA1LjIuIElmIHBvc2l0aW9uIHBvaW50cyB0byB0aGUgc2VxdWVuY2Ugb2YgYnl0ZXMgMHgyRCAweDJEIDB4MEQgMHgwQVxuICAgIC8vICAgICAgKGAtLWAgZm9sbG93ZWQgYnkgQ1IgTEYpIGZvbGxvd2VkIGJ5IHRoZSBlbmQgb2YgaW5wdXQsIHJldHVybiBlbnRyeSBsaXN0LlxuICAgIC8vIE5vdGU6IGEgYm9keSBkb2VzIE5PVCBuZWVkIHRvIGVuZCB3aXRoIENSTEYuIEl0IGNhbiBlbmQgd2l0aCAtLS5cbiAgICBpZiAoXG4gICAgICAocG9zaXRpb24ucG9zaXRpb24gPT09IGlucHV0Lmxlbmd0aCAtIDIgJiYgYnVmZmVyU3RhcnRzV2l0aChpbnB1dCwgZGQsIHBvc2l0aW9uKSkgfHxcbiAgICAgIChwb3NpdGlvbi5wb3NpdGlvbiA9PT0gaW5wdXQubGVuZ3RoIC0gNCAmJiBidWZmZXJTdGFydHNXaXRoKGlucHV0LCBkZGNybGYsIHBvc2l0aW9uKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBlbnRyeUxpc3RcbiAgICB9XG5cbiAgICAvLyA1LjMuIElmIHBvc2l0aW9uIGRvZXMgbm90IHBvaW50IHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDBEXG4gICAgLy8gICAgICAweDBBIChDUiBMRiksIHJldHVybiBmYWlsdXJlLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgfHwgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH1cblxuICAgIC8vIDUuNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAyLiAoVGhpcyBza2lwcyBwYXN0IHRoZSBuZXdsaW5lLilcbiAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG5cbiAgICAvLyA1LjUuIExldCBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nXG4gICAgLy8gICAgICBtdWx0aXBhcnQvZm9ybS1kYXRhIGhlYWRlcnMgb24gaW5wdXQgYW5kIHBvc2l0aW9uLCBpZiB0aGUgcmVzdWx0XG4gICAgLy8gICAgICBpcyBub3QgZmFpbHVyZS4gT3RoZXJ3aXNlLCByZXR1cm4gZmFpbHVyZS5cbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZU11bHRpcGFydEZvcm1EYXRhSGVhZGVycyhpbnB1dCwgcG9zaXRpb24pXG5cbiAgICBpZiAocmVzdWx0ID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICBsZXQgeyBuYW1lLCBmaWxlbmFtZSwgY29udGVudFR5cGUsIGVuY29kaW5nIH0gPSByZXN1bHRcblxuICAgIC8vIDUuNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAyLiAoVGhpcyBza2lwcyBwYXN0IHRoZSBlbXB0eSBsaW5lIHRoYXQgbWFya3NcbiAgICAvLyAgICAgIHRoZSBlbmQgb2YgdGhlIGhlYWRlcnMuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcblxuICAgIC8vIDUuNy4gTGV0IGJvZHkgYmUgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gICAgbGV0IGJvZHlcblxuICAgIC8vIDUuOC4gQm9keSBsb29wOiBXaGlsZSBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0OlxuICAgIC8vIFRPRE86IHRoZSBzdGVwcyBoZXJlIGFyZSBjb21wbGV0ZWx5IHdyb25nXG4gICAge1xuICAgICAgY29uc3QgYm91bmRhcnlJbmRleCA9IGlucHV0LmluZGV4T2YoYm91bmRhcnkuc3ViYXJyYXkoMiksIHBvc2l0aW9uLnBvc2l0aW9uKVxuXG4gICAgICBpZiAoYm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgfVxuXG4gICAgICBib2R5ID0gaW5wdXQuc3ViYXJyYXkocG9zaXRpb24ucG9zaXRpb24sIGJvdW5kYXJ5SW5kZXggLSA0KVxuXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSBib2R5Lmxlbmd0aFxuXG4gICAgICAvLyBOb3RlOiBwb3NpdGlvbiBtdXN0IGJlIGFkdmFuY2VkIGJ5IHRoZSBib2R5J3MgbGVuZ3RoIGJlZm9yZSBiZWluZ1xuICAgICAgLy8gZGVjb2RlZCwgb3RoZXJ3aXNlIHRoZSBwYXJzaW5nIHdpbGwgZmFpbC5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgYm9keSA9IEJ1ZmZlci5mcm9tKGJvZHkudG9TdHJpbmcoKSwgJ2Jhc2U2NCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS45LiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGhcbiAgICAvLyAgICAgIDB4MEQgMHgwQSAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS4gT3RoZXJ3aXNlLCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgwZCB8fCBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdICE9PSAweDBhKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcbiAgICB9XG5cbiAgICAvLyA1LjEwLiBJZiBmaWxlbmFtZSBpcyBub3QgbnVsbDpcbiAgICBsZXQgdmFsdWVcblxuICAgIGlmIChmaWxlbmFtZSAhPT0gbnVsbCkge1xuICAgICAgLy8gNS4xMC4xLiBJZiBjb250ZW50VHlwZSBpcyBudWxsLCBzZXQgY29udGVudFR5cGUgdG8gXCJ0ZXh0L3BsYWluXCIuXG4gICAgICBjb250ZW50VHlwZSA/Pz0gJ3RleHQvcGxhaW4nXG5cbiAgICAgIC8vIDUuMTAuMi4gSWYgY29udGVudFR5cGUgaXMgbm90IGFuIEFTQ0lJIHN0cmluZywgc2V0IGNvbnRlbnRUeXBlIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAgIC8vIE5vdGU6IGBidWZmZXIuaXNBc2NpaWAgY2FuIGJlIHVzZWQgYXQgemVyby1jb3N0LCBidXQgY29udmVydGluZyBhIHN0cmluZyB0byBhIGJ1ZmZlciBpcyBhIGhpZ2ggb3ZlcmhlYWQuXG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgYSByZWxhdGl2ZWx5IHNtYWxsIHN0cmluZywgc28gaXQgaXMgZmFzdGVyIHRvIHVzZSBgU3RyaW5nI2NoYXJDb2RlQXRgLlxuICAgICAgaWYgKCFpc0FzY2lpU3RyaW5nKGNvbnRlbnRUeXBlKSkge1xuICAgICAgICBjb250ZW50VHlwZSA9ICcnXG4gICAgICB9XG5cbiAgICAgIC8vIDUuMTAuMy4gTGV0IHZhbHVlIGJlIGEgbmV3IEZpbGUgb2JqZWN0IHdpdGggbmFtZSBmaWxlbmFtZSwgdHlwZSBjb250ZW50VHlwZSwgYW5kIGJvZHkgYm9keS5cbiAgICAgIHZhbHVlID0gbmV3IEZpbGUoW2JvZHldLCBmaWxlbmFtZSwgeyB0eXBlOiBjb250ZW50VHlwZSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyA1LjExLiBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDUuMTEuMS4gTGV0IHZhbHVlIGJlIHRoZSBVVEYtOCBkZWNvZGluZyB3aXRob3V0IEJPTSBvZiBib2R5LlxuICAgICAgdmFsdWUgPSB1dGY4RGVjb2RlQnl0ZXMoQnVmZmVyLmZyb20oYm9keSkpXG4gICAgfVxuXG4gICAgLy8gNS4xMi4gQXNzZXJ0OiBuYW1lIGlzIGEgc2NhbGFyIHZhbHVlIHN0cmluZyBhbmQgdmFsdWUgaXMgZWl0aGVyIGEgc2NhbGFyIHZhbHVlIHN0cmluZyBvciBhIEZpbGUgb2JqZWN0LlxuICAgIGFzc2VydChpc1VTVlN0cmluZyhuYW1lKSlcbiAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgaXNVU1ZTdHJpbmcodmFsdWUpKSB8fCBpc0ZpbGVMaWtlKHZhbHVlKSlcblxuICAgIC8vIDUuMTMuIENyZWF0ZSBhbiBlbnRyeSB3aXRoIG5hbWUgYW5kIHZhbHVlLCBhbmQgYXBwZW5kIGl0IHRvIGVudHJ5IGxpc3QuXG4gICAgZW50cnlMaXN0LnB1c2gobWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSkpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jcGFyc2UtbXVsdGlwYXJ0LWZvcm0tZGF0YS1oZWFkZXJzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFIZWFkZXJzIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gTGV0IG5hbWUsIGZpbGVuYW1lIGFuZCBjb250ZW50VHlwZSBiZSBudWxsLlxuICBsZXQgbmFtZSA9IG51bGxcbiAgbGV0IGZpbGVuYW1lID0gbnVsbFxuICBsZXQgY29udGVudFR5cGUgPSBudWxsXG4gIGxldCBlbmNvZGluZyA9IG51bGxcblxuICAvLyAyLiBXaGlsZSB0cnVlOlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIDIuMS4gSWYgcG9zaXRpb24gcG9pbnRzIHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDBEIDB4MEEgKENSIExGKTpcbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAweDBkICYmIGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uICsgMV0gPT09IDB4MGEpIHtcbiAgICAgIC8vIDIuMS4xLiBJZiBuYW1lIGlzIG51bGwsIHJldHVybiBmYWlsdXJlLlxuICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgfVxuXG4gICAgICAvLyAyLjEuMi4gUmV0dXJuIG5hbWUsIGZpbGVuYW1lIGFuZCBjb250ZW50VHlwZS5cbiAgICAgIHJldHVybiB7IG5hbWUsIGZpbGVuYW1lLCBjb250ZW50VHlwZSwgZW5jb2RpbmcgfVxuICAgIH1cblxuICAgIC8vIDIuMi4gTGV0IGhlYWRlciBuYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHRoYXQgYXJlXG4gICAgLy8gICAgICBub3QgMHgwQSAoTEYpLCAweDBEIChDUikgb3IgMHgzQSAoOiksIGdpdmVuIHBvc2l0aW9uLlxuICAgIGxldCBoZWFkZXJOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkICYmIGNoYXIgIT09IDB4M2EsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gMi4zLiBSZW1vdmUgYW55IEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGZyb20gdGhlIHN0YXJ0IG9yIGVuZCBvZiBoZWFkZXIgbmFtZS5cbiAgICBoZWFkZXJOYW1lID0gcmVtb3ZlQ2hhcnMoaGVhZGVyTmFtZSwgdHJ1ZSwgdHJ1ZSwgKGNoYXIpID0+IGNoYXIgPT09IDB4OSB8fCBjaGFyID09PSAweDIwKVxuXG4gICAgLy8gMi40LiBJZiBoZWFkZXIgbmFtZSBkb2VzIG5vdCBtYXRjaCB0aGUgZmllbGQtbmFtZSB0b2tlbiBwcm9kdWN0aW9uLCByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KGhlYWRlck5hbWUudG9TdHJpbmcoKSkpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyAyLjUuIElmIHRoZSBieXRlIGF0IHBvc2l0aW9uIGlzIG5vdCAweDNBICg6KSwgcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgzYSkge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH1cblxuICAgIC8vIDIuNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuNy4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGJ5dGVzIHRoYXQgYXJlIEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vICAgICAgKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gMHgyMCB8fCBjaGFyID09PSAweDA5LFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuOC4gQnl0ZS1sb3dlcmNhc2UgaGVhZGVyIG5hbWUgYW5kIHN3aXRjaCBvbiB0aGUgcmVzdWx0OlxuICAgIHN3aXRjaCAoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShoZWFkZXJOYW1lKSkge1xuICAgICAgY2FzZSAnY29udGVudC1kaXNwb3NpdGlvbic6IHtcbiAgICAgICAgLy8gMS4gU2V0IG5hbWUgYW5kIGZpbGVuYW1lIHRvIG51bGwuXG4gICAgICAgIG5hbWUgPSBmaWxlbmFtZSA9IG51bGxcblxuICAgICAgICAvLyAyLiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGhcbiAgICAgICAgLy8gICAgYGZvcm0tZGF0YTsgbmFtZT1cImAsIHJldHVybiBmYWlsdXJlLlxuICAgICAgICBpZiAoIWJ1ZmZlclN0YXJ0c1dpdGgoaW5wdXQsIGZvcm1EYXRhTmFtZUJ1ZmZlciwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQWR2YW5jZSBwb3NpdGlvbiBzbyBpdCBwb2ludHMgYXQgdGhlIGJ5dGUgYWZ0ZXIgdGhlIG5leHQgMHgyMiAoXCIpXG4gICAgICAgIC8vICAgIGJ5dGUgKHRoZSBvbmUgaW4gdGhlIHNlcXVlbmNlIG9mIGJ5dGVzIG1hdGNoZWQgYWJvdmUpLlxuICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAxN1xuXG4gICAgICAgIC8vIDQuIFNldCBuYW1lIHRvIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhIG11bHRpcGFydC9mb3JtLWRhdGEgbmFtZSBnaXZlblxuICAgICAgICAvLyAgICBpbnB1dCBhbmQgcG9zaXRpb24sIGlmIHRoZSByZXN1bHQgaXMgbm90IGZhaWx1cmUuIE90aGVyd2lzZSwgcmV0dXJuXG4gICAgICAgIC8vICAgIGZhaWx1cmUuXG4gICAgICAgIG5hbWUgPSBwYXJzZU11bHRpcGFydEZvcm1EYXRhTmFtZShpbnB1dCwgcG9zaXRpb24pXG5cbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LiBJZiBwb3NpdGlvbiBwb2ludHMgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoIGA7IGZpbGVuYW1lPVwiYDpcbiAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0c1dpdGgoaW5wdXQsIGZpbGVuYW1lQnVmZmVyLCBwb3NpdGlvbikpIHtcbiAgICAgICAgICAvLyBOb3RlOiB1bmRpY2kgYWxzbyBoYW5kbGVzIGZpbGVuYW1lKlxuICAgICAgICAgIGxldCBjaGVjayA9IHBvc2l0aW9uLnBvc2l0aW9uICsgZmlsZW5hbWVCdWZmZXIubGVuZ3RoXG5cbiAgICAgICAgICBpZiAoaW5wdXRbY2hlY2tdID09PSAweDJhKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAxXG4gICAgICAgICAgICBjaGVjayArPSAxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlucHV0W2NoZWNrXSAhPT0gMHgzZCB8fCBpbnB1dFtjaGVjayArIDFdICE9PSAweDIyKSB7IC8vID1cIlxuICAgICAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDEuIEFkdmFuY2UgcG9zaXRpb24gc28gaXQgcG9pbnRzIGF0IHRoZSBieXRlIGFmdGVyIHRoZSBuZXh0IDB4MjIgKFwiKSBieXRlXG4gICAgICAgICAgLy8gICAgKHRoZSBvbmUgaW4gdGhlIHNlcXVlbmNlIG9mIGJ5dGVzIG1hdGNoZWQgYWJvdmUpLlxuICAgICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDEyXG5cbiAgICAgICAgICAvLyAyLiBTZXQgZmlsZW5hbWUgdG8gdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGEgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBuYW1lIGdpdmVuXG4gICAgICAgICAgLy8gICAgaW5wdXQgYW5kIHBvc2l0aW9uLCBpZiB0aGUgcmVzdWx0IGlzIG5vdCBmYWlsdXJlLiBPdGhlcndpc2UsIHJldHVybiBmYWlsdXJlLlxuICAgICAgICAgIGZpbGVuYW1lID0gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUoaW5wdXQsIHBvc2l0aW9uKVxuXG4gICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbnRlbnQtdHlwZSc6IHtcbiAgICAgICAgLy8gMS4gTGV0IGhlYWRlciB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZVxuICAgICAgICAvLyAgICBub3QgMHgwQSAoTEYpIG9yIDB4MEQgKENSKSwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgIGxldCBoZWFkZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAweDBhICYmIGNoYXIgIT09IDB4MGQsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgKVxuXG4gICAgICAgIC8vIDIuIFJlbW92ZSBhbnkgSFRUUCB0YWIgb3Igc3BhY2UgYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIGhlYWRlciB2YWx1ZS5cbiAgICAgICAgaGVhZGVyVmFsdWUgPSByZW1vdmVDaGFycyhoZWFkZXJWYWx1ZSwgZmFsc2UsIHRydWUsIChjaGFyKSA9PiBjaGFyID09PSAweDkgfHwgY2hhciA9PT0gMHgyMClcblxuICAgICAgICAvLyAzLiBTZXQgY29udGVudFR5cGUgdG8gdGhlIGlzb21vcnBoaWMgZGVjb2Rpbmcgb2YgaGVhZGVyIHZhbHVlLlxuICAgICAgICBjb250ZW50VHlwZSA9IGlzb21vcnBoaWNEZWNvZGUoaGVhZGVyVmFsdWUpXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmcnOiB7XG4gICAgICAgIGxldCBoZWFkZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAweDBhICYmIGNoYXIgIT09IDB4MGQsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgKVxuXG4gICAgICAgIGhlYWRlclZhbHVlID0gcmVtb3ZlQ2hhcnMoaGVhZGVyVmFsdWUsIGZhbHNlLCB0cnVlLCAoY2hhcikgPT4gY2hhciA9PT0gMHg5IHx8IGNoYXIgPT09IDB4MjApXG5cbiAgICAgICAgZW5jb2RpbmcgPSBpc29tb3JwaGljRGVjb2RlKGhlYWRlclZhbHVlKVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZSBub3QgMHgwQSAoTEYpIG9yIDB4MEQgKENSKSwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgIC8vIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICAgICAgICBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyLjkuIElmIHBvc2l0aW9uIGRvZXMgbm90IHBvaW50IHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDBEIDB4MEFcbiAgICAvLyAgICAgIChDUiBMRiksIHJldHVybiBmYWlsdXJlLiBPdGhlcndpc2UsIGFkdmFuY2UgcG9zaXRpb24gYnkgMiAocGFzdCB0aGUgbmV3bGluZSkuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgwZCAmJiBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdICE9PSAweDBhKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jcGFyc2UtYS1tdWx0aXBhcnQtZm9ybS1kYXRhLW5hbWVcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUgKGlucHV0LCBwb3NpdGlvbikge1xuICAvLyAxLiBBc3NlcnQ6IFRoZSBieXRlIGF0IChwb3NpdGlvbiAtIDEpIGlzIDB4MjIgKFwiKS5cbiAgYXNzZXJ0KGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uIC0gMV0gPT09IDB4MjIpXG5cbiAgLy8gMi4gTGV0IG5hbWUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmUgbm90IDB4MEEgKExGKSwgMHgwRCAoQ1IpIG9yIDB4MjIgKFwiKSwgZ2l2ZW4gcG9zaXRpb24uXG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwgQnVmZmVyfSAqL1xuICBsZXQgbmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgIChjaGFyKSA9PiBjaGFyICE9PSAweDBhICYmIGNoYXIgIT09IDB4MGQgJiYgY2hhciAhPT0gMHgyMixcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gMy4gSWYgdGhlIGJ5dGUgYXQgcG9zaXRpb24gaXMgbm90IDB4MjIgKFwiKSwgcmV0dXJuIGZhaWx1cmUuIE90aGVyd2lzZSwgYWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dICE9PSAweDIyKSB7XG4gICAgcmV0dXJuIG51bGwgLy8gbmFtZSBjb3VsZCBiZSAnZmFpbHVyZSdcbiAgfSBlbHNlIHtcbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICAvLyA0LiBSZXBsYWNlIGFueSBvY2N1cnJlbmNlIG9mIHRoZSBmb2xsb3dpbmcgc3Vic2VxdWVuY2VzIGluIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZTpcbiAgLy8gLSBgJTBBYDogMHgwQSAoTEYpXG4gIC8vIC0gYCUwRGA6IDB4MEQgKENSKVxuICAvLyAtIGAlMjJgOiAweDIyIChcIilcbiAgbmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuYW1lKVxuICAgIC5yZXBsYWNlKC8lMEEvaWcsICdcXG4nKVxuICAgIC5yZXBsYWNlKC8lMEQvaWcsICdcXHInKVxuICAgIC5yZXBsYWNlKC8lMjIvZywgJ1wiJylcblxuICAvLyA1LiBSZXR1cm4gdGhlIFVURi04IGRlY29kaW5nIHdpdGhvdXQgQk9NIG9mIG5hbWUuXG4gIHJldHVybiBuYW1lXG59XG5cbi8qKlxuICogQHBhcmFtIHsoY2hhcjogbnVtYmVyKSA9PiBib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMgKGNvbmRpdGlvbiwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIGxldCBzdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgd2hpbGUgKHN0YXJ0IDwgaW5wdXQubGVuZ3RoICYmIGNvbmRpdGlvbihpbnB1dFtzdGFydF0pKSB7XG4gICAgKytzdGFydFxuICB9XG5cbiAgcmV0dXJuIGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCAocG9zaXRpb24ucG9zaXRpb24gPSBzdGFydCkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHBhcmFtIHtib29sZWFufSBsZWFkaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRyYWlsaW5nXG4gKiBAcGFyYW0geyhjaGFyQ29kZTogbnVtYmVyKSA9PiBib29sZWFufSBwcmVkaWNhdGVcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoYXJzIChidWYsIGxlYWRpbmcsIHRyYWlsaW5nLCBwcmVkaWNhdGUpIHtcbiAgbGV0IGxlYWQgPSAwXG4gIGxldCB0cmFpbCA9IGJ1Zi5sZW5ndGggLSAxXG5cbiAgaWYgKGxlYWRpbmcpIHtcbiAgICB3aGlsZSAobGVhZCA8IGJ1Zi5sZW5ndGggJiYgcHJlZGljYXRlKGJ1ZltsZWFkXSkpIGxlYWQrK1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgd2hpbGUgKHRyYWlsID4gMCAmJiBwcmVkaWNhdGUoYnVmW3RyYWlsXSkpIHRyYWlsLS1cbiAgfVxuXG4gIHJldHVybiBsZWFkID09PSAwICYmIHRyYWlsID09PSBidWYubGVuZ3RoIC0gMSA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheShsZWFkLCB0cmFpbCArIDEpXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHtAcGFyYW0gYnVmZmVyfSBzdGFydHMgd2l0aCB7QHBhcmFtIHN0YXJ0fVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBidWZmZXJTdGFydHNXaXRoIChidWZmZXIsIHN0YXJ0LCBwb3NpdGlvbikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IHN0YXJ0Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdGFydFtpXSAhPT0gYnVmZmVyW3Bvc2l0aW9uLnBvc2l0aW9uICsgaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtdWx0aXBhcnRGb3JtRGF0YVBhcnNlcixcbiAgdmFsaWRhdGVCb3VuZGFyeVxufVxuIl0sIm5hbWVzIjpbImlzVVNWU3RyaW5nIiwiYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSIsInJlcXVpcmUiLCJ1dGY4RGVjb2RlQnl0ZXMiLCJIVFRQX1RPS0VOX0NPREVQT0lOVFMiLCJpc29tb3JwaGljRGVjb2RlIiwiaXNGaWxlTGlrZSIsIm1ha2VFbnRyeSIsImFzc2VydCIsIkZpbGUiLCJOb2RlRmlsZSIsImdsb2JhbFRoaXMiLCJmb3JtRGF0YU5hbWVCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiZmlsZW5hbWVCdWZmZXIiLCJkZCIsImRkY3JsZiIsImlzQXNjaWlTdHJpbmciLCJjaGFycyIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwidmFsaWRhdGVCb3VuZGFyeSIsImJvdW5kYXJ5IiwiY3AiLCJtdWx0aXBhcnRGb3JtRGF0YVBhcnNlciIsImlucHV0IiwibWltZVR5cGUiLCJlc3NlbmNlIiwiYm91bmRhcnlTdHJpbmciLCJwYXJhbWV0ZXJzIiwiZ2V0IiwidW5kZWZpbmVkIiwiZW50cnlMaXN0IiwicG9zaXRpb24iLCJzdWJhcnJheSIsImVxdWFscyIsImJ1ZmZlclN0YXJ0c1dpdGgiLCJyZXN1bHQiLCJwYXJzZU11bHRpcGFydEZvcm1EYXRhSGVhZGVycyIsIm5hbWUiLCJmaWxlbmFtZSIsImNvbnRlbnRUeXBlIiwiZW5jb2RpbmciLCJib2R5IiwiYm91bmRhcnlJbmRleCIsImluZGV4T2YiLCJ0b1N0cmluZyIsInZhbHVlIiwidHlwZSIsInB1c2giLCJoZWFkZXJOYW1lIiwiY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMiLCJjaGFyIiwicmVtb3ZlQ2hhcnMiLCJ0ZXN0IiwicGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUiLCJjaGVjayIsImhlYWRlclZhbHVlIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJyZXBsYWNlIiwiY29uZGl0aW9uIiwic3RhcnQiLCJidWYiLCJsZWFkaW5nIiwidHJhaWxpbmciLCJwcmVkaWNhdGUiLCJsZWFkIiwidHJhaWwiLCJidWZmZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isBlobLike, iteratorMixin } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { FileLike, isFileLike } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/undici/lib/web/fetch/file.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { File: NativeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\");\n/** @type {globalThis['File']} */ const File = globalThis.File ?? NativeFile;\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n    constructor(form){\n        if (form !== undefined) {\n            throw webidl.errors.conversionFailed({\n                prefix: 'FormData constructor',\n                argument: 'Argument 1',\n                types: [\n                    'undefined'\n                ]\n            });\n        }\n        this[kState] = [];\n    }\n    append(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        const prefix = 'FormData.append';\n        webidl.argumentLengthCheck(arguments, 2, prefix);\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name, prefix, 'name');\n        value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, 'value', {\n            strict: false\n        }) : webidl.converters.USVString(value, prefix, 'value');\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, 'filename') : undefined;\n        // 2. Let entry be the result of creating an entry with\n        // name, value, and filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. Append entry to this’s entry list.\n        this[kState].push(entry);\n    }\n    delete(name) {\n        webidl.brandCheck(this, FormData);\n        const prefix = 'FormData.delete';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        name = webidl.converters.USVString(name, prefix, 'name');\n        // The delete(name) method steps are to remove all entries whose name\n        // is name from this’s entry list.\n        this[kState] = this[kState].filter((entry)=>entry.name !== name);\n    }\n    get(name) {\n        webidl.brandCheck(this, FormData);\n        const prefix = 'FormData.get';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        name = webidl.converters.USVString(name, prefix, 'name');\n        // 1. If there is no entry whose name is name in this’s entry list,\n        // then return null.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx === -1) {\n            return null;\n        }\n        // 2. Return the value of the first entry whose name is name from\n        // this’s entry list.\n        return this[kState][idx].value;\n    }\n    getAll(name) {\n        webidl.brandCheck(this, FormData);\n        const prefix = 'FormData.getAll';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        name = webidl.converters.USVString(name, prefix, 'name');\n        // 1. If there is no entry whose name is name in this’s entry list,\n        // then return the empty list.\n        // 2. Return the values of all entries whose name is name, in order,\n        // from this’s entry list.\n        return this[kState].filter((entry)=>entry.name === name).map((entry)=>entry.value);\n    }\n    has(name) {\n        webidl.brandCheck(this, FormData);\n        const prefix = 'FormData.has';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        name = webidl.converters.USVString(name, prefix, 'name');\n        // The has(name) method steps are to return true if there is an entry\n        // whose name is name in this’s entry list; otherwise false.\n        return this[kState].findIndex((entry)=>entry.name === name) !== -1;\n    }\n    set(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        const prefix = 'FormData.set';\n        webidl.argumentLengthCheck(arguments, 2, prefix);\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // The set(name, value) and set(name, blobValue, filename) method steps\n        // are:\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name, prefix, 'name');\n        value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, 'name', {\n            strict: false\n        }) : webidl.converters.USVString(value, prefix, 'name');\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, 'name') : undefined;\n        // 2. Let entry be the result of creating an entry with name, value, and\n        // filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. If there are entries in this’s entry list whose name is name, then\n        // replace the first such entry with entry and remove the others.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx !== -1) {\n            this[kState] = [\n                ...this[kState].slice(0, idx),\n                entry,\n                ...this[kState].slice(idx + 1).filter((entry)=>entry.name !== name)\n            ];\n        } else {\n            // 4. Otherwise, append entry to this’s entry list.\n            this[kState].push(entry);\n        }\n    }\n    [nodeUtil.inspect.custom](depth, options) {\n        const state = this[kState].reduce((a, b)=>{\n            if (a[b.name]) {\n                if (Array.isArray(a[b.name])) {\n                    a[b.name].push(b.value);\n                } else {\n                    a[b.name] = [\n                        a[b.name],\n                        b.value\n                    ];\n                }\n            } else {\n                a[b.name] = b.value;\n            }\n            return a;\n        }, {\n            __proto__: null\n        });\n        options.depth ??= depth;\n        options.colors ??= true;\n        const output = nodeUtil.formatWithOptions(options, state);\n        // remove [Object null prototype]\n        return `FormData ${output.slice(output.indexOf(']') + 2)}`;\n    }\n}\niteratorMixin('FormData', FormData, kState, 'name', 'value');\nObject.defineProperties(FormData.prototype, {\n    append: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    get: kEnumerableProperty,\n    getAll: kEnumerableProperty,\n    has: kEnumerableProperty,\n    set: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: 'FormData',\n        configurable: true\n    }\n});\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */ function makeEntry(name, value, filename) {\n    // 1. Set name to the result of converting name into a scalar value string.\n    // Note: This operation was done by the webidl converter USVString.\n    // 2. If value is a string, then set value to the result of converting\n    //    value into a scalar value string.\n    if (typeof value === 'string') {\n    // Note: This operation was done by the webidl converter USVString.\n    } else {\n        // 3. Otherwise:\n        // 1. If value is not a File object, then set value to a new File object,\n        //    representing the same bytes, whose name attribute value is \"blob\"\n        if (!isFileLike(value)) {\n            value = value instanceof Blob ? new File([\n                value\n            ], 'blob', {\n                type: value.type\n            }) : new FileLike(value, 'blob', {\n                type: value.type\n            });\n        }\n        // 2. If filename is given, then set value to a new File object,\n        //    representing the same bytes, whose name attribute is filename.\n        if (filename !== undefined) {\n            /** @type {FilePropertyBag} */ const options = {\n                type: value.type,\n                lastModified: value.lastModified\n            };\n            value = value instanceof NativeFile ? new File([\n                value\n            ], filename, options) : new FileLike(value, filename, options);\n        }\n    }\n    // 4. Return an entry whose name is name and whose value is value.\n    return {\n        name,\n        value\n    };\n}\nmodule.exports = {\n    FormData,\n    makeEntry\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRUMsYUFBYSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLGlFQUFRO0FBQ3RELE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDLHVFQUFXO0FBQ3RDLE1BQU0sRUFBRUUsbUJBQW1CLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMscUVBQWlCO0FBQ3pELE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxVQUFVLEVBQUUsR0FBR0osbUJBQU9BLENBQUMsaUVBQVE7QUFDakQsTUFBTSxFQUFFSyxNQUFNLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMscUVBQVU7QUFDckMsTUFBTSxFQUFFTSxNQUFNQyxVQUFVLEVBQUUsR0FBR1AsbUJBQU9BLENBQUMsZ0NBQWE7QUFDbEQsTUFBTVEsV0FBV1IsbUJBQU9BLENBQUMsNEJBQVc7QUFFcEMsK0JBQStCLEdBQy9CLE1BQU1NLE9BQU9HLFdBQVdILElBQUksSUFBSUM7QUFFaEMsd0NBQXdDO0FBQ3hDLE1BQU1HO0lBQ0osWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLElBQUlBLFNBQVNDLFdBQVc7WUFDdEIsTUFBTVAsT0FBT1EsTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQztnQkFDbkNDLFFBQVE7Z0JBQ1JDLFVBQVU7Z0JBQ1ZDLE9BQU87b0JBQUM7aUJBQVk7WUFDdEI7UUFDRjtRQUVBLElBQUksQ0FBQ2hCLE9BQU8sR0FBRyxFQUFFO0lBQ25CO0lBRUFpQixPQUFRQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsV0FBV1QsU0FBUyxFQUFFO1FBQ3pDUCxPQUFPaUIsVUFBVSxDQUFDLElBQUksRUFBRVo7UUFFeEIsTUFBTUssU0FBUztRQUNmVixPQUFPa0IsbUJBQW1CLENBQUNDLFdBQVcsR0FBR1Q7UUFFekMsSUFBSVMsVUFBVUMsTUFBTSxLQUFLLEtBQUssQ0FBQzNC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d0MsS0FBS3hDO0lBQ0wsQ0FBQzRELE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCM0MsT0FBTztRQUNQNEMsY0FBYztJQUNoQjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU2hDLFVBQVdiLElBQUksRUFBRUMsS0FBSyxFQUFFQyxRQUFRO0lBQ3ZDLDJFQUEyRTtJQUMzRSxtRUFBbUU7SUFFbkUsc0VBQXNFO0lBQ3RFLHVDQUF1QztJQUN2QyxJQUFJLE9BQU9ELFVBQVUsVUFBVTtJQUM3QixtRUFBbUU7SUFDckUsT0FBTztRQUNMLGdCQUFnQjtRQUVoQix5RUFBeUU7UUFDekUsdUVBQXVFO1FBQ3ZFLElBQUksQ0FBQ2hCLFdBQVdnQixRQUFRO1lBQ3RCQSxRQUFRQSxpQkFBaUJTLE9BQ3JCLElBQUl2QixLQUFLO2dCQUFDYzthQUFNLEVBQUUsUUFBUTtnQkFBRTZDLE1BQU03QyxNQUFNNkMsSUFBSTtZQUFDLEtBQzdDLElBQUk5RCxTQUFTaUIsT0FBTyxRQUFRO2dCQUFFNkMsTUFBTTdDLE1BQU02QyxJQUFJO1lBQUM7UUFDckQ7UUFFQSxnRUFBZ0U7UUFDaEUsb0VBQW9FO1FBQ3BFLElBQUk1QyxhQUFhVCxXQUFXO1lBQzFCLDRCQUE0QixHQUM1QixNQUFNbUMsVUFBVTtnQkFDZGtCLE1BQU03QyxNQUFNNkMsSUFBSTtnQkFDaEJDLGNBQWM5QyxNQUFNOEMsWUFBWTtZQUNsQztZQUVBOUMsUUFBUUEsaUJBQWlCYixhQUNyQixJQUFJRCxLQUFLO2dCQUFDYzthQUFNLEVBQUVDLFVBQVUwQixXQUM1QixJQUFJNUMsU0FBU2lCLE9BQU9DLFVBQVUwQjtRQUNwQztJQUNGO0lBRUEsa0VBQWtFO0lBQ2xFLE9BQU87UUFBRTVCO1FBQU1DO0lBQU07QUFDdkI7QUFFQStDLE9BQU9DLE9BQU8sR0FBRztJQUFFMUQ7SUFBVXNCO0FBQVUiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcZm9ybWRhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNCbG9iTGlrZSwgaXRlcmF0b3JNaXhpbiB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga1N0YXRlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBGaWxlTGlrZSwgaXNGaWxlTGlrZSB9ID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IEZpbGU6IE5hdGl2ZUZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydGaWxlJ119ICovXG5jb25zdCBGaWxlID0gZ2xvYmFsVGhpcy5GaWxlID8/IE5hdGl2ZUZpbGVcblxuLy8gaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyNmb3JtZGF0YVxuY2xhc3MgRm9ybURhdGEge1xuICBjb25zdHJ1Y3RvciAoZm9ybSkge1xuICAgIGlmIChmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgIHByZWZpeDogJ0Zvcm1EYXRhIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgICAgdHlwZXM6IFsndW5kZWZpbmVkJ11cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpc1trU3RhdGVdID0gW11cbiAgfVxuXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuYXBwZW5kJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdhcHBlbmQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIHZhbHVlIGlmIGdpdmVuOyBvdGhlcndpc2UgYmxvYlZhbHVlLlxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgICB2YWx1ZSA9IGlzQmxvYkxpa2UodmFsdWUpXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJywgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuICAgIGZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZW5hbWUsIHByZWZpeCwgJ2ZpbGVuYW1lJylcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAvLyAyLiBMZXQgZW50cnkgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBlbnRyeSB3aXRoXG4gICAgLy8gbmFtZSwgdmFsdWUsIGFuZCBmaWxlbmFtZSBpZiBnaXZlbi5cbiAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpXG5cbiAgICAvLyAzLiBBcHBlbmQgZW50cnkgdG8gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSlcbiAgfVxuXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0Zvcm1EYXRhLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyBUaGUgZGVsZXRlKG5hbWUpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmVtb3ZlIGFsbCBlbnRyaWVzIHdob3NlIG5hbWVcbiAgICAvLyBpcyBuYW1lIGZyb20gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzW2tTdGF0ZV0gPSB0aGlzW2tTdGF0ZV0uZmlsdGVyKGVudHJ5ID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gIH1cblxuICBnZXQgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5nZXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gbnVsbC5cbiAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgZnJvbVxuICAgIC8vIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVtpZHhdLnZhbHVlXG4gIH1cblxuICBnZXRBbGwgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5nZXRBbGwnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gdGhlIGVtcHR5IGxpc3QuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGVudHJpZXMgd2hvc2UgbmFtZSBpcyBuYW1lLCBpbiBvcmRlcixcbiAgICAvLyBmcm9tIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVxuICAgICAgLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgICAubWFwKChlbnRyeSkgPT4gZW50cnkudmFsdWUpXG4gIH1cblxuICBoYXMgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5oYXMnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gVGhlIGhhcyhuYW1lKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGFuIGVudHJ5XG4gICAgLy8gd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3Q7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpICE9PSAtMVxuICB9XG5cbiAgc2V0IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5zZXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiAhaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3NldCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUaGUgc2V0KG5hbWUsIHZhbHVlKSBhbmQgc2V0KG5hbWUsIGJsb2JWYWx1ZSwgZmlsZW5hbWUpIG1ldGhvZCBzdGVwc1xuICAgIC8vIGFyZTpcblxuICAgIC8vIDEuIExldCB2YWx1ZSBiZSB2YWx1ZSBpZiBnaXZlbjsgb3RoZXJ3aXNlIGJsb2JWYWx1ZS5cblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgdmFsdWUgPSBpc0Jsb2JMaWtlKHZhbHVlKVxuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCBwcmVmaXgsICduYW1lJywgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSwgcHJlZml4LCAnbmFtZScpXG4gICAgZmlsZW5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlbmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgLy8gMi4gTGV0IGVudHJ5IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZW50cnkgd2l0aCBuYW1lLCB2YWx1ZSwgYW5kXG4gICAgLy8gZmlsZW5hbWUgaWYgZ2l2ZW4uXG4gICAgY29uc3QgZW50cnkgPSBtYWtlRW50cnkobmFtZSwgdmFsdWUsIGZpbGVuYW1lKVxuXG4gICAgLy8gMy4gSWYgdGhlcmUgYXJlIGVudHJpZXMgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCB3aG9zZSBuYW1lIGlzIG5hbWUsIHRoZW5cbiAgICAvLyByZXBsYWNlIHRoZSBmaXJzdCBzdWNoIGVudHJ5IHdpdGggZW50cnkgYW5kIHJlbW92ZSB0aGUgb3RoZXJzLlxuICAgIGNvbnN0IGlkeCA9IHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICB0aGlzW2tTdGF0ZV0gPSBbXG4gICAgICAgIC4uLnRoaXNba1N0YXRlXS5zbGljZSgwLCBpZHgpLFxuICAgICAgICBlbnRyeSxcbiAgICAgICAgLi4udGhpc1trU3RhdGVdLnNsaWNlKGlkeCArIDEpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gICAgICBdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgYXBwZW5kIGVudHJ5IHRvIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSlcbiAgICB9XG4gIH1cblxuICBbbm9kZVV0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpc1trU3RhdGVdLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgaWYgKGFbYi5uYW1lXSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhW2IubmFtZV0pKSB7XG4gICAgICAgICAgYVtiLm5hbWVdLnB1c2goYi52YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhW2IubmFtZV0gPSBbYVtiLm5hbWVdLCBiLnZhbHVlXVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhW2IubmFtZV0gPSBiLnZhbHVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhXG4gICAgfSwgeyBfX3Byb3RvX186IG51bGwgfSlcblxuICAgIG9wdGlvbnMuZGVwdGggPz89IGRlcHRoXG4gICAgb3B0aW9ucy5jb2xvcnMgPz89IHRydWVcblxuICAgIGNvbnN0IG91dHB1dCA9IG5vZGVVdGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHN0YXRlKVxuXG4gICAgLy8gcmVtb3ZlIFtPYmplY3QgbnVsbCBwcm90b3R5cGVdXG4gICAgcmV0dXJuIGBGb3JtRGF0YSAke291dHB1dC5zbGljZShvdXRwdXQuaW5kZXhPZignXScpICsgMil9YFxuICB9XG59XG5cbml0ZXJhdG9yTWl4aW4oJ0Zvcm1EYXRhJywgRm9ybURhdGEsIGtTdGF0ZSwgJ25hbWUnLCAndmFsdWUnKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGb3JtRGF0YS5wcm90b3R5cGUsIHtcbiAgYXBwZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0QWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Zvcm1EYXRhJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2NyZWF0ZS1hbi1lbnRyeVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfEJsb2J9IHZhbHVlXG4gKiBAcGFyYW0gez9zdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBtYWtlRW50cnkgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSkge1xuICAvLyAxLiBTZXQgbmFtZSB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgbmFtZSBpbnRvIGEgc2NhbGFyIHZhbHVlIHN0cmluZy5cbiAgLy8gTm90ZTogVGhpcyBvcGVyYXRpb24gd2FzIGRvbmUgYnkgdGhlIHdlYmlkbCBjb252ZXJ0ZXIgVVNWU3RyaW5nLlxuXG4gIC8vIDIuIElmIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGVuIHNldCB2YWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmdcbiAgLy8gICAgdmFsdWUgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gTm90ZTogVGhpcyBvcGVyYXRpb24gd2FzIGRvbmUgYnkgdGhlIHdlYmlkbCBjb252ZXJ0ZXIgVVNWU3RyaW5nLlxuICB9IGVsc2Uge1xuICAgIC8vIDMuIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIElmIHZhbHVlIGlzIG5vdCBhIEZpbGUgb2JqZWN0LCB0aGVuIHNldCB2YWx1ZSB0byBhIG5ldyBGaWxlIG9iamVjdCxcbiAgICAvLyAgICByZXByZXNlbnRpbmcgdGhlIHNhbWUgYnl0ZXMsIHdob3NlIG5hbWUgYXR0cmlidXRlIHZhbHVlIGlzIFwiYmxvYlwiXG4gICAgaWYgKCFpc0ZpbGVMaWtlKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgPyBuZXcgRmlsZShbdmFsdWVdLCAnYmxvYicsIHsgdHlwZTogdmFsdWUudHlwZSB9KVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgJ2Jsb2InLCB7IHR5cGU6IHZhbHVlLnR5cGUgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBmaWxlbmFtZSBpcyBnaXZlbiwgdGhlbiBzZXQgdmFsdWUgdG8gYSBuZXcgRmlsZSBvYmplY3QsXG4gICAgLy8gICAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGJ5dGVzLCB3aG9zZSBuYW1lIGF0dHJpYnV0ZSBpcyBmaWxlbmFtZS5cbiAgICBpZiAoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqIEB0eXBlIHtGaWxlUHJvcGVydHlCYWd9ICovXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IHZhbHVlLmxhc3RNb2RpZmllZFxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgTmF0aXZlRmlsZVxuICAgICAgICA/IG5ldyBGaWxlKFt2YWx1ZV0sIGZpbGVuYW1lLCBvcHRpb25zKVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgZmlsZW5hbWUsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIGFuIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBhbmQgd2hvc2UgdmFsdWUgaXMgdmFsdWUuXG4gIHJldHVybiB7IG5hbWUsIHZhbHVlIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEZvcm1EYXRhLCBtYWtlRW50cnkgfVxuIl0sIm5hbWVzIjpbImlzQmxvYkxpa2UiLCJpdGVyYXRvck1peGluIiwicmVxdWlyZSIsImtTdGF0ZSIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJGaWxlTGlrZSIsImlzRmlsZUxpa2UiLCJ3ZWJpZGwiLCJGaWxlIiwiTmF0aXZlRmlsZSIsIm5vZGVVdGlsIiwiZ2xvYmFsVGhpcyIsIkZvcm1EYXRhIiwiZm9ybSIsInVuZGVmaW5lZCIsImVycm9ycyIsImNvbnZlcnNpb25GYWlsZWQiLCJwcmVmaXgiLCJhcmd1bWVudCIsInR5cGVzIiwiYXBwZW5kIiwibmFtZSIsInZhbHVlIiwiZmlsZW5hbWUiLCJicmFuZENoZWNrIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImxlbmd0aCIsIlR5cGVFcnJvciIsImNvbnZlcnRlcnMiLCJVU1ZTdHJpbmciLCJCbG9iIiwic3RyaWN0IiwiZW50cnkiLCJtYWtlRW50cnkiLCJwdXNoIiwiZGVsZXRlIiwiZmlsdGVyIiwiZ2V0IiwiaWR4IiwiZmluZEluZGV4IiwiZ2V0QWxsIiwibWFwIiwiaGFzIiwic2V0Iiwic2xpY2UiLCJpbnNwZWN0IiwiY3VzdG9tIiwiZGVwdGgiLCJvcHRpb25zIiwic3RhdGUiLCJyZWR1Y2UiLCJhIiwiYiIsIkFycmF5IiwiaXNBcnJheSIsIl9fcHJvdG9fXyIsImNvbG9ycyIsIm91dHB1dCIsImZvcm1hdFdpdGhPcHRpb25zIiwiaW5kZXhPZiIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImNvbmZpZ3VyYWJsZSIsInR5cGUiLCJsYXN0TW9kaWZpZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/global.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/global.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for('undici.globalOrigin.1');\nfunction getGlobalOrigin() {\n    return globalThis[globalOrigin];\n}\nfunction setGlobalOrigin(newOrigin) {\n    if (newOrigin === undefined) {\n        Object.defineProperty(globalThis, globalOrigin, {\n            value: undefined,\n            writable: true,\n            enumerable: false,\n            configurable: false\n        });\n        return;\n    }\n    const parsedURL = new URL(newOrigin);\n    if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {\n        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);\n    }\n    Object.defineProperty(globalThis, globalOrigin, {\n        value: parsedURL,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nmodule.exports = {\n    getGlobalOrigin,\n    setGlobalOrigin\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsb0RBQW9EO0FBQ3BELDZCQUE2QjtBQUM3QixNQUFNQSxlQUFlQyxPQUFPQyxHQUFHLENBQUM7QUFFaEMsU0FBU0M7SUFDUCxPQUFPQyxVQUFVLENBQUNKLGFBQWE7QUFDakM7QUFFQSxTQUFTSyxnQkFBaUJDLFNBQVM7SUFDakMsSUFBSUEsY0FBY0MsV0FBVztRQUMzQkMsT0FBT0MsY0FBYyxDQUFDTCxZQUFZSixjQUFjO1lBQzlDVSxPQUFPSDtZQUNQSSxVQUFVO1lBQ1ZDLFlBQVk7WUFDWkMsY0FBYztRQUNoQjtRQUVBO0lBQ0Y7SUFFQSxNQUFNQyxZQUFZLElBQUlDLElBQUlUO0lBRTFCLElBQUlRLFVBQVVFLFFBQVEsS0FBSyxXQUFXRixVQUFVRSxRQUFRLEtBQUssVUFBVTtRQUNyRSxNQUFNLElBQUlDLFVBQVUsQ0FBQyw2Q0FBNkMsRUFBRUgsVUFBVUUsUUFBUSxFQUFFO0lBQzFGO0lBRUFSLE9BQU9DLGNBQWMsQ0FBQ0wsWUFBWUosY0FBYztRQUM5Q1UsT0FBT0k7UUFDUEgsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGNBQWM7SUFDaEI7QUFDRjtBQUVBSyxPQUFPQyxPQUFPLEdBQUc7SUFDZmhCO0lBQ0FFO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcZ2xvYmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBJbiBjYXNlIG9mIGJyZWFraW5nIGNoYW5nZXMsIGluY3JlYXNlIHRoZSB2ZXJzaW9uXG4vLyBudW1iZXIgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsT3JpZ2luID0gU3ltYm9sLmZvcigndW5kaWNpLmdsb2JhbE9yaWdpbi4xJylcblxuZnVuY3Rpb24gZ2V0R2xvYmFsT3JpZ2luICgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXNbZ2xvYmFsT3JpZ2luXVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxPcmlnaW4gKG5ld09yaWdpbikge1xuICBpZiAobmV3T3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsT3JpZ2luLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KVxuXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKG5ld09yaWdpbilcblxuICBpZiAocGFyc2VkVVJMLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVSTC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBPbmx5IGh0dHAgJiBodHRwcyB1cmxzIGFyZSBhbGxvd2VkLCByZWNlaXZlZCAke3BhcnNlZFVSTC5wcm90b2NvbH1gKVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbE9yaWdpbiwge1xuICAgIHZhbHVlOiBwYXJzZWRVUkwsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0R2xvYmFsT3JpZ2luLFxuICBzZXRHbG9iYWxPcmlnaW5cbn1cbiJdLCJuYW1lcyI6WyJnbG9iYWxPcmlnaW4iLCJTeW1ib2wiLCJmb3IiLCJnZXRHbG9iYWxPcmlnaW4iLCJnbG9iYWxUaGlzIiwic2V0R2xvYmFsT3JpZ2luIiwibmV3T3JpZ2luIiwidW5kZWZpbmVkIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInBhcnNlZFVSTCIsIlVSTCIsInByb3RvY29sIiwiVHlwZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/headers.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { iteratorMixin, isValidHeaderName, isValidHeaderValue } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst util = __webpack_require__(/*! node:util */ \"node:util\");\nconst kHeadersMap = Symbol('headers map');\nconst kHeadersSortedMap = Symbol('headers map sorted');\n/**\n * @param {number} code\n */ function isHTTPWhiteSpaceCharCode(code) {\n    return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */ function headerValueNormalize(potentialValue) {\n    //  To normalize a byte sequence potentialValue, remove\n    //  any leading and trailing HTTP whitespace bytes from\n    //  potentialValue.\n    let i = 0;\n    let j = potentialValue.length;\n    while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))--j;\n    while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))++i;\n    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);\n}\nfunction fill(headers, object) {\n    // To fill a Headers object headers with a given object object, run these steps:\n    // 1. If object is a sequence, then for each header in object:\n    // Note: webidl conversion to array has already been done.\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; ++i){\n            const header = object[i];\n            // 1. If header does not contain exactly two items, then throw a TypeError.\n            if (header.length !== 2) {\n                throw webidl.errors.exception({\n                    header: 'Headers constructor',\n                    message: `expected name/value pair to be length 2, found ${header.length}.`\n                });\n            }\n            // 2. Append (header’s first item, header’s second item) to headers.\n            appendHeader(headers, header[0], header[1]);\n        }\n    } else if (typeof object === 'object' && object !== null) {\n        // Note: null should throw\n        // 2. Otherwise, object is a record, then for each key → value in object,\n        //    append (key, value) to headers\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; ++i){\n            appendHeader(headers, keys[i], object[keys[i]]);\n        }\n    } else {\n        throw webidl.errors.conversionFailed({\n            prefix: 'Headers constructor',\n            argument: 'Argument 1',\n            types: [\n                'sequence<sequence<ByteString>>',\n                'record<ByteString, ByteString>'\n            ]\n        });\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */ function appendHeader(headers, name, value) {\n    // 1. Normalize value.\n    value = headerValueNormalize(value);\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n        throw webidl.errors.invalidArgument({\n            prefix: 'Headers.append',\n            value: name,\n            type: 'header name'\n        });\n    } else if (!isValidHeaderValue(value)) {\n        throw webidl.errors.invalidArgument({\n            prefix: 'Headers.append',\n            value,\n            type: 'header value'\n        });\n    }\n    // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if headers’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n    //    TODO\n    // Note: undici does not implement forbidden header names\n    if (getHeadersGuard(headers) === 'immutable') {\n        throw new TypeError('immutable');\n    }\n    // 6. Otherwise, if headers’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // 7. Append (name, value) to headers’s header list.\n    return getHeadersList(headers).append(name, value, false);\n// 8. If headers’s guard is \"request-no-cors\", then remove\n//    privileged no-CORS request headers from headers\n}\nfunction compareHeaderName(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n}\nclass HeadersList {\n    constructor(init){\n        /** @type {[string, string][]|null} */ this.cookies = null;\n        if (init instanceof HeadersList) {\n            this[kHeadersMap] = new Map(init[kHeadersMap]);\n            this[kHeadersSortedMap] = init[kHeadersSortedMap];\n            this.cookies = init.cookies === null ? null : [\n                ...init.cookies\n            ];\n        } else {\n            this[kHeadersMap] = new Map(init);\n            this[kHeadersSortedMap] = null;\n        }\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#header-list-contains\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */ contains(name, isLowerCase) {\n        // A header list list contains a header name name if list\n        // contains a header whose name is a byte-case-insensitive\n        // match for name.\n        return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());\n    }\n    clear() {\n        this[kHeadersMap].clear();\n        this[kHeadersSortedMap] = null;\n        this.cookies = null;\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-append\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */ append(name, value, isLowerCase) {\n        this[kHeadersSortedMap] = null;\n        // 1. If list contains name, then set name to the first such\n        //    header’s name.\n        const lowercaseName = isLowerCase ? name : name.toLowerCase();\n        const exists = this[kHeadersMap].get(lowercaseName);\n        // 2. Append (name, value) to list.\n        if (exists) {\n            const delimiter = lowercaseName === 'cookie' ? '; ' : ', ';\n            this[kHeadersMap].set(lowercaseName, {\n                name: exists.name,\n                value: `${exists.value}${delimiter}${value}`\n            });\n        } else {\n            this[kHeadersMap].set(lowercaseName, {\n                name,\n                value\n            });\n        }\n        if (lowercaseName === 'set-cookie') {\n            (this.cookies ??= []).push(value);\n        }\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-set\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */ set(name, value, isLowerCase) {\n        this[kHeadersSortedMap] = null;\n        const lowercaseName = isLowerCase ? name : name.toLowerCase();\n        if (lowercaseName === 'set-cookie') {\n            this.cookies = [\n                value\n            ];\n        }\n        // 1. If list contains name, then set the value of\n        //    the first such header to value and remove the\n        //    others.\n        // 2. Otherwise, append header (name, value) to list.\n        this[kHeadersMap].set(lowercaseName, {\n            name,\n            value\n        });\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */ delete(name, isLowerCase) {\n        this[kHeadersSortedMap] = null;\n        if (!isLowerCase) name = name.toLowerCase();\n        if (name === 'set-cookie') {\n            this.cookies = null;\n        }\n        this[kHeadersMap].delete(name);\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-get\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   * @returns {string | null}\n   */ get(name, isLowerCase) {\n        // 1. If list does not contain name, then return null.\n        // 2. Return the values of all headers in list whose name\n        //    is a byte-case-insensitive match for name,\n        //    separated from each other by 0x2C 0x20, in order.\n        return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null;\n    }\n    *[Symbol.iterator]() {\n        // use the lowercased name\n        for (const { 0: name, 1: { value } } of this[kHeadersMap]){\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n    get entries() {\n        const headers = {};\n        if (this[kHeadersMap].size !== 0) {\n            for (const { name, value } of this[kHeadersMap].values()){\n                headers[name] = value;\n            }\n        }\n        return headers;\n    }\n    rawValues() {\n        return this[kHeadersMap].values();\n    }\n    get entriesList() {\n        const headers = [];\n        if (this[kHeadersMap].size !== 0) {\n            for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]){\n                if (lowerName === 'set-cookie') {\n                    for (const cookie of this.cookies){\n                        headers.push([\n                            name,\n                            cookie\n                        ]);\n                    }\n                } else {\n                    headers.push([\n                        name,\n                        value\n                    ]);\n                }\n            }\n        }\n        return headers;\n    }\n    // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set\n    toSortedArray() {\n        const size = this[kHeadersMap].size;\n        const array = new Array(size);\n        // In most cases, you will use the fast-path.\n        // fast-path: Use binary insertion sort for small arrays.\n        if (size <= 32) {\n            if (size === 0) {\n                // If empty, it is an empty array. To avoid the first index assignment.\n                return array;\n            }\n            // Improve performance by unrolling loop and avoiding double-loop.\n            // Double-loop-less version of the binary insertion sort.\n            const iterator = this[kHeadersMap][Symbol.iterator]();\n            const firstValue = iterator.next().value;\n            // set [name, value] to first index.\n            array[0] = [\n                firstValue[0],\n                firstValue[1].value\n            ];\n            // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n            // 3.2.2. Assert: value is non-null.\n            assert(firstValue[1].value !== null);\n            for(let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i){\n                // get next value\n                value = iterator.next().value;\n                // set [name, value] to current index.\n                x = array[i] = [\n                    value[0],\n                    value[1].value\n                ];\n                // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n                // 3.2.2. Assert: value is non-null.\n                assert(x[1] !== null);\n                left = 0;\n                right = i;\n                // binary search\n                while(left < right){\n                    // middle index\n                    pivot = left + (right - left >> 1);\n                    // compare header name\n                    if (array[pivot][0] <= x[0]) {\n                        left = pivot + 1;\n                    } else {\n                        right = pivot;\n                    }\n                }\n                if (i !== pivot) {\n                    j = i;\n                    while(j > left){\n                        array[j] = array[--j];\n                    }\n                    array[left] = x;\n                }\n            }\n            /* c8 ignore next 4 */ if (!iterator.next().done) {\n                // This is for debugging and will never be called.\n                throw new TypeError('Unreachable');\n            }\n            return array;\n        } else {\n            // This case would be a rare occurrence.\n            // slow-path: fallback\n            let i = 0;\n            for (const { 0: name, 1: { value } } of this[kHeadersMap]){\n                array[i++] = [\n                    name,\n                    value\n                ];\n                // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n                // 3.2.2. Assert: value is non-null.\n                assert(value !== null);\n            }\n            return array.sort(compareHeaderName);\n        }\n    }\n}\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n    #guard;\n    #headersList;\n    constructor(init = undefined){\n        if (init === kConstruct) {\n            return;\n        }\n        this.#headersList = new HeadersList();\n        // The new Headers(init) constructor steps are:\n        // 1. Set this’s guard to \"none\".\n        this.#guard = 'none';\n        // 2. If init is given, then fill this with init.\n        if (init !== undefined) {\n            init = webidl.converters.HeadersInit(init, 'Headers contructor', 'init');\n            fill(this, init);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-append\n    append(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, 'Headers.append');\n        const prefix = 'Headers.append';\n        name = webidl.converters.ByteString(name, prefix, 'name');\n        value = webidl.converters.ByteString(value, prefix, 'value');\n        return appendHeader(this, name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-delete\n    delete(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, 'Headers.delete');\n        const prefix = 'Headers.delete';\n        name = webidl.converters.ByteString(name, prefix, 'name');\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: 'Headers.delete',\n                value: name,\n                type: 'header name'\n            });\n        }\n        // 2. If this’s guard is \"immutable\", then throw a TypeError.\n        // 3. Otherwise, if this’s guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n        //    is not a no-CORS-safelisted request-header name, and\n        //    name is not a privileged no-CORS request-header name,\n        //    return.\n        // 5. Otherwise, if this’s guard is \"response\" and name is\n        //    a forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this.#guard === 'immutable') {\n            throw new TypeError('immutable');\n        }\n        // 6. If this’s header list does not contain name, then\n        //    return.\n        if (!this.#headersList.contains(name, false)) {\n            return;\n        }\n        // 7. Delete name from this’s header list.\n        // 8. If this’s guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this.\n        this.#headersList.delete(name, false);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-get\n    get(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, 'Headers.get');\n        const prefix = 'Headers.get';\n        name = webidl.converters.ByteString(name, prefix, 'name');\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix,\n                value: name,\n                type: 'header name'\n            });\n        }\n        // 2. Return the result of getting name from this’s header\n        //    list.\n        return this.#headersList.get(name, false);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-has\n    has(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, 'Headers.has');\n        const prefix = 'Headers.has';\n        name = webidl.converters.ByteString(name, prefix, 'name');\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix,\n                value: name,\n                type: 'header name'\n            });\n        }\n        // 2. Return true if this’s header list contains name;\n        //    otherwise false.\n        return this.#headersList.contains(name, false);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-set\n    set(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, 'Headers.set');\n        const prefix = 'Headers.set';\n        name = webidl.converters.ByteString(name, prefix, 'name');\n        value = webidl.converters.ByteString(value, prefix, 'value');\n        // 1. Normalize value.\n        value = headerValueNormalize(value);\n        // 2. If name is not a header name or value is not a\n        //    header value, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix,\n                value: name,\n                type: 'header name'\n            });\n        } else if (!isValidHeaderValue(value)) {\n            throw webidl.errors.invalidArgument({\n                prefix,\n                value,\n                type: 'header value'\n            });\n        }\n        // 3. If this’s guard is \"immutable\", then throw a TypeError.\n        // 4. Otherwise, if this’s guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n        //    name/value is not a no-CORS-safelisted request-header,\n        //    return.\n        // 6. Otherwise, if this’s guard is \"response\" and name is a\n        //    forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this.#guard === 'immutable') {\n            throw new TypeError('immutable');\n        }\n        // 7. Set (name, value) in this’s header list.\n        // 8. If this’s guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this\n        this.#headersList.set(name, value, false);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n    getSetCookie() {\n        webidl.brandCheck(this, Headers);\n        // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n        // 2. Return the values of all headers in this’s header list whose name is\n        //    a byte-case-insensitive match for `Set-Cookie`, in order.\n        const list = this.#headersList.cookies;\n        if (list) {\n            return [\n                ...list\n            ];\n        }\n        return [];\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n    get [kHeadersSortedMap]() {\n        if (this.#headersList[kHeadersSortedMap]) {\n            return this.#headersList[kHeadersSortedMap];\n        }\n        // 1. Let headers be an empty list of headers with the key being the name\n        //    and value the value.\n        const headers = [];\n        // 2. Let names be the result of convert header names to a sorted-lowercase\n        //    set with all the names of the headers in list.\n        const names = this.#headersList.toSortedArray();\n        const cookies = this.#headersList.cookies;\n        // fast-path\n        if (cookies === null || cookies.length === 1) {\n            // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`\n            return this.#headersList[kHeadersSortedMap] = names;\n        }\n        // 3. For each name of names:\n        for(let i = 0; i < names.length; ++i){\n            const { 0: name, 1: value } = names[i];\n            // 1. If name is `set-cookie`, then:\n            if (name === 'set-cookie') {\n                // 1. Let values be a list of all values of headers in list whose name\n                //    is a byte-case-insensitive match for name, in order.\n                // 2. For each value of values:\n                // 1. Append (name, value) to headers.\n                for(let j = 0; j < cookies.length; ++j){\n                    headers.push([\n                        name,\n                        cookies[j]\n                    ]);\n                }\n            } else {\n                // 2. Otherwise:\n                // 1. Let value be the result of getting name from list.\n                // 2. Assert: value is non-null.\n                // Note: This operation was done by `HeadersList#toSortedArray`.\n                // 3. Append (name, value) to headers.\n                headers.push([\n                    name,\n                    value\n                ]);\n            }\n        }\n        // 4. Return headers.\n        return this.#headersList[kHeadersSortedMap] = headers;\n    }\n    [util.inspect.custom](depth, options) {\n        options.depth ??= depth;\n        return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;\n    }\n    static getHeadersGuard(o) {\n        return o.#guard;\n    }\n    static setHeadersGuard(o, guard) {\n        o.#guard = guard;\n    }\n    static getHeadersList(o) {\n        return o.#headersList;\n    }\n    static setHeadersList(o, list) {\n        o.#headersList = list;\n    }\n}\nconst { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;\nReflect.deleteProperty(Headers, 'getHeadersGuard');\nReflect.deleteProperty(Headers, 'setHeadersGuard');\nReflect.deleteProperty(Headers, 'getHeadersList');\nReflect.deleteProperty(Headers, 'setHeadersList');\niteratorMixin('Headers', Headers, kHeadersSortedMap, 0, 1);\nObject.defineProperties(Headers.prototype, {\n    append: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    get: kEnumerableProperty,\n    has: kEnumerableProperty,\n    set: kEnumerableProperty,\n    getSetCookie: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: 'Headers',\n        configurable: true\n    },\n    [util.inspect.custom]: {\n        enumerable: false\n    }\n});\nwebidl.converters.HeadersInit = function(V, prefix, argument) {\n    if (webidl.util.Type(V) === 'Object') {\n        const iterator = Reflect.get(V, Symbol.iterator);\n        // A work-around to ensure we send the properly-cased Headers when V is a Headers object.\n        // Read https://github.com/nodejs/undici/pull/3159#issuecomment-2075537226 before touching, please.\n        if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) {\n            try {\n                return getHeadersList(V).entriesList;\n            } catch  {\n            // fall-through\n            }\n        }\n        if (typeof iterator === 'function') {\n            return webidl.converters['sequence<sequence<ByteString>>'](V, prefix, argument, iterator.bind(V));\n        }\n        return webidl.converters['record<ByteString, ByteString>'](V, prefix, argument);\n    }\n    throw webidl.errors.conversionFailed({\n        prefix: 'Headers constructor',\n        argument: 'Argument 1',\n        types: [\n            'sequence<sequence<ByteString>>',\n            'record<ByteString, ByteString>'\n        ]\n    });\n};\nmodule.exports = {\n    fill,\n    // for test.\n    compareHeaderName,\n    Headers,\n    HeadersList,\n    getHeadersGuard,\n    setHeadersGuard,\n    setHeadersList,\n    getHeadersList\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpREFBaUQ7QUFFakQ7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQywyRUFBb0I7QUFDbkQsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxxRUFBaUI7QUFDekQsTUFBTSxFQUNKRSxhQUFhLEVBQ2JDLGlCQUFpQixFQUNqQkMsa0JBQWtCLEVBQ25CLEdBQUdKLG1CQUFPQSxDQUFDLGlFQUFRO0FBQ3BCLE1BQU0sRUFBRUssTUFBTSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDLHFFQUFVO0FBQ3JDLE1BQU1NLFNBQVNOLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3BDLE1BQU1PLE9BQU9QLG1CQUFPQSxDQUFDLDRCQUFXO0FBRWhDLE1BQU1RLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsb0JBQW9CRCxPQUFPO0FBRWpDOztDQUVDLEdBQ0QsU0FBU0UseUJBQTBCQyxJQUFJO0lBQ3JDLE9BQU9BLFNBQVMsU0FBU0EsU0FBUyxTQUFTQSxTQUFTLFNBQVNBLFNBQVM7QUFDeEU7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxxQkFBc0JDLGNBQWM7SUFDM0MsdURBQXVEO0lBQ3ZELHVEQUF1RDtJQUN2RCxtQkFBbUI7SUFDbkIsSUFBSUMsSUFBSTtJQUFHLElBQUlDLElBQUlGLGVBQWVHLE1BQU07SUFFeEMsTUFBT0QsSUFBSUQsS0FBS0oseUJBQXlCRyxlQUFlSSxVQUFVLENBQUNGLElBQUksSUFBSyxFQUFFQTtJQUM5RSxNQUFPQSxJQUFJRCxLQUFLSix5QkFBeUJHLGVBQWVJLFVBQVUsQ0FBQ0gsSUFBSyxFQUFFQTtJQUUxRSxPQUFPQSxNQUFNLEtBQUtDLE1BQU1GLGVBQWVHLE1BQU0sR0FBR0gsaUJBQWlCQSxlQUFlSyxTQUFTLENBQUNKLEdBQUdDO0FBQy9GO0FBRUEsU0FBU0ksS0FBTUMsT0FB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QXFDO0lBQ0FsQztJQUNBUDtJQUNBMEQ7SUFDQUU7SUFDQTFEO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcaGVhZGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRXRoYW4tQXJyb3dvb2QvdW5kaWNpLWZldGNoXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7XG4gIGl0ZXJhdG9yTWl4aW4sXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuXG5jb25zdCBrSGVhZGVyc01hcCA9IFN5bWJvbCgnaGVhZGVycyBtYXAnKVxuY29uc3Qga0hlYWRlcnNTb3J0ZWRNYXAgPSBTeW1ib2woJ2hlYWRlcnMgbWFwIHNvcnRlZCcpXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZnVuY3Rpb24gaXNIVFRQV2hpdGVTcGFjZUNoYXJDb2RlIChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAweDAwYSB8fCBjb2RlID09PSAweDAwZCB8fCBjb2RlID09PSAweDAwOSB8fCBjb2RlID09PSAweDAyMFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLXZhbHVlLW5vcm1hbGl6ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGhlYWRlclZhbHVlTm9ybWFsaXplIChwb3RlbnRpYWxWYWx1ZSkge1xuICAvLyAgVG8gbm9ybWFsaXplIGEgYnl0ZSBzZXF1ZW5jZSBwb3RlbnRpYWxWYWx1ZSwgcmVtb3ZlXG4gIC8vICBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGJ5dGVzIGZyb21cbiAgLy8gIHBvdGVudGlhbFZhbHVlLlxuICBsZXQgaSA9IDA7IGxldCBqID0gcG90ZW50aWFsVmFsdWUubGVuZ3RoXG5cbiAgd2hpbGUgKGogPiBpICYmIGlzSFRUUFdoaXRlU3BhY2VDaGFyQ29kZShwb3RlbnRpYWxWYWx1ZS5jaGFyQ29kZUF0KGogLSAxKSkpIC0talxuICB3aGlsZSAoaiA+IGkgJiYgaXNIVFRQV2hpdGVTcGFjZUNoYXJDb2RlKHBvdGVudGlhbFZhbHVlLmNoYXJDb2RlQXQoaSkpKSArK2lcblxuICByZXR1cm4gaSA9PT0gMCAmJiBqID09PSBwb3RlbnRpYWxWYWx1ZS5sZW5ndGggPyBwb3RlbnRpYWxWYWx1ZSA6IHBvdGVudGlhbFZhbHVlLnN1YnN0cmluZyhpLCBqKVxufVxuXG5mdW5jdGlvbiBmaWxsIChoZWFkZXJzLCBvYmplY3QpIHtcbiAgLy8gVG8gZmlsbCBhIEhlYWRlcnMgb2JqZWN0IGhlYWRlcnMgd2l0aCBhIGdpdmVuIG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBzZXF1ZW5jZSwgdGhlbiBmb3IgZWFjaCBoZWFkZXIgaW4gb2JqZWN0OlxuICAvLyBOb3RlOiB3ZWJpZGwgY29udmVyc2lvbiB0byBhcnJheSBoYXMgYWxyZWFkeSBiZWVuIGRvbmUuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaGVhZGVyID0gb2JqZWN0W2ldXG4gICAgICAvLyAxLiBJZiBoZWFkZXIgZG9lcyBub3QgY29udGFpbiBleGFjdGx5IHR3byBpdGVtcywgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChoZWFkZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgICBtZXNzYWdlOiBgZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCAke2hlYWRlci5sZW5ndGh9LmBcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIChoZWFkZXLigJlzIGZpcnN0IGl0ZW0sIGhlYWRlcuKAmXMgc2Vjb25kIGl0ZW0pIHRvIGhlYWRlcnMuXG4gICAgICBhcHBlbmRIZWFkZXIoaGVhZGVycywgaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIC8vIE5vdGU6IG51bGwgc2hvdWxkIHRocm93XG5cbiAgICAvLyAyLiBPdGhlcndpc2UsIG9iamVjdCBpcyBhIHJlY29yZCwgdGhlbiBmb3IgZWFjaCBrZXkg4oaSIHZhbHVlIGluIG9iamVjdCxcbiAgICAvLyAgICBhcHBlbmQgKGtleSwgdmFsdWUpIHRvIGhlYWRlcnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgYXBwZW5kSGVhZGVyKGhlYWRlcnMsIGtleXNbaV0sIG9iamVjdFtrZXlzW2ldXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMgY29uc3RydWN0b3InLFxuICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgIHR5cGVzOiBbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PicsICdyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlcnMtYXBwZW5kXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZEhlYWRlciAoaGVhZGVycywgbmFtZSwgdmFsdWUpIHtcbiAgLy8gMS4gTm9ybWFsaXplIHZhbHVlLlxuICB2YWx1ZSA9IGhlYWRlclZhbHVlTm9ybWFsaXplKHZhbHVlKVxuXG4gIC8vIDIuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUgb3IgdmFsdWUgaXMgbm90IGFcbiAgLy8gICAgaGVhZGVyIHZhbHVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgcHJlZml4OiAnSGVhZGVycy5hcHBlbmQnLFxuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgfSlcbiAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMuYXBwZW5kJyxcbiAgICAgIHZhbHVlLFxuICAgICAgdHlwZTogJ2hlYWRlciB2YWx1ZSdcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgLy8gNC4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAvLyA1LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCI6XG4gIC8vICAgIFRPRE9cbiAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gIGlmIChnZXRIZWFkZXJzR3VhcmQoaGVhZGVycykgPT09ICdpbW11dGFibGUnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgfVxuXG4gIC8vIDYuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXNwb25zZVwiIGFuZCBuYW1lIGlzIGFcbiAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG5cbiAgLy8gNy4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QuXG4gIHJldHVybiBnZXRIZWFkZXJzTGlzdChoZWFkZXJzKS5hcHBlbmQobmFtZSwgdmFsdWUsIGZhbHNlKVxuXG4gIC8vIDguIElmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSBoZWFkZXJzXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVIZWFkZXJOYW1lIChhLCBiKSB7XG4gIHJldHVybiBhWzBdIDwgYlswXSA/IC0xIDogMVxufVxuXG5jbGFzcyBIZWFkZXJzTGlzdCB7XG4gIC8qKiBAdHlwZSB7W3N0cmluZywgc3RyaW5nXVtdfG51bGx9ICovXG4gIGNvb2tpZXMgPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKGluaXQpIHtcbiAgICBpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnNMaXN0KSB7XG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXSA9IG5ldyBNYXAoaW5pdFtrSGVhZGVyc01hcF0pXG4gICAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IGluaXRba0hlYWRlcnNTb3J0ZWRNYXBdXG4gICAgICB0aGlzLmNvb2tpZXMgPSBpbml0LmNvb2tpZXMgPT09IG51bGwgPyBudWxsIDogWy4uLmluaXQuY29va2llc11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0gPSBuZXcgTWFwKGluaXQpXG4gICAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLWxpc3QtY29udGFpbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyQ2FzZVxuICAgKi9cbiAgY29udGFpbnMgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgLy8gQSBoZWFkZXIgbGlzdCBsaXN0IGNvbnRhaW5zIGEgaGVhZGVyIG5hbWUgbmFtZSBpZiBsaXN0XG4gICAgLy8gY29udGFpbnMgYSBoZWFkZXIgd2hvc2UgbmFtZSBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZVxuICAgIC8vIG1hdGNoIGZvciBuYW1lLlxuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLmhhcyhpc0xvd2VyQ2FzZSA/IG5hbWUgOiBuYW1lLnRvTG93ZXJDYXNlKCkpXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpc1trSGVhZGVyc01hcF0uY2xlYXIoKVxuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWFwcGVuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyQ2FzZVxuICAgKi9cbiAgYXBwZW5kIChuYW1lLCB2YWx1ZSwgaXNMb3dlckNhc2UpIHtcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcblxuICAgIC8vIDEuIElmIGxpc3QgY29udGFpbnMgbmFtZSwgdGhlbiBzZXQgbmFtZSB0byB0aGUgZmlyc3Qgc3VjaFxuICAgIC8vICAgIGhlYWRlcuKAmXMgbmFtZS5cbiAgICBjb25zdCBsb3dlcmNhc2VOYW1lID0gaXNMb3dlckNhc2UgPyBuYW1lIDogbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgZXhpc3RzID0gdGhpc1trSGVhZGVyc01hcF0uZ2V0KGxvd2VyY2FzZU5hbWUpXG5cbiAgICAvLyAyLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBsaXN0LlxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IGxvd2VyY2FzZU5hbWUgPT09ICdjb29raWUnID8gJzsgJyA6ICcsICdcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7XG4gICAgICAgIG5hbWU6IGV4aXN0cy5uYW1lLFxuICAgICAgICB2YWx1ZTogYCR7ZXhpc3RzLnZhbHVlfSR7ZGVsaW1pdGVyfSR7dmFsdWV9YFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgICB9XG5cbiAgICBpZiAobG93ZXJjYXNlTmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAodGhpcy5jb29raWVzID8/PSBbXSkucHVzaCh2YWx1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICovXG4gIHNldCAobmFtZSwgdmFsdWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgY29uc3QgbG93ZXJjYXNlTmFtZSA9IGlzTG93ZXJDYXNlID8gbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKGxvd2VyY2FzZU5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID0gW3ZhbHVlXVxuICAgIH1cblxuICAgIC8vIDEuIElmIGxpc3QgY29udGFpbnMgbmFtZSwgdGhlbiBzZXQgdGhlIHZhbHVlIG9mXG4gICAgLy8gICAgdGhlIGZpcnN0IHN1Y2ggaGVhZGVyIHRvIHZhbHVlIGFuZCByZW1vdmUgdGhlXG4gICAgLy8gICAgb3RoZXJzLlxuICAgIC8vIDIuIE90aGVyd2lzZSwgYXBwZW5kIGhlYWRlciAobmFtZSwgdmFsdWUpIHRvIGxpc3QuXG4gICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWRlbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqL1xuICBkZWxldGUgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgaWYgKCFpc0xvd2VyQ2FzZSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKG5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID0gbnVsbFxuICAgIH1cblxuICAgIHRoaXNba0hlYWRlcnNNYXBdLmRlbGV0ZShuYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gICAqL1xuICBnZXQgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgLy8gMS4gSWYgbGlzdCBkb2VzIG5vdCBjb250YWluIG5hbWUsIHRoZW4gcmV0dXJuIG51bGwuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMgaW4gbGlzdCB3aG9zZSBuYW1lXG4gICAgLy8gICAgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIG5hbWUsXG4gICAgLy8gICAgc2VwYXJhdGVkIGZyb20gZWFjaCBvdGhlciBieSAweDJDIDB4MjAsIGluIG9yZGVyLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5nZXQoaXNMb3dlckNhc2UgPyBuYW1lIDogbmFtZS50b0xvd2VyQ2FzZSgpKT8udmFsdWUgPz8gbnVsbFxuICB9XG5cbiAgKiBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgLy8gdXNlIHRoZSBsb3dlcmNhc2VkIG5hbWVcbiAgICBmb3IgKGNvbnN0IHsgMDogbmFtZSwgMTogeyB2YWx1ZSB9IH0gb2YgdGhpc1trSGVhZGVyc01hcF0pIHtcbiAgICAgIHlpZWxkIFtuYW1lLCB2YWx1ZV1cbiAgICB9XG4gIH1cblxuICBnZXQgZW50cmllcyAoKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9XG5cbiAgICBpZiAodGhpc1trSGVhZGVyc01hcF0uc2l6ZSAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgdGhpc1trSGVhZGVyc01hcF0udmFsdWVzKCkpIHtcbiAgICAgICAgaGVhZGVyc1tuYW1lXSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIHJhd1ZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLnZhbHVlcygpXG4gIH1cblxuICBnZXQgZW50cmllc0xpc3QgKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBbXVxuXG4gICAgaWYgKHRoaXNba0hlYWRlcnNNYXBdLnNpemUgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3QgeyAwOiBsb3dlck5hbWUsIDE6IHsgbmFtZSwgdmFsdWUgfSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdKSB7XG4gICAgICAgIGlmIChsb3dlck5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICAgIGZvciAoY29uc3QgY29va2llIG9mIHRoaXMuY29va2llcykge1xuICAgICAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCBjb29raWVdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29udmVydC1oZWFkZXItbmFtZXMtdG8tYS1zb3J0ZWQtbG93ZXJjYXNlLXNldFxuICB0b1NvcnRlZEFycmF5ICgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpc1trSGVhZGVyc01hcF0uc2l6ZVxuICAgIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KHNpemUpXG4gICAgLy8gSW4gbW9zdCBjYXNlcywgeW91IHdpbGwgdXNlIHRoZSBmYXN0LXBhdGguXG4gICAgLy8gZmFzdC1wYXRoOiBVc2UgYmluYXJ5IGluc2VydGlvbiBzb3J0IGZvciBzbWFsbCBhcnJheXMuXG4gICAgaWYgKHNpemUgPD0gMzIpIHtcbiAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIC8vIElmIGVtcHR5LCBpdCBpcyBhbiBlbXB0eSBhcnJheS4gVG8gYXZvaWQgdGhlIGZpcnN0IGluZGV4IGFzc2lnbm1lbnQuXG4gICAgICAgIHJldHVybiBhcnJheVxuICAgICAgfVxuICAgICAgLy8gSW1wcm92ZSBwZXJmb3JtYW5jZSBieSB1bnJvbGxpbmcgbG9vcCBhbmQgYXZvaWRpbmcgZG91YmxlLWxvb3AuXG4gICAgICAvLyBEb3VibGUtbG9vcC1sZXNzIHZlcnNpb24gb2YgdGhlIGJpbmFyeSBpbnNlcnRpb24gc29ydC5cbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpc1trSGVhZGVyc01hcF1bU3ltYm9sLml0ZXJhdG9yXSgpXG4gICAgICBjb25zdCBmaXJzdFZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlXG4gICAgICAvLyBzZXQgW25hbWUsIHZhbHVlXSB0byBmaXJzdCBpbmRleC5cbiAgICAgIGFycmF5WzBdID0gW2ZpcnN0VmFsdWVbMF0sIGZpcnN0VmFsdWVbMV0udmFsdWVdXG4gICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAvLyAzLjIuMi4gQXNzZXJ0OiB2YWx1ZSBpcyBub24tbnVsbC5cbiAgICAgIGFzc2VydChmaXJzdFZhbHVlWzFdLnZhbHVlICE9PSBudWxsKVxuICAgICAgZm9yIChcbiAgICAgICAgbGV0IGkgPSAxLCBqID0gMCwgcmlnaHQgPSAwLCBsZWZ0ID0gMCwgcGl2b3QgPSAwLCB4LCB2YWx1ZTtcbiAgICAgICAgaSA8IHNpemU7XG4gICAgICAgICsraVxuICAgICAgKSB7XG4gICAgICAgIC8vIGdldCBuZXh0IHZhbHVlXG4gICAgICAgIHZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlXG4gICAgICAgIC8vIHNldCBbbmFtZSwgdmFsdWVdIHRvIGN1cnJlbnQgaW5kZXguXG4gICAgICAgIHggPSBhcnJheVtpXSA9IFt2YWx1ZVswXSwgdmFsdWVbMV0udmFsdWVdXG4gICAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbiAgICAgICAgLy8gMy4yLjIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIGFzc2VydCh4WzFdICE9PSBudWxsKVxuICAgICAgICBsZWZ0ID0gMFxuICAgICAgICByaWdodCA9IGlcbiAgICAgICAgLy8gYmluYXJ5IHNlYXJjaFxuICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgLy8gbWlkZGxlIGluZGV4XG4gICAgICAgICAgcGl2b3QgPSBsZWZ0ICsgKChyaWdodCAtIGxlZnQpID4+IDEpXG4gICAgICAgICAgLy8gY29tcGFyZSBoZWFkZXIgbmFtZVxuICAgICAgICAgIGlmIChhcnJheVtwaXZvdF1bMF0gPD0geFswXSkge1xuICAgICAgICAgICAgbGVmdCA9IHBpdm90ICsgMVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByaWdodCA9IHBpdm90XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9PSBwaXZvdCkge1xuICAgICAgICAgIGogPSBpXG4gICAgICAgICAgd2hpbGUgKGogPiBsZWZ0KSB7XG4gICAgICAgICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXlbbGVmdF0gPSB4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDQgKi9cbiAgICAgIGlmICghaXRlcmF0b3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBmb3IgZGVidWdnaW5nIGFuZCB3aWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgY2FzZSB3b3VsZCBiZSBhIHJhcmUgb2NjdXJyZW5jZS5cbiAgICAgIC8vIHNsb3ctcGF0aDogZmFsbGJhY2tcbiAgICAgIGxldCBpID0gMFxuICAgICAgZm9yIChjb25zdCB7IDA6IG5hbWUsIDE6IHsgdmFsdWUgfSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdKSB7XG4gICAgICAgIGFycmF5W2krK10gPSBbbmFtZSwgdmFsdWVdXG4gICAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbiAgICAgICAgLy8gMy4yLjIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gbnVsbClcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheS5zb3J0KGNvbXBhcmVIZWFkZXJOYW1lKVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVycy1jbGFzc1xuY2xhc3MgSGVhZGVycyB7XG4gICNndWFyZFxuICAjaGVhZGVyc0xpc3RcblxuICBjb25zdHJ1Y3RvciAoaW5pdCA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChpbml0ID09PSBrQ29uc3RydWN0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLiNoZWFkZXJzTGlzdCA9IG5ldyBIZWFkZXJzTGlzdCgpXG5cbiAgICAvLyBUaGUgbmV3IEhlYWRlcnMoaW5pdCkgY29uc3RydWN0b3Igc3RlcHMgYXJlOlxuXG4gICAgLy8gMS4gU2V0IHRoaXPigJlzIGd1YXJkIHRvIFwibm9uZVwiLlxuICAgIHRoaXMuI2d1YXJkID0gJ25vbmUnXG5cbiAgICAvLyAyLiBJZiBpbml0IGlzIGdpdmVuLCB0aGVuIGZpbGwgdGhpcyB3aXRoIGluaXQuXG4gICAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0KGluaXQsICdIZWFkZXJzIGNvbnRydWN0b3InLCAnaW5pdCcpXG4gICAgICBmaWxsKHRoaXMsIGluaXQpXG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWFwcGVuZFxuICBhcHBlbmQgKG5hbWUsIHZhbHVlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgJ0hlYWRlcnMuYXBwZW5kJylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmFwcGVuZCdcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJylcblxuICAgIHJldHVybiBhcHBlbmRIZWFkZXIodGhpcywgbmFtZSwgdmFsdWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZGVsZXRlXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmRlbGV0ZScpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5kZWxldGUnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5kZWxldGUnLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIDQuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgbmFtZVxuICAgIC8vICAgIGlzIG5vdCBhIG5vLUNPUlMtc2FmZWxpc3RlZCByZXF1ZXN0LWhlYWRlciBuYW1lLCBhbmRcbiAgICAvLyAgICBuYW1lIGlzIG5vdCBhIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0LWhlYWRlciBuYW1lLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA1LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpc1xuICAgIC8vICAgIGEgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXMuI2d1YXJkID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgICB9XG5cbiAgICAvLyA2LiBJZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIG5hbWUsIHRoZW5cbiAgICAvLyAgICByZXR1cm4uXG4gICAgaWYgKCF0aGlzLiNoZWFkZXJzTGlzdC5jb250YWlucyhuYW1lLCBmYWxzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDcuIERlbGV0ZSBuYW1lIGZyb20gdGhpc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgLy8gOC4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgdGhlbiByZW1vdmVcbiAgICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gdGhpcy5cbiAgICB0aGlzLiNoZWFkZXJzTGlzdC5kZWxldGUobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZ2V0XG4gIGdldCAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmdldCcpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5nZXQnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXJcbiAgICAvLyAgICBsaXN0LlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzTGlzdC5nZXQobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtaGFzXG4gIGhhcyAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmhhcycpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5oYXMnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBuYW1lO1xuICAgIC8vICAgIG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpcy4jaGVhZGVyc0xpc3QuY29udGFpbnMobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtc2V0XG4gIHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCAnSGVhZGVycy5zZXQnKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0hlYWRlcnMuc2V0J1xuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuXG4gICAgLy8gMS4gTm9ybWFsaXplIHZhbHVlLlxuICAgIHZhbHVlID0gaGVhZGVyVmFsdWVOb3JtYWxpemUodmFsdWUpXG5cbiAgICAvLyAyLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lIG9yIHZhbHVlIGlzIG5vdCBhXG4gICAgLy8gICAgaGVhZGVyIHZhbHVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgdmFsdWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDMuIElmIHRoaXPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiIGFuZFxuICAgIC8vICAgIG5hbWUvdmFsdWUgaXMgbm90IGEgbm8tQ09SUy1zYWZlbGlzdGVkIHJlcXVlc3QtaGVhZGVyLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA2LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXMuI2d1YXJkID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgICB9XG5cbiAgICAvLyA3LiBTZXQgKG5hbWUsIHZhbHVlKSBpbiB0aGlz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGlzXG4gICAgdGhpcy4jaGVhZGVyc0xpc3Quc2V0KG5hbWUsIHZhbHVlLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRzZXRjb29raWVcbiAgZ2V0U2V0Q29va2llICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgU2V0LUNvb2tpZWAsIHRoZW4gcmV0dXJuIMKrIMK7LlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIHRoaXPigJlzIGhlYWRlciBsaXN0IHdob3NlIG5hbWUgaXNcbiAgICAvLyAgICBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYFNldC1Db29raWVgLCBpbiBvcmRlci5cblxuICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNoZWFkZXJzTGlzdC5jb29raWVzXG5cbiAgICBpZiAobGlzdCkge1xuICAgICAgcmV0dXJuIFsuLi5saXN0XVxuICAgIH1cblxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc29ydC1hbmQtY29tYmluZVxuICBnZXQgW2tIZWFkZXJzU29ydGVkTWFwXSAoKSB7XG4gICAgaWYgKHRoaXMuI2hlYWRlcnNMaXN0W2tIZWFkZXJzU29ydGVkTWFwXSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2hlYWRlcnNMaXN0W2tIZWFkZXJzU29ydGVkTWFwXVxuICAgIH1cblxuICAgIC8vIDEuIExldCBoZWFkZXJzIGJlIGFuIGVtcHR5IGxpc3Qgb2YgaGVhZGVycyB3aXRoIHRoZSBrZXkgYmVpbmcgdGhlIG5hbWVcbiAgICAvLyAgICBhbmQgdmFsdWUgdGhlIHZhbHVlLlxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXVxuXG4gICAgLy8gMi4gTGV0IG5hbWVzIGJlIHRoZSByZXN1bHQgb2YgY29udmVydCBoZWFkZXIgbmFtZXMgdG8gYSBzb3J0ZWQtbG93ZXJjYXNlXG4gICAgLy8gICAgc2V0IHdpdGggYWxsIHRoZSBuYW1lcyBvZiB0aGUgaGVhZGVycyBpbiBsaXN0LlxuICAgIGNvbnN0IG5hbWVzID0gdGhpcy4jaGVhZGVyc0xpc3QudG9Tb3J0ZWRBcnJheSgpXG5cbiAgICBjb25zdCBjb29raWVzID0gdGhpcy4jaGVhZGVyc0xpc3QuY29va2llc1xuXG4gICAgLy8gZmFzdC1wYXRoXG4gICAgaWYgKGNvb2tpZXMgPT09IG51bGwgfHwgY29va2llcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBub24tbnVsbCBhc3NlcnRpb24gb2YgdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBkb25lIGJ5IGBIZWFkZXJzTGlzdCN0b1NvcnRlZEFycmF5YFxuICAgICAgcmV0dXJuICh0aGlzLiNoZWFkZXJzTGlzdFtrSGVhZGVyc1NvcnRlZE1hcF0gPSBuYW1lcylcbiAgICB9XG5cbiAgICAvLyAzLiBGb3IgZWFjaCBuYW1lIG9mIG5hbWVzOlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHsgMDogbmFtZSwgMTogdmFsdWUgfSA9IG5hbWVzW2ldXG4gICAgICAvLyAxLiBJZiBuYW1lIGlzIGBzZXQtY29va2llYCwgdGhlbjpcbiAgICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgLy8gMS4gTGV0IHZhbHVlcyBiZSBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBvZiBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgICAgICAvLyAgICBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgbmFtZSwgaW4gb3JkZXIuXG5cbiAgICAgICAgLy8gMi4gRm9yIGVhY2ggdmFsdWUgb2YgdmFsdWVzOlxuICAgICAgICAvLyAxLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJzLlxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvb2tpZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIGNvb2tpZXNbal1dKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAyLiBPdGhlcndpc2U6XG5cbiAgICAgICAgLy8gMS4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBuYW1lIGZyb20gbGlzdC5cblxuICAgICAgICAvLyAyLiBBc3NlcnQ6IHZhbHVlIGlzIG5vbi1udWxsLlxuICAgICAgICAvLyBOb3RlOiBUaGlzIG9wZXJhdGlvbiB3YXMgZG9uZSBieSBgSGVhZGVyc0xpc3QjdG9Tb3J0ZWRBcnJheWAuXG5cbiAgICAgICAgLy8gMy4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVycy5cbiAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gUmV0dXJuIGhlYWRlcnMuXG4gICAgcmV0dXJuICh0aGlzLiNoZWFkZXJzTGlzdFtrSGVhZGVyc1NvcnRlZE1hcF0gPSBoZWFkZXJzKVxuICB9XG5cbiAgW3V0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMuZGVwdGggPz89IGRlcHRoXG5cbiAgICByZXR1cm4gYEhlYWRlcnMgJHt1dGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHRoaXMuI2hlYWRlcnNMaXN0LmVudHJpZXMpfWBcbiAgfVxuXG4gIHN0YXRpYyBnZXRIZWFkZXJzR3VhcmQgKG8pIHtcbiAgICByZXR1cm4gby4jZ3VhcmRcbiAgfVxuXG4gIHN0YXRpYyBzZXRIZWFkZXJzR3VhcmQgKG8sIGd1YXJkKSB7XG4gICAgby4jZ3VhcmQgPSBndWFyZFxuICB9XG5cbiAgc3RhdGljIGdldEhlYWRlcnNMaXN0IChvKSB7XG4gICAgcmV0dXJuIG8uI2hlYWRlcnNMaXN0XG4gIH1cblxuICBzdGF0aWMgc2V0SGVhZGVyc0xpc3QgKG8sIGxpc3QpIHtcbiAgICBvLiNoZWFkZXJzTGlzdCA9IGxpc3RcbiAgfVxufVxuXG5jb25zdCB7IGdldEhlYWRlcnNHdWFyZCwgc2V0SGVhZGVyc0d1YXJkLCBnZXRIZWFkZXJzTGlzdCwgc2V0SGVhZGVyc0xpc3QgfSA9IEhlYWRlcnNcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoSGVhZGVycywgJ2dldEhlYWRlcnNHdWFyZCcpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEhlYWRlcnMsICdzZXRIZWFkZXJzR3VhcmQnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShIZWFkZXJzLCAnZ2V0SGVhZGVyc0xpc3QnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShIZWFkZXJzLCAnc2V0SGVhZGVyc0xpc3QnKVxuXG5pdGVyYXRvck1peGluKCdIZWFkZXJzJywgSGVhZGVycywga0hlYWRlcnNTb3J0ZWRNYXAsIDAsIDEpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlYWRlcnMucHJvdG90eXBlLCB7XG4gIGFwcGVuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXRTZXRDb29raWU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdIZWFkZXJzJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgW3V0aWwuaW5zcGVjdC5jdXN0b21dOiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IFJlZmxlY3QuZ2V0KFYsIFN5bWJvbC5pdGVyYXRvcilcblxuICAgIC8vIEEgd29yay1hcm91bmQgdG8gZW5zdXJlIHdlIHNlbmQgdGhlIHByb3Blcmx5LWNhc2VkIEhlYWRlcnMgd2hlbiBWIGlzIGEgSGVhZGVycyBvYmplY3QuXG4gICAgLy8gUmVhZCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzMxNTkjaXNzdWVjb21tZW50LTIwNzU1MzcyMjYgYmVmb3JlIHRvdWNoaW5nLCBwbGVhc2UuXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzUHJveHkoVikgJiYgaXRlcmF0b3IgPT09IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMpIHsgLy8gSGVhZGVycyBvYmplY3RcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBnZXRIZWFkZXJzTGlzdChWKS5lbnRyaWVzTGlzdFxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGZhbGwtdGhyb3VnaFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+J10oViwgcHJlZml4LCBhcmd1bWVudCwgaXRlcmF0b3IuYmluZChWKSlcbiAgICB9XG5cbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddKFYsIHByZWZpeCwgYXJndW1lbnQpXG4gIH1cblxuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgIHByZWZpeDogJ0hlYWRlcnMgY29uc3RydWN0b3InLFxuICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgdHlwZXM6IFsnc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+JywgJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaWxsLFxuICAvLyBmb3IgdGVzdC5cbiAgY29tcGFyZUhlYWRlck5hbWUsXG4gIEhlYWRlcnMsXG4gIEhlYWRlcnNMaXN0LFxuICBnZXRIZWFkZXJzR3VhcmQsXG4gIHNldEhlYWRlcnNHdWFyZCxcbiAgc2V0SGVhZGVyc0xpc3QsXG4gIGdldEhlYWRlcnNMaXN0XG59XG4iXSwibmFtZXMiOlsia0NvbnN0cnVjdCIsInJlcXVpcmUiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiaXRlcmF0b3JNaXhpbiIsImlzVmFsaWRIZWFkZXJOYW1lIiwiaXNWYWxpZEhlYWRlclZhbHVlIiwid2ViaWRsIiwiYXNzZXJ0IiwidXRpbCIsImtIZWFkZXJzTWFwIiwiU3ltYm9sIiwia0hlYWRlcnNTb3J0ZWRNYXAiLCJpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUiLCJjb2RlIiwiaGVhZGVyVmFsdWVOb3JtYWxpemUiLCJwb3RlbnRpYWxWYWx1ZSIsImkiLCJqIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInN1YnN0cmluZyIsImZpbGwiLCJoZWFkZXJzIiwib2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiaGVhZGVyIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsImFwcGVuZEhlYWRlciIsImtleXMiLCJPYmplY3QiLCJjb252ZXJzaW9uRmFpbGVkIiwicHJlZml4IiwiYXJndW1lbnQiLCJ0eXBlcyIsIm5hbWUiLCJ2YWx1ZSIsImludmFsaWRBcmd1bWVudCIsInR5cGUiLCJnZXRIZWFkZXJzR3VhcmQiLCJUeXBlRXJyb3IiLCJnZXRIZWFkZXJzTGlzdCIsImFwcGVuZCIsImNvbXBhcmVIZWFkZXJOYW1lIiwiYSIsImIiLCJIZWFkZXJzTGlzdCIsImluaXQiLCJjb29raWVzIiwiTWFwIiwiY29udGFpbnMiLCJpc0xvd2VyQ2FzZSIsImhhcyIsInRvTG93ZXJDYXNlIiwiY2xlYXIiLCJsb3dlcmNhc2VOYW1lIiwiZXhpc3RzIiwiZ2V0IiwiZGVsaW1pdGVyIiwic2V0IiwicHVzaCIsImRlbGV0ZSIsIml0ZXJhdG9yIiwiZW50cmllcyIsInNpemUiLCJ2YWx1ZXMiLCJyYXdWYWx1ZXMiLCJlbnRyaWVzTGlzdCIsImxvd2VyTmFtZSIsImNvb2tpZSIsInRvU29ydGVkQXJyYXkiLCJhcnJheSIsImZpcnN0VmFsdWUiLCJuZXh0IiwicmlnaHQiLCJsZWZ0IiwicGl2b3QiLCJ4IiwiZG9uZSIsInNvcnQiLCJIZWFkZXJzIiwidW5kZWZpbmVkIiwiY29udmVydGVycyIsIkhlYWRlcnNJbml0IiwiYnJhbmRDaGVjayIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJCeXRlU3RyaW5nIiwiZ2V0U2V0Q29va2llIiwibGlzdCIsIm5hbWVzIiwiaW5zcGVjdCIsImN1c3RvbSIsImRlcHRoIiwib3B0aW9ucyIsImZvcm1hdFdpdGhPcHRpb25zIiwibyIsInNldEhlYWRlcnNHdWFyZCIsImd1YXJkIiwic2V0SGVhZGVyc0xpc3QiLCJSZWZsZWN0IiwiZGVsZXRlUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwidG9TdHJpbmdUYWciLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiViIsIlR5cGUiLCJpc1Byb3h5IiwiYmluZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/headers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/index.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse, fromInnerResponse } = __webpack_require__(/*! ./response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\");\nconst { HeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\nconst { Request, cloneRequest } = __webpack_require__(/*! ./request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\");\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme, clampAndCoarsenConnectionTimingInfo, simpleRangeHeaderValue, buildContentRange, createInflate, extractMimeType } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { kState, kDispatcher } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { safelyExtractBody, extractBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\");\nconst { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\");\nconst EE = __webpack_require__(/*! node:events */ \"node:events\");\nconst { Readable, pipeline, finished } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(ssr)/./node_modules/undici/lib/global.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\");\nconst GET_OR_HEAD = [\n    'GET',\n    'HEAD'\n];\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined' ? 'node' : 'undici';\n/** @type {import('buffer').resolveObjectURL} */ let resolveObjectURL;\nclass Fetch extends EE {\n    constructor(dispatcher){\n        super();\n        this.dispatcher = dispatcher;\n        this.connection = null;\n        this.dump = false;\n        this.state = 'ongoing';\n    }\n    terminate(reason) {\n        if (this.state !== 'ongoing') {\n            return;\n        }\n        this.state = 'terminated';\n        this.connection?.destroy(reason);\n        this.emit('terminated', reason);\n    }\n    // https://fetch.spec.whatwg.org/#fetch-controller-abort\n    abort(error) {\n        if (this.state !== 'ongoing') {\n            return;\n        }\n        // 1. Set controller’s state to \"aborted\".\n        this.state = 'aborted';\n        // 2. Let fallbackError be an \"AbortError\" DOMException.\n        // 3. Set error to fallbackError if it is not given.\n        if (!error) {\n            error = new DOMException('The operation was aborted.', 'AbortError');\n        }\n        // 4. Let serializedError be StructuredSerialize(error).\n        //    If that threw an exception, catch it, and let\n        //    serializedError be StructuredSerialize(fallbackError).\n        // 5. Set controller’s serialized abort reason to serializedError.\n        this.serializedAbortReason = error;\n        this.connection?.destroy(error);\n        this.emit('terminated', error);\n    }\n}\nfunction handleFetchDone(response) {\n    finalizeAndReportTiming(response, 'fetch');\n}\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch(input, init = undefined) {\n    webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch');\n    // 1. Let p be a new promise.\n    let p = createDeferredPromise();\n    // 2. Let requestObject be the result of invoking the initial value of\n    // Request as constructor with input and init as arguments. If this throws\n    // an exception, reject p with it and return p.\n    let requestObject;\n    try {\n        requestObject = new Request(input, init);\n    } catch (e) {\n        p.reject(e);\n        return p.promise;\n    }\n    // 3. Let request be requestObject’s request.\n    const request = requestObject[kState];\n    // 4. If requestObject’s signal’s aborted flag is set, then:\n    if (requestObject.signal.aborted) {\n        // 1. Abort the fetch() call with p, request, null, and\n        //    requestObject’s signal’s abort reason.\n        abortFetch(p, request, null, requestObject.signal.reason);\n        // 2. Return p.\n        return p.promise;\n    }\n    // 5. Let globalObject be request’s client’s global object.\n    const globalObject = request.client.globalObject;\n    // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n    // request’s service-workers mode to \"none\".\n    if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n        request.serviceWorkers = 'none';\n    }\n    // 7. Let responseObject be null.\n    let responseObject = null;\n    // 8. Let relevantRealm be this’s relevant Realm.\n    // 9. Let locallyAborted be false.\n    let locallyAborted = false;\n    // 10. Let controller be null.\n    let controller = null;\n    // 11. Add the following abort steps to requestObject’s signal:\n    addAbortListener(requestObject.signal, ()=>{\n        // 1. Set locallyAborted to true.\n        locallyAborted = true;\n        // 2. Assert: controller is non-null.\n        assert(controller != null);\n        // 3. Abort controller with requestObject’s signal’s abort reason.\n        controller.abort(requestObject.signal.reason);\n        const realResponse = responseObject?.deref();\n        // 4. Abort the fetch() call with p, request, responseObject,\n        //    and requestObject’s signal’s abort reason.\n        abortFetch(p, request, realResponse, requestObject.signal.reason);\n    });\n    // 12. Let handleFetchDone given response response be to finalize and\n    // report timing with response, globalObject, and \"fetch\".\n    // see function handleFetchDone\n    // 13. Set controller to the result of calling fetch given request,\n    // with processResponseEndOfBody set to handleFetchDone, and processResponse\n    // given response being these substeps:\n    const processResponse = (response)=>{\n        // 1. If locallyAborted is true, terminate these substeps.\n        if (locallyAborted) {\n            return;\n        }\n        // 2. If response’s aborted flag is set, then:\n        if (response.aborted) {\n            // 1. Let deserializedError be the result of deserialize a serialized\n            //    abort reason given controller’s serialized abort reason and\n            //    relevantRealm.\n            // 2. Abort the fetch() call with p, request, responseObject, and\n            //    deserializedError.\n            abortFetch(p, request, responseObject, controller.serializedAbortReason);\n            return;\n        }\n        // 3. If response is a network error, then reject p with a TypeError\n        // and terminate these substeps.\n        if (response.type === 'error') {\n            p.reject(new TypeError('fetch failed', {\n                cause: response.error\n            }));\n            return;\n        }\n        // 4. Set responseObject to the result of creating a Response object,\n        // given response, \"immutable\", and relevantRealm.\n        responseObject = new WeakRef(fromInnerResponse(response, 'immutable'));\n        // 5. Resolve p with responseObject.\n        p.resolve(responseObject.deref());\n        p = null;\n    };\n    controller = fetching({\n        request,\n        processResponseEndOfBody: handleFetchDone,\n        processResponse,\n        dispatcher: requestObject[kDispatcher] // undici\n    });\n    // 14. Return p.\n    return p.promise;\n}\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming(response, initiatorType = 'other') {\n    // 1. If response is an aborted network error, then return.\n    if (response.type === 'error' && response.aborted) {\n        return;\n    }\n    // 2. If response’s URL list is null or empty, then return.\n    if (!response.urlList?.length) {\n        return;\n    }\n    // 3. Let originalURL be response’s URL list[0].\n    const originalURL = response.urlList[0];\n    // 4. Let timingInfo be response’s timing info.\n    let timingInfo = response.timingInfo;\n    // 5. Let cacheState be response’s cache state.\n    let cacheState = response.cacheState;\n    // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n    if (!urlIsHttpHttpsScheme(originalURL)) {\n        return;\n    }\n    // 7. If timingInfo is null, then return.\n    if (timingInfo === null) {\n        return;\n    }\n    // 8. If response’s timing allow passed flag is not set, then:\n    if (!response.timingAllowPassed) {\n        //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n        timingInfo = createOpaqueTimingInfo({\n            startTime: timingInfo.startTime\n        });\n        //  2. Set cacheState to the empty string.\n        cacheState = '';\n    }\n    // 9. Set timingInfo’s end time to the coarsened shared current time\n    // given global’s relevant settings object’s cross-origin isolated\n    // capability.\n    // TODO: given global’s relevant settings object’s cross-origin isolated\n    // capability?\n    timingInfo.endTime = coarsenedSharedCurrentTime();\n    // 10. Set response’s timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n    // global, and cacheState.\n    markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);\n}\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming;\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch(p, request, responseObject, error) {\n    // 1. Reject promise with error.\n    if (p) {\n        // We might have already resolved the promise at this stage\n        p.reject(error);\n    }\n    // 2. If request’s body is not null and is readable, then cancel request’s\n    // body with error.\n    if (request.body != null && isReadable(request.body?.stream)) {\n        request.body.stream.cancel(error).catch((err)=>{\n            if (err.code === 'ERR_INVALID_STATE') {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n    // 3. If responseObject is null, then return.\n    if (responseObject == null) {\n        return;\n    }\n    // 4. Let response be responseObject’s response.\n    const response = responseObject[kState];\n    // 5. If response’s body is not null and is readable, then error response’s\n    // body with error.\n    if (response.body != null && isReadable(response.body?.stream)) {\n        response.body.stream.cancel(error).catch((err)=>{\n            if (err.code === 'ERR_INVALID_STATE') {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n}\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching({ request, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher = getGlobalDispatcher() // undici\n }) {\n    // Ensure that the dispatcher is set accordingly\n    assert(dispatcher);\n    // 1. Let taskDestination be null.\n    let taskDestination = null;\n    // 2. Let crossOriginIsolatedCapability be false.\n    let crossOriginIsolatedCapability = false;\n    // 3. If request’s client is non-null, then:\n    if (request.client != null) {\n        // 1. Set taskDestination to request’s client’s global object.\n        taskDestination = request.client.globalObject;\n        // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n        // isolated capability.\n        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n    }\n    // 4. If useParallelQueue is true, then set taskDestination to the result of\n    // starting a new parallel queue.\n    // TODO\n    // 5. Let timingInfo be a new fetch timing info whose start time and\n    // post-redirect start time are the coarsened shared current time given\n    // crossOriginIsolatedCapability.\n    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n    const timingInfo = createOpaqueTimingInfo({\n        startTime: currentTime\n    });\n    // 6. Let fetchParams be a new fetch params whose\n    // request is request,\n    // timing info is timingInfo,\n    // process request body chunk length is processRequestBodyChunkLength,\n    // process request end-of-body is processRequestEndOfBody,\n    // process response is processResponse,\n    // process response consume body is processResponseConsumeBody,\n    // process response end-of-body is processResponseEndOfBody,\n    // task destination is taskDestination,\n    // and cross-origin isolated capability is crossOriginIsolatedCapability.\n    const fetchParams = {\n        controller: new Fetch(dispatcher),\n        request,\n        timingInfo,\n        processRequestBodyChunkLength,\n        processRequestEndOfBody,\n        processResponse,\n        processResponseConsumeBody,\n        processResponseEndOfBody,\n        taskDestination,\n        crossOriginIsolatedCapability\n    };\n    // 7. If request’s body is a byte sequence, then set request’s body to\n    //    request’s body as a body.\n    // NOTE: Since fetching is only called from fetch, body should already be\n    // extracted.\n    assert(!request.body || request.body.stream);\n    // 8. If request’s window is \"client\", then set request’s window to request’s\n    // client, if request’s client’s global object is a Window object; otherwise\n    // \"no-window\".\n    if (request.window === 'client') {\n        // TODO: What if request.client is null?\n        request.window = request.client?.globalObject?.constructor?.name === 'Window' ? request.client : 'no-window';\n    }\n    // 9. If request’s origin is \"client\", then set request’s origin to request’s\n    // client’s origin.\n    if (request.origin === 'client') {\n        request.origin = request.client.origin;\n    }\n    // 10. If all of the following conditions are true:\n    // TODO\n    // 11. If request’s policy container is \"client\", then:\n    if (request.policyContainer === 'client') {\n        // 1. If request’s client is non-null, then set request’s policy\n        // container to a clone of request’s client’s policy container. [HTML]\n        if (request.client != null) {\n            request.policyContainer = clonePolicyContainer(request.client.policyContainer);\n        } else {\n            // 2. Otherwise, set request’s policy container to a new policy\n            // container.\n            request.policyContainer = makePolicyContainer();\n        }\n    }\n    // 12. If request’s header list does not contain `Accept`, then:\n    if (!request.headersList.contains('accept', true)) {\n        // 1. Let value be `*/*`.\n        const value = '*/*';\n        // 2. A user agent should set value to the first matching statement, if\n        // any, switching on request’s destination:\n        // \"document\"\n        // \"frame\"\n        // \"iframe\"\n        // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n        // \"image\"\n        // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n        // \"style\"\n        // `text/css,*/*;q=0.1`\n        // TODO\n        // 3. Append `Accept`/value to request’s header list.\n        request.headersList.append('accept', value, true);\n    }\n    // 13. If request’s header list does not contain `Accept-Language`, then\n    // user agents should append `Accept-Language`/an appropriate value to\n    // request’s header list.\n    if (!request.headersList.contains('accept-language', true)) {\n        request.headersList.append('accept-language', '*', true);\n    }\n    // 14. If request’s priority is null, then use request’s initiator and\n    // destination appropriately in setting request’s priority to a\n    // user-agent-defined object.\n    if (request.priority === null) {\n    // TODO\n    }\n    // 15. If request is a subresource request, then:\n    if (subresourceSet.has(request.destination)) {\n    // TODO\n    }\n    // 16. Run main fetch given fetchParams.\n    mainFetch(fetchParams).catch((err)=>{\n        fetchParams.controller.terminate(err);\n    });\n    // 17. Return fetchParam's controller\n    return fetchParams.controller;\n}\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch(fetchParams, recursive = false) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. If request’s local-URLs-only flag is set and request’s current URL is\n    // not local, then set response to a network error.\n    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n        response = makeNetworkError('local URLs only');\n    }\n    // 4. Run report Content Security Policy violations for request.\n    // TODO\n    // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);\n    // 6. If should request be blocked due to a bad port, should fetching request\n    // be blocked as mixed content, or should request be blocked by Content\n    // Security Policy returns blocked, then set response to a network error.\n    if (requestBadPort(request) === 'blocked') {\n        response = makeNetworkError('bad port');\n    }\n    // TODO: should fetching request be blocked as mixed content?\n    // TODO: should request be blocked by Content Security Policy?\n    // 7. If request’s referrer policy is the empty string, then set request’s\n    // referrer policy to request’s policy container’s referrer policy.\n    if (request.referrerPolicy === '') {\n        request.referrerPolicy = request.policyContainer.referrerPolicy;\n    }\n    // 8. If request’s referrer is not \"no-referrer\", then set request’s\n    // referrer to the result of invoking determine request’s referrer.\n    if (request.referrer !== 'no-referrer') {\n        request.referrer = determineRequestsReferrer(request);\n    }\n    // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n    // conditions are true:\n    // - request’s current URL’s scheme is \"http\"\n    // - request’s current URL’s host is a domain\n    // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n    //   Matching results in either a superdomain match with an asserted\n    //   includeSubDomains directive or a congruent match (with or without an\n    //   asserted includeSubDomains directive). [HSTS]\n    // TODO\n    // 10. If recursive is false, then run the remaining steps in parallel.\n    // TODO\n    // 11. If response is null, then set response to the result of running\n    // the steps corresponding to the first matching statement:\n    if (response === null) {\n        response = await (async ()=>{\n            const currentURL = requestCurrentURL(request);\n            if (// - request’s current URL’s origin is same origin with request’s origin,\n            //   and request’s response tainting is \"basic\"\n            sameOrigin(currentURL, request.url) && request.responseTainting === 'basic' || // request’s current URL’s scheme is \"data\"\n            currentURL.protocol === 'data:' || // - request’s mode is \"navigate\" or \"websocket\"\n            request.mode === 'navigate' || request.mode === 'websocket') {\n                // 1. Set request’s response tainting to \"basic\".\n                request.responseTainting = 'basic';\n                // 2. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // request’s mode is \"same-origin\"\n            if (request.mode === 'same-origin') {\n                // 1. Return a network error.\n                return makeNetworkError('request mode cannot be \"same-origin\"');\n            }\n            // request’s mode is \"no-cors\"\n            if (request.mode === 'no-cors') {\n                // 1. If request’s redirect mode is not \"follow\", then return a network\n                // error.\n                if (request.redirect !== 'follow') {\n                    return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n                }\n                // 2. Set request’s response tainting to \"opaque\".\n                request.responseTainting = 'opaque';\n                // 3. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // request’s current URL’s scheme is not an HTTP(S) scheme\n            if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n                // Return a network error.\n                return makeNetworkError('URL scheme must be a HTTP(S) scheme');\n            }\n            // - request’s use-CORS-preflight flag is set\n            // - request’s unsafe-request flag is set and either request’s method is\n            //   not a CORS-safelisted method or CORS-unsafe request-header names with\n            //   request’s header list is not empty\n            //    1. Set request’s response tainting to \"cors\".\n            //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n            //    given fetchParams and true.\n            //    3. If corsWithPreflightResponse is a network error, then clear cache\n            //    entries using request.\n            //    4. Return corsWithPreflightResponse.\n            // TODO\n            // Otherwise\n            //    1. Set request’s response tainting to \"cors\".\n            request.responseTainting = 'cors';\n            //    2. Return the result of running HTTP fetch given fetchParams.\n            return await httpFetch(fetchParams);\n        })();\n    }\n    // 12. If recursive is true, then return response.\n    if (recursive) {\n        return response;\n    }\n    // 13. If response is not a network error and response is not a filtered\n    // response, then:\n    if (response.status !== 0 && !response.internalResponse) {\n        // If request’s response tainting is \"cors\", then:\n        if (request.responseTainting === 'cors') {\n        // 1. Let headerNames be the result of extracting header list values\n        // given `Access-Control-Expose-Headers` and response’s header list.\n        // TODO\n        // 2. If request’s credentials mode is not \"include\" and headerNames\n        // contains `*`, then set response’s CORS-exposed header-name list to\n        // all unique header names in response’s header list.\n        // TODO\n        // 3. Otherwise, if headerNames is not null or failure, then set\n        // response’s CORS-exposed header-name list to headerNames.\n        // TODO\n        }\n        // Set response to the following filtered response with response as its\n        // internal response, depending on request’s response tainting:\n        if (request.responseTainting === 'basic') {\n            response = filterResponse(response, 'basic');\n        } else if (request.responseTainting === 'cors') {\n            response = filterResponse(response, 'cors');\n        } else if (request.responseTainting === 'opaque') {\n            response = filterResponse(response, 'opaque');\n        } else {\n            assert(false);\n        }\n    }\n    // 14. Let internalResponse be response, if response is a network error,\n    // and response’s internal response otherwise.\n    let internalResponse = response.status === 0 ? response : response.internalResponse;\n    // 15. If internalResponse’s URL list is empty, then set it to a clone of\n    // request’s URL list.\n    if (internalResponse.urlList.length === 0) {\n        internalResponse.urlList.push(...request.urlList);\n    }\n    // 16. If request’s timing allow failed flag is unset, then set\n    // internalResponse’s timing allow passed flag.\n    if (!request.timingAllowFailed) {\n        response.timingAllowPassed = true;\n    }\n    // 17. If response is not a network error and any of the following returns\n    // blocked\n    // - should internalResponse to request be blocked as mixed content\n    // - should internalResponse to request be blocked by Content Security Policy\n    // - should internalResponse to request be blocked due to its MIME type\n    // - should internalResponse to request be blocked due to nosniff\n    // TODO\n    // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n    // internalResponse’s range-requested flag is set, and request’s header\n    // list does not contain `Range`, then set response and internalResponse\n    // to a network error.\n    if (response.type === 'opaque' && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains('range', true)) {\n        response = internalResponse = makeNetworkError();\n    }\n    // 19. If response is not a network error and either request’s method is\n    // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n    // set internalResponse’s body to null and disregard any enqueuing toward\n    // it (if any).\n    if (response.status !== 0 && (request.method === 'HEAD' || request.method === 'CONNECT' || nullBodyStatus.includes(internalResponse.status))) {\n        internalResponse.body = null;\n        fetchParams.controller.dump = true;\n    }\n    // 20. If request’s integrity metadata is not the empty string, then:\n    if (request.integrity) {\n        // 1. Let processBodyError be this step: run fetch finale given fetchParams\n        // and a network error.\n        const processBodyError = (reason)=>fetchFinale(fetchParams, makeNetworkError(reason));\n        // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n        // then run processBodyError and abort these steps.\n        if (request.responseTainting === 'opaque' || response.body == null) {\n            processBodyError(response.error);\n            return;\n        }\n        // 3. Let processBody given bytes be these steps:\n        const processBody = (bytes)=>{\n            // 1. If bytes do not match request’s integrity metadata,\n            // then run processBodyError and abort these steps. [SRI]\n            if (!bytesMatch(bytes, request.integrity)) {\n                processBodyError('integrity mismatch');\n                return;\n            }\n            // 2. Set response’s body to bytes as a body.\n            response.body = safelyExtractBody(bytes)[0];\n            // 3. Run fetch finale given fetchParams and response.\n            fetchFinale(fetchParams, response);\n        };\n        // 4. Fully read response’s body given processBody and processBodyError.\n        await fullyReadBody(response.body, processBody, processBodyError);\n    } else {\n        // 21. Otherwise, run fetch finale given fetchParams and response.\n        fetchFinale(fetchParams, response);\n    }\n}\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch(fetchParams) {\n    // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n    // cancelled state, we do not want this condition to trigger *unless* there have been\n    // no redirects. See https://github.com/nodejs/undici/issues/1776\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n        return Promise.resolve(makeAppropriateNetworkError(fetchParams));\n    }\n    // 2. Let request be fetchParams’s request.\n    const { request } = fetchParams;\n    const { protocol: scheme } = requestCurrentURL(request);\n    // 3. Switch on request’s current URL’s scheme and run the associated steps:\n    switch(scheme){\n        case 'about:':\n            {\n                // If request’s current URL’s path is the string \"blank\", then return a new response\n                // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n                // and body is the empty byte sequence as a body.\n                // Otherwise, return a network error.\n                return Promise.resolve(makeNetworkError('about scheme is not supported'));\n            }\n        case 'blob:':\n            {\n                if (!resolveObjectURL) {\n                    resolveObjectURL = (__webpack_require__(/*! node:buffer */ \"node:buffer\").resolveObjectURL);\n                }\n                // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n                const blobURLEntry = requestCurrentURL(request);\n                // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n                // Buffer.resolveObjectURL does not ignore URL queries.\n                if (blobURLEntry.search.length !== 0) {\n                    return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'));\n                }\n                const blob = resolveObjectURL(blobURLEntry.toString());\n                // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n                //    object is not a Blob object, then return a network error.\n                if (request.method !== 'GET' || !isBlobLike(blob)) {\n                    return Promise.resolve(makeNetworkError('invalid method'));\n                }\n                // 3. Let blob be blobURLEntry’s object.\n                // Note: done above\n                // 4. Let response be a new response.\n                const response = makeResponse();\n                // 5. Let fullLength be blob’s size.\n                const fullLength = blob.size;\n                // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n                const serializedFullLength = isomorphicEncode(`${fullLength}`);\n                // 7. Let type be blob’s type.\n                const type = blob.type;\n                // 8. If request’s header list does not contain `Range`:\n                // 9. Otherwise:\n                if (!request.headersList.contains('range', true)) {\n                    // 1. Let bodyWithType be the result of safely extracting blob.\n                    // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n                    // In node, this can only ever be a Blob. Therefore we can safely\n                    // use extractBody directly.\n                    const bodyWithType = extractBody(blob);\n                    // 2. Set response’s status message to `OK`.\n                    response.statusText = 'OK';\n                    // 3. Set response’s body to bodyWithType’s body.\n                    response.body = bodyWithType[0];\n                    // 4. Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».\n                    response.headersList.set('content-length', serializedFullLength, true);\n                    response.headersList.set('content-type', type, true);\n                } else {\n                    // 1. Set response’s range-requested flag.\n                    response.rangeRequested = true;\n                    // 2. Let rangeHeader be the result of getting `Range` from request’s header list.\n                    const rangeHeader = request.headersList.get('range', true);\n                    // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n                    const rangeValue = simpleRangeHeaderValue(rangeHeader, true);\n                    // 4. If rangeValue is failure, then return a network error.\n                    if (rangeValue === 'failure') {\n                        return Promise.resolve(makeNetworkError('failed to fetch the data URL'));\n                    }\n                    // 5. Let (rangeStart, rangeEnd) be rangeValue.\n                    let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;\n                    // 6. If rangeStart is null:\n                    // 7. Otherwise:\n                    if (rangeStart === null) {\n                        // 1. Set rangeStart to fullLength − rangeEnd.\n                        rangeStart = fullLength - rangeEnd;\n                        // 2. Set rangeEnd to rangeStart + rangeEnd − 1.\n                        rangeEnd = rangeStart + rangeEnd - 1;\n                    } else {\n                        // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n                        if (rangeStart >= fullLength) {\n                            return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'));\n                        }\n                        // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n                        //    rangeEnd to fullLength − 1.\n                        if (rangeEnd === null || rangeEnd >= fullLength) {\n                            rangeEnd = fullLength - 1;\n                        }\n                    }\n                    // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n                    //    rangeEnd + 1, and type.\n                    const slicedBlob = blob.slice(rangeStart, rangeEnd, type);\n                    // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n                    // Note: same reason as mentioned above as to why we use extractBody\n                    const slicedBodyWithType = extractBody(slicedBlob);\n                    // 10. Set response’s body to slicedBodyWithType’s body.\n                    response.body = slicedBodyWithType[0];\n                    // 11. Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.\n                    const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);\n                    // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n                    //     rangeEnd, and fullLength.\n                    const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);\n                    // 13. Set response’s status to 206.\n                    response.status = 206;\n                    // 14. Set response’s status message to `Partial Content`.\n                    response.statusText = 'Partial Content';\n                    // 15. Set response’s header list to « (`Content-Length`, serializedSlicedLength),\n                    //     (`Content-Type`, type), (`Content-Range`, contentRange) ».\n                    response.headersList.set('content-length', serializedSlicedLength, true);\n                    response.headersList.set('content-type', type, true);\n                    response.headersList.set('content-range', contentRange, true);\n                }\n                // 10. Return response.\n                return Promise.resolve(response);\n            }\n        case 'data:':\n            {\n                // 1. Let dataURLStruct be the result of running the\n                //    data: URL processor on request’s current URL.\n                const currentURL = requestCurrentURL(request);\n                const dataURLStruct = dataURLProcessor(currentURL);\n                // 2. If dataURLStruct is failure, then return a\n                //    network error.\n                if (dataURLStruct === 'failure') {\n                    return Promise.resolve(makeNetworkError('failed to fetch the data URL'));\n                }\n                // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n                const mimeType = serializeAMimeType(dataURLStruct.mimeType);\n                // 4. Return a response whose status message is `OK`,\n                //    header list is « (`Content-Type`, mimeType) »,\n                //    and body is dataURLStruct’s body as a body.\n                return Promise.resolve(makeResponse({\n                    statusText: 'OK',\n                    headersList: [\n                        [\n                            'content-type',\n                            {\n                                name: 'Content-Type',\n                                value: mimeType\n                            }\n                        ]\n                    ],\n                    body: safelyExtractBody(dataURLStruct.body)[0]\n                }));\n            }\n        case 'file:':\n            {\n                // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n                // When in doubt, return a network error.\n                return Promise.resolve(makeNetworkError('not implemented... yet...'));\n            }\n        case 'http:':\n        case 'https:':\n            {\n                // Return the result of running HTTP fetch given fetchParams.\n                return httpFetch(fetchParams).catch((err)=>makeNetworkError(err));\n            }\n        default:\n            {\n                return Promise.resolve(makeNetworkError('unknown scheme'));\n            }\n    }\n}\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse(fetchParams, response) {\n    // 1. Set fetchParams’s request’s done flag.\n    fetchParams.request.done = true;\n    // 2, If fetchParams’s process response done is not null, then queue a fetch\n    // task to run fetchParams’s process response done given response, with\n    // fetchParams’s task destination.\n    if (fetchParams.processResponseDone != null) {\n        queueMicrotask(()=>fetchParams.processResponseDone(response));\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale(fetchParams, response) {\n    // 1. Let timingInfo be fetchParams’s timing info.\n    let timingInfo = fetchParams.timingInfo;\n    // 2. If response is not a network error and fetchParams’s request’s client is a secure context,\n    //    then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting\n    //    `Server-Timing` from response’s internal response’s header list.\n    // TODO\n    // 3. Let processResponseEndOfBody be the following steps:\n    const processResponseEndOfBody = ()=>{\n        // 1. Let unsafeEndTime be the unsafe shared current time.\n        const unsafeEndTime = Date.now() // ?\n        ;\n        // 2. If fetchParams’s request’s destination is \"document\", then set fetchParams’s controller’s\n        //    full timing info to fetchParams’s timing info.\n        if (fetchParams.request.destination === 'document') {\n            fetchParams.controller.fullTimingInfo = timingInfo;\n        }\n        // 3. Set fetchParams’s controller’s report timing steps to the following steps given a global object global:\n        fetchParams.controller.reportTimingSteps = ()=>{\n            // 1. If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.\n            if (fetchParams.request.url.protocol !== 'https:') {\n                return;\n            }\n            // 2. Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.\n            timingInfo.endTime = unsafeEndTime;\n            // 3. Let cacheState be response’s cache state.\n            let cacheState = response.cacheState;\n            // 4. Let bodyInfo be response’s body info.\n            const bodyInfo = response.bodyInfo;\n            // 5. If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an\n            //    opaque timing info for timingInfo and set cacheState to the empty string.\n            if (!response.timingAllowPassed) {\n                timingInfo = createOpaqueTimingInfo(timingInfo);\n                cacheState = '';\n            }\n            // 6. Let responseStatus be 0.\n            let responseStatus = 0;\n            // 7. If fetchParams’s request’s mode is not \"navigate\" or response’s has-cross-origin-redirects is false:\n            if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n                // 1. Set responseStatus to response’s status.\n                responseStatus = response.status;\n                // 2. Let mimeType be the result of extracting a MIME type from response’s header list.\n                const mimeType = extractMimeType(response.headersList);\n                // 3. If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.\n                if (mimeType !== 'failure') {\n                    bodyInfo.contentType = minimizeSupportedMimeType(mimeType);\n                }\n            }\n            // 8. If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo,\n            //    fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo,\n            //    and responseStatus.\n            if (fetchParams.request.initiatorType != null) {\n                // TODO: update markresourcetiming\n                markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);\n            }\n        };\n        // 4. Let processResponseEndOfBodyTask be the following steps:\n        const processResponseEndOfBodyTask = ()=>{\n            // 1. Set fetchParams’s request’s done flag.\n            fetchParams.request.done = true;\n            // 2. If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process\n            //    response end-of-body given response.\n            if (fetchParams.processResponseEndOfBody != null) {\n                queueMicrotask(()=>fetchParams.processResponseEndOfBody(response));\n            }\n            // 3. If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s\n            //    global object is fetchParams’s task destination, then run fetchParams’s controller’s report\n            //    timing steps given fetchParams’s request’s client’s global object.\n            if (fetchParams.request.initiatorType != null) {\n                fetchParams.controller.reportTimingSteps();\n            }\n        };\n        // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination\n        queueMicrotask(()=>processResponseEndOfBodyTask());\n    };\n    // 4. If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s\n    //    process response given response, with fetchParams’s task destination.\n    if (fetchParams.processResponse != null) {\n        queueMicrotask(()=>{\n            fetchParams.processResponse(response);\n            fetchParams.processResponse = null;\n        });\n    }\n    // 5. Let internalResponse be response, if response is a network error; otherwise response’s internal response.\n    const internalResponse = response.type === 'error' ? response : response.internalResponse ?? response;\n    // 6. If internalResponse’s body is null, then run processResponseEndOfBody.\n    // 7. Otherwise:\n    if (internalResponse.body == null) {\n        processResponseEndOfBody();\n    } else {\n        // mcollina: all the following steps of the specs are skipped.\n        // The internal transform stream is not needed.\n        // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n        // 1. Let transformStream be a new TransformStream.\n        // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n        // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n        //    set to processResponseEndOfBody.\n        // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.\n        finished(internalResponse.body.stream, ()=>{\n            processResponseEndOfBody();\n        });\n    }\n}\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch(fetchParams) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let actualResponse be null.\n    let actualResponse = null;\n    // 4. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 5. If request’s service-workers mode is \"all\", then:\n    if (request.serviceWorkers === 'all') {\n    // TODO\n    }\n    // 6. If response is null, then:\n    if (response === null) {\n        // 1. If makeCORSPreflight is true and one of these conditions is true:\n        // TODO\n        // 2. If request’s redirect mode is \"follow\", then set request’s\n        // service-workers mode to \"none\".\n        if (request.redirect === 'follow') {\n            request.serviceWorkers = 'none';\n        }\n        // 3. Set response and actualResponse to the result of running\n        // HTTP-network-or-cache fetch given fetchParams.\n        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);\n        // 4. If request’s response tainting is \"cors\" and a CORS check\n        // for request and response returns failure, then return a network error.\n        if (request.responseTainting === 'cors' && corsCheck(request, response) === 'failure') {\n            return makeNetworkError('cors failure');\n        }\n        // 5. If the TAO check for request and response returns failure, then set\n        // request’s timing allow failed flag.\n        if (TAOCheck(request, response) === 'failure') {\n            request.timingAllowFailed = true;\n        }\n    }\n    // 7. If either request’s response tainting or response’s type\n    // is \"opaque\", and the cross-origin resource policy check with\n    // request’s origin, request’s client, request’s destination,\n    // and actualResponse returns blocked, then return a network error.\n    if ((request.responseTainting === 'opaque' || response.type === 'opaque') && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === 'blocked') {\n        return makeNetworkError('blocked');\n    }\n    // 8. If actualResponse’s status is a redirect status, then:\n    if (redirectStatusSet.has(actualResponse.status)) {\n        // 1. If actualResponse’s status is not 303, request’s body is not null,\n        // and the connection uses HTTP/2, then user agents may, and are even\n        // encouraged to, transmit an RST_STREAM frame.\n        // See, https://github.com/whatwg/fetch/issues/1288\n        if (request.redirect !== 'manual') {\n            fetchParams.controller.connection.destroy(undefined, false);\n        }\n        // 2. Switch on request’s redirect mode:\n        if (request.redirect === 'error') {\n            // Set response to a network error.\n            response = makeNetworkError('unexpected redirect');\n        } else if (request.redirect === 'manual') {\n            // Set response to an opaque-redirect filtered response whose internal\n            // response is actualResponse.\n            // NOTE(spec): On the web this would return an `opaqueredirect` response,\n            // but that doesn't make sense server side.\n            // See https://github.com/nodejs/undici/issues/1193.\n            response = actualResponse;\n        } else if (request.redirect === 'follow') {\n            // Set response to the result of running HTTP-redirect fetch given\n            // fetchParams and response.\n            response = await httpRedirectFetch(fetchParams, response);\n        } else {\n            assert(false);\n        }\n    }\n    // 9. Set response’s timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 10. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch(fetchParams, response) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let actualResponse be response, if response is not a filtered response,\n    // and response’s internal response otherwise.\n    const actualResponse = response.internalResponse ? response.internalResponse : response;\n    // 3. Let locationURL be actualResponse’s location URL given request’s current\n    // URL’s fragment.\n    let locationURL;\n    try {\n        locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);\n        // 4. If locationURL is null, then return response.\n        if (locationURL == null) {\n            return response;\n        }\n    } catch (err) {\n        // 5. If locationURL is failure, then return a network error.\n        return Promise.resolve(makeNetworkError(err));\n    }\n    // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n    // error.\n    if (!urlIsHttpHttpsScheme(locationURL)) {\n        return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'));\n    }\n    // 7. If request’s redirect count is 20, then return a network error.\n    if (request.redirectCount === 20) {\n        return Promise.resolve(makeNetworkError('redirect count exceeded'));\n    }\n    // 8. Increase request’s redirect count by 1.\n    request.redirectCount += 1;\n    // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n    // request’s origin is not same origin with locationURL’s origin, then return\n    //  a network error.\n    if (request.mode === 'cors' && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {\n        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'));\n    }\n    // 10. If request’s response tainting is \"cors\" and locationURL includes\n    // credentials, then return a network error.\n    if (request.responseTainting === 'cors' && (locationURL.username || locationURL.password)) {\n        return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode \"cors\"'));\n    }\n    // 11. If actualResponse’s status is not 303, request’s body is non-null,\n    // and request’s body’s source is null, then return a network error.\n    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {\n        return Promise.resolve(makeNetworkError());\n    }\n    // 12. If one of the following is true\n    // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n    // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n    if ([\n        301,\n        302\n    ].includes(actualResponse.status) && request.method === 'POST' || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {\n        // then:\n        // 1. Set request’s method to `GET` and request’s body to null.\n        request.method = 'GET';\n        request.body = null;\n        // 2. For each headerName of request-body-header name, delete headerName from\n        // request’s header list.\n        for (const headerName of requestBodyHeader){\n            request.headersList.delete(headerName);\n        }\n    }\n    // 13. If request’s current URL’s origin is not same origin with locationURL’s\n    //     origin, then for each headerName of CORS non-wildcard request-header name,\n    //     delete headerName from request’s header list.\n    if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n        // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n        request.headersList.delete('authorization', true);\n        // https://fetch.spec.whatwg.org/#authentication-entries\n        request.headersList.delete('proxy-authorization', true);\n        // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n        request.headersList.delete('cookie', true);\n        request.headersList.delete('host', true);\n    }\n    // 14. If request’s body is non-null, then set request’s body to the first return\n    // value of safely extracting request’s body’s source.\n    if (request.body != null) {\n        assert(request.body.source != null);\n        request.body = safelyExtractBody(request.body.source)[0];\n    }\n    // 15. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n    // coarsened shared current time given fetchParams’s cross-origin isolated\n    // capability.\n    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n    // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n    //  redirect start time to timingInfo’s start time.\n    if (timingInfo.redirectStartTime === 0) {\n        timingInfo.redirectStartTime = timingInfo.startTime;\n    }\n    // 18. Append locationURL to request’s URL list.\n    request.urlList.push(locationURL);\n    // 19. Invoke set request’s referrer policy on redirect on request and\n    // actualResponse.\n    setRequestReferrerPolicyOnRedirect(request, actualResponse);\n    // 20. Return the result of running main fetch given fetchParams and true.\n    return mainFetch(fetchParams, true);\n}\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let httpFetchParams be null.\n    let httpFetchParams = null;\n    // 3. Let httpRequest be null.\n    let httpRequest = null;\n    // 4. Let response be null.\n    let response = null;\n    // 5. Let storedResponse be null.\n    // TODO: cache\n    // 6. Let httpCache be null.\n    const httpCache = null;\n    // 7. Let the revalidatingFlag be unset.\n    const revalidatingFlag = false;\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If request’s window is \"no-window\" and request’s redirect mode is\n    //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n    //    request.\n    if (request.window === 'no-window' && request.redirect === 'error') {\n        httpFetchParams = fetchParams;\n        httpRequest = request;\n    } else {\n        // Otherwise:\n        // 1. Set httpRequest to a clone of request.\n        httpRequest = cloneRequest(request);\n        // 2. Set httpFetchParams to a copy of fetchParams.\n        httpFetchParams = {\n            ...fetchParams\n        };\n        // 3. Set httpFetchParams’s request to httpRequest.\n        httpFetchParams.request = httpRequest;\n    }\n    //    3. Let includeCredentials be true if one of\n    const includeCredentials = request.credentials === 'include' || request.credentials === 'same-origin' && request.responseTainting === 'basic';\n    //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n    //    body is non-null; otherwise null.\n    const contentLength = httpRequest.body ? httpRequest.body.length : null;\n    //    5. Let contentLengthHeaderValue be null.\n    let contentLengthHeaderValue = null;\n    //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n    //    `PUT`, then set contentLengthHeaderValue to `0`.\n    if (httpRequest.body == null && [\n        'POST',\n        'PUT'\n    ].includes(httpRequest.method)) {\n        contentLengthHeaderValue = '0';\n    }\n    //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n    //    contentLength, serialized and isomorphic encoded.\n    if (contentLength != null) {\n        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);\n    }\n    //    8. If contentLengthHeaderValue is non-null, then append\n    //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n    //    list.\n    if (contentLengthHeaderValue != null) {\n        httpRequest.headersList.append('content-length', contentLengthHeaderValue, true);\n    }\n    //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n    //    contentLengthHeaderValue) to httpRequest’s header list.\n    //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n    //    then:\n    if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n    }\n    //    11. If httpRequest’s referrer is a URL, then append\n    //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n    //     to httpRequest’s header list.\n    if (httpRequest.referrer instanceof URL) {\n        httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true);\n    }\n    //    12. Append a request `Origin` header for httpRequest.\n    appendRequestOriginHeader(httpRequest);\n    //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n    appendFetchMetadata(httpRequest);\n    //    14. If httpRequest’s header list does not contain `User-Agent`, then\n    //    user agents should append `User-Agent`/default `User-Agent` value to\n    //    httpRequest’s header list.\n    if (!httpRequest.headersList.contains('user-agent', true)) {\n        httpRequest.headersList.append('user-agent', defaultUserAgent);\n    }\n    //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n    //    list contains `If-Modified-Since`, `If-None-Match`,\n    //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n    //    httpRequest’s cache mode to \"no-store\".\n    if (httpRequest.cache === 'default' && (httpRequest.headersList.contains('if-modified-since', true) || httpRequest.headersList.contains('if-none-match', true) || httpRequest.headersList.contains('if-unmodified-since', true) || httpRequest.headersList.contains('if-match', true) || httpRequest.headersList.contains('if-range', true))) {\n        httpRequest.cache = 'no-store';\n    }\n    //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n    //    no-cache cache-control header modification flag is unset, and\n    //    httpRequest’s header list does not contain `Cache-Control`, then append\n    //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n    if (httpRequest.cache === 'no-cache' && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains('cache-control', true)) {\n        httpRequest.headersList.append('cache-control', 'max-age=0', true);\n    }\n    //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n    if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n        // 1. If httpRequest’s header list does not contain `Pragma`, then append\n        // `Pragma`/`no-cache` to httpRequest’s header list.\n        if (!httpRequest.headersList.contains('pragma', true)) {\n            httpRequest.headersList.append('pragma', 'no-cache', true);\n        }\n        // 2. If httpRequest’s header list does not contain `Cache-Control`,\n        // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n        if (!httpRequest.headersList.contains('cache-control', true)) {\n            httpRequest.headersList.append('cache-control', 'no-cache', true);\n        }\n    }\n    //    18. If httpRequest’s header list contains `Range`, then append\n    //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n    if (httpRequest.headersList.contains('range', true)) {\n        httpRequest.headersList.append('accept-encoding', 'identity', true);\n    }\n    //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n    //    header if httpRequest’s header list contains that header’s name.\n    //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n    if (!httpRequest.headersList.contains('accept-encoding', true)) {\n        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n            httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true);\n        } else {\n            httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true);\n        }\n    }\n    httpRequest.headersList.delete('host', true);\n    //    20. If includeCredentials is true, then:\n    if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n    }\n    //    21. If there’s a proxy-authentication entry, use it as appropriate.\n    //    TODO: proxy-authentication\n    //    22. Set httpCache to the result of determining the HTTP cache\n    //    partition, given httpRequest.\n    //    TODO: cache\n    //    23. If httpCache is null, then set httpRequest’s cache mode to\n    //    \"no-store\".\n    if (httpCache == null) {\n        httpRequest.cache = 'no-store';\n    }\n    //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n    //    then:\n    if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n    }\n    // 9. If aborted, then return the appropriate network error for fetchParams.\n    // TODO\n    // 10. If response is null, then:\n    if (response == null) {\n        // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n        // network error.\n        if (httpRequest.cache === 'only-if-cached') {\n            return makeNetworkError('only if cached');\n        }\n        // 2. Let forwardResponse be the result of running HTTP-network fetch\n        // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n        const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);\n        // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n        // in the range 200 to 399, inclusive, invalidate appropriate stored\n        // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n        // Caching, and set storedResponse to null. [HTTP-CACHING]\n        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {\n        // TODO: cache\n        }\n        // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n        // then:\n        if (revalidatingFlag && forwardResponse.status === 304) {\n        // TODO: cache\n        }\n        // 5. If response is null, then:\n        if (response == null) {\n            // 1. Set response to forwardResponse.\n            response = forwardResponse;\n        // 2. Store httpRequest and forwardResponse in httpCache, as per the\n        // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n        // TODO: cache\n        }\n    }\n    // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n    response.urlList = [\n        ...httpRequest.urlList\n    ];\n    // 12. If httpRequest’s header list contains `Range`, then set response’s\n    // range-requested flag.\n    if (httpRequest.headersList.contains('range', true)) {\n        response.rangeRequested = true;\n    }\n    // 13. Set response’s request-includes-credentials to includeCredentials.\n    response.requestIncludesCredentials = includeCredentials;\n    // 14. If response’s status is 401, httpRequest’s response tainting is not\n    // \"cors\", includeCredentials is true, and request’s window is an environment\n    // settings object, then:\n    // TODO\n    // 15. If response’s status is 407, then:\n    if (response.status === 407) {\n        // 1. If request’s window is \"no-window\", then return a network error.\n        if (request.window === 'no-window') {\n            return makeNetworkError();\n        }\n        // 2. ???\n        // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 4. Prompt the end user as appropriate in request’s window and store\n        // the result as a proxy-authentication entry. [HTTP-AUTH]\n        // TODO: Invoke some kind of callback?\n        // 5. Set response to the result of running HTTP-network-or-cache fetch given\n        // fetchParams.\n        // TODO\n        return makeNetworkError('proxy authentication required');\n    }\n    // 16. If all of the following are true\n    if (// response’s status is 421\n    response.status === 421 && // isNewConnectionFetch is false\n    !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)) {\n        // then:\n        // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 2. Set response to the result of running HTTP-network-or-cache\n        // fetch given fetchParams, isAuthenticationFetch, and true.\n        // TODO (spec): The spec doesn't specify this but we need to cancel\n        // the active response before we can start a new one.\n        // https://github.com/whatwg/fetch/issues/1293\n        fetchParams.controller.connection.destroy();\n        response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);\n    }\n    // 17. If isAuthenticationFetch is true, then create an authentication entry\n    if (isAuthenticationFetch) {\n    // TODO\n    }\n    // 18. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n    fetchParams.controller.connection = {\n        abort: null,\n        destroyed: false,\n        destroy (err, abort = true) {\n            if (!this.destroyed) {\n                this.destroyed = true;\n                if (abort) {\n                    this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'));\n                }\n            }\n        }\n    };\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null;\n    // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n    if (httpCache == null) {\n        request.cache = 'no-store';\n    }\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n    // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n    // \"no\".\n    const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n    ;\n    // 8. Switch on request’s mode:\n    if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n    } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n    }\n    // 9. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If connection is failure, then return a network error.\n    //    2. Set timingInfo’s final connection timing info to the result of\n    //    calling clamp and coarsen connection timing info with connection’s\n    //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n    //    cross-origin isolated capability.\n    //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n    //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n    //    `chunked`) to request’s header list.\n    //    4. Set timingInfo’s final network-request start time to the coarsened\n    //    shared current time given fetchParams’s cross-origin isolated\n    //    capability.\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n    //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n    //        - If request’s body is non-null, and request’s body’s source is null,\n    //        then the user agent may have a buffer of up to 64 kibibytes and store\n    //        a part of request’s body in that buffer. If the user agent reads from\n    //        request’s body beyond that buffer’s size and the user agent needs to\n    //        resend request, then instead return a network error.\n    //        - Set timingInfo’s final network-response start time to the coarsened\n    //        shared current time given fetchParams’s cross-origin isolated capability,\n    //        immediately after the user agent’s HTTP parser receives the first byte\n    //        of the response (e.g., frame header bytes for HTTP/2 or response status\n    //        line for HTTP/1.x).\n    //        - Wait until all the headers are transmitted.\n    //        - Any responses whose status is in the range 100 to 199, inclusive,\n    //        and is not 101, are to be ignored, except for the purposes of setting\n    //        timingInfo’s final network-response start time above.\n    //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n    //    - If the HTTP request results in a TLS client certificate dialog, then:\n    //        1. If request’s window is an environment settings object, make the\n    //        dialog available in request’s window.\n    //        2. Otherwise, return a network error.\n    // To transmit request’s body body, run these steps:\n    let requestBody = null;\n    // 1. If body is null and fetchParams’s process request end-of-body is\n    // non-null, then queue a fetch task given fetchParams’s process request\n    // end-of-body and fetchParams’s task destination.\n    if (request.body == null && fetchParams.processRequestEndOfBody) {\n        queueMicrotask(()=>fetchParams.processRequestEndOfBody());\n    } else if (request.body != null) {\n        // 2. Otherwise, if body is non-null:\n        //    1. Let processBodyChunk given bytes be these steps:\n        const processBodyChunk = async function*(bytes) {\n            // 1. If the ongoing fetch is terminated, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. Run this step in parallel: transmit bytes.\n            yield bytes;\n            // 3. If fetchParams’s process request body is non-null, then run\n            // fetchParams’s process request body given bytes’s length.\n            fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);\n        };\n        // 2. Let processEndOfBody be these steps:\n        const processEndOfBody = ()=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If fetchParams’s process request end-of-body is non-null,\n            // then run fetchParams’s process request end-of-body.\n            if (fetchParams.processRequestEndOfBody) {\n                fetchParams.processRequestEndOfBody();\n            }\n        };\n        // 3. Let processBodyError given e be these steps:\n        const processBodyError = (e)=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n            if (e.name === 'AbortError') {\n                fetchParams.controller.abort();\n            } else {\n                fetchParams.controller.terminate(e);\n            }\n        };\n        // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n        // processBodyError, and fetchParams’s task destination.\n        requestBody = async function*() {\n            try {\n                for await (const bytes of request.body.stream){\n                    yield* processBodyChunk(bytes);\n                }\n                processEndOfBody();\n            } catch (err) {\n                processBodyError(err);\n            }\n        }();\n    }\n    try {\n        // socket is only provided for websockets\n        const { body, status, statusText, headersList, socket } = await dispatch({\n            body: requestBody\n        });\n        if (socket) {\n            response = makeResponse({\n                status,\n                statusText,\n                headersList,\n                socket\n            });\n        } else {\n            const iterator = body[Symbol.asyncIterator]();\n            fetchParams.controller.next = ()=>iterator.next();\n            response = makeResponse({\n                status,\n                statusText,\n                headersList\n            });\n        }\n    } catch (err) {\n        // 10. If aborted, then:\n        if (err.name === 'AbortError') {\n            // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n            fetchParams.controller.connection.destroy();\n            // 2. Return the appropriate network error for fetchParams.\n            return makeAppropriateNetworkError(fetchParams, err);\n        }\n        return makeNetworkError(err);\n    }\n    // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    const pullAlgorithm = async ()=>{\n        await fetchParams.controller.resume();\n    };\n    // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n    // controller with reason, given reason.\n    const cancelAlgorithm = (reason)=>{\n        // If the aborted fetch was already terminated, then we do not\n        // need to do anything.\n        if (!isCancelled(fetchParams)) {\n            fetchParams.controller.abort(reason);\n        }\n    };\n    // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    // TODO\n    // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n    // 15. Let stream be a new ReadableStream.\n    // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n    //     cancelAlgorithm set to cancelAlgorithm.\n    const stream = new ReadableStream({\n        async start (controller) {\n            fetchParams.controller.controller = controller;\n        },\n        async pull (controller) {\n            await pullAlgorithm(controller);\n        },\n        async cancel (reason) {\n            await cancelAlgorithm(reason);\n        },\n        type: 'bytes'\n    });\n    // 17. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. Set response’s body to a new body whose stream is stream.\n    response.body = {\n        stream,\n        source: null,\n        length: null\n    };\n    //    2. If response is not a network error and request’s cache mode is\n    //    not \"no-store\", then update response in httpCache for request.\n    //    TODO\n    //    3. If includeCredentials is true and the user agent is not configured\n    //    to block cookies for request (see section 7 of [COOKIES]), then run the\n    //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n    //    the value of each header whose name is a byte-case-insensitive match for\n    //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n    //    TODO\n    // 18. If aborted, then:\n    // TODO\n    // 19. Run these steps in parallel:\n    //    1. Run these steps, but abort when fetchParams is canceled:\n    fetchParams.controller.onAborted = onAborted;\n    fetchParams.controller.on('terminated', onAborted);\n    fetchParams.controller.resume = async ()=>{\n        // 1. While true\n        while(true){\n            // 1-3. See onData...\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes;\n            let isFailure;\n            try {\n                const { done, value } = await fetchParams.controller.next();\n                if (isAborted(fetchParams)) {\n                    break;\n                }\n                bytes = done ? undefined : value;\n            } catch (err) {\n                if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n                    // zlib doesn't like empty streams.\n                    bytes = undefined;\n                } else {\n                    bytes = err;\n                    // err may be propagated from the result of calling readablestream.cancel,\n                    // which might not be an error. https://github.com/nodejs/undici/issues/2009\n                    isFailure = true;\n                }\n            }\n            if (bytes === undefined) {\n                // 2. Otherwise, if the bytes transmission for response’s message\n                // body is done normally and stream is readable, then close\n                // stream, finalize response for fetchParams and response, and\n                // abort these in-parallel steps.\n                readableStreamClose(fetchParams.controller.controller);\n                finalizeResponse(fetchParams, response);\n                return;\n            }\n            // 5. Increase timingInfo’s decoded body size by bytes’s length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0;\n            // 6. If bytes is failure, then terminate fetchParams’s controller.\n            if (isFailure) {\n                fetchParams.controller.terminate(bytes);\n                return;\n            }\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            const buffer = new Uint8Array(bytes);\n            if (buffer.byteLength) {\n                fetchParams.controller.controller.enqueue(buffer);\n            }\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if (isErrored(stream)) {\n                fetchParams.controller.terminate();\n                return;\n            }\n            // 9. If stream doesn’t need more data ask the user agent to suspend\n            // the ongoing fetch.\n            if (fetchParams.controller.controller.desiredSize <= 0) {\n                return;\n            }\n        }\n    };\n    //    2. If aborted, then:\n    function onAborted(reason) {\n        // 2. If fetchParams is aborted, then:\n        if (isAborted(fetchParams)) {\n            // 1. Set response’s aborted flag.\n            response.aborted = true;\n            // 2. If stream is readable, then error stream with the result of\n            //    deserialize a serialized abort reason given fetchParams’s\n            //    controller’s serialized abort reason and an\n            //    implementation-defined realm.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);\n            }\n        } else {\n            // 3. Otherwise, if stream is readable, error stream with a TypeError.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(new TypeError('terminated', {\n                    cause: isErrorLike(reason) ? reason : undefined\n                }));\n            }\n        }\n        // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n        // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n        fetchParams.controller.connection.destroy();\n    }\n    // 20. Return response.\n    return response;\n    function dispatch({ body }) {\n        const url = requestCurrentURL(request);\n        /** @type {import('../..').Agent} */ const agent = fetchParams.controller.dispatcher;\n        return new Promise((resolve, reject)=>agent.dispatch({\n                path: url.pathname + url.search,\n                origin: url.origin,\n                method: request.method,\n                body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n                headers: request.headersList.entries,\n                maxRedirections: 0,\n                upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n            }, {\n                body: null,\n                abort: null,\n                onConnect (abort) {\n                    // TODO (fix): Do we need connection here?\n                    const { connection } = fetchParams.controller;\n                    // Set timingInfo’s final connection timing info to the result of calling clamp and coarsen\n                    // connection timing info with connection’s timing info, timingInfo’s post-redirect start\n                    // time, and fetchParams’s cross-origin isolated capability.\n                    // TODO: implement connection timing\n                    timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);\n                    if (connection.destroyed) {\n                        abort(new DOMException('The operation was aborted.', 'AbortError'));\n                    } else {\n                        fetchParams.controller.on('terminated', abort);\n                        this.abort = connection.abort = abort;\n                    }\n                    // Set timingInfo’s final network-request start time to the coarsened shared current time given\n                    // fetchParams’s cross-origin isolated capability.\n                    timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n                },\n                onResponseStarted () {\n                    // Set timingInfo’s final network-response start time to the coarsened shared current\n                    // time given fetchParams’s cross-origin isolated capability, immediately after the\n                    // user agent’s HTTP parser receives the first byte of the response (e.g., frame header\n                    // bytes for HTTP/2 or response status line for HTTP/1.x).\n                    timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n                },\n                onHeaders (status, rawHeaders, resume, statusText) {\n                    if (status < 200) {\n                        return;\n                    }\n                    /** @type {string[]} */ let codings = [];\n                    let location = '';\n                    const headersList = new HeadersList();\n                    for(let i = 0; i < rawHeaders.length; i += 2){\n                        headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true);\n                    }\n                    const contentEncoding = headersList.get('content-encoding', true);\n                    if (contentEncoding) {\n                        // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                        // \"All content-coding values are case-insensitive...\"\n                        codings = contentEncoding.toLowerCase().split(',').map((x)=>x.trim());\n                    }\n                    location = headersList.get('location', true);\n                    this.body = new Readable({\n                        read: resume\n                    });\n                    const decoders = [];\n                    const willFollow = location && request.redirect === 'follow' && redirectStatusSet.has(status);\n                    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n                    if (codings.length !== 0 && request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n                        for(let i = 0; i < codings.length; ++i){\n                            const coding = codings[i];\n                            // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n                            if (coding === 'x-gzip' || coding === 'gzip') {\n                                decoders.push(zlib.createGunzip({\n                                    // Be less strict when decoding compressed responses, since sometimes\n                                    // servers send slightly invalid responses that are still accepted\n                                    // by common browsers.\n                                    // Always using Z_SYNC_FLUSH is what cURL does.\n                                    flush: zlib.constants.Z_SYNC_FLUSH,\n                                    finishFlush: zlib.constants.Z_SYNC_FLUSH\n                                }));\n                            } else if (coding === 'deflate') {\n                                decoders.push(createInflate());\n                            } else if (coding === 'br') {\n                                decoders.push(zlib.createBrotliDecompress());\n                            } else {\n                                decoders.length = 0;\n                                break;\n                            }\n                        }\n                    }\n                    resolve({\n                        status,\n                        statusText,\n                        headersList,\n                        body: decoders.length ? pipeline(this.body, ...decoders, ()=>{}) : this.body.on('error', ()=>{})\n                    });\n                    return true;\n                },\n                onData (chunk) {\n                    if (fetchParams.controller.dump) {\n                        return;\n                    }\n                    // 1. If one or more bytes have been transmitted from response’s\n                    // message body, then:\n                    //  1. Let bytes be the transmitted bytes.\n                    const bytes = chunk;\n                    //  2. Let codings be the result of extracting header list values\n                    //  given `Content-Encoding` and response’s header list.\n                    //  See pullAlgorithm.\n                    //  3. Increase timingInfo’s encoded body size by bytes’s length.\n                    timingInfo.encodedBodySize += bytes.byteLength;\n                    //  4. See pullAlgorithm...\n                    return this.body.push(bytes);\n                },\n                onComplete () {\n                    if (this.abort) {\n                        fetchParams.controller.off('terminated', this.abort);\n                    }\n                    if (fetchParams.controller.onAborted) {\n                        fetchParams.controller.off('terminated', fetchParams.controller.onAborted);\n                    }\n                    fetchParams.controller.ended = true;\n                    this.body.push(null);\n                },\n                onError (error) {\n                    if (this.abort) {\n                        fetchParams.controller.off('terminated', this.abort);\n                    }\n                    this.body?.destroy(error);\n                    fetchParams.controller.terminate(error);\n                    reject(error);\n                },\n                onUpgrade (status, rawHeaders, socket) {\n                    if (status !== 101) {\n                        return;\n                    }\n                    const headersList = new HeadersList();\n                    for(let i = 0; i < rawHeaders.length; i += 2){\n                        headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true);\n                    }\n                    resolve({\n                        status,\n                        statusText: STATUS_CODES[status],\n                        headersList,\n                        socket\n                    });\n                    return true;\n                }\n            }));\n    }\n}\nmodule.exports = {\n    fetch,\n    Fetch,\n    fetching,\n    finalizeAndReportTiming\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaURBQWlEO0FBRWpEO0FBRUEsTUFBTSxFQUNKQSxnQkFBZ0IsRUFDaEJDLDJCQUEyQixFQUMzQkMsY0FBYyxFQUNkQyxZQUFZLEVBQ1pDLGlCQUFpQixFQUNsQixHQUFHQyxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN4QixNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyx1RUFBVztBQUMzQyxNQUFNLEVBQUVFLE9BQU8sRUFBRUMsWUFBWSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDLHVFQUFXO0FBQ3JELE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDLDRCQUFXO0FBQ2hDLE1BQU0sRUFDSkssVUFBVSxFQUNWQyxtQkFBbUIsRUFDbkJDLG9CQUFvQixFQUNwQkMsY0FBYyxFQUNkQyxRQUFRLEVBQ1JDLHlCQUF5QixFQUN6QkMsbUJBQW1CLEVBQ25CQyxpQkFBaUIsRUFDakJDLGtDQUFrQyxFQUNsQ0MsNkNBQTZDLEVBQzdDQyxzQkFBc0IsRUFDdEJDLG1CQUFtQixFQUNuQkMsU0FBUyxFQUNUQyw4QkFBOEIsRUFDOUJDLHlCQUF5QixFQUN6QkMsMEJBQTBCLEVBQzFCQyxxQkFBcUIsRUFDckJDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVEMsV0FBVyxFQUNYQyxhQUFhLEVBQ2JDLG1CQUFtQixFQUNuQkMsZ0JBQWdCLEVBQ2hCQyxVQUFVLEVBQ1ZDLG9CQUFvQixFQUNwQkMsaUJBQWlCLEVBQ2pCQyxtQ0FBbUMsRUFDbkNDLHNCQUFzQixFQUN0QkMsaUJBQWlCLEVBQ2pCQyxhQUFhLEVBQ2JDLGVBQWUsRUFDaEIsR0FBR3JDLG1CQUFPQSxDQUFDLGlFQUFRO0FBQ3BCLE1BQU0sRUFBRXNDLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUd2QyxtQkFBT0EsQ0FBQyx1RUFBVztBQUNuRCxNQUFNd0MsU0FB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QkFDakI7Z0JBRUFvSixTQUFTOU8sS0FBSztvQkFDWixJQUFJLElBQUksQ0FBQ0QsS0FBSyxFQUFFO3dCQUNkaUUsWUFBWXJDLFVBQVUsQ0FBQ2tOLEdBQUcsQ0FBQyxjQUFjLElBQUksQ0FBQzlPLEtBQUs7b0JBQ3JEO29CQUVBLElBQUksQ0FBQ29ELElBQUksRUFBRXRELFFBQVFHO29CQUVuQmdFLFlBQVlyQyxVQUFVLENBQUNoQyxTQUFTLENBQUNLO29CQUVqQ2UsT0FBT2Y7Z0JBQ1Q7Z0JBRUErTyxXQUFXdkosTUFBTSxFQUFFOEgsVUFBVSxFQUFFbkMsTUFBTTtvQkFDbkMsSUFBSTNGLFdBQVcsS0FBSzt3QkFDbEI7b0JBQ0Y7b0JBRUEsTUFBTXBCLGNBQWMsSUFBSWhKO29CQUV4QixJQUFLLElBQUlxUyxJQUFJLEdBQUdBLElBQUlILFdBQVc5SyxNQUFNLEVBQUVpTCxLQUFLLEVBQUc7d0JBQzdDckosWUFBWUcsTUFBTSxDQUFDN0YsNkJBQTZCNE8sVUFBVSxDQUFDRyxFQUFFLEdBQUdILFVBQVUsQ0FBQ0csSUFBSSxFQUFFLENBQUM5RyxRQUFRLENBQUMsV0FBVztvQkFDeEc7b0JBRUF4RSxRQUFRO3dCQUNOcUQ7d0JBQ0F3QixZQUFZaEksWUFBWSxDQUFDd0csT0FBTzt3QkFDaENwQjt3QkFDQStHO29CQUNGO29CQUVBLE9BQU87Z0JBQ1Q7WUFDRjtJQUVKO0FBQ0Y7QUFFQTZELE9BQU9DLE9BQU8sR0FBRztJQUNmM087SUFDQWhCO0lBQ0E4QztJQUNBL0I7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRXRoYW4tQXJyb3dvb2QvdW5kaWNpLWZldGNoXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIG1ha2VOZXR3b3JrRXJyb3IsXG4gIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcixcbiAgZmlsdGVyUmVzcG9uc2UsXG4gIG1ha2VSZXNwb25zZSxcbiAgZnJvbUlubmVyUmVzcG9uc2Vcbn0gPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbmNvbnN0IHsgSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IFJlcXVlc3QsIGNsb25lUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi9yZXF1ZXN0JylcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCdub2RlOnpsaWInKVxuY29uc3Qge1xuICBieXRlc01hdGNoLFxuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBjbG9uZVBvbGljeUNvbnRhaW5lcixcbiAgcmVxdWVzdEJhZFBvcnQsXG4gIFRBT0NoZWNrLFxuICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyLFxuICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICByZXF1ZXN0Q3VycmVudFVSTCxcbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCxcbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMLFxuICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICBhcHBlbmRGZXRjaE1ldGFkYXRhLFxuICBjb3JzQ2hlY2ssXG4gIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayxcbiAgZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcixcbiAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgaXNCbG9iTGlrZSxcbiAgc2FtZU9yaWdpbixcbiAgaXNDYW5jZWxsZWQsXG4gIGlzQWJvcnRlZCxcbiAgaXNFcnJvckxpa2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGlzb21vcnBoaWNFbmNvZGUsXG4gIHVybElzTG9jYWwsXG4gIHVybElzSHR0cEh0dHBzU2NoZW1lLFxuICB1cmxIYXNIdHRwc1NjaGVtZSxcbiAgY2xhbXBBbmRDb2Fyc2VuQ29ubmVjdGlvblRpbWluZ0luZm8sXG4gIHNpbXBsZVJhbmdlSGVhZGVyVmFsdWUsXG4gIGJ1aWxkQ29udGVudFJhbmdlLFxuICBjcmVhdGVJbmZsYXRlLFxuICBleHRyYWN0TWltZVR5cGVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrU3RhdGUsIGtEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBzYWZlbHlFeHRyYWN0Qm9keSwgZXh0cmFjdEJvZHkgfSA9IHJlcXVpcmUoJy4vYm9keScpXG5jb25zdCB7XG4gIHJlZGlyZWN0U3RhdHVzU2V0LFxuICBudWxsQm9keVN0YXR1cyxcbiAgc2FmZU1ldGhvZHNTZXQsXG4gIHJlcXVlc3RCb2R5SGVhZGVyLFxuICBzdWJyZXNvdXJjZVNldFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuY29uc3QgeyBSZWFkYWJsZSwgcGlwZWxpbmUsIGZpbmlzaGVkIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IGFkZEFib3J0TGlzdGVuZXIsIGlzRXJyb3JlZCwgaXNSZWFkYWJsZSwgYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZGF0YVVSTFByb2Nlc3Nvciwgc2VyaWFsaXplQU1pbWVUeXBlLCBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vLi4vZ2xvYmFsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IEdFVF9PUl9IRUFEID0gWydHRVQnLCAnSEVBRCddXG5cbmNvbnN0IGRlZmF1bHRVc2VyQWdlbnQgPSB0eXBlb2YgX19VTkRJQ0lfSVNfTk9ERV9fICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXNidWlsZERldGVjdGlvbiAhPT0gJ3VuZGVmaW5lZCdcbiAgPyAnbm9kZSdcbiAgOiAndW5kaWNpJ1xuXG4vKiogQHR5cGUge2ltcG9ydCgnYnVmZmVyJykucmVzb2x2ZU9iamVjdFVSTH0gKi9cbmxldCByZXNvbHZlT2JqZWN0VVJMXG5cbmNsYXNzIEZldGNoIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2hlcikge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXJcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsXG4gICAgdGhpcy5kdW1wID0gZmFsc2VcbiAgICB0aGlzLnN0YXRlID0gJ29uZ29pbmcnXG4gIH1cblxuICB0ZXJtaW5hdGUgKHJlYXNvbikge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnb25nb2luZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSAndGVybWluYXRlZCdcbiAgICB0aGlzLmNvbm5lY3Rpb24/LmRlc3Ryb3kocmVhc29uKVxuICAgIHRoaXMuZW1pdCgndGVybWluYXRlZCcsIHJlYXNvbilcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaC1jb250cm9sbGVyLWFib3J0XG4gIGFib3J0IChlcnJvcikge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnb25nb2luZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDEuIFNldCBjb250cm9sbGVy4oCZcyBzdGF0ZSB0byBcImFib3J0ZWRcIi5cbiAgICB0aGlzLnN0YXRlID0gJ2Fib3J0ZWQnXG5cbiAgICAvLyAyLiBMZXQgZmFsbGJhY2tFcnJvciBiZSBhbiBcIkFib3J0RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgLy8gMy4gU2V0IGVycm9yIHRvIGZhbGxiYWNrRXJyb3IgaWYgaXQgaXMgbm90IGdpdmVuLlxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGVycm9yID0gbmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IHNlcmlhbGl6ZWRFcnJvciBiZSBTdHJ1Y3R1cmVkU2VyaWFsaXplKGVycm9yKS5cbiAgICAvLyAgICBJZiB0aGF0IHRocmV3IGFuIGV4Y2VwdGlvbiwgY2F0Y2ggaXQsIGFuZCBsZXRcbiAgICAvLyAgICBzZXJpYWxpemVkRXJyb3IgYmUgU3RydWN0dXJlZFNlcmlhbGl6ZShmYWxsYmFja0Vycm9yKS5cblxuICAgIC8vIDUuIFNldCBjb250cm9sbGVy4oCZcyBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiB0byBzZXJpYWxpemVkRXJyb3IuXG4gICAgdGhpcy5zZXJpYWxpemVkQWJvcnRSZWFzb24gPSBlcnJvclxuXG4gICAgdGhpcy5jb25uZWN0aW9uPy5kZXN0cm95KGVycm9yKVxuICAgIHRoaXMuZW1pdCgndGVybWluYXRlZCcsIGVycm9yKVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZldGNoRG9uZSAocmVzcG9uc2UpIHtcbiAgZmluYWxpemVBbmRSZXBvcnRUaW1pbmcocmVzcG9uc2UsICdmZXRjaCcpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaC1tZXRob2RcbmZ1bmN0aW9uIGZldGNoIChpbnB1dCwgaW5pdCA9IHVuZGVmaW5lZCkge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdnbG9iYWxUaGlzLmZldGNoJylcblxuICAvLyAxLiBMZXQgcCBiZSBhIG5ldyBwcm9taXNlLlxuICBsZXQgcCA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMi4gTGV0IHJlcXVlc3RPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgaW5pdGlhbCB2YWx1ZSBvZlxuICAvLyBSZXF1ZXN0IGFzIGNvbnN0cnVjdG9yIHdpdGggaW5wdXQgYW5kIGluaXQgYXMgYXJndW1lbnRzLiBJZiB0aGlzIHRocm93c1xuICAvLyBhbiBleGNlcHRpb24sIHJlamVjdCBwIHdpdGggaXQgYW5kIHJldHVybiBwLlxuICBsZXQgcmVxdWVzdE9iamVjdFxuXG4gIHRyeSB7XG4gICAgcmVxdWVzdE9iamVjdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICB9IGNhdGNoIChlKSB7XG4gICAgcC5yZWplY3QoZSlcbiAgICByZXR1cm4gcC5wcm9taXNlXG4gIH1cblxuICAvLyAzLiBMZXQgcmVxdWVzdCBiZSByZXF1ZXN0T2JqZWN04oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdE9iamVjdFtrU3RhdGVdXG5cbiAgLy8gNC4gSWYgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydGVkIGZsYWcgaXMgc2V0LCB0aGVuOlxuICBpZiAocmVxdWVzdE9iamVjdC5zaWduYWwuYWJvcnRlZCkge1xuICAgIC8vIDEuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCBudWxsLCBhbmRcbiAgICAvLyAgICByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIG51bGwsIHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcblxuICAgIC8vIDIuIFJldHVybiBwLlxuICAgIHJldHVybiBwLnByb21pc2VcbiAgfVxuXG4gIC8vIDUuIExldCBnbG9iYWxPYmplY3QgYmUgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0LlxuICBjb25zdCBnbG9iYWxPYmplY3QgPSByZXF1ZXN0LmNsaWVudC5nbG9iYWxPYmplY3RcblxuICAvLyA2LiBJZiBnbG9iYWxPYmplY3QgaXMgYSBTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUgb2JqZWN0LCB0aGVuIHNldFxuICAvLyByZXF1ZXN04oCZcyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSB0byBcIm5vbmVcIi5cbiAgaWYgKGdsb2JhbE9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUnKSB7XG4gICAgcmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9ICdub25lJ1xuICB9XG5cbiAgLy8gNy4gTGV0IHJlc3BvbnNlT2JqZWN0IGJlIG51bGwuXG4gIGxldCByZXNwb25zZU9iamVjdCA9IG51bGxcblxuICAvLyA4LiBMZXQgcmVsZXZhbnRSZWFsbSBiZSB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cblxuICAvLyA5LiBMZXQgbG9jYWxseUFib3J0ZWQgYmUgZmFsc2UuXG4gIGxldCBsb2NhbGx5QWJvcnRlZCA9IGZhbHNlXG5cbiAgLy8gMTAuIExldCBjb250cm9sbGVyIGJlIG51bGwuXG4gIGxldCBjb250cm9sbGVyID0gbnVsbFxuXG4gIC8vIDExLiBBZGQgdGhlIGZvbGxvd2luZyBhYm9ydCBzdGVwcyB0byByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWw6XG4gIGFkZEFib3J0TGlzdGVuZXIoXG4gICAgcmVxdWVzdE9iamVjdC5zaWduYWwsXG4gICAgKCkgPT4ge1xuICAgICAgLy8gMS4gU2V0IGxvY2FsbHlBYm9ydGVkIHRvIHRydWUuXG4gICAgICBsb2NhbGx5QWJvcnRlZCA9IHRydWVcblxuICAgICAgLy8gMi4gQXNzZXJ0OiBjb250cm9sbGVyIGlzIG5vbi1udWxsLlxuICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIgIT0gbnVsbClcblxuICAgICAgLy8gMy4gQWJvcnQgY29udHJvbGxlciB3aXRoIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgICAgY29udHJvbGxlci5hYm9ydChyZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG5cbiAgICAgIGNvbnN0IHJlYWxSZXNwb25zZSA9IHJlc3BvbnNlT2JqZWN0Py5kZXJlZigpXG5cbiAgICAgIC8vIDQuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCxcbiAgICAgIC8vICAgIGFuZCByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVhbFJlc3BvbnNlLCByZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG4gICAgfVxuICApXG5cbiAgLy8gMTIuIExldCBoYW5kbGVGZXRjaERvbmUgZ2l2ZW4gcmVzcG9uc2UgcmVzcG9uc2UgYmUgdG8gZmluYWxpemUgYW5kXG4gIC8vIHJlcG9ydCB0aW1pbmcgd2l0aCByZXNwb25zZSwgZ2xvYmFsT2JqZWN0LCBhbmQgXCJmZXRjaFwiLlxuICAvLyBzZWUgZnVuY3Rpb24gaGFuZGxlRmV0Y2hEb25lXG5cbiAgLy8gMTMuIFNldCBjb250cm9sbGVyIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyBmZXRjaCBnaXZlbiByZXF1ZXN0LFxuICAvLyB3aXRoIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSBzZXQgdG8gaGFuZGxlRmV0Y2hEb25lLCBhbmQgcHJvY2Vzc1Jlc3BvbnNlXG4gIC8vIGdpdmVuIHJlc3BvbnNlIGJlaW5nIHRoZXNlIHN1YnN0ZXBzOlxuXG4gIGNvbnN0IHByb2Nlc3NSZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgIC8vIDEuIElmIGxvY2FsbHlBYm9ydGVkIGlzIHRydWUsIHRlcm1pbmF0ZSB0aGVzZSBzdWJzdGVwcy5cbiAgICBpZiAobG9jYWxseUFib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDIuIElmIHJlc3BvbnNl4oCZcyBhYm9ydGVkIGZsYWcgaXMgc2V0LCB0aGVuOlxuICAgIGlmIChyZXNwb25zZS5hYm9ydGVkKSB7XG4gICAgICAvLyAxLiBMZXQgZGVzZXJpYWxpemVkRXJyb3IgYmUgdGhlIHJlc3VsdCBvZiBkZXNlcmlhbGl6ZSBhIHNlcmlhbGl6ZWRcbiAgICAgIC8vICAgIGFib3J0IHJlYXNvbiBnaXZlbiBjb250cm9sbGVy4oCZcyBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiBhbmRcbiAgICAgIC8vICAgIHJlbGV2YW50UmVhbG0uXG5cbiAgICAgIC8vIDIuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgYW5kXG4gICAgICAvLyAgICBkZXNlcmlhbGl6ZWRFcnJvci5cblxuICAgICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgY29udHJvbGxlci5zZXJpYWxpemVkQWJvcnRSZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAzLiBJZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsIHRoZW4gcmVqZWN0IHAgd2l0aCBhIFR5cGVFcnJvclxuICAgIC8vIGFuZCB0ZXJtaW5hdGUgdGhlc2Ugc3Vic3RlcHMuXG4gICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHAucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2ZldGNoIGZhaWxlZCcsIHsgY2F1c2U6IHJlc3BvbnNlLmVycm9yIH0pKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gNC4gU2V0IHJlc3BvbnNlT2JqZWN0IHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXNwb25zZSBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gcmVzcG9uc2UsIFwiaW1tdXRhYmxlXCIsIGFuZCByZWxldmFudFJlYWxtLlxuICAgIHJlc3BvbnNlT2JqZWN0ID0gbmV3IFdlYWtSZWYoZnJvbUlubmVyUmVzcG9uc2UocmVzcG9uc2UsICdpbW11dGFibGUnKSlcblxuICAgIC8vIDUuIFJlc29sdmUgcCB3aXRoIHJlc3BvbnNlT2JqZWN0LlxuICAgIHAucmVzb2x2ZShyZXNwb25zZU9iamVjdC5kZXJlZigpKVxuICAgIHAgPSBudWxsXG4gIH1cblxuICBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgIHJlcXVlc3QsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5OiBoYW5kbGVGZXRjaERvbmUsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlLFxuICAgIGRpc3BhdGNoZXI6IHJlcXVlc3RPYmplY3Rba0Rpc3BhdGNoZXJdIC8vIHVuZGljaVxuICB9KVxuXG4gIC8vIDE0LiBSZXR1cm4gcC5cbiAgcmV0dXJuIHAucHJvbWlzZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmluYWxpemUtYW5kLXJlcG9ydC10aW1pbmdcbmZ1bmN0aW9uIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nIChyZXNwb25zZSwgaW5pdGlhdG9yVHlwZSA9ICdvdGhlcicpIHtcbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yLCB0aGVuIHJldHVybi5cbiAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgJiYgcmVzcG9uc2UuYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMi4gSWYgcmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIG51bGwgb3IgZW1wdHksIHRoZW4gcmV0dXJuLlxuICBpZiAoIXJlc3BvbnNlLnVybExpc3Q/Lmxlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMy4gTGV0IG9yaWdpbmFsVVJMIGJlIHJlc3BvbnNl4oCZcyBVUkwgbGlzdFswXS5cbiAgY29uc3Qgb3JpZ2luYWxVUkwgPSByZXNwb25zZS51cmxMaXN0WzBdXG5cbiAgLy8gNC4gTGV0IHRpbWluZ0luZm8gYmUgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvLlxuICBsZXQgdGltaW5nSW5mbyA9IHJlc3BvbnNlLnRpbWluZ0luZm9cblxuICAvLyA1LiBMZXQgY2FjaGVTdGF0ZSBiZSByZXNwb25zZeKAmXMgY2FjaGUgc3RhdGUuXG4gIGxldCBjYWNoZVN0YXRlID0gcmVzcG9uc2UuY2FjaGVTdGF0ZVxuXG4gIC8vIDYuIElmIG9yaWdpbmFsVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lLCB0aGVuIHJldHVybi5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShvcmlnaW5hbFVSTCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDcuIElmIHRpbWluZ0luZm8gaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmICh0aW1pbmdJbmZvID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA4LiBJZiByZXNwb25zZeKAmXMgdGltaW5nIGFsbG93IHBhc3NlZCBmbGFnIGlzIG5vdCBzZXQsIHRoZW46XG4gIGlmICghcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAvLyAgMS4gU2V0IHRpbWluZ0luZm8gdG8gYSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIG9wYXF1ZSB0aW1pbmcgaW5mbyBmb3IgdGltaW5nSW5mby5cbiAgICB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gICAgfSlcblxuICAgIC8vICAyLiBTZXQgY2FjaGVTdGF0ZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGNhY2hlU3RhdGUgPSAnJ1xuICB9XG5cbiAgLy8gOS4gU2V0IHRpbWluZ0luZm/igJlzIGVuZCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZVxuICAvLyBnaXZlbiBnbG9iYWzigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIC8vIFRPRE86IGdpdmVuIGdsb2JhbOKAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eT9cbiAgdGltaW5nSW5mby5lbmRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoKVxuXG4gIC8vIDEwLiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRpbWluZ0luZm8uXG4gIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG5cbiAgLy8gMTEuIE1hcmsgcmVzb3VyY2UgdGltaW5nIGZvciB0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTCwgaW5pdGlhdG9yVHlwZSxcbiAgLy8gZ2xvYmFsLCBhbmQgY2FjaGVTdGF0ZS5cbiAgbWFya1Jlc291cmNlVGltaW5nKFxuICAgIHRpbWluZ0luZm8sXG4gICAgb3JpZ2luYWxVUkwuaHJlZixcbiAgICBpbml0aWF0b3JUeXBlLFxuICAgIGdsb2JhbFRoaXMsXG4gICAgY2FjaGVTdGF0ZVxuICApXG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9yZXNvdXJjZS10aW1pbmcvI2Rmbi1tYXJrLXJlc291cmNlLXRpbWluZ1xuY29uc3QgbWFya1Jlc291cmNlVGltaW5nID0gcGVyZm9ybWFuY2UubWFya1Jlc291cmNlVGltaW5nXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhYm9ydC1mZXRjaFxuZnVuY3Rpb24gYWJvcnRGZXRjaCAocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGVycm9yKSB7XG4gIC8vIDEuIFJlamVjdCBwcm9taXNlIHdpdGggZXJyb3IuXG4gIGlmIChwKSB7XG4gICAgLy8gV2UgbWlnaHQgaGF2ZSBhbHJlYWR5IHJlc29sdmVkIHRoZSBwcm9taXNlIGF0IHRoaXMgc3RhZ2VcbiAgICBwLnJlamVjdChlcnJvcilcbiAgfVxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm90IG51bGwgYW5kIGlzIHJlYWRhYmxlLCB0aGVuIGNhbmNlbCByZXF1ZXN04oCZc1xuICAvLyBib2R5IHdpdGggZXJyb3IuXG4gIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCAmJiBpc1JlYWRhYmxlKHJlcXVlc3QuYm9keT8uc3RyZWFtKSkge1xuICAgIHJlcXVlc3QuYm9keS5zdHJlYW0uY2FuY2VsKGVycm9yKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfSU5WQUxJRF9TVEFURScpIHtcbiAgICAgICAgLy8gTm9kZSBidWc/XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHJlc3BvbnNlT2JqZWN0IGlzIG51bGwsIHRoZW4gcmV0dXJuLlxuICBpZiAocmVzcG9uc2VPYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gNC4gTGV0IHJlc3BvbnNlIGJlIHJlc3BvbnNlT2JqZWN04oCZcyByZXNwb25zZS5cbiAgY29uc3QgcmVzcG9uc2UgPSByZXNwb25zZU9iamVjdFtrU3RhdGVdXG5cbiAgLy8gNS4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbm90IG51bGwgYW5kIGlzIHJlYWRhYmxlLCB0aGVuIGVycm9yIHJlc3BvbnNl4oCZc1xuICAvLyBib2R5IHdpdGggZXJyb3IuXG4gIGlmIChyZXNwb25zZS5ib2R5ICE9IG51bGwgJiYgaXNSZWFkYWJsZShyZXNwb25zZS5ib2R5Py5zdHJlYW0pKSB7XG4gICAgcmVzcG9uc2UuYm9keS5zdHJlYW0uY2FuY2VsKGVycm9yKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfSU5WQUxJRF9TVEFURScpIHtcbiAgICAgICAgLy8gTm9kZSBidWc/XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2hpbmdcbmZ1bmN0aW9uIGZldGNoaW5nICh7XG4gIHJlcXVlc3QsXG4gIHByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoLFxuICBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgcHJvY2Vzc1Jlc3BvbnNlLFxuICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHksXG4gIHByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5LFxuICB1c2VQYXJhbGxlbFF1ZXVlID0gZmFsc2UsXG4gIGRpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyKCkgLy8gdW5kaWNpXG59KSB7XG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBkaXNwYXRjaGVyIGlzIHNldCBhY2NvcmRpbmdseVxuICBhc3NlcnQoZGlzcGF0Y2hlcilcblxuICAvLyAxLiBMZXQgdGFza0Rlc3RpbmF0aW9uIGJlIG51bGwuXG4gIGxldCB0YXNrRGVzdGluYXRpb24gPSBudWxsXG5cbiAgLy8gMi4gTGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IGJlIGZhbHNlLlxuICBsZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgPSBmYWxzZVxuXG4gIC8vIDMuIElmIHJlcXVlc3TigJlzIGNsaWVudCBpcyBub24tbnVsbCwgdGhlbjpcbiAgaWYgKHJlcXVlc3QuY2xpZW50ICE9IG51bGwpIHtcbiAgICAvLyAxLiBTZXQgdGFza0Rlc3RpbmF0aW9uIHRvIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdC5cbiAgICB0YXNrRGVzdGluYXRpb24gPSByZXF1ZXN0LmNsaWVudC5nbG9iYWxPYmplY3RcblxuICAgIC8vIDIuIFNldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSB0byByZXF1ZXN04oCZcyBjbGllbnTigJlzIGNyb3NzLW9yaWdpblxuICAgIC8vIGlzb2xhdGVkIGNhcGFiaWxpdHkuXG4gICAgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgPVxuICAgICAgcmVxdWVzdC5jbGllbnQuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHlcbiAgfVxuXG4gIC8vIDQuIElmIHVzZVBhcmFsbGVsUXVldWUgaXMgdHJ1ZSwgdGhlbiBzZXQgdGFza0Rlc3RpbmF0aW9uIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gc3RhcnRpbmcgYSBuZXcgcGFyYWxsZWwgcXVldWUuXG4gIC8vIFRPRE9cblxuICAvLyA1LiBMZXQgdGltaW5nSW5mbyBiZSBhIG5ldyBmZXRjaCB0aW1pbmcgaW5mbyB3aG9zZSBzdGFydCB0aW1lIGFuZFxuICAvLyBwb3N0LXJlZGlyZWN0IHN0YXJ0IHRpbWUgYXJlIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlblxuICAvLyBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eS5cbiAgY29uc3QgY3VycmVudFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbiAgY29uc3QgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWVcbiAgfSlcblxuICAvLyA2LiBMZXQgZmV0Y2hQYXJhbXMgYmUgYSBuZXcgZmV0Y2ggcGFyYW1zIHdob3NlXG4gIC8vIHJlcXVlc3QgaXMgcmVxdWVzdCxcbiAgLy8gdGltaW5nIGluZm8gaXMgdGltaW5nSW5mbyxcbiAgLy8gcHJvY2VzcyByZXF1ZXN0IGJvZHkgY2h1bmsgbGVuZ3RoIGlzIHByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoLFxuICAvLyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkgaXMgcHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHksXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgaXMgcHJvY2Vzc1Jlc3BvbnNlLFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGNvbnN1bWUgYm9keSBpcyBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBlbmQtb2YtYm9keSBpcyBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHksXG4gIC8vIHRhc2sgZGVzdGluYXRpb24gaXMgdGFza0Rlc3RpbmF0aW9uLFxuICAvLyBhbmQgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHkgaXMgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkuXG4gIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgIGNvbnRyb2xsZXI6IG5ldyBGZXRjaChkaXNwYXRjaGVyKSxcbiAgICByZXF1ZXN0LFxuICAgIHRpbWluZ0luZm8sXG4gICAgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gICAgcHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHksXG4gICAgcHJvY2Vzc1Jlc3BvbnNlLFxuICAgIHByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5LFxuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgICB0YXNrRGVzdGluYXRpb24sXG4gICAgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHlcbiAgfVxuXG4gIC8vIDcuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgYSBieXRlIHNlcXVlbmNlLCB0aGVuIHNldCByZXF1ZXN04oCZcyBib2R5IHRvXG4gIC8vICAgIHJlcXVlc3TigJlzIGJvZHkgYXMgYSBib2R5LlxuICAvLyBOT1RFOiBTaW5jZSBmZXRjaGluZyBpcyBvbmx5IGNhbGxlZCBmcm9tIGZldGNoLCBib2R5IHNob3VsZCBhbHJlYWR5IGJlXG4gIC8vIGV4dHJhY3RlZC5cbiAgYXNzZXJ0KCFyZXF1ZXN0LmJvZHkgfHwgcmVxdWVzdC5ib2R5LnN0cmVhbSlcblxuICAvLyA4LiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgXCJjbGllbnRcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgd2luZG93IHRvIHJlcXVlc3TigJlzXG4gIC8vIGNsaWVudCwgaWYgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0IGlzIGEgV2luZG93IG9iamVjdDsgb3RoZXJ3aXNlXG4gIC8vIFwibm8td2luZG93XCIuXG4gIGlmIChyZXF1ZXN0LndpbmRvdyA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyBUT0RPOiBXaGF0IGlmIHJlcXVlc3QuY2xpZW50IGlzIG51bGw/XG4gICAgcmVxdWVzdC53aW5kb3cgPVxuICAgICAgcmVxdWVzdC5jbGllbnQ/Lmdsb2JhbE9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdXaW5kb3cnXG4gICAgICAgID8gcmVxdWVzdC5jbGllbnRcbiAgICAgICAgOiAnbm8td2luZG93J1xuICB9XG5cbiAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgb3JpZ2luIGlzIFwiY2xpZW50XCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzIG9yaWdpbiB0byByZXF1ZXN04oCZc1xuICAvLyBjbGllbnTigJlzIG9yaWdpbi5cbiAgaWYgKHJlcXVlc3Qub3JpZ2luID09PSAnY2xpZW50Jykge1xuICAgIHJlcXVlc3Qub3JpZ2luID0gcmVxdWVzdC5jbGllbnQub3JpZ2luXG4gIH1cblxuICAvLyAxMC4gSWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgdHJ1ZTpcbiAgLy8gVE9ET1xuXG4gIC8vIDExLiBJZiByZXF1ZXN04oCZcyBwb2xpY3kgY29udGFpbmVyIGlzIFwiY2xpZW50XCIsIHRoZW46XG4gIGlmIChyZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyBjbGllbnQgaXMgbm9uLW51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHBvbGljeVxuICAgIC8vIGNvbnRhaW5lciB0byBhIGNsb25lIG9mIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgcG9saWN5IGNvbnRhaW5lci4gW0hUTUxdXG4gICAgaWYgKHJlcXVlc3QuY2xpZW50ICE9IG51bGwpIHtcbiAgICAgIHJlcXVlc3QucG9saWN5Q29udGFpbmVyID0gY2xvbmVQb2xpY3lDb250YWluZXIoXG4gICAgICAgIHJlcXVlc3QuY2xpZW50LnBvbGljeUNvbnRhaW5lclxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAyLiBPdGhlcndpc2UsIHNldCByZXF1ZXN04oCZcyBwb2xpY3kgY29udGFpbmVyIHRvIGEgbmV3IHBvbGljeVxuICAgICAgLy8gY29udGFpbmVyLlxuICAgICAgcmVxdWVzdC5wb2xpY3lDb250YWluZXIgPSBtYWtlUG9saWN5Q29udGFpbmVyKClcbiAgICB9XG4gIH1cblxuICAvLyAxMi4gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQWNjZXB0YCwgdGhlbjpcbiAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQnLCB0cnVlKSkge1xuICAgIC8vIDEuIExldCB2YWx1ZSBiZSBgKi8qYC5cbiAgICBjb25zdCB2YWx1ZSA9ICcqLyonXG5cbiAgICAvLyAyLiBBIHVzZXIgYWdlbnQgc2hvdWxkIHNldCB2YWx1ZSB0byB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RhdGVtZW50LCBpZlxuICAgIC8vIGFueSwgc3dpdGNoaW5nIG9uIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uOlxuICAgIC8vIFwiZG9jdW1lbnRcIlxuICAgIC8vIFwiZnJhbWVcIlxuICAgIC8vIFwiaWZyYW1lXCJcbiAgICAvLyBgdGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksKi8qO3E9MC44YFxuICAgIC8vIFwiaW1hZ2VcIlxuICAgIC8vIGBpbWFnZS9wbmcsaW1hZ2Uvc3ZnK3htbCxpbWFnZS8qO3E9MC44LCovKjtxPTAuNWBcbiAgICAvLyBcInN0eWxlXCJcbiAgICAvLyBgdGV4dC9jc3MsKi8qO3E9MC4xYFxuICAgIC8vIFRPRE9cblxuICAgIC8vIDMuIEFwcGVuZCBgQWNjZXB0YC92YWx1ZSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0JywgdmFsdWUsIHRydWUpXG4gIH1cblxuICAvLyAxMy4gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQWNjZXB0LUxhbmd1YWdlYCwgdGhlblxuICAvLyB1c2VyIGFnZW50cyBzaG91bGQgYXBwZW5kIGBBY2NlcHQtTGFuZ3VhZ2VgL2FuIGFwcHJvcHJpYXRlIHZhbHVlIHRvXG4gIC8vIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIXJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2FjY2VwdC1sYW5ndWFnZScsIHRydWUpKSB7XG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1sYW5ndWFnZScsICcqJywgdHJ1ZSlcbiAgfVxuXG4gIC8vIDE0LiBJZiByZXF1ZXN04oCZcyBwcmlvcml0eSBpcyBudWxsLCB0aGVuIHVzZSByZXF1ZXN04oCZcyBpbml0aWF0b3IgYW5kXG4gIC8vIGRlc3RpbmF0aW9uIGFwcHJvcHJpYXRlbHkgaW4gc2V0dGluZyByZXF1ZXN04oCZcyBwcmlvcml0eSB0byBhXG4gIC8vIHVzZXItYWdlbnQtZGVmaW5lZCBvYmplY3QuXG4gIGlmIChyZXF1ZXN0LnByaW9yaXR5ID09PSBudWxsKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gMTUuIElmIHJlcXVlc3QgaXMgYSBzdWJyZXNvdXJjZSByZXF1ZXN0LCB0aGVuOlxuICBpZiAoc3VicmVzb3VyY2VTZXQuaGFzKHJlcXVlc3QuZGVzdGluYXRpb24pKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gMTYuIFJ1biBtYWluIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICBtYWluRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlcnIpXG4gICAgfSlcblxuICAvLyAxNy4gUmV0dXJuIGZldGNoUGFyYW0ncyBjb250cm9sbGVyXG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1haW4tZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIG1haW5GZXRjaCAoZmV0Y2hQYXJhbXMsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gMy4gSWYgcmVxdWVzdOKAmXMgbG9jYWwtVVJMcy1vbmx5IGZsYWcgaXMgc2V0IGFuZCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTCBpc1xuICAvLyBub3QgbG9jYWwsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKHJlcXVlc3QubG9jYWxVUkxzT25seSAmJiAhdXJsSXNMb2NhbChyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ2xvY2FsIFVSTHMgb25seScpXG4gIH1cblxuICAvLyA0LiBSdW4gcmVwb3J0IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHZpb2xhdGlvbnMgZm9yIHJlcXVlc3QuXG4gIC8vIFRPRE9cblxuICAvLyA1LiBVcGdyYWRlIHJlcXVlc3QgdG8gYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIGlmIGFwcHJvcHJpYXRlLlxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwocmVxdWVzdClcblxuICAvLyA2LiBJZiBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBhIGJhZCBwb3J0LCBzaG91bGQgZmV0Y2hpbmcgcmVxdWVzdFxuICAvLyBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnQsIG9yIHNob3VsZCByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudFxuICAvLyBTZWN1cml0eSBQb2xpY3kgcmV0dXJucyBibG9ja2VkLCB0aGVuIHNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0QmFkUG9ydChyZXF1ZXN0KSA9PT0gJ2Jsb2NrZWQnKSB7XG4gICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCdiYWQgcG9ydCcpXG4gIH1cbiAgLy8gVE9ETzogc2hvdWxkIGZldGNoaW5nIHJlcXVlc3QgYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50P1xuICAvLyBUT0RPOiBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5P1xuXG4gIC8vIDcuIElmIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlciBwb2xpY3kgdG8gcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lcuKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICBpZiAocmVxdWVzdC5yZWZlcnJlclBvbGljeSA9PT0gJycpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gcmVxdWVzdC5wb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3lcbiAgfVxuXG4gIC8vIDguIElmIHJlcXVlc3TigJlzIHJlZmVycmVyIGlzIG5vdCBcIm5vLXJlZmVycmVyXCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzXG4gIC8vIHJlZmVycmVyIHRvIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgZGV0ZXJtaW5lIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICBpZiAocmVxdWVzdC5yZWZlcnJlciAhPT0gJ25vLXJlZmVycmVyJykge1xuICAgIHJlcXVlc3QucmVmZXJyZXIgPSBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyKHJlcXVlc3QpXG4gIH1cblxuICAvLyA5LiBTZXQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSB0byBcImh0dHBzXCIgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBhcmUgdHJ1ZTpcbiAgLy8gLSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIFwiaHR0cFwiXG4gIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGhvc3QgaXMgYSBkb21haW5cbiAgLy8gLSBNYXRjaGluZyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgaG9zdCBwZXIgS25vd24gSFNUUyBIb3N0IERvbWFpbiBOYW1lXG4gIC8vICAgTWF0Y2hpbmcgcmVzdWx0cyBpbiBlaXRoZXIgYSBzdXBlcmRvbWFpbiBtYXRjaCB3aXRoIGFuIGFzc2VydGVkXG4gIC8vICAgaW5jbHVkZVN1YkRvbWFpbnMgZGlyZWN0aXZlIG9yIGEgY29uZ3J1ZW50IG1hdGNoICh3aXRoIG9yIHdpdGhvdXQgYW5cbiAgLy8gICBhc3NlcnRlZCBpbmNsdWRlU3ViRG9tYWlucyBkaXJlY3RpdmUpLiBbSFNUU11cbiAgLy8gVE9ET1xuXG4gIC8vIDEwLiBJZiByZWN1cnNpdmUgaXMgZmFsc2UsIHRoZW4gcnVuIHRoZSByZW1haW5pbmcgc3RlcHMgaW4gcGFyYWxsZWwuXG4gIC8vIFRPRE9cblxuICAvLyAxMS4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gIC8vIHRoZSBzdGVwcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBmaXJzdCBtYXRjaGluZyBzdGF0ZW1lbnQ6XG4gIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgIHJlc3BvbnNlID0gYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICBpZiAoXG4gICAgICAgIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbiBpcyBzYW1lIG9yaWdpbiB3aXRoIHJlcXVlc3TigJlzIG9yaWdpbixcbiAgICAgICAgLy8gICBhbmQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJiYXNpY1wiXG4gICAgICAgIChzYW1lT3JpZ2luKGN1cnJlbnRVUkwsIHJlcXVlc3QudXJsKSAmJiByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdiYXNpYycpIHx8XG4gICAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgXCJkYXRhXCJcbiAgICAgICAgKGN1cnJlbnRVUkwucHJvdG9jb2wgPT09ICdkYXRhOicpIHx8XG4gICAgICAgIC8vIC0gcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5hdmlnYXRlXCIgb3IgXCJ3ZWJzb2NrZXRcIlxuICAgICAgICAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnIHx8IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpXG4gICAgICApIHtcbiAgICAgICAgLy8gMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiYmFzaWNcIi5cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ2Jhc2ljJ1xuXG4gICAgICAgIC8vIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2NoZW1lIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgICAgICByZXR1cm4gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJzYW1lLW9yaWdpblwiXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnc2FtZS1vcmlnaW4nKSB7XG4gICAgICAgIC8vIDEuIFJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdyZXF1ZXN0IG1vZGUgY2Fubm90IGJlIFwic2FtZS1vcmlnaW5cIicpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuby1jb3JzXCJcbiAgICAgIGlmIChyZXF1ZXN0Lm1vZGUgPT09ICduby1jb3JzJykge1xuICAgICAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzIG5vdCBcImZvbGxvd1wiLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ICE9PSAnZm9sbG93Jykge1xuICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgICAgICAgJ3JlZGlyZWN0IG1vZGUgY2Fubm90IGJlIFwiZm9sbG93XCIgZm9yIFwibm8tY29yc1wiIHJlcXVlc3QnXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwib3BhcXVlXCIuXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdvcGFxdWUnXG5cbiAgICAgICAgLy8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBzY2hlbWUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICAgIHJldHVybiBhd2FpdCBzY2hlbWVGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgIH1cblxuICAgICAgLy8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWVcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICAgIC8vIFJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdVUkwgc2NoZW1lIG11c3QgYmUgYSBIVFRQKFMpIHNjaGVtZScpXG4gICAgICB9XG5cbiAgICAgIC8vIC0gcmVxdWVzdOKAmXMgdXNlLUNPUlMtcHJlZmxpZ2h0IGZsYWcgaXMgc2V0XG4gICAgICAvLyAtIHJlcXVlc3TigJlzIHVuc2FmZS1yZXF1ZXN0IGZsYWcgaXMgc2V0IGFuZCBlaXRoZXIgcmVxdWVzdOKAmXMgbWV0aG9kIGlzXG4gICAgICAvLyAgIG5vdCBhIENPUlMtc2FmZWxpc3RlZCBtZXRob2Qgb3IgQ09SUy11bnNhZmUgcmVxdWVzdC1oZWFkZXIgbmFtZXMgd2l0aFxuICAgICAgLy8gICByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgIC8vICAgIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImNvcnNcIi5cbiAgICAgIC8vICAgIDIuIExldCBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlIGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQIGZldGNoXG4gICAgICAvLyAgICBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgdHJ1ZS5cbiAgICAgIC8vICAgIDMuIElmIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIGNsZWFyIGNhY2hlXG4gICAgICAvLyAgICBlbnRyaWVzIHVzaW5nIHJlcXVlc3QuXG4gICAgICAvLyAgICA0LiBSZXR1cm4gY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZS5cbiAgICAgIC8vIFRPRE9cblxuICAgICAgLy8gT3RoZXJ3aXNlXG4gICAgICAvLyAgICAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJjb3JzXCIuXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnY29ycydcblxuICAgICAgLy8gICAgMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgICAgcmV0dXJuIGF3YWl0IGh0dHBGZXRjaChmZXRjaFBhcmFtcylcbiAgICB9KSgpXG4gIH1cblxuICAvLyAxMi4gSWYgcmVjdXJzaXZlIGlzIHRydWUsIHRoZW4gcmV0dXJuIHJlc3BvbnNlLlxuICBpZiAocmVjdXJzaXZlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvLyAxMy4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgcmVzcG9uc2UgaXMgbm90IGEgZmlsdGVyZWRcbiAgLy8gcmVzcG9uc2UsIHRoZW46XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDAgJiYgIXJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UpIHtcbiAgICAvLyBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiwgdGhlbjpcbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycpIHtcbiAgICAgIC8vIDEuIExldCBoZWFkZXJOYW1lcyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzXG4gICAgICAvLyBnaXZlbiBgQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnNgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAvLyBUT0RPXG4gICAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlIGlzIG5vdCBcImluY2x1ZGVcIiBhbmQgaGVhZGVyTmFtZXNcbiAgICAgIC8vIGNvbnRhaW5zIGAqYCwgdGhlbiBzZXQgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0IHRvXG4gICAgICAvLyBhbGwgdW5pcXVlIGhlYWRlciBuYW1lcyBpbiByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAvLyBUT0RPXG4gICAgICAvLyAzLiBPdGhlcndpc2UsIGlmIGhlYWRlck5hbWVzIGlzIG5vdCBudWxsIG9yIGZhaWx1cmUsIHRoZW4gc2V0XG4gICAgICAvLyByZXNwb25zZeKAmXMgQ09SUy1leHBvc2VkIGhlYWRlci1uYW1lIGxpc3QgdG8gaGVhZGVyTmFtZXMuXG4gICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgLy8gU2V0IHJlc3BvbnNlIHRvIHRoZSBmb2xsb3dpbmcgZmlsdGVyZWQgcmVzcG9uc2Ugd2l0aCByZXNwb25zZSBhcyBpdHNcbiAgICAvLyBpbnRlcm5hbCByZXNwb25zZSwgZGVwZW5kaW5nIG9uIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nOlxuICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdiYXNpYycpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdiYXNpYycpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJykge1xuICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ2NvcnMnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJykge1xuICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ29wYXF1ZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvLyAxNC4gTGV0IGludGVybmFsUmVzcG9uc2UgYmUgcmVzcG9uc2UsIGlmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvcixcbiAgLy8gYW5kIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZSBvdGhlcndpc2UuXG4gIGxldCBpbnRlcm5hbFJlc3BvbnNlID1cbiAgICByZXNwb25zZS5zdGF0dXMgPT09IDAgPyByZXNwb25zZSA6IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2VcblxuICAvLyAxNS4gSWYgaW50ZXJuYWxSZXNwb25zZeKAmXMgVVJMIGxpc3QgaXMgZW1wdHksIHRoZW4gc2V0IGl0IHRvIGEgY2xvbmUgb2ZcbiAgLy8gcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIGlmIChpbnRlcm5hbFJlc3BvbnNlLnVybExpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZS51cmxMaXN0LnB1c2goLi4ucmVxdWVzdC51cmxMaXN0KVxuICB9XG5cbiAgLy8gMTYuIElmIHJlcXVlc3TigJlzIHRpbWluZyBhbGxvdyBmYWlsZWQgZmxhZyBpcyB1bnNldCwgdGhlbiBzZXRcbiAgLy8gaW50ZXJuYWxSZXNwb25zZeKAmXMgdGltaW5nIGFsbG93IHBhc3NlZCBmbGFnLlxuICBpZiAoIXJlcXVlc3QudGltaW5nQWxsb3dGYWlsZWQpIHtcbiAgICByZXNwb25zZS50aW1pbmdBbGxvd1Bhc3NlZCA9IHRydWVcbiAgfVxuXG4gIC8vIDE3LiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBhbnkgb2YgdGhlIGZvbGxvd2luZyByZXR1cm5zXG4gIC8vIGJsb2NrZWRcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudFxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50IFNlY3VyaXR5IFBvbGljeVxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gaXRzIE1JTUUgdHlwZVxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gbm9zbmlmZlxuICAvLyBUT0RPXG5cbiAgLy8gMTguIElmIHJlc3BvbnNl4oCZcyB0eXBlIGlzIFwib3BhcXVlXCIsIGludGVybmFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAyMDYsXG4gIC8vIGludGVybmFsUmVzcG9uc2XigJlzIHJhbmdlLXJlcXVlc3RlZCBmbGFnIGlzIHNldCwgYW5kIHJlcXVlc3TigJlzIGhlYWRlclxuICAvLyBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFJhbmdlYCwgdGhlbiBzZXQgcmVzcG9uc2UgYW5kIGludGVybmFsUmVzcG9uc2VcbiAgLy8gdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgcmVzcG9uc2UudHlwZSA9PT0gJ29wYXF1ZScgJiZcbiAgICBpbnRlcm5hbFJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2ICYmXG4gICAgaW50ZXJuYWxSZXNwb25zZS5yYW5nZVJlcXVlc3RlZCAmJlxuICAgICFyZXF1ZXN0LmhlYWRlcnMuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSlcbiAgKSB7XG4gICAgcmVzcG9uc2UgPSBpbnRlcm5hbFJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcigpXG4gIH1cblxuICAvLyAxOS4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgZWl0aGVyIHJlcXVlc3TigJlzIG1ldGhvZCBpc1xuICAvLyBgSEVBRGAgb3IgYENPTk5FQ1RgLCBvciBpbnRlcm5hbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYSBudWxsIGJvZHkgc3RhdHVzLFxuICAvLyBzZXQgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keSB0byBudWxsIGFuZCBkaXNyZWdhcmQgYW55IGVucXVldWluZyB0b3dhcmRcbiAgLy8gaXQgKGlmIGFueSkuXG4gIGlmIChcbiAgICByZXNwb25zZS5zdGF0dXMgIT09IDAgJiZcbiAgICAocmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyB8fFxuICAgICAgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJyB8fFxuICAgICAgbnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMoaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMpKVxuICApIHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlLmJvZHkgPSBudWxsXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kdW1wID0gdHJ1ZVxuICB9XG5cbiAgLy8gMjAuIElmIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbjpcbiAgaWYgKHJlcXVlc3QuaW50ZWdyaXR5KSB7XG4gICAgLy8gMS4gTGV0IHByb2Nlc3NCb2R5RXJyb3IgYmUgdGhpcyBzdGVwOiBydW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zXG4gICAgLy8gYW5kIGEgbmV0d29yayBlcnJvci5cbiAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gKHJlYXNvbikgPT5cbiAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCBtYWtlTmV0d29ya0Vycm9yKHJlYXNvbikpXG5cbiAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcIm9wYXF1ZVwiLCBvciByZXNwb25zZeKAmXMgYm9keSBpcyBudWxsLFxuICAgIC8vIHRoZW4gcnVuIHByb2Nlc3NCb2R5RXJyb3IgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnIHx8IHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzc0JvZHlFcnJvcihyZXNwb25zZS5lcnJvcilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDMuIExldCBwcm9jZXNzQm9keSBnaXZlbiBieXRlcyBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keSA9IChieXRlcykgPT4ge1xuICAgICAgLy8gMS4gSWYgYnl0ZXMgZG8gbm90IG1hdGNoIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YSxcbiAgICAgIC8vIHRoZW4gcnVuIHByb2Nlc3NCb2R5RXJyb3IgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLiBbU1JJXVxuICAgICAgaWYgKCFieXRlc01hdGNoKGJ5dGVzLCByZXF1ZXN0LmludGVncml0eSkpIHtcbiAgICAgICAgcHJvY2Vzc0JvZHlFcnJvcignaW50ZWdyaXR5IG1pc21hdGNoJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBieXRlcyBhcyBhIGJvZHkuXG4gICAgICByZXNwb25zZS5ib2R5ID0gc2FmZWx5RXh0cmFjdEJvZHkoYnl0ZXMpWzBdXG5cbiAgICAgIC8vIDMuIFJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIDQuIEZ1bGx5IHJlYWQgcmVzcG9uc2XigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHkgYW5kIHByb2Nlc3NCb2R5RXJyb3IuXG4gICAgYXdhaXQgZnVsbHlSZWFkQm9keShyZXNwb25zZS5ib2R5LCBwcm9jZXNzQm9keSwgcHJvY2Vzc0JvZHlFcnJvcilcbiAgfSBlbHNlIHtcbiAgICAvLyAyMS4gT3RoZXJ3aXNlLCBydW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtc2NoZW1lLWZldGNoXG4vLyBnaXZlbiBhIGZldGNoIHBhcmFtcyBmZXRjaFBhcmFtc1xuZnVuY3Rpb24gc2NoZW1lRmV0Y2ggKGZldGNoUGFyYW1zKSB7XG4gIC8vIE5vdGU6IHNpbmNlIHRoZSBjb25uZWN0aW9uIGlzIGRlc3Ryb3llZCBvbiByZWRpcmVjdCwgd2hpY2ggc2V0cyBmZXRjaFBhcmFtcyB0byBhXG4gIC8vIGNhbmNlbGxlZCBzdGF0ZSwgd2UgZG8gbm90IHdhbnQgdGhpcyBjb25kaXRpb24gdG8gdHJpZ2dlciAqdW5sZXNzKiB0aGVyZSBoYXZlIGJlZW5cbiAgLy8gbm8gcmVkaXJlY3RzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE3NzZcbiAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSAmJiBmZXRjaFBhcmFtcy5yZXF1ZXN0LnJlZGlyZWN0Q291bnQgPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcykpXG4gIH1cblxuICAvLyAyLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgeyByZXF1ZXN0IH0gPSBmZXRjaFBhcmFtc1xuXG4gIGNvbnN0IHsgcHJvdG9jb2w6IHNjaGVtZSB9ID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAzLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBhbmQgcnVuIHRoZSBhc3NvY2lhdGVkIHN0ZXBzOlxuICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgIGNhc2UgJ2Fib3V0Oic6IHtcbiAgICAgIC8vIElmIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBwYXRoIGlzIHRoZSBzdHJpbmcgXCJibGFua1wiLCB0aGVuIHJldHVybiBhIG5ldyByZXNwb25zZVxuICAgICAgLy8gd2hvc2Ugc3RhdHVzIG1lc3NhZ2UgaXMgYE9LYCwgaGVhZGVyIGxpc3QgaXMgwqsgKGBDb250ZW50LVR5cGVgLCBgdGV4dC9odG1sO2NoYXJzZXQ9dXRmLThgKSDCuyxcbiAgICAgIC8vIGFuZCBib2R5IGlzIHRoZSBlbXB0eSBieXRlIHNlcXVlbmNlIGFzIGEgYm9keS5cblxuICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdhYm91dCBzY2hlbWUgaXMgbm90IHN1cHBvcnRlZCcpKVxuICAgIH1cbiAgICBjYXNlICdibG9iOic6IHtcbiAgICAgIGlmICghcmVzb2x2ZU9iamVjdFVSTCkge1xuICAgICAgICByZXNvbHZlT2JqZWN0VVJMID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKS5yZXNvbHZlT2JqZWN0VVJMXG4gICAgICB9XG5cbiAgICAgIC8vIDEuIExldCBibG9iVVJMRW50cnkgYmUgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGJsb2IgVVJMIGVudHJ5LlxuICAgICAgY29uc3QgYmxvYlVSTEVudHJ5ID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYi1wbGF0Zm9ybS10ZXN0cy93cHQvYmxvYi83YjBlYmFjY2M2MmI1NjZhMTk2NTM5NmU1YmU3YmIyYmMwNmY4NDFmL0ZpbGVBUEkvdXJsL3Jlc291cmNlcy9mZXRjaC10ZXN0cy5qcyNMNTItTDU2XG4gICAgICAvLyBCdWZmZXIucmVzb2x2ZU9iamVjdFVSTCBkb2VzIG5vdCBpZ25vcmUgVVJMIHF1ZXJpZXMuXG4gICAgICBpZiAoYmxvYlVSTEVudHJ5LnNlYXJjaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLicpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9iID0gcmVzb2x2ZU9iamVjdFVSTChibG9iVVJMRW50cnkudG9TdHJpbmcoKSlcblxuICAgICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBgR0VUYCwgYmxvYlVSTEVudHJ5IGlzIG51bGwsIG9yIGJsb2JVUkxFbnRyeeKAmXNcbiAgICAgIC8vICAgIG9iamVjdCBpcyBub3QgYSBCbG9iIG9iamVjdCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJyB8fCAhaXNCbG9iTGlrZShibG9iKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ludmFsaWQgbWV0aG9kJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBibG9iIGJlIGJsb2JVUkxFbnRyeeKAmXMgb2JqZWN0LlxuICAgICAgLy8gTm90ZTogZG9uZSBhYm92ZVxuXG4gICAgICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgYSBuZXcgcmVzcG9uc2UuXG4gICAgICBjb25zdCByZXNwb25zZSA9IG1ha2VSZXNwb25zZSgpXG5cbiAgICAgIC8vIDUuIExldCBmdWxsTGVuZ3RoIGJlIGJsb2LigJlzIHNpemUuXG4gICAgICBjb25zdCBmdWxsTGVuZ3RoID0gYmxvYi5zaXplXG5cbiAgICAgIC8vIDYuIExldCBzZXJpYWxpemVkRnVsbExlbmd0aCBiZSBmdWxsTGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgICBjb25zdCBzZXJpYWxpemVkRnVsbExlbmd0aCA9IGlzb21vcnBoaWNFbmNvZGUoYCR7ZnVsbExlbmd0aH1gKVxuXG4gICAgICAvLyA3LiBMZXQgdHlwZSBiZSBibG9i4oCZcyB0eXBlLlxuICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZVxuXG4gICAgICAvLyA4LiBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBSYW5nZWA6XG4gICAgICAvLyA5LiBPdGhlcndpc2U6XG4gICAgICBpZiAoIXJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSkpIHtcbiAgICAgICAgLy8gMS4gTGV0IGJvZHlXaXRoVHlwZSBiZSB0aGUgcmVzdWx0IG9mIHNhZmVseSBleHRyYWN0aW5nIGJsb2IuXG4gICAgICAgIC8vIE5vdGU6IGluIHRoZSBGaWxlQVBJIGEgYmxvYiBcIm9iamVjdFwiIGlzIGEgQmxvYiAqb3IqIGEgTWVkaWFTb3VyY2UuXG4gICAgICAgIC8vIEluIG5vZGUsIHRoaXMgY2FuIG9ubHkgZXZlciBiZSBhIEJsb2IuIFRoZXJlZm9yZSB3ZSBjYW4gc2FmZWx5XG4gICAgICAgIC8vIHVzZSBleHRyYWN0Qm9keSBkaXJlY3RseS5cbiAgICAgICAgY29uc3QgYm9keVdpdGhUeXBlID0gZXh0cmFjdEJvZHkoYmxvYilcblxuICAgICAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGBPS2AuXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQgPSAnT0snXG5cbiAgICAgICAgLy8gMy4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGJvZHlXaXRoVHlwZeKAmXMgYm9keS5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9IGJvZHlXaXRoVHlwZVswXVxuXG4gICAgICAgIC8vIDQuIFNldCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgdG8gwqsgKGBDb250ZW50LUxlbmd0aGAsIHNlcmlhbGl6ZWRGdWxsTGVuZ3RoKSwgKGBDb250ZW50LVR5cGVgLCB0eXBlKSDCuy5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LWxlbmd0aCcsIHNlcmlhbGl6ZWRGdWxsTGVuZ3RoLCB0cnVlKVxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtdHlwZScsIHR5cGUsIHRydWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAxLiBTZXQgcmVzcG9uc2XigJlzIHJhbmdlLXJlcXVlc3RlZCBmbGFnLlxuICAgICAgICByZXNwb25zZS5yYW5nZVJlcXVlc3RlZCA9IHRydWVcblxuICAgICAgICAvLyAyLiBMZXQgcmFuZ2VIZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGBSYW5nZWAgZnJvbSByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnNMaXN0LmdldCgncmFuZ2UnLCB0cnVlKVxuXG4gICAgICAgIC8vIDMuIExldCByYW5nZVZhbHVlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhIHNpbmdsZSByYW5nZSBoZWFkZXIgdmFsdWUgZ2l2ZW4gcmFuZ2VIZWFkZXIgYW5kIHRydWUuXG4gICAgICAgIGNvbnN0IHJhbmdlVmFsdWUgPSBzaW1wbGVSYW5nZUhlYWRlclZhbHVlKHJhbmdlSGVhZGVyLCB0cnVlKVxuXG4gICAgICAgIC8vIDQuIElmIHJhbmdlVmFsdWUgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICBpZiAocmFuZ2VWYWx1ZSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdmYWlsZWQgdG8gZmV0Y2ggdGhlIGRhdGEgVVJMJykpXG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LiBMZXQgKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSBiZSByYW5nZVZhbHVlLlxuICAgICAgICBsZXQgeyByYW5nZVN0YXJ0VmFsdWU6IHJhbmdlU3RhcnQsIHJhbmdlRW5kVmFsdWU6IHJhbmdlRW5kIH0gPSByYW5nZVZhbHVlXG5cbiAgICAgICAgLy8gNi4gSWYgcmFuZ2VTdGFydCBpcyBudWxsOlxuICAgICAgICAvLyA3LiBPdGhlcndpc2U6XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gMS4gU2V0IHJhbmdlU3RhcnQgdG8gZnVsbExlbmd0aCDiiJIgcmFuZ2VFbmQuXG4gICAgICAgICAgcmFuZ2VTdGFydCA9IGZ1bGxMZW5ndGggLSByYW5nZUVuZFxuXG4gICAgICAgICAgLy8gMi4gU2V0IHJhbmdlRW5kIHRvIHJhbmdlU3RhcnQgKyByYW5nZUVuZCDiiJIgMS5cbiAgICAgICAgICByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyByYW5nZUVuZCAtIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAxLiBJZiByYW5nZVN0YXJ0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBmdWxsTGVuZ3RoLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPj0gZnVsbExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdSYW5nZSBzdGFydCBpcyBncmVhdGVyIHRoYW4gdGhlIGJsb2JcXCdzIHNpemUuJykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMi4gSWYgcmFuZ2VFbmQgaXMgbnVsbCBvciByYW5nZUVuZCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gZnVsbExlbmd0aCwgdGhlbiBzZXRcbiAgICAgICAgICAvLyAgICByYW5nZUVuZCB0byBmdWxsTGVuZ3RoIOKIkiAxLlxuICAgICAgICAgIGlmIChyYW5nZUVuZCA9PT0gbnVsbCB8fCByYW5nZUVuZCA+PSBmdWxsTGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZUVuZCA9IGZ1bGxMZW5ndGggLSAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gOC4gTGV0IHNsaWNlZEJsb2IgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyBzbGljZSBibG9iIGdpdmVuIGJsb2IsIHJhbmdlU3RhcnQsXG4gICAgICAgIC8vICAgIHJhbmdlRW5kICsgMSwgYW5kIHR5cGUuXG4gICAgICAgIGNvbnN0IHNsaWNlZEJsb2IgPSBibG9iLnNsaWNlKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCB0eXBlKVxuXG4gICAgICAgIC8vIDkuIExldCBzbGljZWRCb2R5V2l0aFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBzYWZlbHkgZXh0cmFjdGluZyBzbGljZWRCbG9iLlxuICAgICAgICAvLyBOb3RlOiBzYW1lIHJlYXNvbiBhcyBtZW50aW9uZWQgYWJvdmUgYXMgdG8gd2h5IHdlIHVzZSBleHRyYWN0Qm9keVxuICAgICAgICBjb25zdCBzbGljZWRCb2R5V2l0aFR5cGUgPSBleHRyYWN0Qm9keShzbGljZWRCbG9iKVxuXG4gICAgICAgIC8vIDEwLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gc2xpY2VkQm9keVdpdGhUeXBl4oCZcyBib2R5LlxuICAgICAgICByZXNwb25zZS5ib2R5ID0gc2xpY2VkQm9keVdpdGhUeXBlWzBdXG5cbiAgICAgICAgLy8gMTEuIExldCBzZXJpYWxpemVkU2xpY2VkTGVuZ3RoIGJlIHNsaWNlZEJsb2LigJlzIHNpemUsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFNsaWNlZExlbmd0aCA9IGlzb21vcnBoaWNFbmNvZGUoYCR7c2xpY2VkQmxvYi5zaXplfWApXG5cbiAgICAgICAgLy8gMTIuIExldCBjb250ZW50UmFuZ2UgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyBidWlsZCBhIGNvbnRlbnQgcmFuZ2UgZ2l2ZW4gcmFuZ2VTdGFydCxcbiAgICAgICAgLy8gICAgIHJhbmdlRW5kLCBhbmQgZnVsbExlbmd0aC5cbiAgICAgICAgY29uc3QgY29udGVudFJhbmdlID0gYnVpbGRDb250ZW50UmFuZ2UocmFuZ2VTdGFydCwgcmFuZ2VFbmQsIGZ1bGxMZW5ndGgpXG5cbiAgICAgICAgLy8gMTMuIFNldCByZXNwb25zZeKAmXMgc3RhdHVzIHRvIDIwNi5cbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID0gMjA2XG5cbiAgICAgICAgLy8gMTQuIFNldCByZXNwb25zZeKAmXMgc3RhdHVzIG1lc3NhZ2UgdG8gYFBhcnRpYWwgQ29udGVudGAuXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQgPSAnUGFydGlhbCBDb250ZW50J1xuXG4gICAgICAgIC8vIDE1LiBTZXQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IHRvIMKrIChgQ29udGVudC1MZW5ndGhgLCBzZXJpYWxpemVkU2xpY2VkTGVuZ3RoKSxcbiAgICAgICAgLy8gICAgIChgQ29udGVudC1UeXBlYCwgdHlwZSksIChgQ29udGVudC1SYW5nZWAsIGNvbnRlbnRSYW5nZSkgwrsuXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldCgnY29udGVudC1sZW5ndGgnLCBzZXJpYWxpemVkU2xpY2VkTGVuZ3RoLCB0cnVlKVxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtdHlwZScsIHR5cGUsIHRydWUpXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldCgnY29udGVudC1yYW5nZScsIGNvbnRlbnRSYW5nZSwgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgLy8gMTAuIFJldHVybiByZXNwb25zZS5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpXG4gICAgfVxuICAgIGNhc2UgJ2RhdGE6Jzoge1xuICAgICAgLy8gMS4gTGV0IGRhdGFVUkxTdHJ1Y3QgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZVxuICAgICAgLy8gICAgZGF0YTogVVJMIHByb2Nlc3NvciBvbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuICAgICAgY29uc3QgZGF0YVVSTFN0cnVjdCA9IGRhdGFVUkxQcm9jZXNzb3IoY3VycmVudFVSTClcblxuICAgICAgLy8gMi4gSWYgZGF0YVVSTFN0cnVjdCBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhXG4gICAgICAvLyAgICBuZXR3b3JrIGVycm9yLlxuICAgICAgaWYgKGRhdGFVUkxTdHJ1Y3QgPT09ICdmYWlsdXJlJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCB0aGUgZGF0YSBVUkwnKSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gTGV0IG1pbWVUeXBlIGJlIGRhdGFVUkxTdHJ1Y3TigJlzIE1JTUUgdHlwZSwgc2VyaWFsaXplZC5cbiAgICAgIGNvbnN0IG1pbWVUeXBlID0gc2VyaWFsaXplQU1pbWVUeXBlKGRhdGFVUkxTdHJ1Y3QubWltZVR5cGUpXG5cbiAgICAgIC8vIDQuIFJldHVybiBhIHJlc3BvbnNlIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsXG4gICAgICAvLyAgICBoZWFkZXIgbGlzdCBpcyDCqyAoYENvbnRlbnQtVHlwZWAsIG1pbWVUeXBlKSDCuyxcbiAgICAgIC8vICAgIGFuZCBib2R5IGlzIGRhdGFVUkxTdHJ1Y3TigJlzIGJvZHkgYXMgYSBib2R5LlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlUmVzcG9uc2Uoe1xuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzTGlzdDogW1xuICAgICAgICAgIFsnY29udGVudC10eXBlJywgeyBuYW1lOiAnQ29udGVudC1UeXBlJywgdmFsdWU6IG1pbWVUeXBlIH1dXG4gICAgICAgIF0sXG4gICAgICAgIGJvZHk6IHNhZmVseUV4dHJhY3RCb2R5KGRhdGFVUkxTdHJ1Y3QuYm9keSlbMF1cbiAgICAgIH0pKVxuICAgIH1cbiAgICBjYXNlICdmaWxlOic6IHtcbiAgICAgIC8vIEZvciBub3csIHVuZm9ydHVuYXRlIGFzIGl0IGlzLCBmaWxlIFVSTHMgYXJlIGxlZnQgYXMgYW4gZXhlcmNpc2UgZm9yIHRoZSByZWFkZXIuXG4gICAgICAvLyBXaGVuIGluIGRvdWJ0LCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdub3QgaW1wbGVtZW50ZWQuLi4geWV0Li4uJykpXG4gICAgfVxuICAgIGNhc2UgJ2h0dHA6JzpcbiAgICBjYXNlICdodHRwczonOiB7XG4gICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG5cbiAgICAgIHJldHVybiBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiBtYWtlTmV0d29ya0Vycm9yKGVycikpXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigndW5rbm93biBzY2hlbWUnKSlcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZpbmFsaXplLXJlc3BvbnNlXG5mdW5jdGlvbiBmaW5hbGl6ZVJlc3BvbnNlIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gU2V0IGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkb25lIGZsYWcuXG4gIGZldGNoUGFyYW1zLnJlcXVlc3QuZG9uZSA9IHRydWVcblxuICAvLyAyLCBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBkb25lIGlzIG5vdCBudWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2hcbiAgLy8gdGFzayB0byBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZG9uZSBnaXZlbiByZXNwb25zZSwgd2l0aFxuICAvLyBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZURvbmUgIT0gbnVsbCkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZURvbmUocmVzcG9uc2UpKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaC1maW5hbGVcbmZ1bmN0aW9uIGZldGNoRmluYWxlIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBsZXQgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyAyLiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgY2xpZW50IGlzIGEgc2VjdXJlIGNvbnRleHQsXG4gIC8vICAgIHRoZW4gc2V0IHRpbWluZ0luZm/igJlzIHNlcnZlci10aW1pbmcgaGVhZGVycyB0byB0aGUgcmVzdWx0IG9mIGdldHRpbmcsIGRlY29kaW5nLCBhbmQgc3BsaXR0aW5nXG4gIC8vICAgIGBTZXJ2ZXItVGltaW5nYCBmcm9tIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIFRPRE9cblxuICAvLyAzLiBMZXQgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IGJlIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gIGNvbnN0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSA9ICgpID0+IHtcbiAgICAvLyAxLiBMZXQgdW5zYWZlRW5kVGltZSBiZSB0aGUgdW5zYWZlIHNoYXJlZCBjdXJyZW50IHRpbWUuXG4gICAgY29uc3QgdW5zYWZlRW5kVGltZSA9IERhdGUubm93KCkgLy8gP1xuXG4gICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uIGlzIFwiZG9jdW1lbnRcIiwgdGhlbiBzZXQgZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXLigJlzXG4gICAgLy8gICAgZnVsbCB0aW1pbmcgaW5mbyB0byBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QuZGVzdGluYXRpb24gPT09ICdkb2N1bWVudCcpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZnVsbFRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG4gICAgfVxuXG4gICAgLy8gMy4gU2V0IGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVy4oCZcyByZXBvcnQgdGltaW5nIHN0ZXBzIHRvIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ2l2ZW4gYSBnbG9iYWwgb2JqZWN0IGdsb2JhbDpcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlcG9ydFRpbWluZ1N0ZXBzID0gKCkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4uXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucmVxdWVzdC51cmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgdGltaW5nSW5mb+KAmXMgZW5kIHRpbWUgdG8gdGhlIHJlbGF0aXZlIGhpZ2ggcmVzb2x1dGlvbiB0aW1lIGdpdmVuIHVuc2FmZUVuZFRpbWUgYW5kIGdsb2JhbC5cbiAgICAgIHRpbWluZ0luZm8uZW5kVGltZSA9IHVuc2FmZUVuZFRpbWVcblxuICAgICAgLy8gMy4gTGV0IGNhY2hlU3RhdGUgYmUgcmVzcG9uc2XigJlzIGNhY2hlIHN0YXRlLlxuICAgICAgbGV0IGNhY2hlU3RhdGUgPSByZXNwb25zZS5jYWNoZVN0YXRlXG5cbiAgICAgIC8vIDQuIExldCBib2R5SW5mbyBiZSByZXNwb25zZeKAmXMgYm9keSBpbmZvLlxuICAgICAgY29uc3QgYm9keUluZm8gPSByZXNwb25zZS5ib2R5SW5mb1xuXG4gICAgICAvLyA1LiBJZiByZXNwb25zZeKAmXMgdGltaW5nIGFsbG93IHBhc3NlZCBmbGFnIGlzIG5vdCBzZXQsIHRoZW4gc2V0IHRpbWluZ0luZm8gdG8gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhblxuICAgICAgLy8gICAgb3BhcXVlIHRpbWluZyBpbmZvIGZvciB0aW1pbmdJbmZvIGFuZCBzZXQgY2FjaGVTdGF0ZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgaWYgKCFyZXNwb25zZS50aW1pbmdBbGxvd1Bhc3NlZCkge1xuICAgICAgICB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh0aW1pbmdJbmZvKVxuXG4gICAgICAgIGNhY2hlU3RhdGUgPSAnJ1xuICAgICAgfVxuXG4gICAgICAvLyA2LiBMZXQgcmVzcG9uc2VTdGF0dXMgYmUgMC5cbiAgICAgIGxldCByZXNwb25zZVN0YXR1cyA9IDBcblxuICAgICAgLy8gNy4gSWYgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIG1vZGUgaXMgbm90IFwibmF2aWdhdGVcIiBvciByZXNwb25zZeKAmXMgaGFzLWNyb3NzLW9yaWdpbi1yZWRpcmVjdHMgaXMgZmFsc2U6XG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucmVxdWVzdC5tb2RlICE9PSAnbmF2aWdhdG9yJyB8fCAhcmVzcG9uc2UuaGFzQ3Jvc3NPcmlnaW5SZWRpcmVjdHMpIHtcbiAgICAgICAgLy8gMS4gU2V0IHJlc3BvbnNlU3RhdHVzIHRvIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gICAgICAgIHJlc3BvbnNlU3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzXG5cbiAgICAgICAgLy8gMi4gTGV0IG1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBhIE1JTUUgdHlwZSBmcm9tIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBleHRyYWN0TWltZVR5cGUocmVzcG9uc2UuaGVhZGVyc0xpc3QpXG5cbiAgICAgICAgLy8gMy4gSWYgbWltZVR5cGUgaXMgbm90IGZhaWx1cmUsIHRoZW4gc2V0IGJvZHlJbmZv4oCZcyBjb250ZW50IHR5cGUgdG8gdGhlIHJlc3VsdCBvZiBtaW5pbWl6aW5nIGEgc3VwcG9ydGVkIE1JTUUgdHlwZSBnaXZlbiBtaW1lVHlwZS5cbiAgICAgICAgaWYgKG1pbWVUeXBlICE9PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICBib2R5SW5mby5jb250ZW50VHlwZSA9IG1pbmltaXplU3VwcG9ydGVkTWltZVR5cGUobWltZVR5cGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gOC4gSWYgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGluaXRpYXRvciB0eXBlIGlzIG5vbi1udWxsLCB0aGVuIG1hcmsgcmVzb3VyY2UgdGltaW5nIGdpdmVuIHRpbWluZ0luZm8sXG4gICAgICAvLyAgICBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgVVJMLCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIHR5cGUsIGdsb2JhbCwgY2FjaGVTdGF0ZSwgYm9keUluZm8sXG4gICAgICAvLyAgICBhbmQgcmVzcG9uc2VTdGF0dXMuXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucmVxdWVzdC5pbml0aWF0b3JUeXBlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIG1hcmtyZXNvdXJjZXRpbWluZ1xuICAgICAgICBtYXJrUmVzb3VyY2VUaW1pbmcodGltaW5nSW5mbywgZmV0Y2hQYXJhbXMucmVxdWVzdC51cmwuaHJlZiwgZmV0Y2hQYXJhbXMucmVxdWVzdC5pbml0aWF0b3JUeXBlLCBnbG9iYWxUaGlzLCBjYWNoZVN0YXRlLCBib2R5SW5mbywgcmVzcG9uc2VTdGF0dXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVRhc2sgYmUgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrID0gKCkgPT4ge1xuICAgICAgLy8gMS4gU2V0IGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkb25lIGZsYWcuXG4gICAgICBmZXRjaFBhcmFtcy5yZXF1ZXN0LmRvbmUgPSB0cnVlXG5cbiAgICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIG5vbi1udWxsLCB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2Vzc1xuICAgICAgLy8gICAgcmVzcG9uc2UgZW5kLW9mLWJvZHkgZ2l2ZW4gcmVzcG9uc2UuXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5ICE9IG51bGwpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KHJlc3BvbnNlKSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGluaXRpYXRvciB0eXBlIGlzIG5vbi1udWxsIGFuZCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgY2xpZW504oCZc1xuICAgICAgLy8gICAgZ2xvYmFsIG9iamVjdCBpcyBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbiwgdGhlbiBydW4gZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXLigJlzIHJlcG9ydFxuICAgICAgLy8gICAgdGltaW5nIHN0ZXBzIGdpdmVuIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucmVxdWVzdC5pbml0aWF0b3JUeXBlICE9IG51bGwpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXBvcnRUaW1pbmdTdGVwcygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4gUXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrIHdpdGggZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb25cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrKCkpXG4gIH1cblxuICAvLyA0LiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBpcyBub24tbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIGZldGNoUGFyYW1z4oCZc1xuICAvLyAgICBwcm9jZXNzIHJlc3BvbnNlIGdpdmVuIHJlc3BvbnNlLCB3aXRoIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlICE9IG51bGwpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpXG4gICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UgPSBudWxsXG4gICAgfSlcbiAgfVxuXG4gIC8vIDUuIExldCBpbnRlcm5hbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3I7IG90aGVyd2lzZSByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2UuXG4gIGNvbnN0IGludGVybmFsUmVzcG9uc2UgPSByZXNwb25zZS50eXBlID09PSAnZXJyb3InID8gcmVzcG9uc2UgOiAocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSA/PyByZXNwb25zZSlcblxuICAvLyA2LiBJZiBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcnVuIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keS5cbiAgLy8gNy4gT3RoZXJ3aXNlOlxuICBpZiAoaW50ZXJuYWxSZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkoKVxuICB9IGVsc2Uge1xuICAgIC8vIG1jb2xsaW5hOiBhbGwgdGhlIGZvbGxvd2luZyBzdGVwcyBvZiB0aGUgc3BlY3MgYXJlIHNraXBwZWQuXG4gICAgLy8gVGhlIGludGVybmFsIHRyYW5zZm9ybSBzdHJlYW0gaXMgbm90IG5lZWRlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvcHVsbC8zMDkzI2lzc3VlY29tbWVudC0yMDUwMTk4NTQxXG5cbiAgICAvLyAxLiBMZXQgdHJhbnNmb3JtU3RyZWFtIGJlIGEgbmV3IFRyYW5zZm9ybVN0cmVhbS5cbiAgICAvLyAyLiBMZXQgaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHdoaWNoLCBnaXZlbiBjaHVuaywgZW5xdWV1ZXMgY2h1bmsgaW4gdHJhbnNmb3JtU3RyZWFtLlxuICAgIC8vIDMuIFNldCB1cCB0cmFuc2Zvcm1TdHJlYW0gd2l0aCB0cmFuc2Zvcm1BbGdvcml0aG0gc2V0IHRvIGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtIGFuZCBmbHVzaEFsZ29yaXRobVxuICAgIC8vICAgIHNldCB0byBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkuXG4gICAgLy8gNC4gU2V0IGludGVybmFsUmVzcG9uc2XigJlzIGJvZHnigJlzIHN0cmVhbSB0byB0aGUgcmVzdWx0IG9mIGludGVybmFsUmVzcG9uc2XigJlzIGJvZHnigJlzIHN0cmVhbSBwaXBlZCB0aHJvdWdoIHRyYW5zZm9ybVN0cmVhbS5cblxuICAgIGZpbmlzaGVkKGludGVybmFsUmVzcG9uc2UuYm9keS5zdHJlYW0sICgpID0+IHtcbiAgICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSgpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cEZldGNoIChmZXRjaFBhcmFtcykge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCBhY3R1YWxSZXNwb25zZSBiZSBudWxsLlxuICBsZXQgYWN0dWFsUmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gNC4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDUuIElmIHJlcXVlc3TigJlzIHNlcnZpY2Utd29ya2VycyBtb2RlIGlzIFwiYWxsXCIsIHRoZW46XG4gIGlmIChyZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID09PSAnYWxsJykge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDYuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgIC8vIDEuIElmIG1ha2VDT1JTUHJlZmxpZ2h0IGlzIHRydWUgYW5kIG9uZSBvZiB0aGVzZSBjb25kaXRpb25zIGlzIHRydWU6XG4gICAgLy8gVE9ET1xuXG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpcyBcImZvbGxvd1wiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAgIC8vIHNlcnZpY2Utd29ya2VycyBtb2RlIHRvIFwibm9uZVwiLlxuICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgcmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9ICdub25lJ1xuICAgIH1cblxuICAgIC8vIDMuIFNldCByZXNwb25zZSBhbmQgYWN0dWFsUmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgLy8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgIGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChmZXRjaFBhcmFtcylcblxuICAgIC8vIDQuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIGFuZCBhIENPUlMgY2hlY2tcbiAgICAvLyBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcmV0dXJucyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKFxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgJiZcbiAgICAgIGNvcnNDaGVjayhyZXF1ZXN0LCByZXNwb25zZSkgPT09ICdmYWlsdXJlJ1xuICAgICkge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ2NvcnMgZmFpbHVyZScpXG4gICAgfVxuXG4gICAgLy8gNS4gSWYgdGhlIFRBTyBjaGVjayBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcmV0dXJucyBmYWlsdXJlLCB0aGVuIHNldFxuICAgIC8vIHJlcXVlc3TigJlzIHRpbWluZyBhbGxvdyBmYWlsZWQgZmxhZy5cbiAgICBpZiAoVEFPQ2hlY2socmVxdWVzdCwgcmVzcG9uc2UpID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJlcXVlc3QudGltaW5nQWxsb3dGYWlsZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gNy4gSWYgZWl0aGVyIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIG9yIHJlc3BvbnNl4oCZcyB0eXBlXG4gIC8vIGlzIFwib3BhcXVlXCIsIGFuZCB0aGUgY3Jvc3Mtb3JpZ2luIHJlc291cmNlIHBvbGljeSBjaGVjayB3aXRoXG4gIC8vIHJlcXVlc3TigJlzIG9yaWdpbiwgcmVxdWVzdOKAmXMgY2xpZW50LCByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbixcbiAgLy8gYW5kIGFjdHVhbFJlc3BvbnNlIHJldHVybnMgYmxvY2tlZCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScgfHwgcmVzcG9uc2UudHlwZSA9PT0gJ29wYXF1ZScpICYmXG4gICAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrKFxuICAgICAgcmVxdWVzdC5vcmlnaW4sXG4gICAgICByZXF1ZXN0LmNsaWVudCxcbiAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24sXG4gICAgICBhY3R1YWxSZXNwb25zZVxuICAgICkgPT09ICdibG9ja2VkJ1xuICApIHtcbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignYmxvY2tlZCcpXG4gIH1cblxuICAvLyA4LiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuOlxuICBpZiAocmVkaXJlY3RTdGF0dXNTZXQuaGFzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAvLyAxLiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIG5vdCAzMDMsIHJlcXVlc3TigJlzIGJvZHkgaXMgbm90IG51bGwsXG4gICAgLy8gYW5kIHRoZSBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHVzZXIgYWdlbnRzIG1heSwgYW5kIGFyZSBldmVuXG4gICAgLy8gZW5jb3VyYWdlZCB0bywgdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODhcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KHVuZGVmaW5lZCwgZmFsc2UpXG4gICAgfVxuXG4gICAgLy8gMi4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGU6XG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdlcnJvcicpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ3VuZXhwZWN0ZWQgcmVkaXJlY3QnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ21hbnVhbCcpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byBhbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgaW50ZXJuYWxcbiAgICAgIC8vIHJlc3BvbnNlIGlzIGFjdHVhbFJlc3BvbnNlLlxuICAgICAgLy8gTk9URShzcGVjKTogT24gdGhlIHdlYiB0aGlzIHdvdWxkIHJldHVybiBhbiBgb3BhcXVlcmVkaXJlY3RgIHJlc3BvbnNlLFxuICAgICAgLy8gYnV0IHRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIHNlcnZlciBzaWRlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMTkzLlxuICAgICAgcmVzcG9uc2UgPSBhY3R1YWxSZXNwb25zZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1yZWRpcmVjdCBmZXRjaCBnaXZlblxuICAgICAgLy8gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBodHRwUmVkaXJlY3RGZXRjaChmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvLyA5LiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRpbWluZ0luZm8uXG4gIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG5cbiAgLy8gMTAuIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXJlZGlyZWN0LWZldGNoXG5mdW5jdGlvbiBodHRwUmVkaXJlY3RGZXRjaCAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCBhY3R1YWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgbm90IGEgZmlsdGVyZWQgcmVzcG9uc2UsXG4gIC8vIGFuZCByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2Ugb3RoZXJ3aXNlLlxuICBjb25zdCBhY3R1YWxSZXNwb25zZSA9IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2VcbiAgICA/IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2VcbiAgICA6IHJlc3BvbnNlXG5cbiAgLy8gMy4gTGV0IGxvY2F0aW9uVVJMIGJlIGFjdHVhbFJlc3BvbnNl4oCZcyBsb2NhdGlvbiBVUkwgZ2l2ZW4gcmVxdWVzdOKAmXMgY3VycmVudFxuICAvLyBVUkzigJlzIGZyYWdtZW50LlxuICBsZXQgbG9jYXRpb25VUkxcblxuICB0cnkge1xuICAgIGxvY2F0aW9uVVJMID0gcmVzcG9uc2VMb2NhdGlvblVSTChcbiAgICAgIGFjdHVhbFJlc3BvbnNlLFxuICAgICAgcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkuaGFzaFxuICAgIClcblxuICAgIC8vIDQuIElmIGxvY2F0aW9uVVJMIGlzIG51bGwsIHRoZW4gcmV0dXJuIHJlc3BvbnNlLlxuICAgIGlmIChsb2NhdGlvblVSTCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIDUuIElmIGxvY2F0aW9uVVJMIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoZXJyKSlcbiAgfVxuXG4gIC8vIDYuIElmIGxvY2F0aW9uVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgLy8gZXJyb3IuXG4gIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUobG9jYXRpb25VUkwpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdVUkwgc2NoZW1lIG11c3QgYmUgYSBIVFRQKFMpIHNjaGVtZScpKVxuICB9XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgY291bnQgaXMgMjAsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKHJlcXVlc3QucmVkaXJlY3RDb3VudCA9PT0gMjApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ3JlZGlyZWN0IGNvdW50IGV4Y2VlZGVkJykpXG4gIH1cblxuICAvLyA4LiBJbmNyZWFzZSByZXF1ZXN04oCZcyByZWRpcmVjdCBjb3VudCBieSAxLlxuICByZXF1ZXN0LnJlZGlyZWN0Q291bnQgKz0gMVxuXG4gIC8vIDkuIElmIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJjb3JzXCIsIGxvY2F0aW9uVVJMIGluY2x1ZGVzIGNyZWRlbnRpYWxzLCBhbmRcbiAgLy8gcmVxdWVzdOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIGxvY2F0aW9uVVJM4oCZcyBvcmlnaW4sIHRoZW4gcmV0dXJuXG4gIC8vICBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXF1ZXN0Lm1vZGUgPT09ICdjb3JzJyAmJlxuICAgIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZCkgJiZcbiAgICAhc2FtZU9yaWdpbihyZXF1ZXN0LCBsb2NhdGlvblVSTClcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdjcm9zcyBvcmlnaW4gbm90IGFsbG93ZWQgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIicpKVxuICB9XG5cbiAgLy8gMTAuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIGFuZCBsb2NhdGlvblVSTCBpbmNsdWRlc1xuICAvLyBjcmVkZW50aWFscywgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgJiZcbiAgICAobG9jYXRpb25VUkwudXNlcm5hbWUgfHwgbG9jYXRpb25VUkwucGFzc3dvcmQpXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICdVUkwgY2Fubm90IGNvbnRhaW4gY3JlZGVudGlhbHMgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIidcbiAgICApKVxuICB9XG5cbiAgLy8gMTEuIElmIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IDMwMywgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCxcbiAgLy8gYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICBhY3R1YWxSZXNwb25zZS5zdGF0dXMgIT09IDMwMyAmJlxuICAgIHJlcXVlc3QuYm9keSAhPSBudWxsICYmXG4gICAgcmVxdWVzdC5ib2R5LnNvdXJjZSA9PSBudWxsXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigpKVxuICB9XG5cbiAgLy8gMTIuIElmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWVcbiAgLy8gLSBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwMSBvciAzMDIgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBgUE9TVGBcbiAgLy8gLSBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwMyBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBgR0VUYCBvciBgSEVBRGBcbiAgaWYgKFxuICAgIChbMzAxLCAzMDJdLmluY2x1ZGVzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykgfHxcbiAgICAoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzID09PSAzMDMgJiZcbiAgICAgICFHRVRfT1JfSEVBRC5pbmNsdWRlcyhyZXF1ZXN0Lm1ldGhvZCkpXG4gICkge1xuICAgIC8vIHRoZW46XG4gICAgLy8gMS4gU2V0IHJlcXVlc3TigJlzIG1ldGhvZCB0byBgR0VUYCBhbmQgcmVxdWVzdOKAmXMgYm9keSB0byBudWxsLlxuICAgIHJlcXVlc3QubWV0aG9kID0gJ0dFVCdcbiAgICByZXF1ZXN0LmJvZHkgPSBudWxsXG5cbiAgICAvLyAyLiBGb3IgZWFjaCBoZWFkZXJOYW1lIG9mIHJlcXVlc3QtYm9keS1oZWFkZXIgbmFtZSwgZGVsZXRlIGhlYWRlck5hbWUgZnJvbVxuICAgIC8vIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiByZXF1ZXN0Qm9keUhlYWRlcikge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoaGVhZGVyTmFtZSlcbiAgICB9XG4gIH1cblxuICAvLyAxMy4gSWYgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBsb2NhdGlvblVSTOKAmXNcbiAgLy8gICAgIG9yaWdpbiwgdGhlbiBmb3IgZWFjaCBoZWFkZXJOYW1lIG9mIENPUlMgbm9uLXdpbGRjYXJkIHJlcXVlc3QtaGVhZGVyIG5hbWUsXG4gIC8vICAgICBkZWxldGUgaGVhZGVyTmFtZSBmcm9tIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIXNhbWVPcmlnaW4ocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCksIGxvY2F0aW9uVVJMKSkge1xuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb3JzLW5vbi13aWxkY2FyZC1yZXF1ZXN0LWhlYWRlci1uYW1lXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2F1dGhvcml6YXRpb24nLCB0cnVlKVxuXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2F1dGhlbnRpY2F0aW9uLWVudHJpZXNcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgncHJveHktYXV0aG9yaXphdGlvbicsIHRydWUpXG5cbiAgICAvLyBcIkNvb2tpZVwiIGFuZCBcIkhvc3RcIiBhcmUgZm9yYmlkZGVuIHJlcXVlc3QtaGVhZGVycywgd2hpY2ggdW5kaWNpIGRvZXNuJ3QgaW1wbGVtZW50LlxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdjb29raWUnLCB0cnVlKVxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdob3N0JywgdHJ1ZSlcbiAgfVxuXG4gIC8vIDE0LiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBib2R5IHRvIHRoZSBmaXJzdCByZXR1cm5cbiAgLy8gdmFsdWUgb2Ygc2FmZWx5IGV4dHJhY3RpbmcgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlLlxuICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICBhc3NlcnQocmVxdWVzdC5ib2R5LnNvdXJjZSAhPSBudWxsKVxuICAgIHJlcXVlc3QuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KHJlcXVlc3QuYm9keS5zb3VyY2UpWzBdXG4gIH1cblxuICAvLyAxNS4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDE2LiBTZXQgdGltaW5nSW5mb+KAmXMgcmVkaXJlY3QgZW5kIHRpbWUgYW5kIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSB0byB0aGVcbiAgLy8gY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyBjYXBhYmlsaXR5LlxuICB0aW1pbmdJbmZvLnJlZGlyZWN0RW5kVGltZSA9IHRpbWluZ0luZm8ucG9zdFJlZGlyZWN0U3RhcnRUaW1lID1cbiAgICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcblxuICAvLyAxNy4gSWYgdGltaW5nSW5mb+KAmXMgcmVkaXJlY3Qgc3RhcnQgdGltZSBpcyAwLCB0aGVuIHNldCB0aW1pbmdJbmZv4oCZc1xuICAvLyAgcmVkaXJlY3Qgc3RhcnQgdGltZSB0byB0aW1pbmdJbmZv4oCZcyBzdGFydCB0aW1lLlxuICBpZiAodGltaW5nSW5mby5yZWRpcmVjdFN0YXJ0VGltZSA9PT0gMCkge1xuICAgIHRpbWluZ0luZm8ucmVkaXJlY3RTdGFydFRpbWUgPSB0aW1pbmdJbmZvLnN0YXJ0VGltZVxuICB9XG5cbiAgLy8gMTguIEFwcGVuZCBsb2NhdGlvblVSTCB0byByZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgcmVxdWVzdC51cmxMaXN0LnB1c2gobG9jYXRpb25VUkwpXG5cbiAgLy8gMTkuIEludm9rZSBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IG9uIHJlZGlyZWN0IG9uIHJlcXVlc3QgYW5kXG4gIC8vIGFjdHVhbFJlc3BvbnNlLlxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0KHJlcXVlc3QsIGFjdHVhbFJlc3BvbnNlKVxuXG4gIC8vIDIwLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIG1haW4gZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gIHJldHVybiBtYWluRmV0Y2goZmV0Y2hQYXJhbXMsIHRydWUpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLW5ldHdvcmstb3ItY2FjaGUtZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoIChcbiAgZmV0Y2hQYXJhbXMsXG4gIGlzQXV0aGVudGljYXRpb25GZXRjaCA9IGZhbHNlLFxuICBpc05ld0Nvbm5lY3Rpb25GZXRjaCA9IGZhbHNlXG4pIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IGh0dHBGZXRjaFBhcmFtcyBiZSBudWxsLlxuICBsZXQgaHR0cEZldGNoUGFyYW1zID0gbnVsbFxuXG4gIC8vIDMuIExldCBodHRwUmVxdWVzdCBiZSBudWxsLlxuICBsZXQgaHR0cFJlcXVlc3QgPSBudWxsXG5cbiAgLy8gNC4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyA1LiBMZXQgc3RvcmVkUmVzcG9uc2UgYmUgbnVsbC5cbiAgLy8gVE9ETzogY2FjaGVcblxuICAvLyA2LiBMZXQgaHR0cENhY2hlIGJlIG51bGwuXG4gIGNvbnN0IGh0dHBDYWNoZSA9IG51bGxcblxuICAvLyA3LiBMZXQgdGhlIHJldmFsaWRhdGluZ0ZsYWcgYmUgdW5zZXQuXG4gIGNvbnN0IHJldmFsaWRhdGluZ0ZsYWcgPSBmYWxzZVxuXG4gIC8vIDguIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZDpcblxuICAvLyAgICAxLiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgXCJuby13aW5kb3dcIiBhbmQgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpc1xuICAvLyAgICBcImVycm9yXCIsIHRoZW4gc2V0IGh0dHBGZXRjaFBhcmFtcyB0byBmZXRjaFBhcmFtcyBhbmQgaHR0cFJlcXVlc3QgdG9cbiAgLy8gICAgcmVxdWVzdC5cbiAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnbm8td2luZG93JyAmJiByZXF1ZXN0LnJlZGlyZWN0ID09PSAnZXJyb3InKSB7XG4gICAgaHR0cEZldGNoUGFyYW1zID0gZmV0Y2hQYXJhbXNcbiAgICBodHRwUmVxdWVzdCA9IHJlcXVlc3RcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBTZXQgaHR0cFJlcXVlc3QgdG8gYSBjbG9uZSBvZiByZXF1ZXN0LlxuICAgIGh0dHBSZXF1ZXN0ID0gY2xvbmVSZXF1ZXN0KHJlcXVlc3QpXG5cbiAgICAvLyAyLiBTZXQgaHR0cEZldGNoUGFyYW1zIHRvIGEgY29weSBvZiBmZXRjaFBhcmFtcy5cbiAgICBodHRwRmV0Y2hQYXJhbXMgPSB7IC4uLmZldGNoUGFyYW1zIH1cblxuICAgIC8vIDMuIFNldCBodHRwRmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QgdG8gaHR0cFJlcXVlc3QuXG4gICAgaHR0cEZldGNoUGFyYW1zLnJlcXVlc3QgPSBodHRwUmVxdWVzdFxuICB9XG5cbiAgLy8gICAgMy4gTGV0IGluY2x1ZGVDcmVkZW50aWFscyBiZSB0cnVlIGlmIG9uZSBvZlxuICBjb25zdCBpbmNsdWRlQ3JlZGVudGlhbHMgPVxuICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJyB8fFxuICAgIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnc2FtZS1vcmlnaW4nICYmXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdiYXNpYycpXG5cbiAgLy8gICAgNC4gTGV0IGNvbnRlbnRMZW5ndGggYmUgaHR0cFJlcXVlc3TigJlzIGJvZHnigJlzIGxlbmd0aCwgaWYgaHR0cFJlcXVlc3TigJlzXG4gIC8vICAgIGJvZHkgaXMgbm9uLW51bGw7IG90aGVyd2lzZSBudWxsLlxuICBjb25zdCBjb250ZW50TGVuZ3RoID0gaHR0cFJlcXVlc3QuYm9keSA/IGh0dHBSZXF1ZXN0LmJvZHkubGVuZ3RoIDogbnVsbFxuXG4gIC8vICAgIDUuIExldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgYmUgbnVsbC5cbiAgbGV0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSA9IG51bGxcblxuICAvLyAgICA2LiBJZiBodHRwUmVxdWVzdOKAmXMgYm9keSBpcyBudWxsIGFuZCBodHRwUmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBQT1NUYCBvclxuICAvLyAgICBgUFVUYCwgdGhlbiBzZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIHRvIGAwYC5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmJvZHkgPT0gbnVsbCAmJlxuICAgIFsnUE9TVCcsICdQVVQnXS5pbmNsdWRlcyhodHRwUmVxdWVzdC5tZXRob2QpXG4gICkge1xuICAgIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSA9ICcwJ1xuICB9XG5cbiAgLy8gICAgNy4gSWYgY29udGVudExlbmd0aCBpcyBub24tbnVsbCwgdGhlbiBzZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIHRvXG4gIC8vICAgIGNvbnRlbnRMZW5ndGgsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSA9IGlzb21vcnBoaWNFbmNvZGUoYCR7Y29udGVudExlbmd0aH1gKVxuICB9XG5cbiAgLy8gICAgOC4gSWYgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGlzIG5vbi1udWxsLCB0aGVuIGFwcGVuZFxuICAvLyAgICBgQ29udGVudC1MZW5ndGhgL2NvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QuXG4gIGlmIChjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgIT0gbnVsbCkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnY29udGVudC1sZW5ndGgnLCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUsIHRydWUpXG4gIH1cblxuICAvLyAgICA5LiBJZiBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgaXMgbm9uLW51bGwsIHRoZW4gYXBwZW5kIChgQ29udGVudC1MZW5ndGhgLFxuICAvLyAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUpIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cblxuICAvLyAgICAxMC4gSWYgY29udGVudExlbmd0aCBpcyBub24tbnVsbCBhbmQgaHR0cFJlcXVlc3TigJlzIGtlZXBhbGl2ZSBpcyB0cnVlLFxuICAvLyAgICB0aGVuOlxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsICYmIGh0dHBSZXF1ZXN0LmtlZXBhbGl2ZSkge1xuICAgIC8vIE5PVEU6IGtlZXBhbGl2ZSBpcyBhIG5vb3Agb3V0c2lkZSBvZiBicm93c2VyIGNvbnRleHQuXG4gIH1cblxuICAvLyAgICAxMS4gSWYgaHR0cFJlcXVlc3TigJlzIHJlZmVycmVyIGlzIGEgVVJMLCB0aGVuIGFwcGVuZFxuICAvLyAgICBgUmVmZXJlcmAvaHR0cFJlcXVlc3TigJlzIHJlZmVycmVyLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQsXG4gIC8vICAgICB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChodHRwUmVxdWVzdC5yZWZlcnJlciBpbnN0YW5jZW9mIFVSTCkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgncmVmZXJlcicsIGlzb21vcnBoaWNFbmNvZGUoaHR0cFJlcXVlc3QucmVmZXJyZXIuaHJlZiksIHRydWUpXG4gIH1cblxuICAvLyAgICAxMi4gQXBwZW5kIGEgcmVxdWVzdCBgT3JpZ2luYCBoZWFkZXIgZm9yIGh0dHBSZXF1ZXN0LlxuICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyKGh0dHBSZXF1ZXN0KVxuXG4gIC8vICAgIDEzLiBBcHBlbmQgdGhlIEZldGNoIG1ldGFkYXRhIGhlYWRlcnMgZm9yIGh0dHBSZXF1ZXN0LiBbRkVUQ0gtTUVUQURBVEFdXG4gIGFwcGVuZEZldGNoTWV0YWRhdGEoaHR0cFJlcXVlc3QpXG5cbiAgLy8gICAgMTQuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBVc2VyLUFnZW50YCwgdGhlblxuICAvLyAgICB1c2VyIGFnZW50cyBzaG91bGQgYXBwZW5kIGBVc2VyLUFnZW50YC9kZWZhdWx0IGBVc2VyLUFnZW50YCB2YWx1ZSB0b1xuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3VzZXItYWdlbnQnLCB0cnVlKSkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgndXNlci1hZ2VudCcsIGRlZmF1bHRVc2VyQWdlbnQpXG4gIH1cblxuICAvLyAgICAxNS4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJkZWZhdWx0XCIgYW5kIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdCBjb250YWlucyBgSWYtTW9kaWZpZWQtU2luY2VgLCBgSWYtTm9uZS1NYXRjaGAsXG4gIC8vICAgIGBJZi1Vbm1vZGlmaWVkLVNpbmNlYCwgYElmLU1hdGNoYCwgb3IgYElmLVJhbmdlYCwgdGhlbiBzZXRcbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICBpZiAoXG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPT09ICdkZWZhdWx0JyAmJlxuICAgIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbW9kaWZpZWQtc2luY2UnLCB0cnVlKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLW5vbmUtbWF0Y2gnLCB0cnVlKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLXVubW9kaWZpZWQtc2luY2UnLCB0cnVlKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLW1hdGNoJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1yYW5nZScsIHRydWUpKVxuICApIHtcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcbiAgfVxuXG4gIC8vICAgIDE2LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm5vLWNhY2hlXCIsIGh0dHBSZXF1ZXN04oCZcyBwcmV2ZW50XG4gIC8vICAgIG5vLWNhY2hlIGNhY2hlLWNvbnRyb2wgaGVhZGVyIG1vZGlmaWNhdGlvbiBmbGFnIGlzIHVuc2V0LCBhbmRcbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYENhY2hlLUNvbnRyb2xgLCB0aGVuIGFwcGVuZFxuICAvLyAgICBgQ2FjaGUtQ29udHJvbGAvYG1heC1hZ2U9MGAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoXG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPT09ICduby1jYWNoZScgJiZcbiAgICAhaHR0cFJlcXVlc3QucHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24gJiZcbiAgICAhaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NhY2hlLWNvbnRyb2wnLCB0cnVlKVxuICApIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NhY2hlLWNvbnRyb2wnLCAnbWF4LWFnZT0wJywgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDE3LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm5vLXN0b3JlXCIgb3IgXCJyZWxvYWRcIiwgdGhlbjpcbiAgaWYgKGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IGh0dHBSZXF1ZXN0LmNhY2hlID09PSAncmVsb2FkJykge1xuICAgIC8vIDEuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBQcmFnbWFgLCB0aGVuIGFwcGVuZFxuICAgIC8vIGBQcmFnbWFgL2Buby1jYWNoZWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ByYWdtYScsIHRydWUpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3ByYWdtYScsICduby1jYWNoZScsIHRydWUpXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYENhY2hlLUNvbnRyb2xgLFxuICAgIC8vIHRoZW4gYXBwZW5kIGBDYWNoZS1Db250cm9sYC9gbm8tY2FjaGVgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdjYWNoZS1jb250cm9sJywgdHJ1ZSkpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnY2FjaGUtY29udHJvbCcsICduby1jYWNoZScsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgLy8gICAgMTguIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgUmFuZ2VgLCB0aGVuIGFwcGVuZFxuICAvLyAgICBgQWNjZXB0LUVuY29kaW5nYC9gaWRlbnRpdHlgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdyYW5nZScsIHRydWUpKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHknLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgMTkuIE1vZGlmeSBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgcGVyIEhUVFAuIERvIG5vdCBhcHBlbmQgYSBnaXZlblxuICAvLyAgICBoZWFkZXIgaWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIHRoYXQgaGVhZGVy4oCZcyBuYW1lLlxuICAvLyAgICBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8xMjg1I2lzc3VlY29tbWVudC04OTY1NjAxMjlcbiAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0LWVuY29kaW5nJywgdHJ1ZSkpIHtcbiAgICBpZiAodXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdEN1cnJlbnRVUkwoaHR0cFJlcXVlc3QpKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtZW5jb2RpbmcnLCAnYnIsIGd6aXAsIGRlZmxhdGUnLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdnemlwLCBkZWZsYXRlJywgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2hvc3QnLCB0cnVlKVxuXG4gIC8vICAgIDIwLiBJZiBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSwgdGhlbjpcbiAgaWYgKGluY2x1ZGVDcmVkZW50aWFscykge1xuICAgIC8vIDEuIElmIHRoZSB1c2VyIGFnZW50IGlzIG5vdCBjb25maWd1cmVkIHRvIGJsb2NrIGNvb2tpZXMgZm9yIGh0dHBSZXF1ZXN0XG4gICAgLy8gKHNlZSBzZWN0aW9uIDcgb2YgW0NPT0tJRVNdKSwgdGhlbjpcbiAgICAvLyBUT0RPOiBjcmVkZW50aWFsc1xuICAgIC8vIDIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBBdXRob3JpemF0aW9uYCwgdGhlbjpcbiAgICAvLyBUT0RPOiBjcmVkZW50aWFsc1xuICB9XG5cbiAgLy8gICAgMjEuIElmIHRoZXJl4oCZcyBhIHByb3h5LWF1dGhlbnRpY2F0aW9uIGVudHJ5LCB1c2UgaXQgYXMgYXBwcm9wcmlhdGUuXG4gIC8vICAgIFRPRE86IHByb3h5LWF1dGhlbnRpY2F0aW9uXG5cbiAgLy8gICAgMjIuIFNldCBodHRwQ2FjaGUgdG8gdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgSFRUUCBjYWNoZVxuICAvLyAgICBwYXJ0aXRpb24sIGdpdmVuIGh0dHBSZXF1ZXN0LlxuICAvLyAgICBUT0RPOiBjYWNoZVxuXG4gIC8vICAgIDIzLiBJZiBodHRwQ2FjaGUgaXMgbnVsbCwgdGhlbiBzZXQgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG9cbiAgLy8gICAgXCJuby1zdG9yZVwiLlxuICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcbiAgfVxuXG4gIC8vICAgIDI0LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBuZWl0aGVyIFwibm8tc3RvcmVcIiBub3IgXCJyZWxvYWRcIixcbiAgLy8gICAgdGhlbjpcbiAgaWYgKGh0dHBSZXF1ZXN0LmNhY2hlICE9PSAnbm8tc3RvcmUnICYmIGh0dHBSZXF1ZXN0LmNhY2hlICE9PSAncmVsb2FkJykge1xuICAgIC8vIFRPRE86IGNhY2hlXG4gIH1cblxuICAvLyA5LiBJZiBhYm9ydGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAvLyAxLiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm9ubHktaWYtY2FjaGVkXCIsIHRoZW4gcmV0dXJuIGFcbiAgICAvLyBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ29ubHktaWYtY2FjaGVkJykge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ29ubHkgaWYgY2FjaGVkJylcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgZm9yd2FyZFJlc3BvbnNlIGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmsgZmV0Y2hcbiAgICAvLyBnaXZlbiBodHRwRmV0Y2hQYXJhbXMsIGluY2x1ZGVDcmVkZW50aWFscywgYW5kIGlzTmV3Q29ubmVjdGlvbkZldGNoLlxuICAgIGNvbnN0IGZvcndhcmRSZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrRmV0Y2goXG4gICAgICBodHRwRmV0Y2hQYXJhbXMsXG4gICAgICBpbmNsdWRlQ3JlZGVudGlhbHMsXG4gICAgICBpc05ld0Nvbm5lY3Rpb25GZXRjaFxuICAgIClcblxuICAgIC8vIDMuIElmIGh0dHBSZXF1ZXN04oCZcyBtZXRob2QgaXMgdW5zYWZlIGFuZCBmb3J3YXJkUmVzcG9uc2XigJlzIHN0YXR1cyBpc1xuICAgIC8vIGluIHRoZSByYW5nZSAyMDAgdG8gMzk5LCBpbmNsdXNpdmUsIGludmFsaWRhdGUgYXBwcm9wcmlhdGUgc3RvcmVkXG4gICAgLy8gcmVzcG9uc2VzIGluIGh0dHBDYWNoZSwgYXMgcGVyIHRoZSBcIkludmFsaWRhdGlvblwiIGNoYXB0ZXIgb2YgSFRUUFxuICAgIC8vIENhY2hpbmcsIGFuZCBzZXQgc3RvcmVkUmVzcG9uc2UgdG8gbnVsbC4gW0hUVFAtQ0FDSElOR11cbiAgICBpZiAoXG4gICAgICAhc2FmZU1ldGhvZHNTZXQuaGFzKGh0dHBSZXF1ZXN0Lm1ldGhvZCkgJiZcbiAgICAgIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmXG4gICAgICBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzIDw9IDM5OVxuICAgICkge1xuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG5cbiAgICAvLyA0LiBJZiB0aGUgcmV2YWxpZGF0aW5nRmxhZyBpcyBzZXQgYW5kIGZvcndhcmRSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwNCxcbiAgICAvLyB0aGVuOlxuICAgIGlmIChyZXZhbGlkYXRpbmdGbGFnICYmIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG5cbiAgICAvLyA1LiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAvLyAxLiBTZXQgcmVzcG9uc2UgdG8gZm9yd2FyZFJlc3BvbnNlLlxuICAgICAgcmVzcG9uc2UgPSBmb3J3YXJkUmVzcG9uc2VcblxuICAgICAgLy8gMi4gU3RvcmUgaHR0cFJlcXVlc3QgYW5kIGZvcndhcmRSZXNwb25zZSBpbiBodHRwQ2FjaGUsIGFzIHBlciB0aGVcbiAgICAgIC8vIFwiU3RvcmluZyBSZXNwb25zZXMgaW4gQ2FjaGVzXCIgY2hhcHRlciBvZiBIVFRQIENhY2hpbmcuIFtIVFRQLUNBQ0hJTkddXG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cbiAgfVxuXG4gIC8vIDExLiBTZXQgcmVzcG9uc2XigJlzIFVSTCBsaXN0IHRvIGEgY2xvbmUgb2YgaHR0cFJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICByZXNwb25zZS51cmxMaXN0ID0gWy4uLmh0dHBSZXF1ZXN0LnVybExpc3RdXG5cbiAgLy8gMTIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgUmFuZ2VgLCB0aGVuIHNldCByZXNwb25zZeKAmXNcbiAgLy8gcmFuZ2UtcmVxdWVzdGVkIGZsYWcuXG4gIGlmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnLCB0cnVlKSkge1xuICAgIHJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gMTMuIFNldCByZXNwb25zZeKAmXMgcmVxdWVzdC1pbmNsdWRlcy1jcmVkZW50aWFscyB0byBpbmNsdWRlQ3JlZGVudGlhbHMuXG4gIHJlc3BvbnNlLnJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzID0gaW5jbHVkZUNyZWRlbnRpYWxzXG5cbiAgLy8gMTQuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDAxLCBodHRwUmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgbm90XG4gIC8vIFwiY29yc1wiLCBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSwgYW5kIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudFxuICAvLyBzZXR0aW5ncyBvYmplY3QsIHRoZW46XG4gIC8vIFRPRE9cblxuICAvLyAxNS4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MDcsIHRoZW46XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNykge1xuICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcIm5vLXdpbmRvd1wiLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnbm8td2luZG93Jykge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoKVxuICAgIH1cblxuICAgIC8vIDIuID8/P1xuXG4gICAgLy8gMy4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKVxuICAgIH1cblxuICAgIC8vIDQuIFByb21wdCB0aGUgZW5kIHVzZXIgYXMgYXBwcm9wcmlhdGUgaW4gcmVxdWVzdOKAmXMgd2luZG93IGFuZCBzdG9yZVxuICAgIC8vIHRoZSByZXN1bHQgYXMgYSBwcm94eS1hdXRoZW50aWNhdGlvbiBlbnRyeS4gW0hUVFAtQVVUSF1cbiAgICAvLyBUT0RPOiBJbnZva2Ugc29tZSBraW5kIG9mIGNhbGxiYWNrP1xuXG4gICAgLy8gNS4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggZ2l2ZW5cbiAgICAvLyBmZXRjaFBhcmFtcy5cbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ3Byb3h5IGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJylcbiAgfVxuXG4gIC8vIDE2LiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZVxuICBpZiAoXG4gICAgLy8gcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MjFcbiAgICByZXNwb25zZS5zdGF0dXMgPT09IDQyMSAmJlxuICAgIC8vIGlzTmV3Q29ubmVjdGlvbkZldGNoIGlzIGZhbHNlXG4gICAgIWlzTmV3Q29ubmVjdGlvbkZldGNoICYmXG4gICAgLy8gcmVxdWVzdOKAmXMgYm9keSBpcyBudWxsLCBvciByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbm9uLW51bGxcbiAgICAocmVxdWVzdC5ib2R5ID09IG51bGwgfHwgcmVxdWVzdC5ib2R5LnNvdXJjZSAhPSBudWxsKVxuICApIHtcbiAgICAvLyB0aGVuOlxuXG4gICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrLW9yLWNhY2hlXG4gICAgLy8gZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMsIGlzQXV0aGVudGljYXRpb25GZXRjaCwgYW5kIHRydWUuXG5cbiAgICAvLyBUT0RPIChzcGVjKTogVGhlIHNwZWMgZG9lc24ndCBzcGVjaWZ5IHRoaXMgYnV0IHdlIG5lZWQgdG8gY2FuY2VsXG4gICAgLy8gdGhlIGFjdGl2ZSByZXNwb25zZSBiZWZvcmUgd2UgY2FuIHN0YXJ0IGEgbmV3IG9uZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8xMjkzXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuXG4gICAgcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChcbiAgICAgIGZldGNoUGFyYW1zLFxuICAgICAgaXNBdXRoZW50aWNhdGlvbkZldGNoLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgfVxuXG4gIC8vIDE3LiBJZiBpc0F1dGhlbnRpY2F0aW9uRmV0Y2ggaXMgdHJ1ZSwgdGhlbiBjcmVhdGUgYW4gYXV0aGVudGljYXRpb24gZW50cnlcbiAgaWYgKGlzQXV0aGVudGljYXRpb25GZXRjaCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE4LiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1uZXR3b3JrLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya0ZldGNoIChcbiAgZmV0Y2hQYXJhbXMsXG4gIGluY2x1ZGVDcmVkZW50aWFscyA9IGZhbHNlLFxuICBmb3JjZU5ld0Nvbm5lY3Rpb24gPSBmYWxzZVxuKSB7XG4gIGFzc2VydCghZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uIHx8IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95ZWQpXG5cbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uID0ge1xuICAgIGFib3J0OiBudWxsLFxuICAgIGRlc3Ryb3llZDogZmFsc2UsXG4gICAgZGVzdHJveSAoZXJyLCBhYm9ydCA9IHRydWUpIHtcbiAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gICAgICAgIGlmIChhYm9ydCkge1xuICAgICAgICAgIHRoaXMuYWJvcnQ/LihlcnIgPz8gbmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyAzLiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gNC4gTGV0IGh0dHBDYWNoZSBiZSB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBIVFRQIGNhY2hlIHBhcnRpdGlvbixcbiAgLy8gZ2l2ZW4gcmVxdWVzdC5cbiAgLy8gVE9ETzogY2FjaGVcbiAgY29uc3QgaHR0cENhY2hlID0gbnVsbFxuXG4gIC8vIDUuIElmIGh0dHBDYWNoZSBpcyBudWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIFwibm8tc3RvcmVcIi5cbiAgaWYgKGh0dHBDYWNoZSA9PSBudWxsKSB7XG4gICAgcmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcbiAgfVxuXG4gIC8vIDYuIExldCBuZXR3b3JrUGFydGl0aW9uS2V5IGJlIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIG5ldHdvcmtcbiAgLy8gcGFydGl0aW9uIGtleSBnaXZlbiByZXF1ZXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gNy4gTGV0IG5ld0Nvbm5lY3Rpb24gYmUgXCJ5ZXNcIiBpZiBmb3JjZU5ld0Nvbm5lY3Rpb24gaXMgdHJ1ZTsgb3RoZXJ3aXNlXG4gIC8vIFwibm9cIi5cbiAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IGZvcmNlTmV3Q29ubmVjdGlvbiA/ICd5ZXMnIDogJ25vJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLy8gOC4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIG1vZGU6XG4gIGlmIChyZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgLy8gTGV0IGNvbm5lY3Rpb24gYmUgdGhlIHJlc3VsdCBvZiBvYnRhaW5pbmcgYSBXZWJTb2NrZXQgY29ubmVjdGlvbixcbiAgICAvLyBnaXZlbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAvLyBUT0RPXG4gIH0gZWxzZSB7XG4gICAgLy8gTGV0IGNvbm5lY3Rpb24gYmUgdGhlIHJlc3VsdCBvZiBvYnRhaW5pbmcgYSBjb25uZWN0aW9uLCBnaXZlblxuICAgIC8vIG5ldHdvcmtQYXJ0aXRpb25LZXksIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4sXG4gICAgLy8gaW5jbHVkZUNyZWRlbnRpYWxzLCBhbmQgZm9yY2VOZXdDb25uZWN0aW9uLlxuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDkuIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZDpcblxuICAvLyAgICAxLiBJZiBjb25uZWN0aW9uIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cblxuICAvLyAgICAyLiBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgY29ubmVjdGlvbiB0aW1pbmcgaW5mbyB0byB0aGUgcmVzdWx0IG9mXG4gIC8vICAgIGNhbGxpbmcgY2xhbXAgYW5kIGNvYXJzZW4gY29ubmVjdGlvbiB0aW1pbmcgaW5mbyB3aXRoIGNvbm5lY3Rpb27igJlzXG4gIC8vICAgIHRpbWluZyBpbmZvLCB0aW1pbmdJbmZv4oCZcyBwb3N0LXJlZGlyZWN0IHN0YXJ0IHRpbWUsIGFuZCBmZXRjaFBhcmFtc+KAmXNcbiAgLy8gICAgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHkuXG5cbiAgLy8gICAgMy4gSWYgY29ubmVjdGlvbiBpcyBub3QgYW4gSFRUUC8yIGNvbm5lY3Rpb24sIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsXG4gIC8vICAgIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbnVsbCwgdGhlbiBhcHBlbmQgKGBUcmFuc2Zlci1FbmNvZGluZ2AsXG4gIC8vICAgIGBjaHVua2VkYCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG5cbiAgLy8gICAgNC4gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVxdWVzdCBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWRcbiAgLy8gICAgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vICAgIGNhcGFiaWxpdHkuXG5cbiAgLy8gICAgNS4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgbWFraW5nIGFuIEhUVFAgcmVxdWVzdCBvdmVyIGNvbm5lY3Rpb25cbiAgLy8gICAgdXNpbmcgcmVxdWVzdCB3aXRoIHRoZSBmb2xsb3dpbmcgY2F2ZWF0czpcblxuICAvLyAgICAgICAgLSBGb2xsb3cgdGhlIHJlbGV2YW50IHJlcXVpcmVtZW50cyBmcm9tIEhUVFAuIFtIVFRQXSBbSFRUUC1TRU1BTlRJQ1NdXG4gIC8vICAgICAgICBbSFRUUC1DT05EXSBbSFRUUC1DQUNISU5HXSBbSFRUUC1BVVRIXVxuXG4gIC8vICAgICAgICAtIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbnVsbCxcbiAgLy8gICAgICAgIHRoZW4gdGhlIHVzZXIgYWdlbnQgbWF5IGhhdmUgYSBidWZmZXIgb2YgdXAgdG8gNjQga2liaWJ5dGVzIGFuZCBzdG9yZVxuICAvLyAgICAgICAgYSBwYXJ0IG9mIHJlcXVlc3TigJlzIGJvZHkgaW4gdGhhdCBidWZmZXIuIElmIHRoZSB1c2VyIGFnZW50IHJlYWRzIGZyb21cbiAgLy8gICAgICAgIHJlcXVlc3TigJlzIGJvZHkgYmV5b25kIHRoYXQgYnVmZmVy4oCZcyBzaXplIGFuZCB0aGUgdXNlciBhZ2VudCBuZWVkcyB0b1xuICAvLyAgICAgICAgcmVzZW5kIHJlcXVlc3QsIHRoZW4gaW5zdGVhZCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vICAgICAgICAtIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlc3BvbnNlIHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZFxuICAvLyAgICAgICAgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHksXG4gIC8vICAgICAgICBpbW1lZGlhdGVseSBhZnRlciB0aGUgdXNlciBhZ2VudOKAmXMgSFRUUCBwYXJzZXIgcmVjZWl2ZXMgdGhlIGZpcnN0IGJ5dGVcbiAgLy8gICAgICAgIG9mIHRoZSByZXNwb25zZSAoZS5nLiwgZnJhbWUgaGVhZGVyIGJ5dGVzIGZvciBIVFRQLzIgb3IgcmVzcG9uc2Ugc3RhdHVzXG4gIC8vICAgICAgICBsaW5lIGZvciBIVFRQLzEueCkuXG5cbiAgLy8gICAgICAgIC0gV2FpdCB1bnRpbCBhbGwgdGhlIGhlYWRlcnMgYXJlIHRyYW5zbWl0dGVkLlxuXG4gIC8vICAgICAgICAtIEFueSByZXNwb25zZXMgd2hvc2Ugc3RhdHVzIGlzIGluIHRoZSByYW5nZSAxMDAgdG8gMTk5LCBpbmNsdXNpdmUsXG4gIC8vICAgICAgICBhbmQgaXMgbm90IDEwMSwgYXJlIHRvIGJlIGlnbm9yZWQsIGV4Y2VwdCBmb3IgdGhlIHB1cnBvc2VzIG9mIHNldHRpbmdcbiAgLy8gICAgICAgIHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSBhYm92ZS5cblxuICAvLyAgICAtIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBUcmFuc2Zlci1FbmNvZGluZ2AvYGNodW5rZWRgIGFuZFxuICAvLyAgICByZXNwb25zZSBpcyB0cmFuc2ZlcnJlZCB2aWEgSFRUUC8xLjAgb3Igb2xkZXIsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAvLyAgICBlcnJvci5cblxuICAvLyAgICAtIElmIHRoZSBIVFRQIHJlcXVlc3QgcmVzdWx0cyBpbiBhIFRMUyBjbGllbnQgY2VydGlmaWNhdGUgZGlhbG9nLCB0aGVuOlxuXG4gIC8vICAgICAgICAxLiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgYW4gZW52aXJvbm1lbnQgc2V0dGluZ3Mgb2JqZWN0LCBtYWtlIHRoZVxuICAvLyAgICAgICAgZGlhbG9nIGF2YWlsYWJsZSBpbiByZXF1ZXN04oCZcyB3aW5kb3cuXG5cbiAgLy8gICAgICAgIDIuIE90aGVyd2lzZSwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cblxuICAvLyBUbyB0cmFuc21pdCByZXF1ZXN04oCZcyBib2R5IGJvZHksIHJ1biB0aGVzZSBzdGVwczpcbiAgbGV0IHJlcXVlc3RCb2R5ID0gbnVsbFxuICAvLyAxLiBJZiBib2R5IGlzIG51bGwgYW5kIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkgaXNcbiAgLy8gbm9uLW51bGwsIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3RcbiAgLy8gZW5kLW9mLWJvZHkgYW5kIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICBpZiAocmVxdWVzdC5ib2R5ID09IG51bGwgJiYgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSgpKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBib2R5IGlzIG5vbi1udWxsOlxuXG4gICAgLy8gICAgMS4gTGV0IHByb2Nlc3NCb2R5Q2h1bmsgZ2l2ZW4gYnl0ZXMgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHlDaHVuayA9IGFzeW5jIGZ1bmN0aW9uICogKGJ5dGVzKSB7XG4gICAgICAvLyAxLiBJZiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gUnVuIHRoaXMgc3RlcCBpbiBwYXJhbGxlbDogdHJhbnNtaXQgYnl0ZXMuXG4gICAgICB5aWVsZCBieXRlc1xuXG4gICAgICAvLyAzLiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gcnVuXG4gICAgICAvLyBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGJvZHkgZ2l2ZW4gYnl0ZXPigJlzIGxlbmd0aC5cbiAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoPy4oYnl0ZXMuYnl0ZUxlbmd0aClcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgcHJvY2Vzc0VuZE9mQm9keSBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzRW5kT2ZCb2R5ID0gKCkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzIG5vbi1udWxsLFxuICAgICAgLy8gdGhlbiBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keS5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHByb2Nlc3NCb2R5RXJyb3IgZ2l2ZW4gZSBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gKGUpID0+IHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgZSBpcyBhbiBcIkFib3J0RXJyb3JcIiBET01FeGNlcHRpb24sIHRoZW4gYWJvcnQgZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXIuXG4gICAgICBpZiAoZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5hYm9ydCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIEluY3JlbWVudGFsbHkgcmVhZCByZXF1ZXN04oCZcyBib2R5IGdpdmVuIHByb2Nlc3NCb2R5Q2h1bmssIHByb2Nlc3NFbmRPZkJvZHksXG4gICAgLy8gcHJvY2Vzc0JvZHlFcnJvciwgYW5kIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICAgIHJlcXVlc3RCb2R5ID0gKGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBieXRlcyBvZiByZXF1ZXN0LmJvZHkuc3RyZWFtKSB7XG4gICAgICAgICAgeWllbGQgKiBwcm9jZXNzQm9keUNodW5rKGJ5dGVzKVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NFbmRPZkJvZHkoKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHByb2Nlc3NCb2R5RXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH0pKClcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gc29ja2V0IGlzIG9ubHkgcHJvdmlkZWQgZm9yIHdlYnNvY2tldHNcbiAgICBjb25zdCB7IGJvZHksIHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QsIHNvY2tldCB9ID0gYXdhaXQgZGlzcGF0Y2goeyBib2R5OiByZXF1ZXN0Qm9keSB9KVxuXG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyBzdGF0dXMsIHN0YXR1c1RleHQsIGhlYWRlcnNMaXN0LCBzb2NrZXQgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSBib2R5W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm5leHQgPSAoKSA9PiBpdGVyYXRvci5uZXh0KClcblxuICAgICAgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyBzdGF0dXMsIHN0YXR1c1RleHQsIGhlYWRlcnNMaXN0IH0pXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyAxMC4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgICBpZiAoZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgLy8gMS4gSWYgY29ubmVjdGlvbiB1c2VzIEhUVFAvMiwgdGhlbiB0cmFuc21pdCBhbiBSU1RfU1RSRUFNIGZyYW1lLlxuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuXG4gICAgICAvLyAyLiBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcywgZXJyKVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKGVycilcbiAgfVxuXG4gIC8vIDExLiBMZXQgcHVsbEFsZ29yaXRobSBiZSBhbiBhY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBvbmdvaW5nIGZldGNoXG4gIC8vIGlmIGl0IGlzIHN1c3BlbmRlZC5cbiAgY29uc3QgcHVsbEFsZ29yaXRobSA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSgpXG4gIH1cblxuICAvLyAxMi4gTGV0IGNhbmNlbEFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gdGhhdCBhYm9ydHMgZmV0Y2hQYXJhbXPigJlzXG4gIC8vIGNvbnRyb2xsZXIgd2l0aCByZWFzb24sIGdpdmVuIHJlYXNvbi5cbiAgY29uc3QgY2FuY2VsQWxnb3JpdGhtID0gKHJlYXNvbikgPT4ge1xuICAgIC8vIElmIHRoZSBhYm9ydGVkIGZldGNoIHdhcyBhbHJlYWR5IHRlcm1pbmF0ZWQsIHRoZW4gd2UgZG8gbm90XG4gICAgLy8gbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICBpZiAoIWlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5hYm9ydChyZWFzb24pXG4gICAgfVxuICB9XG5cbiAgLy8gMTMuIExldCBoaWdoV2F0ZXJNYXJrIGJlIGEgbm9uLW5lZ2F0aXZlLCBub24tTmFOIG51bWJlciwgY2hvc2VuIGJ5XG4gIC8vIHRoZSB1c2VyIGFnZW50LlxuICAvLyBUT0RPXG5cbiAgLy8gMTQuIExldCBzaXplQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB0aGF0IGFjY2VwdHMgYSBjaHVuayBvYmplY3RcbiAgLy8gYW5kIHJldHVybnMgYSBub24tbmVnYXRpdmUsIG5vbi1OYU4sIG5vbi1pbmZpbml0ZSBudW1iZXIsIGNob3NlbiBieSB0aGUgdXNlciBhZ2VudC5cbiAgLy8gVE9ET1xuXG4gIC8vIDE1LiBMZXQgc3RyZWFtIGJlIGEgbmV3IFJlYWRhYmxlU3RyZWFtLlxuICAvLyAxNi4gU2V0IHVwIHN0cmVhbSB3aXRoIGJ5dGUgcmVhZGluZyBzdXBwb3J0IHdpdGggcHVsbEFsZ29yaXRobSBzZXQgdG8gcHVsbEFsZ29yaXRobSxcbiAgLy8gICAgIGNhbmNlbEFsZ29yaXRobSBzZXQgdG8gY2FuY2VsQWxnb3JpdGhtLlxuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgYXN5bmMgc3RhcnQgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyID0gY29udHJvbGxlclxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgYXdhaXQgcHVsbEFsZ29yaXRobShjb250cm9sbGVyKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGNhbmNlbEFsZ29yaXRobShyZWFzb24pXG4gICAgICB9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH1cbiAgKVxuXG4gIC8vIDE3LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGEgbmV3IGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbS5cbiAgcmVzcG9uc2UuYm9keSA9IHsgc3RyZWFtLCBzb3VyY2U6IG51bGwsIGxlbmd0aDogbnVsbCB9XG5cbiAgLy8gICAgMi4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpc1xuICAvLyAgICBub3QgXCJuby1zdG9yZVwiLCB0aGVuIHVwZGF0ZSByZXNwb25zZSBpbiBodHRwQ2FjaGUgZm9yIHJlcXVlc3QuXG4gIC8vICAgIFRPRE9cblxuICAvLyAgICAzLiBJZiBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSBhbmQgdGhlIHVzZXIgYWdlbnQgaXMgbm90IGNvbmZpZ3VyZWRcbiAgLy8gICAgdG8gYmxvY2sgY29va2llcyBmb3IgcmVxdWVzdCAoc2VlIHNlY3Rpb24gNyBvZiBbQ09PS0lFU10pLCB0aGVuIHJ1biB0aGVcbiAgLy8gICAgXCJzZXQtY29va2llLXN0cmluZ1wiIHBhcnNpbmcgYWxnb3JpdGhtIChzZWUgc2VjdGlvbiA1LjIgb2YgW0NPT0tJRVNdKSBvblxuICAvLyAgICB0aGUgdmFsdWUgb2YgZWFjaCBoZWFkZXIgd2hvc2UgbmFtZSBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgLy8gICAgYFNldC1Db29raWVgIGluIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCwgaWYgYW55LCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gIC8vICAgIFRPRE9cblxuICAvLyAxOC4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgLy8gVE9ET1xuXG4gIC8vIDE5LiBSdW4gdGhlc2Ugc3RlcHMgaW4gcGFyYWxsZWw6XG5cbiAgLy8gICAgMS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZDpcbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbkFib3J0ZWQgPSBvbkFib3J0ZWRcbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbigndGVybWluYXRlZCcsIG9uQWJvcnRlZClcbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gMS4gV2hpbGUgdHJ1ZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyAxLTMuIFNlZSBvbkRhdGEuLi5cblxuICAgICAgLy8gNC4gU2V0IGJ5dGVzIHRvIHRoZSByZXN1bHQgb2YgaGFuZGxpbmcgY29udGVudCBjb2RpbmdzIGdpdmVuXG4gICAgICAvLyBjb2RpbmdzIGFuZCBieXRlcy5cbiAgICAgIGxldCBieXRlc1xuICAgICAgbGV0IGlzRmFpbHVyZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0KClcblxuICAgICAgICBpZiAoaXNBYm9ydGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBieXRlcyA9IGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmVuZGVkICYmICF0aW1pbmdJbmZvLmVuY29kZWRCb2R5U2l6ZSkge1xuICAgICAgICAgIC8vIHpsaWIgZG9lc24ndCBsaWtlIGVtcHR5IHN0cmVhbXMuXG4gICAgICAgICAgYnl0ZXMgPSB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBieXRlcyA9IGVyclxuXG4gICAgICAgICAgLy8gZXJyIG1heSBiZSBwcm9wYWdhdGVkIGZyb20gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHJlYWRhYmxlc3RyZWFtLmNhbmNlbCxcbiAgICAgICAgICAvLyB3aGljaCBtaWdodCBub3QgYmUgYW4gZXJyb3IuIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDA5XG4gICAgICAgICAgaXNGYWlsdXJlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChieXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgdGhlIGJ5dGVzIHRyYW5zbWlzc2lvbiBmb3IgcmVzcG9uc2XigJlzIG1lc3NhZ2VcbiAgICAgICAgLy8gYm9keSBpcyBkb25lIG5vcm1hbGx5IGFuZCBzdHJlYW0gaXMgcmVhZGFibGUsIHRoZW4gY2xvc2VcbiAgICAgICAgLy8gc3RyZWFtLCBmaW5hbGl6ZSByZXNwb25zZSBmb3IgZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLCBhbmRcbiAgICAgICAgLy8gYWJvcnQgdGhlc2UgaW4tcGFyYWxsZWwgc3RlcHMuXG4gICAgICAgIHJlYWRhYmxlU3RyZWFtQ2xvc2UoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyKVxuXG4gICAgICAgIGZpbmFsaXplUmVzcG9uc2UoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA1LiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBkZWNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgdGltaW5nSW5mby5kZWNvZGVkQm9keVNpemUgKz0gYnl0ZXM/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgICAvLyA2LiBJZiBieXRlcyBpcyBmYWlsdXJlLCB0aGVuIHRlcm1pbmF0ZSBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChpc0ZhaWx1cmUpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoYnl0ZXMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA3LiBFbnF1ZXVlIGEgVWludDhBcnJheSB3cmFwcGluZyBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIGJ5dGVzXG4gICAgICAvLyBpbnRvIHN0cmVhbS5cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKVxuICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcilcbiAgICAgIH1cblxuICAgICAgLy8gOC4gSWYgc3RyZWFtIGlzIGVycm9yZWQsIHRoZW4gdGVybWluYXRlIHRoZSBvbmdvaW5nIGZldGNoLlxuICAgICAgaWYgKGlzRXJyb3JlZChzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDkuIElmIHN0cmVhbSBkb2VzbuKAmXQgbmVlZCBtb3JlIGRhdGEgYXNrIHRoZSB1c2VyIGFnZW50IHRvIHN1c3BlbmRcbiAgICAgIC8vIHRoZSBvbmdvaW5nIGZldGNoLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vICAgIDIuIElmIGFib3J0ZWQsIHRoZW46XG4gIGZ1bmN0aW9uIG9uQWJvcnRlZCAocmVhc29uKSB7XG4gICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZCwgdGhlbjpcbiAgICBpZiAoaXNBYm9ydGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgLy8gMS4gU2V0IHJlc3BvbnNl4oCZcyBhYm9ydGVkIGZsYWcuXG4gICAgICByZXNwb25zZS5hYm9ydGVkID0gdHJ1ZVxuXG4gICAgICAvLyAyLiBJZiBzdHJlYW0gaXMgcmVhZGFibGUsIHRoZW4gZXJyb3Igc3RyZWFtIHdpdGggdGhlIHJlc3VsdCBvZlxuICAgICAgLy8gICAgZGVzZXJpYWxpemUgYSBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiBnaXZlbiBmZXRjaFBhcmFtc+KAmXNcbiAgICAgIC8vICAgIGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGFuZCBhblxuICAgICAgLy8gICAgaW1wbGVtZW50YXRpb24tZGVmaW5lZCByZWFsbS5cbiAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKFxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuc2VyaWFsaXplZEFib3J0UmVhc29uXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBzdHJlYW0gaXMgcmVhZGFibGUsIGVycm9yIHN0cmVhbSB3aXRoIGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3IobmV3IFR5cGVFcnJvcigndGVybWluYXRlZCcsIHtcbiAgICAgICAgICBjYXVzZTogaXNFcnJvckxpa2UocmVhc29uKSA/IHJlYXNvbiA6IHVuZGVmaW5lZFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJZiBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCB0aGUgdXNlciBhZ2VudCBzaG91bGQgY2xvc2UgY29ubmVjdGlvbiB1bmxlc3MgaXQgd291bGQgYmUgYmFkIGZvciBwZXJmb3JtYW5jZSB0byBkbyBzby5cbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG4gIH1cblxuICAvLyAyMC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2VcblxuICBmdW5jdGlvbiBkaXNwYXRjaCAoeyBib2R5IH0pIHtcbiAgICBjb25zdCB1cmwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLicpLkFnZW50fSAqL1xuICAgIGNvbnN0IGFnZW50ID0gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kaXNwYXRjaGVyXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWdlbnQuZGlzcGF0Y2goXG4gICAgICB7XG4gICAgICAgIHBhdGg6IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gsXG4gICAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgYm9keTogYWdlbnQuaXNNb2NrQWN0aXZlID8gcmVxdWVzdC5ib2R5ICYmIChyZXF1ZXN0LmJvZHkuc291cmNlIHx8IHJlcXVlc3QuYm9keS5zdHJlYW0pIDogYm9keSxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzTGlzdC5lbnRyaWVzLFxuICAgICAgICBtYXhSZWRpcmVjdGlvbnM6IDAsXG4gICAgICAgIHVwZ3JhZGU6IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcgPyAnd2Vic29ja2V0JyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYm9keTogbnVsbCxcbiAgICAgICAgYWJvcnQ6IG51bGwsXG5cbiAgICAgICAgb25Db25uZWN0IChhYm9ydCkge1xuICAgICAgICAgIC8vIFRPRE8gKGZpeCk6IERvIHdlIG5lZWQgY29ubmVjdGlvbiBoZXJlP1xuICAgICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbiB9ID0gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxuXG4gICAgICAgICAgLy8gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGNsYW1wIGFuZCBjb2Fyc2VuXG4gICAgICAgICAgLy8gY29ubmVjdGlvbiB0aW1pbmcgaW5mbyB3aXRoIGNvbm5lY3Rpb27igJlzIHRpbWluZyBpbmZvLCB0aW1pbmdJbmZv4oCZcyBwb3N0LXJlZGlyZWN0IHN0YXJ0XG4gICAgICAgICAgLy8gdGltZSwgYW5kIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cbiAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgY29ubmVjdGlvbiB0aW1pbmdcbiAgICAgICAgICB0aW1pbmdJbmZvLmZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm8gPSBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyh1bmRlZmluZWQsIHRpbWluZ0luZm8ucG9zdFJlZGlyZWN0U3RhcnRUaW1lLCBmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcblxuICAgICAgICAgIGlmIChjb25uZWN0aW9uLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgYWJvcnQobmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uKCd0ZXJtaW5hdGVkJywgYWJvcnQpXG4gICAgICAgICAgICB0aGlzLmFib3J0ID0gY29ubmVjdGlvbi5hYm9ydCA9IGFib3J0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVxdWVzdCBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlblxuICAgICAgICAgIC8vIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cbiAgICAgICAgICB0aW1pbmdJbmZvLmZpbmFsTmV0d29ya1JlcXVlc3RTdGFydFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlc3BvbnNlU3RhcnRlZCAoKSB7XG4gICAgICAgICAgLy8gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50XG4gICAgICAgICAgLy8gdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHksIGltbWVkaWF0ZWx5IGFmdGVyIHRoZVxuICAgICAgICAgIC8vIHVzZXIgYWdlbnTigJlzIEhUVFAgcGFyc2VyIHJlY2VpdmVzIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZSAoZS5nLiwgZnJhbWUgaGVhZGVyXG4gICAgICAgICAgLy8gYnl0ZXMgZm9yIEhUVFAvMiBvciByZXNwb25zZSBzdGF0dXMgbGluZSBmb3IgSFRUUC8xLngpLlxuICAgICAgICAgIHRpbWluZ0luZm8uZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbiAgICAgICAgfSxcblxuICAgICAgICBvbkhlYWRlcnMgKHN0YXR1cywgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgICAgICAgaWYgKHN0YXR1cyA8IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICAgICAgICBsZXQgY29kaW5ncyA9IFtdXG4gICAgICAgICAgbGV0IGxvY2F0aW9uID0gJydcblxuICAgICAgICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gbmV3IEhlYWRlcnNMaXN0KClcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3SGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgaGVhZGVyc0xpc3QuYXBwZW5kKGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUocmF3SGVhZGVyc1tpXSksIHJhd0hlYWRlcnNbaSArIDFdLnRvU3RyaW5nKCdsYXRpbjEnKSwgdHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29udGVudEVuY29kaW5nID0gaGVhZGVyc0xpc3QuZ2V0KCdjb250ZW50LWVuY29kaW5nJywgdHJ1ZSlcbiAgICAgICAgICBpZiAoY29udGVudEVuY29kaW5nKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMSNzZWN0aW9uLTMuMS4yLjFcbiAgICAgICAgICAgIC8vIFwiQWxsIGNvbnRlbnQtY29kaW5nIHZhbHVlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZS4uLlwiXG4gICAgICAgICAgICBjb2RpbmdzID0gY29udGVudEVuY29kaW5nLnRvTG93ZXJDYXNlKCkuc3BsaXQoJywnKS5tYXAoKHgpID0+IHgudHJpbSgpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhdGlvbiA9IGhlYWRlcnNMaXN0LmdldCgnbG9jYXRpb24nLCB0cnVlKVxuXG4gICAgICAgICAgdGhpcy5ib2R5ID0gbmV3IFJlYWRhYmxlKHsgcmVhZDogcmVzdW1lIH0pXG5cbiAgICAgICAgICBjb25zdCBkZWNvZGVycyA9IFtdXG5cbiAgICAgICAgICBjb25zdCB3aWxsRm9sbG93ID0gbG9jYXRpb24gJiYgcmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycgJiZcbiAgICAgICAgICAgIHJlZGlyZWN0U3RhdHVzU2V0LmhhcyhzdGF0dXMpXG5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29udGVudC1FbmNvZGluZ1xuICAgICAgICAgIGlmIChjb2RpbmdzLmxlbmd0aCAhPT0gMCAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnQ09OTkVDVCcgJiYgIW51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHN0YXR1cykgJiYgIXdpbGxGb2xsb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kaW5ncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjb25zdCBjb2RpbmcgPSBjb2RpbmdzW2ldXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTEyLmh0bWwjc2VjdGlvbi03LjJcbiAgICAgICAgICAgICAgaWYgKGNvZGluZyA9PT0gJ3gtZ3ppcCcgfHwgY29kaW5nID09PSAnZ3ppcCcpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlR3VuemlwKHtcbiAgICAgICAgICAgICAgICAgIC8vIEJlIGxlc3Mgc3RyaWN0IHdoZW4gZGVjb2RpbmcgY29tcHJlc3NlZCByZXNwb25zZXMsIHNpbmNlIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgICAgLy8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgcmVzcG9uc2VzIHRoYXQgYXJlIHN0aWxsIGFjY2VwdGVkXG4gICAgICAgICAgICAgICAgICAvLyBieSBjb21tb24gYnJvd3NlcnMuXG4gICAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXNpbmcgWl9TWU5DX0ZMVVNIIGlzIHdoYXQgY1VSTCBkb2VzLlxuICAgICAgICAgICAgICAgICAgZmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaEZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0hcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09ICdkZWZsYXRlJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goY3JlYXRlSW5mbGF0ZSgpKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGluZyA9PT0gJ2JyJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCkpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMubGVuZ3RoID0gMFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzTGlzdCxcbiAgICAgICAgICAgIGJvZHk6IGRlY29kZXJzLmxlbmd0aFxuICAgICAgICAgICAgICA/IHBpcGVsaW5lKHRoaXMuYm9keSwgLi4uZGVjb2RlcnMsICgpID0+IHsgfSlcbiAgICAgICAgICAgICAgOiB0aGlzLmJvZHkub24oJ2Vycm9yJywgKCkgPT4geyB9KVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRGF0YSAoY2h1bmspIHtcbiAgICAgICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kdW1wKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAxLiBJZiBvbmUgb3IgbW9yZSBieXRlcyBoYXZlIGJlZW4gdHJhbnNtaXR0ZWQgZnJvbSByZXNwb25zZeKAmXNcbiAgICAgICAgICAvLyBtZXNzYWdlIGJvZHksIHRoZW46XG5cbiAgICAgICAgICAvLyAgMS4gTGV0IGJ5dGVzIGJlIHRoZSB0cmFuc21pdHRlZCBieXRlcy5cbiAgICAgICAgICBjb25zdCBieXRlcyA9IGNodW5rXG5cbiAgICAgICAgICAvLyAgMi4gTGV0IGNvZGluZ3MgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlc1xuICAgICAgICAgIC8vICBnaXZlbiBgQ29udGVudC1FbmNvZGluZ2AgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgICAgICAvLyAgU2VlIHB1bGxBbGdvcml0aG0uXG5cbiAgICAgICAgICAvLyAgMy4gSW5jcmVhc2UgdGltaW5nSW5mb+KAmXMgZW5jb2RlZCBib2R5IHNpemUgYnkgYnl0ZXPigJlzIGxlbmd0aC5cbiAgICAgICAgICB0aW1pbmdJbmZvLmVuY29kZWRCb2R5U2l6ZSArPSBieXRlcy5ieXRlTGVuZ3RoXG5cbiAgICAgICAgICAvLyAgNC4gU2VlIHB1bGxBbGdvcml0aG0uLi5cblxuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucHVzaChieXRlcylcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNvbXBsZXRlICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vZmYoJ3Rlcm1pbmF0ZWQnLCB0aGlzLmFib3J0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uQWJvcnRlZCkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vZmYoJ3Rlcm1pbmF0ZWQnLCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uQWJvcnRlZClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmVuZGVkID0gdHJ1ZVxuXG4gICAgICAgICAgdGhpcy5ib2R5LnB1c2gobnVsbClcbiAgICAgICAgfSxcblxuICAgICAgICBvbkVycm9yIChlcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIHRoaXMuYWJvcnQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5Py5kZXN0cm95KGVycm9yKVxuXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyb3IpXG5cbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25VcGdyYWRlIChzdGF0dXMsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgICAgICAgIGlmIChzdGF0dXMgIT09IDEwMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdIZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBoZWFkZXJzTGlzdC5hcHBlbmQoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShyYXdIZWFkZXJzW2ldKSwgcmF3SGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ2xhdGluMScpLCB0cnVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogU1RBVFVTX0NPREVTW3N0YXR1c10sXG4gICAgICAgICAgICBoZWFkZXJzTGlzdCxcbiAgICAgICAgICAgIHNvY2tldFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmV0Y2gsXG4gIEZldGNoLFxuICBmZXRjaGluZyxcbiAgZmluYWxpemVBbmRSZXBvcnRUaW1pbmdcbn1cbiJdLCJuYW1lcyI6WyJtYWtlTmV0d29ya0Vycm9yIiwibWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIiwiZmlsdGVyUmVzcG9uc2UiLCJtYWtlUmVzcG9uc2UiLCJmcm9tSW5uZXJSZXNwb25zZSIsInJlcXVpcmUiLCJIZWFkZXJzTGlzdCIsIlJlcXVlc3QiLCJjbG9uZVJlcXVlc3QiLCJ6bGliIiwiYnl0ZXNNYXRjaCIsIm1ha2VQb2xpY3lDb250YWluZXIiLCJjbG9uZVBvbGljeUNvbnRhaW5lciIsInJlcXVlc3RCYWRQb3J0IiwiVEFPQ2hlY2siLCJhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyIiwicmVzcG9uc2VMb2NhdGlvblVSTCIsInJlcXVlc3RDdXJyZW50VVJMIiwic2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCIsInRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCIsImNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8iLCJhcHBlbmRGZXRjaE1ldGFkYXRhIiwiY29yc0NoZWNrIiwiY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrIiwiZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciIsImNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwiaXNCbG9iTGlrZSIsInNhbWVPcmlnaW4iLCJpc0NhbmNlbGxlZCIsImlzQWJvcnRlZCIsImlzRXJyb3JMaWtlIiwiZnVsbHlSZWFkQm9keSIsInJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJpc29tb3JwaGljRW5jb2RlIiwidXJsSXNMb2NhbCIsInVybElzSHR0cEh0dHBzU2NoZW1lIiwidXJsSGFzSHR0cHNTY2hlbWUiLCJjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyIsInNpbXBsZVJhbmdlSGVhZGVyVmFsdWUiLCJidWlsZENvbnRlbnRSYW5nZSIsImNyZWF0ZUluZmxhdGUiLCJleHRyYWN0TWltZVR5cGUiLCJrU3RhdGUiLCJrRGlzcGF0Y2hlciIsImFzc2VydCIsInNhZmVseUV4dHJhY3RCb2R5IiwiZXh0cmFjdEJvZHkiLCJyZWRpcmVjdFN0YXR1c1NldCIsIm51bGxCb2R5U3RhdHVzIiwic2FmZU1ldGhvZHNTZXQiLCJyZXF1ZXN0Qm9keUhlYWRlciIsInN1YnJlc291cmNlU2V0IiwiRUUiLCJSZWFkYWJsZSIsInBpcGVsaW5lIiwiZmluaXNoZWQiLCJhZGRBYm9ydExpc3RlbmVyIiwiaXNFcnJvcmVkIiwiaXNSZWFkYWJsZSIsImJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUiLCJkYXRhVVJMUHJvY2Vzc29yIiwic2VyaWFsaXplQU1pbWVUeXBlIiwibWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJ3ZWJpZGwiLCJTVEFUVVNfQ09ERVMiLCJHRVRfT1JfSEVBRCIsImRlZmF1bHRVc2VyQWdlbnQiLCJfX1VORElDSV9JU19OT0RFX18iLCJlc2J1aWxkRGV0ZWN0aW9uIiwicmVzb2x2ZU9iamVjdFVSTCIsIkZldGNoIiwiZGlzcGF0Y2hlciIsImNvbm5lY3Rpb24iLCJkdW1wIiwic3RhdGUiLCJ0ZXJtaW5hdGUiLCJyZWFzb24iLCJkZXN0cm95IiwiZW1pdCIsImFib3J0IiwiZXJyb3IiLCJET01FeGNlcHRpb24iLCJzZXJpYWxpemVkQWJvcnRSZWFzb24iLCJoYW5kbGVGZXRjaERvbmUiLCJyZXNwb25zZSIsImZpbmFsaXplQW5kUmVwb3J0VGltaW5nIiwiZmV0Y2giLCJpbnB1dCIsImluaXQiLCJ1bmRlZmluZWQiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwicCIsInJlcXVlc3RPYmplY3QiLCJlIiwicmVqZWN0IiwicHJvbWlzZSIsInJlcXVlc3QiLCJzaWduYWwiLCJhYm9ydGVkIiwiYWJvcnRGZXRjaCIsImdsb2JhbE9iamVjdCIsImNsaWVudCIsIm5hbWUiLCJzZXJ2aWNlV29ya2VycyIsInJlc3BvbnNlT2JqZWN0IiwibG9jYWxseUFib3J0ZWQiLCJjb250cm9sbGVyIiwicmVhbFJlc3BvbnNlIiwiZGVyZWYiLCJwcm9jZXNzUmVzcG9uc2UiLCJ0eXBlIiwiVHlwZUVycm9yIiwiY2F1c2UiLCJXZWFrUmVmIiwicmVzb2x2ZSIsImZldGNoaW5nIiwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IiwiaW5pdGlhdG9yVHlwZSIsInVybExpc3QiLCJsZW5ndGgiLCJvcmlnaW5hbFVSTCIsInRpbWluZ0luZm8iLCJjYWNoZVN0YXRlIiwidGltaW5nQWxsb3dQYXNzZWQiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwibWFya1Jlc291cmNlVGltaW5nIiwiaHJlZiIsImdsb2JhbFRoaXMiLCJwZXJmb3JtYW5jZSIsImJvZHkiLCJzdHJlYW0iLCJjYW5jZWwiLCJjYXRjaCIsImVyciIsImNvZGUiLCJwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCIsInByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5IiwicHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHkiLCJ1c2VQYXJhbGxlbFF1ZXVlIiwidGFza0Rlc3RpbmF0aW9uIiwiY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkiLCJjdXJyZW50VGltZSIsImZldGNoUGFyYW1zIiwid2luZG93Iiwib3JpZ2luIiwicG9saWN5Q29udGFpbmVyIiwiaGVhZGVyc0xpc3QiLCJjb250YWlucyIsInZhbHVlIiwiYXBwZW5kIiwicHJpb3JpdHkiLCJoYXMiLCJkZXN0aW5hdGlvbiIsIm1haW5GZXRjaCIsInJlY3Vyc2l2ZSIsImxvY2FsVVJMc09ubHkiLCJyZWZlcnJlclBvbGljeSIsInJlZmVycmVyIiwiY3VycmVudFVSTCIsInVybCIsInJlc3BvbnNlVGFpbnRpbmciLCJwcm90b2NvbCIsIm1vZGUiLCJzY2hlbWVGZXRjaCIsInJlZGlyZWN0IiwiaHR0cEZldGNoIiwic3RhdHVzIiwiaW50ZXJuYWxSZXNwb25zZSIsInB1c2giLCJ0aW1pbmdBbGxvd0ZhaWxlZCIsInJhbmdlUmVxdWVzdGVkIiwiaGVhZGVycyIsIm1ldGhvZCIsImluY2x1ZGVzIiwiaW50ZWdyaXR5IiwicHJvY2Vzc0JvZHlFcnJvciIsImZldGNoRmluYWxlIiwicHJvY2Vzc0JvZHkiLCJieXRlcyIsInJlZGlyZWN0Q291bnQiLCJQcm9taXNlIiwic2NoZW1lIiwiYmxvYlVSTEVudHJ5Iiwic2VhcmNoIiwiYmxvYiIsInRvU3RyaW5nIiwiZnVsbExlbmd0aCIsInNpemUiLCJzZXJpYWxpemVkRnVsbExlbmd0aCIsImJvZHlXaXRoVHlwZSIsInN0YXR1c1RleHQiLCJzZXQiLCJyYW5nZUhlYWRlciIsImdldCIsInJhbmdlVmFsdWUiLCJyYW5nZVN0YXJ0VmFsdWUiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmRWYWx1ZSIsInJhbmdlRW5kIiwic2xpY2VkQmxvYiIsInNsaWNlIiwic2xpY2VkQm9keVdpdGhUeXBlIiwic2VyaWFsaXplZFNsaWNlZExlbmd0aCIsImNvbnRlbnRSYW5nZSIsImRhdGFVUkxTdHJ1Y3QiLCJtaW1lVHlwZSIsImZpbmFsaXplUmVzcG9uc2UiLCJkb25lIiwicHJvY2Vzc1Jlc3BvbnNlRG9uZSIsInF1ZXVlTWljcm90YXNrIiwidW5zYWZlRW5kVGltZSIsIkRhdGUiLCJub3ciLCJmdWxsVGltaW5nSW5mbyIsInJlcG9ydFRpbWluZ1N0ZXBzIiwiYm9keUluZm8iLCJyZXNwb25zZVN0YXR1cyIsImhhc0Nyb3NzT3JpZ2luUmVkaXJlY3RzIiwiY29udGVudFR5cGUiLCJwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrIiwiYWN0dWFsUmVzcG9uc2UiLCJodHRwTmV0d29ya09yQ2FjaGVGZXRjaCIsImh0dHBSZWRpcmVjdEZldGNoIiwibG9jYXRpb25VUkwiLCJoYXNoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInNvdXJjZSIsImhlYWRlck5hbWUiLCJkZWxldGUiLCJyZWRpcmVjdEVuZFRpbWUiLCJwb3N0UmVkaXJlY3RTdGFydFRpbWUiLCJyZWRpcmVjdFN0YXJ0VGltZSIsImlzQXV0aGVudGljYXRpb25GZXRjaCIsImlzTmV3Q29ubmVjdGlvbkZldGNoIiwiaHR0cEZldGNoUGFyYW1zIiwiaHR0cFJlcXVlc3QiLCJodHRwQ2FjaGUiLCJyZXZhbGlkYXRpbmdGbGFnIiwiaW5jbHVkZUNyZWRlbnRpYWxzIiwiY3JlZGVudGlhbHMiLCJjb250ZW50TGVuZ3RoIiwiY29udGVudExlbmd0aEhlYWRlclZhbHVlIiwia2VlcGFsaXZlIiwiVVJMIiwiY2FjaGUiLCJwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiIsImZvcndhcmRSZXNwb25zZSIsImh0dHBOZXR3b3JrRmV0Y2giLCJyZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyIsImZvcmNlTmV3Q29ubmVjdGlvbiIsImRlc3Ryb3llZCIsIm5ld0Nvbm5lY3Rpb24iLCJyZXF1ZXN0Qm9keSIsInByb2Nlc3NCb2R5Q2h1bmsiLCJieXRlTGVuZ3RoIiwicHJvY2Vzc0VuZE9mQm9keSIsInNvY2tldCIsImRpc3BhdGNoIiwiaXRlcmF0b3IiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwibmV4dCIsInB1bGxBbGdvcml0aG0iLCJyZXN1bWUiLCJjYW5jZWxBbGdvcml0aG0iLCJSZWFkYWJsZVN0cmVhbSIsInN0YXJ0IiwicHVsbCIsIm9uQWJvcnRlZCIsIm9uIiwiaXNGYWlsdXJlIiwiZW5kZWQiLCJlbmNvZGVkQm9keVNpemUiLCJkZWNvZGVkQm9keVNpemUiLCJidWZmZXIiLCJVaW50OEFycmF5IiwiZW5xdWV1ZSIsImRlc2lyZWRTaXplIiwiYWdlbnQiLCJwYXRoIiwicGF0aG5hbWUiLCJpc01vY2tBY3RpdmUiLCJlbnRyaWVzIiwibWF4UmVkaXJlY3Rpb25zIiwidXBncmFkZSIsIm9uQ29ubmVjdCIsImZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm8iLCJmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lIiwib25SZXNwb25zZVN0YXJ0ZWQiLCJmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZSIsIm9uSGVhZGVycyIsInJhd0hlYWRlcnMiLCJjb2RpbmdzIiwibG9jYXRpb24iLCJpIiwiY29udGVudEVuY29kaW5nIiwidG9Mb3dlckNhc2UiLCJzcGxpdCIsIm1hcCIsIngiLCJ0cmltIiwicmVhZCIsImRlY29kZXJzIiwid2lsbEZvbGxvdyIsImNvZGluZyIsImNyZWF0ZUd1bnppcCIsImZsdXNoIiwiY29uc3RhbnRzIiwiWl9TWU5DX0ZMVVNIIiwiZmluaXNoRmx1c2giLCJjcmVhdGVCcm90bGlEZWNvbXByZXNzIiwib25EYXRhIiwiY2h1bmsiLCJvbkNvbXBsZXRlIiwib2ZmIiwib25FcnJvciIsIm9uVXBncmFkZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/request.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* globals AbortController */ \nconst { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\");\nconst { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\nconst { FinalizationRegistry } = __webpack_require__(/*! ./dispatcher-weakref */ \"(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\")();\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\");\nconst { isValidHTTPToken, sameOrigin, environmentSettingsObject } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\");\nconst { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;\nconst { kHeaders, kSignal, kState, kDispatcher } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! node:events */ \"node:events\");\nconst kAbortController = Symbol('abortController');\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort })=>{\n    signal.removeEventListener('abort', abort);\n});\nconst dependentControllerMap = new WeakMap();\nfunction buildAbort(acRef) {\n    return abort;\n    function abort() {\n        const ac = acRef.deref();\n        if (ac !== undefined) {\n            // Currently, there is a problem with FinalizationRegistry.\n            // https://github.com/nodejs/node/issues/49344\n            // https://github.com/nodejs/node/issues/47748\n            // In the case of abort, the first step is to unregister from it.\n            // If the controller can refer to it, it is still registered.\n            // It will be removed in the future.\n            requestFinalizer.unregister(abort);\n            // Unsubscribe a listener.\n            // FinalizationRegistry will no longer be called, so this must be done.\n            this.removeEventListener('abort', abort);\n            ac.abort(this.reason);\n            const controllerList = dependentControllerMap.get(ac.signal);\n            if (controllerList !== undefined) {\n                if (controllerList.size !== 0) {\n                    for (const ref of controllerList){\n                        const ctrl = ref.deref();\n                        if (ctrl !== undefined) {\n                            ctrl.abort(this.reason);\n                        }\n                    }\n                    controllerList.clear();\n                }\n                dependentControllerMap.delete(ac.signal);\n            }\n        }\n    }\n}\nlet patchMethodWarning = false;\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n    // https://fetch.spec.whatwg.org/#dom-request\n    constructor(input, init = {}){\n        if (input === kConstruct) {\n            return;\n        }\n        const prefix = 'Request constructor';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        input = webidl.converters.RequestInfo(input, prefix, 'input');\n        init = webidl.converters.RequestInit(init, prefix, 'init');\n        // 1. Let request be null.\n        let request = null;\n        // 2. Let fallbackMode be null.\n        let fallbackMode = null;\n        // 3. Let baseURL be this’s relevant settings object’s API base URL.\n        const baseUrl = environmentSettingsObject.settingsObject.baseUrl;\n        // 4. Let signal be null.\n        let signal = null;\n        // 5. If input is a string, then:\n        if (typeof input === 'string') {\n            this[kDispatcher] = init.dispatcher;\n            // 1. Let parsedURL be the result of parsing input with baseURL.\n            // 2. If parsedURL is failure, then throw a TypeError.\n            let parsedURL;\n            try {\n                parsedURL = new URL(input, baseUrl);\n            } catch (err) {\n                throw new TypeError('Failed to parse URL from ' + input, {\n                    cause: err\n                });\n            }\n            // 3. If parsedURL includes credentials, then throw a TypeError.\n            if (parsedURL.username || parsedURL.password) {\n                throw new TypeError('Request cannot be constructed from a URL that includes credentials: ' + input);\n            }\n            // 4. Set request to a new request whose URL is parsedURL.\n            request = makeRequest({\n                urlList: [\n                    parsedURL\n                ]\n            });\n            // 5. Set fallbackMode to \"cors\".\n            fallbackMode = 'cors';\n        } else {\n            this[kDispatcher] = init.dispatcher || input[kDispatcher];\n            // 6. Otherwise:\n            // 7. Assert: input is a Request object.\n            assert(input instanceof Request);\n            // 8. Set request to input’s request.\n            request = input[kState];\n            // 9. Set signal to input’s signal.\n            signal = input[kSignal];\n        }\n        // 7. Let origin be this’s relevant settings object’s origin.\n        const origin = environmentSettingsObject.settingsObject.origin;\n        // 8. Let window be \"client\".\n        let window = 'client';\n        // 9. If request’s window is an environment settings object and its origin\n        // is same origin with origin, then set window to request’s window.\n        if (request.window?.constructor?.name === 'EnvironmentSettingsObject' && sameOrigin(request.window, origin)) {\n            window = request.window;\n        }\n        // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n        if (init.window != null) {\n            throw new TypeError(`'window' option '${window}' must be null`);\n        }\n        // 11. If init[\"window\"] exists, then set window to \"no-window\".\n        if ('window' in init) {\n            window = 'no-window';\n        }\n        // 12. Set request to a new request with the following properties:\n        request = makeRequest({\n            // URL request’s URL.\n            // undici implementation note: this is set as the first item in request's urlList in makeRequest\n            // method request’s method.\n            method: request.method,\n            // header list A copy of request’s header list.\n            // undici implementation note: headersList is cloned in makeRequest\n            headersList: request.headersList,\n            // unsafe-request flag Set.\n            unsafeRequest: request.unsafeRequest,\n            // client This’s relevant settings object.\n            client: environmentSettingsObject.settingsObject,\n            // window window.\n            window,\n            // priority request’s priority.\n            priority: request.priority,\n            // origin request’s origin. The propagation of the origin is only significant for navigation requests\n            // being handled by a service worker. In this scenario a request can have an origin that is different\n            // from the current client.\n            origin: request.origin,\n            // referrer request’s referrer.\n            referrer: request.referrer,\n            // referrer policy request’s referrer policy.\n            referrerPolicy: request.referrerPolicy,\n            // mode request’s mode.\n            mode: request.mode,\n            // credentials mode request’s credentials mode.\n            credentials: request.credentials,\n            // cache mode request’s cache mode.\n            cache: request.cache,\n            // redirect mode request’s redirect mode.\n            redirect: request.redirect,\n            // integrity metadata request’s integrity metadata.\n            integrity: request.integrity,\n            // keepalive request’s keepalive.\n            keepalive: request.keepalive,\n            // reload-navigation flag request’s reload-navigation flag.\n            reloadNavigation: request.reloadNavigation,\n            // history-navigation flag request’s history-navigation flag.\n            historyNavigation: request.historyNavigation,\n            // URL list A clone of request’s URL list.\n            urlList: [\n                ...request.urlList\n            ]\n        });\n        const initHasKey = Object.keys(init).length !== 0;\n        // 13. If init is not empty, then:\n        if (initHasKey) {\n            // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n            if (request.mode === 'navigate') {\n                request.mode = 'same-origin';\n            }\n            // 2. Unset request’s reload-navigation flag.\n            request.reloadNavigation = false;\n            // 3. Unset request’s history-navigation flag.\n            request.historyNavigation = false;\n            // 4. Set request’s origin to \"client\".\n            request.origin = 'client';\n            // 5. Set request’s referrer to \"client\"\n            request.referrer = 'client';\n            // 6. Set request’s referrer policy to the empty string.\n            request.referrerPolicy = '';\n            // 7. Set request’s URL to request’s current URL.\n            request.url = request.urlList[request.urlList.length - 1];\n            // 8. Set request’s URL list to « request’s URL ».\n            request.urlList = [\n                request.url\n            ];\n        }\n        // 14. If init[\"referrer\"] exists, then:\n        if (init.referrer !== undefined) {\n            // 1. Let referrer be init[\"referrer\"].\n            const referrer = init.referrer;\n            // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n            if (referrer === '') {\n                request.referrer = 'no-referrer';\n            } else {\n                // 1. Let parsedReferrer be the result of parsing referrer with\n                // baseURL.\n                // 2. If parsedReferrer is failure, then throw a TypeError.\n                let parsedReferrer;\n                try {\n                    parsedReferrer = new URL(referrer, baseUrl);\n                } catch (err) {\n                    throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, {\n                        cause: err\n                    });\n                }\n                // 3. If one of the following is true\n                // - parsedReferrer’s scheme is \"about\" and path is the string \"client\"\n                // - parsedReferrer’s origin is not same origin with origin\n                // then set request’s referrer to \"client\".\n                if (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client' || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {\n                    request.referrer = 'client';\n                } else {\n                    // 4. Otherwise, set request’s referrer to parsedReferrer.\n                    request.referrer = parsedReferrer;\n                }\n            }\n        }\n        // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n        // to it.\n        if (init.referrerPolicy !== undefined) {\n            request.referrerPolicy = init.referrerPolicy;\n        }\n        // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n        let mode;\n        if (init.mode !== undefined) {\n            mode = init.mode;\n        } else {\n            mode = fallbackMode;\n        }\n        // 17. If mode is \"navigate\", then throw a TypeError.\n        if (mode === 'navigate') {\n            throw webidl.errors.exception({\n                header: 'Request constructor',\n                message: 'invalid request mode navigate.'\n            });\n        }\n        // 18. If mode is non-null, set request’s mode to mode.\n        if (mode != null) {\n            request.mode = mode;\n        }\n        // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n        // to it.\n        if (init.credentials !== undefined) {\n            request.credentials = init.credentials;\n        }\n        // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n        if (init.cache !== undefined) {\n            request.cache = init.cache;\n        }\n        // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n        // not \"same-origin\", then throw a TypeError.\n        if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n            throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\");\n        }\n        // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n        if (init.redirect !== undefined) {\n            request.redirect = init.redirect;\n        }\n        // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n        if (init.integrity != null) {\n            request.integrity = String(init.integrity);\n        }\n        // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n        if (init.keepalive !== undefined) {\n            request.keepalive = Boolean(init.keepalive);\n        }\n        // 25. If init[\"method\"] exists, then:\n        if (init.method !== undefined) {\n            // 1. Let method be init[\"method\"].\n            let method = init.method;\n            const mayBeNormalized = normalizedMethodRecords[method];\n            if (mayBeNormalized !== undefined) {\n                // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones\n                request.method = mayBeNormalized;\n            } else {\n                // 2. If method is not a method or method is a forbidden method, then\n                // throw a TypeError.\n                if (!isValidHTTPToken(method)) {\n                    throw new TypeError(`'${method}' is not a valid HTTP method.`);\n                }\n                const upperCase = method.toUpperCase();\n                if (forbiddenMethodsSet.has(upperCase)) {\n                    throw new TypeError(`'${method}' HTTP method is unsupported.`);\n                }\n                // 3. Normalize method.\n                // https://fetch.spec.whatwg.org/#concept-method-normalize\n                // Note: must be in uppercase\n                method = normalizedMethodRecordsBase[upperCase] ?? method;\n                // 4. Set request’s method to method.\n                request.method = method;\n            }\n            if (!patchMethodWarning && request.method === 'patch') {\n                process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {\n                    code: 'UNDICI-FETCH-patch'\n                });\n                patchMethodWarning = true;\n            }\n        }\n        // 26. If init[\"signal\"] exists, then set signal to it.\n        if (init.signal !== undefined) {\n            signal = init.signal;\n        }\n        // 27. Set this’s request to request.\n        this[kState] = request;\n        // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n        // Realm.\n        // TODO: could this be simplified with AbortSignal.any\n        // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n        const ac = new AbortController();\n        this[kSignal] = ac.signal;\n        // 29. If signal is not null, then make this’s signal follow signal.\n        if (signal != null) {\n            if (!signal || typeof signal.aborted !== 'boolean' || typeof signal.addEventListener !== 'function') {\n                throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\");\n            }\n            if (signal.aborted) {\n                ac.abort(signal.reason);\n            } else {\n                // Keep a strong ref to ac while request object\n                // is alive. This is needed to prevent AbortController\n                // from being prematurely garbage collected.\n                // See, https://github.com/nodejs/undici/issues/1926.\n                this[kAbortController] = ac;\n                const acRef = new WeakRef(ac);\n                const abort = buildAbort(acRef);\n                // Third-party AbortControllers may not work with these.\n                // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n                try {\n                    // If the max amount of listeners is equal to the default, increase it\n                    // This is only available in node >= v19.9.0\n                    if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {\n                        setMaxListeners(1500, signal);\n                    } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {\n                        setMaxListeners(1500, signal);\n                    }\n                } catch  {}\n                util.addAbortListener(signal, abort);\n                // The third argument must be a registry key to be unregistered.\n                // Without it, you cannot unregister.\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n                // abort is used as the unregister key. (because it is unique)\n                requestFinalizer.register(ac, {\n                    signal,\n                    abort\n                }, abort);\n            }\n        }\n        // 30. Set this’s headers to a new Headers object with this’s relevant\n        // Realm, whose header list is request’s header list and guard is\n        // \"request\".\n        this[kHeaders] = new Headers(kConstruct);\n        setHeadersList(this[kHeaders], request.headersList);\n        setHeadersGuard(this[kHeaders], 'request');\n        // 31. If this’s request’s mode is \"no-cors\", then:\n        if (mode === 'no-cors') {\n            // 1. If this’s request’s method is not a CORS-safelisted method,\n            // then throw a TypeError.\n            if (!corsSafeListedMethodsSet.has(request.method)) {\n                throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);\n            }\n            // 2. Set this’s headers’s guard to \"request-no-cors\".\n            setHeadersGuard(this[kHeaders], 'request-no-cors');\n        }\n        // 32. If init is not empty, then:\n        if (initHasKey) {\n            /** @type {HeadersList} */ const headersList = getHeadersList(this[kHeaders]);\n            // 1. Let headers be a copy of this’s headers and its associated header\n            // list.\n            // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n            const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);\n            // 3. Empty this’s headers’s header list.\n            headersList.clear();\n            // 4. If headers is a Headers object, then for each header in its header\n            // list, append header’s name/header’s value to this’s headers.\n            if (headers instanceof HeadersList) {\n                for (const { name, value } of headers.rawValues()){\n                    headersList.append(name, value, false);\n                }\n                // Note: Copy the `set-cookie` meta-data.\n                headersList.cookies = headers.cookies;\n            } else {\n                // 5. Otherwise, fill this’s headers with headers.\n                fillHeaders(this[kHeaders], headers);\n            }\n        }\n        // 33. Let inputBody be input’s request’s body if input is a Request\n        // object; otherwise null.\n        const inputBody = input instanceof Request ? input[kState].body : null;\n        // 34. If either init[\"body\"] exists and is non-null or inputBody is\n        // non-null, and request’s method is `GET` or `HEAD`, then throw a\n        // TypeError.\n        if ((init.body != null || inputBody != null) && (request.method === 'GET' || request.method === 'HEAD')) {\n            throw new TypeError('Request with GET/HEAD method cannot have body.');\n        }\n        // 35. Let initBody be null.\n        let initBody = null;\n        // 36. If init[\"body\"] exists and is non-null, then:\n        if (init.body != null) {\n            // 1. Let Content-Type be null.\n            // 2. Set initBody and Content-Type to the result of extracting\n            // init[\"body\"], with keepalive set to request’s keepalive.\n            const [extractedBody, contentType] = extractBody(init.body, request.keepalive);\n            initBody = extractedBody;\n            // 3, If Content-Type is non-null and this’s headers’s header list does\n            // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n            // this’s headers.\n            if (contentType && !getHeadersList(this[kHeaders]).contains('content-type', true)) {\n                this[kHeaders].append('content-type', contentType);\n            }\n        }\n        // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n        // inputBody.\n        const inputOrInitBody = initBody ?? inputBody;\n        // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n        // null, then:\n        if (inputOrInitBody != null && inputOrInitBody.source == null) {\n            // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n            //    then throw a TypeError.\n            if (initBody != null && init.duplex == null) {\n                throw new TypeError('RequestInit: duplex option is required when sending a body.');\n            }\n            // 2. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n            // then throw a TypeError.\n            if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n                throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"');\n            }\n            // 3. Set this’s request’s use-CORS-preflight flag.\n            request.useCORSPreflightFlag = true;\n        }\n        // 39. Let finalBody be inputOrInitBody.\n        let finalBody = inputOrInitBody;\n        // 40. If initBody is null and inputBody is non-null, then:\n        if (initBody == null && inputBody != null) {\n            // 1. If input is unusable, then throw a TypeError.\n            if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n                throw new TypeError('Cannot construct a Request with a Request object that has already been used.');\n            }\n            // 2. Set finalBody to the result of creating a proxy for inputBody.\n            // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n            const identityTransform = new TransformStream();\n            inputBody.stream.pipeThrough(identityTransform);\n            finalBody = {\n                source: inputBody.source,\n                length: inputBody.length,\n                stream: identityTransform.readable\n            };\n        }\n        // 41. Set this’s request’s body to finalBody.\n        this[kState].body = finalBody;\n    }\n    // Returns request’s HTTP method, which is \"GET\" by default.\n    get method() {\n        webidl.brandCheck(this, Request);\n        // The method getter steps are to return this’s request’s method.\n        return this[kState].method;\n    }\n    // Returns the URL of request as a string.\n    get url() {\n        webidl.brandCheck(this, Request);\n        // The url getter steps are to return this’s request’s URL, serialized.\n        return URLSerializer(this[kState].url);\n    }\n    // Returns a Headers object consisting of the headers associated with request.\n    // Note that headers added in the network layer by the user agent will not\n    // be accounted for in this object, e.g., the \"Host\" header.\n    get headers() {\n        webidl.brandCheck(this, Request);\n        // The headers getter steps are to return this’s headers.\n        return this[kHeaders];\n    }\n    // Returns the kind of resource requested by request, e.g., \"document\"\n    // or \"script\".\n    get destination() {\n        webidl.brandCheck(this, Request);\n        // The destination getter are to return this’s request’s destination.\n        return this[kState].destination;\n    }\n    // Returns the referrer of request. Its value can be a same-origin URL if\n    // explicitly set in init, the empty string to indicate no referrer, and\n    // \"about:client\" when defaulting to the global’s default. This is used\n    // during fetching to determine the value of the `Referer` header of the\n    // request being made.\n    get referrer() {\n        webidl.brandCheck(this, Request);\n        // 1. If this’s request’s referrer is \"no-referrer\", then return the\n        // empty string.\n        if (this[kState].referrer === 'no-referrer') {\n            return '';\n        }\n        // 2. If this’s request’s referrer is \"client\", then return\n        // \"about:client\".\n        if (this[kState].referrer === 'client') {\n            return 'about:client';\n        }\n        // Return this’s request’s referrer, serialized.\n        return this[kState].referrer.toString();\n    }\n    // Returns the referrer policy associated with request.\n    // This is used during fetching to compute the value of the request’s\n    // referrer.\n    get referrerPolicy() {\n        webidl.brandCheck(this, Request);\n        // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n        return this[kState].referrerPolicy;\n    }\n    // Returns the mode associated with request, which is a string indicating\n    // whether the request will use CORS, or will be restricted to same-origin\n    // URLs.\n    get mode() {\n        webidl.brandCheck(this, Request);\n        // The mode getter steps are to return this’s request’s mode.\n        return this[kState].mode;\n    }\n    // Returns the credentials mode associated with request,\n    // which is a string indicating whether credentials will be sent with the\n    // request always, never, or only when sent to a same-origin URL.\n    get credentials() {\n        // The credentials getter steps are to return this’s request’s credentials mode.\n        return this[kState].credentials;\n    }\n    // Returns the cache mode associated with request,\n    // which is a string indicating how the request will\n    // interact with the browser’s cache when fetching.\n    get cache() {\n        webidl.brandCheck(this, Request);\n        // The cache getter steps are to return this’s request’s cache mode.\n        return this[kState].cache;\n    }\n    // Returns the redirect mode associated with request,\n    // which is a string indicating how redirects for the\n    // request will be handled during fetching. A request\n    // will follow redirects by default.\n    get redirect() {\n        webidl.brandCheck(this, Request);\n        // The redirect getter steps are to return this’s request’s redirect mode.\n        return this[kState].redirect;\n    }\n    // Returns request’s subresource integrity metadata, which is a\n    // cryptographic hash of the resource being fetched. Its value\n    // consists of multiple hashes separated by whitespace. [SRI]\n    get integrity() {\n        webidl.brandCheck(this, Request);\n        // The integrity getter steps are to return this’s request’s integrity\n        // metadata.\n        return this[kState].integrity;\n    }\n    // Returns a boolean indicating whether or not request can outlive the\n    // global in which it was created.\n    get keepalive() {\n        webidl.brandCheck(this, Request);\n        // The keepalive getter steps are to return this’s request’s keepalive.\n        return this[kState].keepalive;\n    }\n    // Returns a boolean indicating whether or not request is for a reload\n    // navigation.\n    get isReloadNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isReloadNavigation getter steps are to return true if this’s\n        // request’s reload-navigation flag is set; otherwise false.\n        return this[kState].reloadNavigation;\n    }\n    // Returns a boolean indicating whether or not request is for a history\n    // navigation (a.k.a. back-forward navigation).\n    get isHistoryNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isHistoryNavigation getter steps are to return true if this’s request’s\n        // history-navigation flag is set; otherwise false.\n        return this[kState].historyNavigation;\n    }\n    // Returns the signal associated with request, which is an AbortSignal\n    // object indicating whether or not request has been aborted, and its\n    // abort event handler.\n    get signal() {\n        webidl.brandCheck(this, Request);\n        // The signal getter steps are to return this’s signal.\n        return this[kSignal];\n    }\n    get body() {\n        webidl.brandCheck(this, Request);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Request);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    get duplex() {\n        webidl.brandCheck(this, Request);\n        return 'half';\n    }\n    // Returns a clone of request.\n    clone() {\n        webidl.brandCheck(this, Request);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body?.locked) {\n            throw new TypeError('unusable');\n        }\n        // 2. Let clonedRequest be the result of cloning this’s request.\n        const clonedRequest = cloneRequest(this[kState]);\n        // 3. Let clonedRequestObject be the result of creating a Request object,\n        // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n        // 4. Make clonedRequestObject’s signal follow this’s signal.\n        const ac = new AbortController();\n        if (this.signal.aborted) {\n            ac.abort(this.signal.reason);\n        } else {\n            let list = dependentControllerMap.get(this.signal);\n            if (list === undefined) {\n                list = new Set();\n                dependentControllerMap.set(this.signal, list);\n            }\n            const acRef = new WeakRef(ac);\n            list.add(acRef);\n            util.addAbortListener(ac.signal, buildAbort(acRef));\n        }\n        // 4. Return clonedRequestObject.\n        return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));\n    }\n    [nodeUtil.inspect.custom](depth, options) {\n        if (options.depth === null) {\n            options.depth = 2;\n        }\n        options.colors ??= true;\n        const properties = {\n            method: this.method,\n            url: this.url,\n            headers: this.headers,\n            destination: this.destination,\n            referrer: this.referrer,\n            referrerPolicy: this.referrerPolicy,\n            mode: this.mode,\n            credentials: this.credentials,\n            cache: this.cache,\n            redirect: this.redirect,\n            integrity: this.integrity,\n            keepalive: this.keepalive,\n            isReloadNavigation: this.isReloadNavigation,\n            isHistoryNavigation: this.isHistoryNavigation,\n            signal: this.signal\n        };\n        return `Request ${nodeUtil.formatWithOptions(options, properties)}`;\n    }\n}\nmixinBody(Request);\n// https://fetch.spec.whatwg.org/#requests\nfunction makeRequest(init) {\n    return {\n        method: init.method ?? 'GET',\n        localURLsOnly: init.localURLsOnly ?? false,\n        unsafeRequest: init.unsafeRequest ?? false,\n        body: init.body ?? null,\n        client: init.client ?? null,\n        reservedClient: init.reservedClient ?? null,\n        replacesClientId: init.replacesClientId ?? '',\n        window: init.window ?? 'client',\n        keepalive: init.keepalive ?? false,\n        serviceWorkers: init.serviceWorkers ?? 'all',\n        initiator: init.initiator ?? '',\n        destination: init.destination ?? '',\n        priority: init.priority ?? null,\n        origin: init.origin ?? 'client',\n        policyContainer: init.policyContainer ?? 'client',\n        referrer: init.referrer ?? 'client',\n        referrerPolicy: init.referrerPolicy ?? '',\n        mode: init.mode ?? 'no-cors',\n        useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,\n        credentials: init.credentials ?? 'same-origin',\n        useCredentials: init.useCredentials ?? false,\n        cache: init.cache ?? 'default',\n        redirect: init.redirect ?? 'follow',\n        integrity: init.integrity ?? '',\n        cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? '',\n        parserMetadata: init.parserMetadata ?? '',\n        reloadNavigation: init.reloadNavigation ?? false,\n        historyNavigation: init.historyNavigation ?? false,\n        userActivation: init.userActivation ?? false,\n        taintedOrigin: init.taintedOrigin ?? false,\n        redirectCount: init.redirectCount ?? 0,\n        responseTainting: init.responseTainting ?? 'basic',\n        preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,\n        done: init.done ?? false,\n        timingAllowFailed: init.timingAllowFailed ?? false,\n        urlList: init.urlList,\n        url: init.urlList[0],\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()\n    };\n}\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest(request) {\n    // To clone a request request, run these steps:\n    // 1. Let newRequest be a copy of request, except for its body.\n    const newRequest = makeRequest({\n        ...request,\n        body: null\n    });\n    // 2. If request’s body is non-null, set newRequest’s body to the\n    // result of cloning request’s body.\n    if (request.body != null) {\n        newRequest.body = cloneBody(request.body);\n    }\n    // 3. Return newRequest.\n    return newRequest;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#request-create\n * @param {any} innerRequest\n * @param {AbortSignal} signal\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Request}\n */ function fromInnerRequest(innerRequest, signal, guard) {\n    const request = new Request(kConstruct);\n    request[kState] = innerRequest;\n    request[kSignal] = signal;\n    request[kHeaders] = new Headers(kConstruct);\n    setHeadersList(request[kHeaders], innerRequest.headersList);\n    setHeadersGuard(request[kHeaders], guard);\n    return request;\n}\nObject.defineProperties(Request.prototype, {\n    method: kEnumerableProperty,\n    url: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    signal: kEnumerableProperty,\n    duplex: kEnumerableProperty,\n    destination: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    isHistoryNavigation: kEnumerableProperty,\n    isReloadNavigation: kEnumerableProperty,\n    keepalive: kEnumerableProperty,\n    integrity: kEnumerableProperty,\n    cache: kEnumerableProperty,\n    credentials: kEnumerableProperty,\n    attribute: kEnumerableProperty,\n    referrerPolicy: kEnumerableProperty,\n    referrer: kEnumerableProperty,\n    mode: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: 'Request',\n        configurable: true\n    }\n});\nwebidl.converters.Request = webidl.interfaceConverter(Request);\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function(V, prefix, argument) {\n    if (typeof V === 'string') {\n        return webidl.converters.USVString(V, prefix, argument);\n    }\n    if (V instanceof Request) {\n        return webidl.converters.Request(V, prefix, argument);\n    }\n    return webidl.converters.USVString(V, prefix, argument);\n};\nwebidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n    {\n        key: 'method',\n        converter: webidl.converters.ByteString\n    },\n    {\n        key: 'headers',\n        converter: webidl.converters.HeadersInit\n    },\n    {\n        key: 'body',\n        converter: webidl.nullableConverter(webidl.converters.BodyInit)\n    },\n    {\n        key: 'referrer',\n        converter: webidl.converters.USVString\n    },\n    {\n        key: 'referrerPolicy',\n        converter: webidl.converters.DOMString,\n        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        allowedValues: referrerPolicy\n    },\n    {\n        key: 'mode',\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#concept-request-mode\n        allowedValues: requestMode\n    },\n    {\n        key: 'credentials',\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcredentials\n        allowedValues: requestCredentials\n    },\n    {\n        key: 'cache',\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcache\n        allowedValues: requestCache\n    },\n    {\n        key: 'redirect',\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestredirect\n        allowedValues: requestRedirect\n    },\n    {\n        key: 'integrity',\n        converter: webidl.converters.DOMString\n    },\n    {\n        key: 'keepalive',\n        converter: webidl.converters.boolean\n    },\n    {\n        key: 'signal',\n        converter: webidl.nullableConverter((signal)=>webidl.converters.AbortSignal(signal, 'RequestInit', 'signal', {\n                strict: false\n            }))\n    },\n    {\n        key: 'window',\n        converter: webidl.converters.any\n    },\n    {\n        key: 'duplex',\n        converter: webidl.converters.DOMString,\n        allowedValues: requestDuplex\n    },\n    {\n        key: 'dispatcher',\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    Request,\n    makeRequest,\n    fromInnerRequest,\n    cloneRequest\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsR0FFM0I7QUFFQSxNQUFNLEVBQUVBLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsaUVBQVE7QUFDOUQsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU1DLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxlQUFlLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFQyxjQUFjLEVBQUUsR0FBR1IsbUJBQU9BLENBQUMsdUVBQVc7QUFDekksTUFBTSxFQUFFUyxvQkFBb0IsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQyw2RkFBc0I7QUFDL0QsTUFBTVUsT0FBT1YsbUJBQU9BLENBQUMscUVBQWlCO0FBQ3RDLE1BQU1XLFdBQVdYLG1CQUFPQSxDQUFDLDRCQUFXO0FBQ3BDLE1BQU0sRUFDSlksZ0JBQWdCLEVBQ2hCQyxVQUFVLEVBQ1ZDLHlCQUF5QixFQUMxQixHQUFHZCxtQkFBT0EsQ0FBQyxpRUFBUTtBQUNwQixNQUFNLEVBQ0plLG1CQUFtQixFQUNuQkMsd0JBQXdCLEVBQ3hCQyxjQUFjLEVBQ2RDLGVBQWUsRUFDZkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLFlBQVksRUFDWkMsYUFBYSxFQUNkLEdBQUd0QixtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QixNQUFNLEVBQUV1QixtQkFBbUIsRUFBRUMsMkJBQTJCLEVBQUVDLHVCQUF1QixFQUFFLEdBQUdmO0FBQ3RGLE1BQU0sRUFBRWdCLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHN0IsbUJBQU9BLENBQUMsdUVBQVc7QUFDdEUsTUFBTSxFQUFFOEIsTUFBTSxFQUFFLEdBQUc5QixtQkFBT0EsQ0FBQyxxRUFBVTtBQUNyQyxNQUFNLEVBQUUrQixhQUFhLEVBQUUsR0FBRy9CLG1CQUFPQSxDQUFDLHlFQUFZO0FB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VSxDQUFDNkksU0FBUztRQUN0Qyw4Q0FBOEM7UUFDOUNDLGVBQWU1TDtJQUNqQjtJQUNBO1FBQ0VxTCxLQUFLO1FBQ0xDLFdBQVc3SyxPQUFPcUMsVUFBVSxDQUFDNkksU0FBUztRQUN0QyxpREFBaUQ7UUFDakRDLGVBQWUvTDtJQUNqQjtJQUNBO1FBQ0V3TCxLQUFLO1FBQ0xDLFdBQVc3SyxPQUFPcUMsVUFBVSxDQUFDNkksU0FBUztJQUN4QztJQUNBO1FBQ0VOLEtBQUs7UUFDTEMsV0FBVzdLLE9BQU9xQyxVQUFVLENBQUMrSSxPQUFPO0lBQ3RDO0lBQ0E7UUFDRVIsS0FBSztRQUNMQyxXQUFXN0ssT0FBT2dMLGlCQUFpQixDQUNqQyxDQUFDckssU0FBV1gsT0FBT3FDLFVBQVUsQ0FBQ3FJLFdBQVcsQ0FDdkMvSixRQUNBLGVBQ0EsVUFDQTtnQkFBRTBLLFFBQVE7WUFBTTtJQUd0QjtJQUNBO1FBQ0VULEtBQUs7UUFDTEMsV0FBVzdLLE9BQU9xQyxVQUFVLENBQUNpSixHQUFHO0lBQ2xDO0lBQ0E7UUFDRVYsS0FBSztRQUNMQyxXQUFXN0ssT0FBT3FDLFVBQVUsQ0FBQzZJLFNBQVM7UUFDdENDLGVBQWUzTDtJQUNqQjtJQUNBO1FBQ0VvTCxLQUFLO1FBQ0xDLFdBQVc3SyxPQUFPcUMsVUFBVSxDQUFDaUosR0FBRztJQUNsQztDQUNEO0FBRURDLE9BQU9DLE9BQU8sR0FBRztJQUFFeko7SUFBU3FCO0lBQWFrRjtJQUFrQkw7QUFBYSIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxyZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgQWJvcnRDb250cm9sbGVyICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBtaXhpbkJvZHksIGNsb25lQm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHsgSGVhZGVycywgZmlsbDogZmlsbEhlYWRlcnMsIEhlYWRlcnNMaXN0LCBzZXRIZWFkZXJzR3VhcmQsIGdldEhlYWRlcnNHdWFyZCwgc2V0SGVhZGVyc0xpc3QsIGdldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBGaW5hbGl6YXRpb25SZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLXdlYWtyZWYnKSgpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHtcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgc2FtZU9yaWdpbixcbiAgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIGZvcmJpZGRlbk1ldGhvZHNTZXQsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCxcbiAgcmVmZXJyZXJQb2xpY3ksXG4gIHJlcXVlc3RSZWRpcmVjdCxcbiAgcmVxdWVzdE1vZGUsXG4gIHJlcXVlc3RDcmVkZW50aWFscyxcbiAgcmVxdWVzdENhY2hlLFxuICByZXF1ZXN0RHVwbGV4XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UsIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzIH0gPSB1dGlsXG5jb25zdCB7IGtIZWFkZXJzLCBrU2lnbmFsLCBrU3RhdGUsIGtEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGdldE1heExpc3RlbmVycywgc2V0TWF4TGlzdGVuZXJzLCBnZXRFdmVudExpc3RlbmVycywgZGVmYXVsdE1heExpc3RlbmVycyB9ID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuXG5jb25zdCBrQWJvcnRDb250cm9sbGVyID0gU3ltYm9sKCdhYm9ydENvbnRyb2xsZXInKVxuXG5jb25zdCByZXF1ZXN0RmluYWxpemVyID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh7IHNpZ25hbCwgYWJvcnQgfSkgPT4ge1xuICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydClcbn0pXG5cbmNvbnN0IGRlcGVuZGVudENvbnRyb2xsZXJNYXAgPSBuZXcgV2Vha01hcCgpXG5cbmZ1bmN0aW9uIGJ1aWxkQWJvcnQgKGFjUmVmKSB7XG4gIHJldHVybiBhYm9ydFxuXG4gIGZ1bmN0aW9uIGFib3J0ICgpIHtcbiAgICBjb25zdCBhYyA9IGFjUmVmLmRlcmVmKClcbiAgICBpZiAoYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ3VycmVudGx5LCB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCBGaW5hbGl6YXRpb25SZWdpc3RyeS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDc3NDhcbiAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFib3J0LCB0aGUgZmlyc3Qgc3RlcCBpcyB0byB1bnJlZ2lzdGVyIGZyb20gaXQuXG4gICAgICAvLyBJZiB0aGUgY29udHJvbGxlciBjYW4gcmVmZXIgdG8gaXQsIGl0IGlzIHN0aWxsIHJlZ2lzdGVyZWQuXG4gICAgICAvLyBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgIHJlcXVlc3RGaW5hbGl6ZXIudW5yZWdpc3RlcihhYm9ydClcblxuICAgICAgLy8gVW5zdWJzY3JpYmUgYSBsaXN0ZW5lci5cbiAgICAgIC8vIEZpbmFsaXphdGlvblJlZ2lzdHJ5IHdpbGwgbm8gbG9uZ2VyIGJlIGNhbGxlZCwgc28gdGhpcyBtdXN0IGJlIGRvbmUuXG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQpXG5cbiAgICAgIGFjLmFib3J0KHRoaXMucmVhc29uKVxuXG4gICAgICBjb25zdCBjb250cm9sbGVyTGlzdCA9IGRlcGVuZGVudENvbnRyb2xsZXJNYXAuZ2V0KGFjLnNpZ25hbClcblxuICAgICAgaWYgKGNvbnRyb2xsZXJMaXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXJMaXN0LnNpemUgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBjb250cm9sbGVyTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgY3RybCA9IHJlZi5kZXJlZigpXG4gICAgICAgICAgICBpZiAoY3RybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGN0cmwuYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXJMaXN0LmNsZWFyKClcbiAgICAgICAgfVxuICAgICAgICBkZXBlbmRlbnRDb250cm9sbGVyTWFwLmRlbGV0ZShhYy5zaWduYWwpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmxldCBwYXRjaE1ldGhvZFdhcm5pbmcgPSBmYWxzZVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1jbGFzc1xuY2xhc3MgUmVxdWVzdCB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdFxuICBjb25zdHJ1Y3RvciAoaW5wdXQsIGluaXQgPSB7fSkge1xuICAgIGlmIChpbnB1dCA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1JlcXVlc3QgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBpbnB1dCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGlucHV0LCBwcmVmaXgsICdpbnB1dCcpXG4gICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0KGluaXQsIHByZWZpeCwgJ2luaXQnKVxuXG4gICAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgbnVsbC5cbiAgICBsZXQgcmVxdWVzdCA9IG51bGxcblxuICAgIC8vIDIuIExldCBmYWxsYmFja01vZGUgYmUgbnVsbC5cbiAgICBsZXQgZmFsbGJhY2tNb2RlID0gbnVsbFxuXG4gICAgLy8gMy4gTGV0IGJhc2VVUkwgYmUgdGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBBUEkgYmFzZSBVUkwuXG4gICAgY29uc3QgYmFzZVVybCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QuYmFzZVVybFxuXG4gICAgLy8gNC4gTGV0IHNpZ25hbCBiZSBudWxsLlxuICAgIGxldCBzaWduYWwgPSBudWxsXG5cbiAgICAvLyA1LiBJZiBpbnB1dCBpcyBhIHN0cmluZywgdGhlbjpcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpc1trRGlzcGF0Y2hlcl0gPSBpbml0LmRpc3BhdGNoZXJcblxuICAgICAgLy8gMS4gTGV0IHBhcnNlZFVSTCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgaW5wdXQgd2l0aCBiYXNlVVJMLlxuICAgICAgLy8gMi4gSWYgcGFyc2VkVVJMIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBsZXQgcGFyc2VkVVJMXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRVUkwgPSBuZXcgVVJMKGlucHV0LCBiYXNlVXJsKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSAnICsgaW5wdXQsIHsgY2F1c2U6IGVyciB9KVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBwYXJzZWRVUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAocGFyc2VkVVJMLnVzZXJuYW1lIHx8IHBhcnNlZFVSTC5wYXNzd29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdSZXF1ZXN0IGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBmcm9tIGEgVVJMIHRoYXQgaW5jbHVkZXMgY3JlZGVudGlhbHM6ICcgK1xuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdCB0byBhIG5ldyByZXF1ZXN0IHdob3NlIFVSTCBpcyBwYXJzZWRVUkwuXG4gICAgICByZXF1ZXN0ID0gbWFrZVJlcXVlc3QoeyB1cmxMaXN0OiBbcGFyc2VkVVJMXSB9KVxuXG4gICAgICAvLyA1LiBTZXQgZmFsbGJhY2tNb2RlIHRvIFwiY29yc1wiLlxuICAgICAgZmFsbGJhY2tNb2RlID0gJ2NvcnMnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0Rpc3BhdGNoZXJdID0gaW5pdC5kaXNwYXRjaGVyIHx8IGlucHV0W2tEaXNwYXRjaGVyXVxuXG4gICAgICAvLyA2LiBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDcuIEFzc2VydDogaW5wdXQgaXMgYSBSZXF1ZXN0IG9iamVjdC5cbiAgICAgIGFzc2VydChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpXG5cbiAgICAgIC8vIDguIFNldCByZXF1ZXN0IHRvIGlucHV04oCZcyByZXF1ZXN0LlxuICAgICAgcmVxdWVzdCA9IGlucHV0W2tTdGF0ZV1cblxuICAgICAgLy8gOS4gU2V0IHNpZ25hbCB0byBpbnB1dOKAmXMgc2lnbmFsLlxuICAgICAgc2lnbmFsID0gaW5wdXRba1NpZ25hbF1cbiAgICB9XG5cbiAgICAvLyA3LiBMZXQgb3JpZ2luIGJlIHRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgb3JpZ2luLlxuICAgIGNvbnN0IG9yaWdpbiA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3Qub3JpZ2luXG5cbiAgICAvLyA4LiBMZXQgd2luZG93IGJlIFwiY2xpZW50XCIuXG4gICAgbGV0IHdpbmRvdyA9ICdjbGllbnQnXG5cbiAgICAvLyA5LiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgYW4gZW52aXJvbm1lbnQgc2V0dGluZ3Mgb2JqZWN0IGFuZCBpdHMgb3JpZ2luXG4gICAgLy8gaXMgc2FtZSBvcmlnaW4gd2l0aCBvcmlnaW4sIHRoZW4gc2V0IHdpbmRvdyB0byByZXF1ZXN04oCZcyB3aW5kb3cuXG4gICAgaWYgKFxuICAgICAgcmVxdWVzdC53aW5kb3c/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCcgJiZcbiAgICAgIHNhbWVPcmlnaW4ocmVxdWVzdC53aW5kb3csIG9yaWdpbilcbiAgICApIHtcbiAgICAgIHdpbmRvdyA9IHJlcXVlc3Qud2luZG93XG4gICAgfVxuXG4gICAgLy8gMTAuIElmIGluaXRbXCJ3aW5kb3dcIl0gZXhpc3RzIGFuZCBpcyBub24tbnVsbCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoaW5pdC53aW5kb3cgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJ3dpbmRvdycgb3B0aW9uICcke3dpbmRvd30nIG11c3QgYmUgbnVsbGApXG4gICAgfVxuXG4gICAgLy8gMTEuIElmIGluaXRbXCJ3aW5kb3dcIl0gZXhpc3RzLCB0aGVuIHNldCB3aW5kb3cgdG8gXCJuby13aW5kb3dcIi5cbiAgICBpZiAoJ3dpbmRvdycgaW4gaW5pdCkge1xuICAgICAgd2luZG93ID0gJ25vLXdpbmRvdydcbiAgICB9XG5cbiAgICAvLyAxMi4gU2V0IHJlcXVlc3QgdG8gYSBuZXcgcmVxdWVzdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICByZXF1ZXN0ID0gbWFrZVJlcXVlc3Qoe1xuICAgICAgLy8gVVJMIHJlcXVlc3TigJlzIFVSTC5cbiAgICAgIC8vIHVuZGljaSBpbXBsZW1lbnRhdGlvbiBub3RlOiB0aGlzIGlzIHNldCBhcyB0aGUgZmlyc3QgaXRlbSBpbiByZXF1ZXN0J3MgdXJsTGlzdCBpbiBtYWtlUmVxdWVzdFxuICAgICAgLy8gbWV0aG9kIHJlcXVlc3TigJlzIG1ldGhvZC5cbiAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAvLyBoZWFkZXIgbGlzdCBBIGNvcHkgb2YgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAvLyB1bmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogaGVhZGVyc0xpc3QgaXMgY2xvbmVkIGluIG1ha2VSZXF1ZXN0XG4gICAgICBoZWFkZXJzTGlzdDogcmVxdWVzdC5oZWFkZXJzTGlzdCxcbiAgICAgIC8vIHVuc2FmZS1yZXF1ZXN0IGZsYWcgU2V0LlxuICAgICAgdW5zYWZlUmVxdWVzdDogcmVxdWVzdC51bnNhZmVSZXF1ZXN0LFxuICAgICAgLy8gY2xpZW50IFRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdC5cbiAgICAgIGNsaWVudDogZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdCxcbiAgICAgIC8vIHdpbmRvdyB3aW5kb3cuXG4gICAgICB3aW5kb3csXG4gICAgICAvLyBwcmlvcml0eSByZXF1ZXN04oCZcyBwcmlvcml0eS5cbiAgICAgIHByaW9yaXR5OiByZXF1ZXN0LnByaW9yaXR5LFxuICAgICAgLy8gb3JpZ2luIHJlcXVlc3TigJlzIG9yaWdpbi4gVGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBvcmlnaW4gaXMgb25seSBzaWduaWZpY2FudCBmb3IgbmF2aWdhdGlvbiByZXF1ZXN0c1xuICAgICAgLy8gYmVpbmcgaGFuZGxlZCBieSBhIHNlcnZpY2Ugd29ya2VyLiBJbiB0aGlzIHNjZW5hcmlvIGEgcmVxdWVzdCBjYW4gaGF2ZSBhbiBvcmlnaW4gdGhhdCBpcyBkaWZmZXJlbnRcbiAgICAgIC8vIGZyb20gdGhlIGN1cnJlbnQgY2xpZW50LlxuICAgICAgb3JpZ2luOiByZXF1ZXN0Lm9yaWdpbixcbiAgICAgIC8vIHJlZmVycmVyIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICAgICAgcmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG4gICAgICAvLyByZWZlcnJlciBwb2xpY3kgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHJlcXVlc3QucmVmZXJyZXJQb2xpY3ksXG4gICAgICAvLyBtb2RlIHJlcXVlc3TigJlzIG1vZGUuXG4gICAgICBtb2RlOiByZXF1ZXN0Lm1vZGUsXG4gICAgICAvLyBjcmVkZW50aWFscyBtb2RlIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUuXG4gICAgICBjcmVkZW50aWFsczogcmVxdWVzdC5jcmVkZW50aWFscyxcbiAgICAgIC8vIGNhY2hlIG1vZGUgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZS5cbiAgICAgIGNhY2hlOiByZXF1ZXN0LmNhY2hlLFxuICAgICAgLy8gcmVkaXJlY3QgbW9kZSByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlLlxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICAvLyBpbnRlZ3JpdHkgbWV0YWRhdGEgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhLlxuICAgICAgaW50ZWdyaXR5OiByZXF1ZXN0LmludGVncml0eSxcbiAgICAgIC8vIGtlZXBhbGl2ZSByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgICBrZWVwYWxpdmU6IHJlcXVlc3Qua2VlcGFsaXZlLFxuICAgICAgLy8gcmVsb2FkLW5hdmlnYXRpb24gZmxhZyByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVsb2FkTmF2aWdhdGlvbjogcmVxdWVzdC5yZWxvYWROYXZpZ2F0aW9uLFxuICAgICAgLy8gaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICBoaXN0b3J5TmF2aWdhdGlvbjogcmVxdWVzdC5oaXN0b3J5TmF2aWdhdGlvbixcbiAgICAgIC8vIFVSTCBsaXN0IEEgY2xvbmUgb2YgcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gICAgICB1cmxMaXN0OiBbLi4ucmVxdWVzdC51cmxMaXN0XVxuICAgIH0pXG5cbiAgICBjb25zdCBpbml0SGFzS2V5ID0gT2JqZWN0LmtleXMoaW5pdCkubGVuZ3RoICE9PSAwXG5cbiAgICAvLyAxMy4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKGluaXRIYXNLZXkpIHtcbiAgICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiLCB0aGVuIHNldCBpdCB0byBcInNhbWUtb3JpZ2luXCIuXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICAgIHJlcXVlc3QubW9kZSA9ICdzYW1lLW9yaWdpbidcbiAgICAgIH1cblxuICAgICAgLy8gMi4gVW5zZXQgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbiA9IGZhbHNlXG5cbiAgICAgIC8vIDMuIFVuc2V0IHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVxdWVzdC5oaXN0b3J5TmF2aWdhdGlvbiA9IGZhbHNlXG5cbiAgICAgIC8vIDQuIFNldCByZXF1ZXN04oCZcyBvcmlnaW4gdG8gXCJjbGllbnRcIi5cbiAgICAgIHJlcXVlc3Qub3JpZ2luID0gJ2NsaWVudCdcblxuICAgICAgLy8gNS4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwiY2xpZW50XCJcbiAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSAnY2xpZW50J1xuXG4gICAgICAvLyA2LiBTZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gJydcblxuICAgICAgLy8gNy4gU2V0IHJlcXVlc3TigJlzIFVSTCB0byByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAgIHJlcXVlc3QudXJsID0gcmVxdWVzdC51cmxMaXN0W3JlcXVlc3QudXJsTGlzdC5sZW5ndGggLSAxXVxuXG4gICAgICAvLyA4LiBTZXQgcmVxdWVzdOKAmXMgVVJMIGxpc3QgdG8gwqsgcmVxdWVzdOKAmXMgVVJMIMK7LlxuICAgICAgcmVxdWVzdC51cmxMaXN0ID0gW3JlcXVlc3QudXJsXVxuICAgIH1cblxuICAgIC8vIDE0LiBJZiBpbml0W1wicmVmZXJyZXJcIl0gZXhpc3RzLCB0aGVuOlxuICAgIGlmIChpbml0LnJlZmVycmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCByZWZlcnJlciBiZSBpbml0W1wicmVmZXJyZXJcIl0uXG4gICAgICBjb25zdCByZWZlcnJlciA9IGluaXQucmVmZXJyZXJcblxuICAgICAgLy8gMi4gSWYgcmVmZXJyZXIgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJuby1yZWZlcnJlclwiLlxuICAgICAgaWYgKHJlZmVycmVyID09PSAnJykge1xuICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ25vLXJlZmVycmVyJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMS4gTGV0IHBhcnNlZFJlZmVycmVyIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyByZWZlcnJlciB3aXRoXG4gICAgICAgIC8vIGJhc2VVUkwuXG4gICAgICAgIC8vIDIuIElmIHBhcnNlZFJlZmVycmVyIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIGxldCBwYXJzZWRSZWZlcnJlclxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZFJlZmVycmVyID0gbmV3IFVSTChyZWZlcnJlciwgYmFzZVVybClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVmZXJyZXIgXCIke3JlZmVycmVyfVwiIGlzIG5vdCBhIHZhbGlkIFVSTC5gLCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIElmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWVcbiAgICAgICAgLy8gLSBwYXJzZWRSZWZlcnJlcuKAmXMgc2NoZW1lIGlzIFwiYWJvdXRcIiBhbmQgcGF0aCBpcyB0aGUgc3RyaW5nIFwiY2xpZW50XCJcbiAgICAgICAgLy8gLSBwYXJzZWRSZWZlcnJlcuKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIG9yaWdpblxuICAgICAgICAvLyB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHBhcnNlZFJlZmVycmVyLnByb3RvY29sID09PSAnYWJvdXQ6JyAmJiBwYXJzZWRSZWZlcnJlci5ob3N0bmFtZSA9PT0gJ2NsaWVudCcpIHx8XG4gICAgICAgICAgKG9yaWdpbiAmJiAhc2FtZU9yaWdpbihwYXJzZWRSZWZlcnJlciwgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdC5iYXNlVXJsKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICdjbGllbnQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gcGFyc2VkUmVmZXJyZXIuXG4gICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9IHBhcnNlZFJlZmVycmVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxNS4gSWYgaW5pdFtcInJlZmVycmVyUG9saWN5XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5XG4gICAgLy8gdG8gaXQuXG4gICAgaWYgKGluaXQucmVmZXJyZXJQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3lcbiAgICB9XG5cbiAgICAvLyAxNi4gTGV0IG1vZGUgYmUgaW5pdFtcIm1vZGVcIl0gaWYgaXQgZXhpc3RzLCBhbmQgZmFsbGJhY2tNb2RlIG90aGVyd2lzZS5cbiAgICBsZXQgbW9kZVxuICAgIGlmIChpbml0Lm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbW9kZSA9IGluaXQubW9kZVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlID0gZmFsbGJhY2tNb2RlXG4gICAgfVxuXG4gICAgLy8gMTcuIElmIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChtb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1JlcXVlc3QgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCByZXF1ZXN0IG1vZGUgbmF2aWdhdGUuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAxOC4gSWYgbW9kZSBpcyBub24tbnVsbCwgc2V0IHJlcXVlc3TigJlzIG1vZGUgdG8gbW9kZS5cbiAgICBpZiAobW9kZSAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0Lm1vZGUgPSBtb2RlXG4gICAgfVxuXG4gICAgLy8gMTkuIElmIGluaXRbXCJjcmVkZW50aWFsc1wiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGVcbiAgICAvLyB0byBpdC5cbiAgICBpZiAoaW5pdC5jcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID0gaW5pdC5jcmVkZW50aWFsc1xuICAgIH1cblxuICAgIC8vIDE4LiBJZiBpbml0W1wiY2FjaGVcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIGl0LlxuICAgIGlmIChpbml0LmNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QuY2FjaGUgPSBpbml0LmNhY2hlXG4gICAgfVxuXG4gICAgLy8gMjEuIElmIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJvbmx5LWlmLWNhY2hlZFwiIGFuZCByZXF1ZXN04oCZcyBtb2RlIGlzXG4gICAgLy8gbm90IFwic2FtZS1vcmlnaW5cIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAocmVxdWVzdC5jYWNoZSA9PT0gJ29ubHktaWYtY2FjaGVkJyAmJiByZXF1ZXN0Lm1vZGUgIT09ICdzYW1lLW9yaWdpbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ29ubHktaWYtY2FjaGVkJyBjYW4gYmUgc2V0IG9ubHkgd2l0aCAnc2FtZS1vcmlnaW4nIG1vZGVcIlxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDIyLiBJZiBpbml0W1wicmVkaXJlY3RcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIHRvIGl0LlxuICAgIGlmIChpbml0LnJlZGlyZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBpbml0LnJlZGlyZWN0XG4gICAgfVxuXG4gICAgLy8gMjMuIElmIGluaXRbXCJpbnRlZ3JpdHlcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgdG8gaXQuXG4gICAgaWYgKGluaXQuaW50ZWdyaXR5ICE9IG51bGwpIHtcbiAgICAgIHJlcXVlc3QuaW50ZWdyaXR5ID0gU3RyaW5nKGluaXQuaW50ZWdyaXR5KVxuICAgIH1cblxuICAgIC8vIDI0LiBJZiBpbml0W1wia2VlcGFsaXZlXCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMga2VlcGFsaXZlIHRvIGl0LlxuICAgIGlmIChpbml0LmtlZXBhbGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmtlZXBhbGl2ZSA9IEJvb2xlYW4oaW5pdC5rZWVwYWxpdmUpXG4gICAgfVxuXG4gICAgLy8gMjUuIElmIGluaXRbXCJtZXRob2RcIl0gZXhpc3RzLCB0aGVuOlxuICAgIGlmIChpbml0Lm1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgbWV0aG9kIGJlIGluaXRbXCJtZXRob2RcIl0uXG4gICAgICBsZXQgbWV0aG9kID0gaW5pdC5tZXRob2RcblxuICAgICAgY29uc3QgbWF5QmVOb3JtYWxpemVkID0gbm9ybWFsaXplZE1ldGhvZFJlY29yZHNbbWV0aG9kXVxuXG4gICAgICBpZiAobWF5QmVOb3JtYWxpemVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTm90ZTogQnlwYXNzIHZhbGlkYXRpb24gREVMRVRFLCBHRVQsIEhFQUQsIE9QVElPTlMsIFBPU1QsIFBVVCwgUEFUQ0ggYW5kIHRoZXNlIGxvd2VyY2FzZSBvbmVzXG4gICAgICAgIHJlcXVlc3QubWV0aG9kID0gbWF5QmVOb3JtYWxpemVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAyLiBJZiBtZXRob2QgaXMgbm90IGEgbWV0aG9kIG9yIG1ldGhvZCBpcyBhIGZvcmJpZGRlbiBtZXRob2QsIHRoZW5cbiAgICAgICAgLy8gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIGlmICghaXNWYWxpZEhUVFBUb2tlbihtZXRob2QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJyR7bWV0aG9kfScgaXMgbm90IGEgdmFsaWQgSFRUUCBtZXRob2QuYClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwcGVyQ2FzZSA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG5cbiAgICAgICAgaWYgKGZvcmJpZGRlbk1ldGhvZHNTZXQuaGFzKHVwcGVyQ2FzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnJHttZXRob2R9JyBIVFRQIG1ldGhvZCBpcyB1bnN1cHBvcnRlZC5gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gTm9ybWFsaXplIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kLW5vcm1hbGl6ZVxuICAgICAgICAvLyBOb3RlOiBtdXN0IGJlIGluIHVwcGVyY2FzZVxuICAgICAgICBtZXRob2QgPSBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2VbdXBwZXJDYXNlXSA/PyBtZXRob2RcblxuICAgICAgICAvLyA0LiBTZXQgcmVxdWVzdOKAmXMgbWV0aG9kIHRvIG1ldGhvZC5cbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPSBtZXRob2RcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXRjaE1ldGhvZFdhcm5pbmcgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnVXNpbmcgYHBhdGNoYCBpcyBoaWdobHkgbGlrZWx5IHRvIHJlc3VsdCBpbiBhIGA0MDUgTWV0aG9kIE5vdCBBbGxvd2VkYC4gYFBBVENIYCBpcyBtdWNoIG1vcmUgbGlrZWx5IHRvIHN1Y2NlZWQuJywge1xuICAgICAgICAgIGNvZGU6ICdVTkRJQ0ktRkVUQ0gtcGF0Y2gnXG4gICAgICAgIH0pXG5cbiAgICAgICAgcGF0Y2hNZXRob2RXYXJuaW5nID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDI2LiBJZiBpbml0W1wic2lnbmFsXCJdIGV4aXN0cywgdGhlbiBzZXQgc2lnbmFsIHRvIGl0LlxuICAgIGlmIChpbml0LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaWduYWwgPSBpbml0LnNpZ25hbFxuICAgIH1cblxuICAgIC8vIDI3LiBTZXQgdGhpc+KAmXMgcmVxdWVzdCB0byByZXF1ZXN0LlxuICAgIHRoaXNba1N0YXRlXSA9IHJlcXVlc3RcblxuICAgIC8vIDI4LiBTZXQgdGhpc+KAmXMgc2lnbmFsIHRvIGEgbmV3IEFib3J0U2lnbmFsIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0uXG4gICAgLy8gVE9ETzogY291bGQgdGhpcyBiZSBzaW1wbGlmaWVkIHdpdGggQWJvcnRTaWduYWwuYW55XG4gICAgLy8gKGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWFib3J0c2lnbmFsLWFueSlcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIHRoaXNba1NpZ25hbF0gPSBhYy5zaWduYWxcblxuICAgIC8vIDI5LiBJZiBzaWduYWwgaXMgbm90IG51bGwsIHRoZW4gbWFrZSB0aGlz4oCZcyBzaWduYWwgZm9sbG93IHNpZ25hbC5cbiAgICBpZiAoc2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXNpZ25hbCB8fFxuICAgICAgICB0eXBlb2Ygc2lnbmFsLmFib3J0ZWQgIT09ICdib29sZWFuJyB8fFxuICAgICAgICB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXCJcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWMuYWJvcnQoc2lnbmFsLnJlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgYSBzdHJvbmcgcmVmIHRvIGFjIHdoaWxlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIC8vIGlzIGFsaXZlLiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IEFib3J0Q29udHJvbGxlclxuICAgICAgICAvLyBmcm9tIGJlaW5nIHByZW1hdHVyZWx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xOTI2LlxuICAgICAgICB0aGlzW2tBYm9ydENvbnRyb2xsZXJdID0gYWNcblxuICAgICAgICBjb25zdCBhY1JlZiA9IG5ldyBXZWFrUmVmKGFjKVxuICAgICAgICBjb25zdCBhYm9ydCA9IGJ1aWxkQWJvcnQoYWNSZWYpXG5cbiAgICAgICAgLy8gVGhpcmQtcGFydHkgQWJvcnRDb250cm9sbGVycyBtYXkgbm90IHdvcmsgd2l0aCB0aGVzZS5cbiAgICAgICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzE5MTAjaXNzdWVjb21tZW50LTE0NjQ0OTU2MTkuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSWYgdGhlIG1heCBhbW91bnQgb2YgbGlzdGVuZXJzIGlzIGVxdWFsIHRvIHRoZSBkZWZhdWx0LCBpbmNyZWFzZSBpdFxuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaW4gbm9kZSA+PSB2MTkuOS4wXG4gICAgICAgICAgaWYgKHR5cGVvZiBnZXRNYXhMaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgJiYgZ2V0TWF4TGlzdGVuZXJzKHNpZ25hbCkgPT09IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHNldE1heExpc3RlbmVycygxNTAwLCBzaWduYWwpXG4gICAgICAgICAgfSBlbHNlIGlmIChnZXRFdmVudExpc3RlbmVycyhzaWduYWwsICdhYm9ydCcpLmxlbmd0aCA+PSBkZWZhdWx0TWF4TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoMTUwMCwgc2lnbmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgIHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIGFib3J0KVxuICAgICAgICAvLyBUaGUgdGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhIHJlZ2lzdHJ5IGtleSB0byBiZSB1bnJlZ2lzdGVyZWQuXG4gICAgICAgIC8vIFdpdGhvdXQgaXQsIHlvdSBjYW5ub3QgdW5yZWdpc3Rlci5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICAgICAgLy8gYWJvcnQgaXMgdXNlZCBhcyB0aGUgdW5yZWdpc3RlciBrZXkuIChiZWNhdXNlIGl0IGlzIHVuaXF1ZSlcbiAgICAgICAgcmVxdWVzdEZpbmFsaXplci5yZWdpc3RlcihhYywgeyBzaWduYWwsIGFib3J0IH0sIGFib3J0KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMwLiBTZXQgdGhpc+KAmXMgaGVhZGVycyB0byBhIG5ldyBIZWFkZXJzIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0sIHdob3NlIGhlYWRlciBsaXN0IGlzIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGFuZCBndWFyZCBpc1xuICAgIC8vIFwicmVxdWVzdFwiLlxuICAgIHRoaXNba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgICBzZXRIZWFkZXJzTGlzdCh0aGlzW2tIZWFkZXJzXSwgcmVxdWVzdC5oZWFkZXJzTGlzdClcbiAgICBzZXRIZWFkZXJzR3VhcmQodGhpc1trSGVhZGVyc10sICdyZXF1ZXN0JylcblxuICAgIC8vIDMxLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIFwibm8tY29yc1wiLCB0aGVuOlxuICAgIGlmIChtb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgIC8vIDEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kLFxuICAgICAgLy8gdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmICghY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LmhhcyhyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgJyR7cmVxdWVzdC5tZXRob2R9IGlzIHVuc3VwcG9ydGVkIGluIG5vLWNvcnMgbW9kZS5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkIHRvIFwicmVxdWVzdC1uby1jb3JzXCIuXG4gICAgICBzZXRIZWFkZXJzR3VhcmQodGhpc1trSGVhZGVyc10sICdyZXF1ZXN0LW5vLWNvcnMnKVxuICAgIH1cblxuICAgIC8vIDMyLiBJZiBpbml0IGlzIG5vdCBlbXB0eSwgdGhlbjpcbiAgICBpZiAoaW5pdEhhc0tleSkge1xuICAgICAgLyoqIEB0eXBlIHtIZWFkZXJzTGlzdH0gKi9cbiAgICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gZ2V0SGVhZGVyc0xpc3QodGhpc1trSGVhZGVyc10pXG4gICAgICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhIGNvcHkgb2YgdGhpc+KAmXMgaGVhZGVycyBhbmQgaXRzIGFzc29jaWF0ZWQgaGVhZGVyXG4gICAgICAvLyBsaXN0LlxuICAgICAgLy8gMi4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIHNldCBoZWFkZXJzIHRvIGluaXRbXCJoZWFkZXJzXCJdLlxuICAgICAgY29uc3QgaGVhZGVycyA9IGluaXQuaGVhZGVycyAhPT0gdW5kZWZpbmVkID8gaW5pdC5oZWFkZXJzIDogbmV3IEhlYWRlcnNMaXN0KGhlYWRlcnNMaXN0KVxuXG4gICAgICAvLyAzLiBFbXB0eSB0aGlz4oCZcyBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIGhlYWRlcnNMaXN0LmNsZWFyKClcblxuICAgICAgLy8gNC4gSWYgaGVhZGVycyBpcyBhIEhlYWRlcnMgb2JqZWN0LCB0aGVuIGZvciBlYWNoIGhlYWRlciBpbiBpdHMgaGVhZGVyXG4gICAgICAvLyBsaXN0LCBhcHBlbmQgaGVhZGVy4oCZcyBuYW1lL2hlYWRlcuKAmXMgdmFsdWUgdG8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVyc0xpc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgaGVhZGVycy5yYXdWYWx1ZXMoKSkge1xuICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChuYW1lLCB2YWx1ZSwgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogQ29weSB0aGUgYHNldC1jb29raWVgIG1ldGEtZGF0YS5cbiAgICAgICAgaGVhZGVyc0xpc3QuY29va2llcyA9IGhlYWRlcnMuY29va2llc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBmaWxsIHRoaXPigJlzIGhlYWRlcnMgd2l0aCBoZWFkZXJzLlxuICAgICAgICBmaWxsSGVhZGVycyh0aGlzW2tIZWFkZXJzXSwgaGVhZGVycylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzMy4gTGV0IGlucHV0Qm9keSBiZSBpbnB1dOKAmXMgcmVxdWVzdOKAmXMgYm9keSBpZiBpbnB1dCBpcyBhIFJlcXVlc3RcbiAgICAvLyBvYmplY3Q7IG90aGVyd2lzZSBudWxsLlxuICAgIGNvbnN0IGlucHV0Qm9keSA9IGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0W2tTdGF0ZV0uYm9keSA6IG51bGxcblxuICAgIC8vIDM0LiBJZiBlaXRoZXIgaW5pdFtcImJvZHlcIl0gZXhpc3RzIGFuZCBpcyBub24tbnVsbCBvciBpbnB1dEJvZHkgaXNcbiAgICAvLyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBgR0VUYCBvciBgSEVBRGAsIHRoZW4gdGhyb3cgYVxuICAgIC8vIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICAoaW5pdC5ib2R5ICE9IG51bGwgfHwgaW5wdXRCb2R5ICE9IG51bGwpICYmXG4gICAgICAocmVxdWVzdC5tZXRob2QgPT09ICdHRVQnIHx8IHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHkuJylcbiAgICB9XG5cbiAgICAvLyAzNS4gTGV0IGluaXRCb2R5IGJlIG51bGwuXG4gICAgbGV0IGluaXRCb2R5ID0gbnVsbFxuXG4gICAgLy8gMzYuIElmIGluaXRbXCJib2R5XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW46XG4gICAgaWYgKGluaXQuYm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxLiBMZXQgQ29udGVudC1UeXBlIGJlIG51bGwuXG4gICAgICAvLyAyLiBTZXQgaW5pdEJvZHkgYW5kIENvbnRlbnQtVHlwZSB0byB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmdcbiAgICAgIC8vIGluaXRbXCJib2R5XCJdLCB3aXRoIGtlZXBhbGl2ZSBzZXQgdG8gcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAgY29uc3QgW2V4dHJhY3RlZEJvZHksIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KFxuICAgICAgICBpbml0LmJvZHksXG4gICAgICAgIHJlcXVlc3Qua2VlcGFsaXZlXG4gICAgICApXG4gICAgICBpbml0Qm9keSA9IGV4dHJhY3RlZEJvZHlcblxuICAgICAgLy8gMywgSWYgQ29udGVudC1UeXBlIGlzIG5vbi1udWxsIGFuZCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdCBkb2VzXG4gICAgICAvLyBub3QgY29udGFpbiBgQ29udGVudC1UeXBlYCwgdGhlbiBhcHBlbmQgYENvbnRlbnQtVHlwZWAvQ29udGVudC1UeXBlIHRvXG4gICAgICAvLyB0aGlz4oCZcyBoZWFkZXJzLlxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmICFnZXRIZWFkZXJzTGlzdCh0aGlzW2tIZWFkZXJzXSkuY29udGFpbnMoJ2NvbnRlbnQtdHlwZScsIHRydWUpKSB7XG4gICAgICAgIHRoaXNba0hlYWRlcnNdLmFwcGVuZCgnY29udGVudC10eXBlJywgY29udGVudFR5cGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzcuIExldCBpbnB1dE9ySW5pdEJvZHkgYmUgaW5pdEJvZHkgaWYgaXQgaXMgbm9uLW51bGw7IG90aGVyd2lzZVxuICAgIC8vIGlucHV0Qm9keS5cbiAgICBjb25zdCBpbnB1dE9ySW5pdEJvZHkgPSBpbml0Qm9keSA/PyBpbnB1dEJvZHlcblxuICAgIC8vIDM4LiBJZiBpbnB1dE9ySW5pdEJvZHkgaXMgbm9uLW51bGwgYW5kIGlucHV0T3JJbml0Qm9keeKAmXMgc291cmNlIGlzXG4gICAgLy8gbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5wdXRPckluaXRCb2R5ICE9IG51bGwgJiYgaW5wdXRPckluaXRCb2R5LnNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAvLyAxLiBJZiBpbml0Qm9keSBpcyBub24tbnVsbCBhbmQgaW5pdFtcImR1cGxleFwiXSBkb2VzIG5vdCBleGlzdCxcbiAgICAgIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaW5pdEJvZHkgIT0gbnVsbCAmJiBpbml0LmR1cGxleCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3RJbml0OiBkdXBsZXggb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gc2VuZGluZyBhIGJvZHkuJylcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbW9kZSBpcyBuZWl0aGVyIFwic2FtZS1vcmlnaW5cIiBub3IgXCJjb3JzXCIsXG4gICAgICAvLyB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSAhPT0gJ3NhbWUtb3JpZ2luJyAmJiByZXF1ZXN0Lm1vZGUgIT09ICdjb3JzJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdJZiByZXF1ZXN0IGlzIG1hZGUgZnJvbSBSZWFkYWJsZVN0cmVhbSwgbW9kZSBzaG91bGQgYmUgXCJzYW1lLW9yaWdpblwiIG9yIFwiY29yc1wiJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIFNldCB0aGlz4oCZcyByZXF1ZXN04oCZcyB1c2UtQ09SUy1wcmVmbGlnaHQgZmxhZy5cbiAgICAgIHJlcXVlc3QudXNlQ09SU1ByZWZsaWdodEZsYWcgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gMzkuIExldCBmaW5hbEJvZHkgYmUgaW5wdXRPckluaXRCb2R5LlxuICAgIGxldCBmaW5hbEJvZHkgPSBpbnB1dE9ySW5pdEJvZHlcblxuICAgIC8vIDQwLiBJZiBpbml0Qm9keSBpcyBudWxsIGFuZCBpbnB1dEJvZHkgaXMgbm9uLW51bGwsIHRoZW46XG4gICAgaWYgKGluaXRCb2R5ID09IG51bGwgJiYgaW5wdXRCb2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDEuIElmIGlucHV0IGlzIHVudXNhYmxlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHV0aWwuaXNEaXN0dXJiZWQoaW5wdXRCb2R5LnN0cmVhbSkgfHwgaW5wdXRCb2R5LnN0cmVhbS5sb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnN0cnVjdCBhIFJlcXVlc3Qgd2l0aCBhIFJlcXVlc3Qgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1c2VkLidcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgZmluYWxCb2R5IHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBwcm94eSBmb3IgaW5wdXRCb2R5LlxuICAgICAgLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tY3JlYXRlLWEtcHJveHlcbiAgICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpXG4gICAgICBpbnB1dEJvZHkuc3RyZWFtLnBpcGVUaHJvdWdoKGlkZW50aXR5VHJhbnNmb3JtKVxuICAgICAgZmluYWxCb2R5ID0ge1xuICAgICAgICBzb3VyY2U6IGlucHV0Qm9keS5zb3VyY2UsXG4gICAgICAgIGxlbmd0aDogaW5wdXRCb2R5Lmxlbmd0aCxcbiAgICAgICAgc3RyZWFtOiBpZGVudGl0eVRyYW5zZm9ybS5yZWFkYWJsZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQxLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgYm9keSB0byBmaW5hbEJvZHkuXG4gICAgdGhpc1trU3RhdGVdLmJvZHkgPSBmaW5hbEJvZHlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgSFRUUCBtZXRob2QsIHdoaWNoIGlzIFwiR0VUXCIgYnkgZGVmYXVsdC5cbiAgZ2V0IG1ldGhvZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBtZXRob2QgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgbWV0aG9kLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubWV0aG9kXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBVUkwgb2YgcmVxdWVzdCBhcyBhIHN0cmluZy5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgVVJMLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXNba1N0YXRlXS51cmwpXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgSGVhZGVycyBvYmplY3QgY29uc2lzdGluZyBvZiB0aGUgaGVhZGVycyBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdC5cbiAgLy8gTm90ZSB0aGF0IGhlYWRlcnMgYWRkZWQgaW4gdGhlIG5ldHdvcmsgbGF5ZXIgYnkgdGhlIHVzZXIgYWdlbnQgd2lsbCBub3RcbiAgLy8gYmUgYWNjb3VudGVkIGZvciBpbiB0aGlzIG9iamVjdCwgZS5nLiwgdGhlIFwiSG9zdFwiIGhlYWRlci5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzXVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUga2luZCBvZiByZXNvdXJjZSByZXF1ZXN0ZWQgYnkgcmVxdWVzdCwgZS5nLiwgXCJkb2N1bWVudFwiXG4gIC8vIG9yIFwic2NyaXB0XCIuXG4gIGdldCBkZXN0aW5hdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBnZXR0ZXIgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbi5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmRlc3RpbmF0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWZlcnJlciBvZiByZXF1ZXN0LiBJdHMgdmFsdWUgY2FuIGJlIGEgc2FtZS1vcmlnaW4gVVJMIGlmXG4gIC8vIGV4cGxpY2l0bHkgc2V0IGluIGluaXQsIHRoZSBlbXB0eSBzdHJpbmcgdG8gaW5kaWNhdGUgbm8gcmVmZXJyZXIsIGFuZFxuICAvLyBcImFib3V0OmNsaWVudFwiIHdoZW4gZGVmYXVsdGluZyB0byB0aGUgZ2xvYmFs4oCZcyBkZWZhdWx0LiBUaGlzIGlzIHVzZWRcbiAgLy8gZHVyaW5nIGZldGNoaW5nIHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgdGhlIGBSZWZlcmVyYCBoZWFkZXIgb2YgdGhlXG4gIC8vIHJlcXVlc3QgYmVpbmcgbWFkZS5cbiAgZ2V0IHJlZmVycmVyICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJuby1yZWZlcnJlclwiLCB0aGVuIHJldHVybiB0aGVcbiAgICAvLyBlbXB0eSBzdHJpbmcuXG4gICAgaWYgKHRoaXNba1N0YXRlXS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJjbGllbnRcIiwgdGhlbiByZXR1cm5cbiAgICAvLyBcImFib3V0OmNsaWVudFwiLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0ucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG4gICAgICByZXR1cm4gJ2Fib3V0OmNsaWVudCdcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIsIHNlcmlhbGl6ZWQuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWZlcnJlci50b1N0cmluZygpXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWZlcnJlciBwb2xpY3kgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdXNlZCBkdXJpbmcgZmV0Y2hpbmcgdG8gY29tcHV0ZSB0aGUgdmFsdWUgb2YgdGhlIHJlcXVlc3TigJlzXG4gIC8vIHJlZmVycmVyLlxuICBnZXQgcmVmZXJyZXJQb2xpY3kgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgcmVmZXJyZXJQb2xpY3kgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVmZXJyZXJQb2xpY3lcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmdcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCB3aWxsIHVzZSBDT1JTLCBvciB3aWxsIGJlIHJlc3RyaWN0ZWQgdG8gc2FtZS1vcmlnaW5cbiAgLy8gVVJMcy5cbiAgZ2V0IG1vZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgbW9kZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubW9kZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY3JlZGVudGlhbHMgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyB3aGV0aGVyIGNyZWRlbnRpYWxzIHdpbGwgYmUgc2VudCB3aXRoIHRoZVxuICAvLyByZXF1ZXN0IGFsd2F5cywgbmV2ZXIsIG9yIG9ubHkgd2hlbiBzZW50IHRvIGEgc2FtZS1vcmlnaW4gVVJMLlxuICBnZXQgY3JlZGVudGlhbHMgKCkge1xuICAgIC8vIFRoZSBjcmVkZW50aWFscyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uY3JlZGVudGlhbHNcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGNhY2hlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgaG93IHRoZSByZXF1ZXN0IHdpbGxcbiAgLy8gaW50ZXJhY3Qgd2l0aCB0aGUgYnJvd3NlcuKAmXMgY2FjaGUgd2hlbiBmZXRjaGluZy5cbiAgZ2V0IGNhY2hlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGNhY2hlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5jYWNoZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVkaXJlY3QgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyBob3cgcmVkaXJlY3RzIGZvciB0aGVcbiAgLy8gcmVxdWVzdCB3aWxsIGJlIGhhbmRsZWQgZHVyaW5nIGZldGNoaW5nLiBBIHJlcXVlc3RcbiAgLy8gd2lsbCBmb2xsb3cgcmVkaXJlY3RzIGJ5IGRlZmF1bHQuXG4gIGdldCByZWRpcmVjdCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSByZWRpcmVjdCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVkaXJlY3RcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgc3VicmVzb3VyY2UgaW50ZWdyaXR5IG1ldGFkYXRhLCB3aGljaCBpcyBhXG4gIC8vIGNyeXB0b2dyYXBoaWMgaGFzaCBvZiB0aGUgcmVzb3VyY2UgYmVpbmcgZmV0Y2hlZC4gSXRzIHZhbHVlXG4gIC8vIGNvbnNpc3RzIG9mIG11bHRpcGxlIGhhc2hlcyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS4gW1NSSV1cbiAgZ2V0IGludGVncml0eSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpbnRlZ3JpdHkgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgaW50ZWdyaXR5XG4gICAgLy8gbWV0YWRhdGEuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5pbnRlZ3JpdHlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBjYW4gb3V0bGl2ZSB0aGVcbiAgLy8gZ2xvYmFsIGluIHdoaWNoIGl0IHdhcyBjcmVhdGVkLlxuICBnZXQga2VlcGFsaXZlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGtlZXBhbGl2ZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5rZWVwYWxpdmVcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBpcyBmb3IgYSByZWxvYWRcbiAgLy8gbmF2aWdhdGlvbi5cbiAgZ2V0IGlzUmVsb2FkTmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc1JlbG9hZE5hdmlnYXRpb24gZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZc1xuICAgIC8vIHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgaXMgc2V0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWxvYWROYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgaGlzdG9yeVxuICAvLyBuYXZpZ2F0aW9uIChhLmsuYS4gYmFjay1mb3J3YXJkIG5hdmlnYXRpb24pLlxuICBnZXQgaXNIaXN0b3J5TmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc0hpc3RvcnlOYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVxdWVzdOKAmXNcbiAgICAvLyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZyBpcyBzZXQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmhpc3RvcnlOYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBzaWduYWwgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGFuIEFib3J0U2lnbmFsXG4gIC8vIG9iamVjdCBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgYW5kIGl0c1xuICAvLyBhYm9ydCBldmVudCBoYW5kbGVyLlxuICBnZXQgc2lnbmFsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHNpZ25hbCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBzaWduYWwuXG4gICAgcmV0dXJuIHRoaXNba1NpZ25hbF1cbiAgfVxuXG4gIGdldCBib2R5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ib2R5ID8gdGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtIDogbnVsbFxuICB9XG5cbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuICEhdGhpc1trU3RhdGVdLmJvZHkgJiYgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0pXG4gIH1cblxuICBnZXQgZHVwbGV4ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuICdoYWxmJ1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGNsb25lIG9mIHJlcXVlc3QuXG4gIGNsb25lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodGhpcy5ib2R5VXNlZCB8fCB0aGlzLmJvZHk/LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW51c2FibGUnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXF1ZXN0IGJlIHRoZSByZXN1bHQgb2YgY2xvbmluZyB0aGlz4oCZcyByZXF1ZXN0LlxuICAgIGNvbnN0IGNsb25lZFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QodGhpc1trU3RhdGVdKVxuXG4gICAgLy8gMy4gTGV0IGNsb25lZFJlcXVlc3RPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlcXVlc3Qgb2JqZWN0LFxuICAgIC8vIGdpdmVuIGNsb25lZFJlcXVlc3QsIHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgLy8gNC4gTWFrZSBjbG9uZWRSZXF1ZXN0T2JqZWN04oCZcyBzaWduYWwgZm9sbG93IHRoaXPigJlzIHNpZ25hbC5cbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBhYy5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsaXN0ID0gZGVwZW5kZW50Q29udHJvbGxlck1hcC5nZXQodGhpcy5zaWduYWwpXG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpc3QgPSBuZXcgU2V0KClcbiAgICAgICAgZGVwZW5kZW50Q29udHJvbGxlck1hcC5zZXQodGhpcy5zaWduYWwsIGxpc3QpXG4gICAgICB9XG4gICAgICBjb25zdCBhY1JlZiA9IG5ldyBXZWFrUmVmKGFjKVxuICAgICAgbGlzdC5hZGQoYWNSZWYpXG4gICAgICB1dGlsLmFkZEFib3J0TGlzdGVuZXIoXG4gICAgICAgIGFjLnNpZ25hbCxcbiAgICAgICAgYnVpbGRBYm9ydChhY1JlZilcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4gY2xvbmVkUmVxdWVzdE9iamVjdC5cbiAgICByZXR1cm4gZnJvbUlubmVyUmVxdWVzdChjbG9uZWRSZXF1ZXN0LCBhYy5zaWduYWwsIGdldEhlYWRlcnNHdWFyZCh0aGlzW2tIZWFkZXJzXSkpXG4gIH1cblxuICBbbm9kZVV0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRlcHRoID09PSBudWxsKSB7XG4gICAgICBvcHRpb25zLmRlcHRoID0gMlxuICAgIH1cblxuICAgIG9wdGlvbnMuY29sb3JzID8/PSB0cnVlXG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBkZXN0aW5hdGlvbjogdGhpcy5kZXN0aW5hdGlvbixcbiAgICAgIHJlZmVycmVyOiB0aGlzLnJlZmVycmVyLFxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHRoaXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscyxcbiAgICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgICAgcmVkaXJlY3Q6IHRoaXMucmVkaXJlY3QsXG4gICAgICBpbnRlZ3JpdHk6IHRoaXMuaW50ZWdyaXR5LFxuICAgICAga2VlcGFsaXZlOiB0aGlzLmtlZXBhbGl2ZSxcbiAgICAgIGlzUmVsb2FkTmF2aWdhdGlvbjogdGhpcy5pc1JlbG9hZE5hdmlnYXRpb24sXG4gICAgICBpc0hpc3RvcnlOYXZpZ2F0aW9uOiB0aGlzLmlzSGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICBzaWduYWw6IHRoaXMuc2lnbmFsXG4gICAgfVxuXG4gICAgcmV0dXJuIGBSZXF1ZXN0ICR7bm9kZVV0aWwuZm9ybWF0V2l0aE9wdGlvbnMob3B0aW9ucywgcHJvcGVydGllcyl9YFxuICB9XG59XG5cbm1peGluQm9keShSZXF1ZXN0KVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdHNcbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0IChpbml0KSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBpbml0Lm1ldGhvZCA/PyAnR0VUJyxcbiAgICBsb2NhbFVSTHNPbmx5OiBpbml0LmxvY2FsVVJMc09ubHkgPz8gZmFsc2UsXG4gICAgdW5zYWZlUmVxdWVzdDogaW5pdC51bnNhZmVSZXF1ZXN0ID8/IGZhbHNlLFxuICAgIGJvZHk6IGluaXQuYm9keSA/PyBudWxsLFxuICAgIGNsaWVudDogaW5pdC5jbGllbnQgPz8gbnVsbCxcbiAgICByZXNlcnZlZENsaWVudDogaW5pdC5yZXNlcnZlZENsaWVudCA/PyBudWxsLFxuICAgIHJlcGxhY2VzQ2xpZW50SWQ6IGluaXQucmVwbGFjZXNDbGllbnRJZCA/PyAnJyxcbiAgICB3aW5kb3c6IGluaXQud2luZG93ID8/ICdjbGllbnQnLFxuICAgIGtlZXBhbGl2ZTogaW5pdC5rZWVwYWxpdmUgPz8gZmFsc2UsXG4gICAgc2VydmljZVdvcmtlcnM6IGluaXQuc2VydmljZVdvcmtlcnMgPz8gJ2FsbCcsXG4gICAgaW5pdGlhdG9yOiBpbml0LmluaXRpYXRvciA/PyAnJyxcbiAgICBkZXN0aW5hdGlvbjogaW5pdC5kZXN0aW5hdGlvbiA/PyAnJyxcbiAgICBwcmlvcml0eTogaW5pdC5wcmlvcml0eSA/PyBudWxsLFxuICAgIG9yaWdpbjogaW5pdC5vcmlnaW4gPz8gJ2NsaWVudCcsXG4gICAgcG9saWN5Q29udGFpbmVyOiBpbml0LnBvbGljeUNvbnRhaW5lciA/PyAnY2xpZW50JyxcbiAgICByZWZlcnJlcjogaW5pdC5yZWZlcnJlciA/PyAnY2xpZW50JyxcbiAgICByZWZlcnJlclBvbGljeTogaW5pdC5yZWZlcnJlclBvbGljeSA/PyAnJyxcbiAgICBtb2RlOiBpbml0Lm1vZGUgPz8gJ25vLWNvcnMnLFxuICAgIHVzZUNPUlNQcmVmbGlnaHRGbGFnOiBpbml0LnVzZUNPUlNQcmVmbGlnaHRGbGFnID8/IGZhbHNlLFxuICAgIGNyZWRlbnRpYWxzOiBpbml0LmNyZWRlbnRpYWxzID8/ICdzYW1lLW9yaWdpbicsXG4gICAgdXNlQ3JlZGVudGlhbHM6IGluaXQudXNlQ3JlZGVudGlhbHMgPz8gZmFsc2UsXG4gICAgY2FjaGU6IGluaXQuY2FjaGUgPz8gJ2RlZmF1bHQnLFxuICAgIHJlZGlyZWN0OiBpbml0LnJlZGlyZWN0ID8/ICdmb2xsb3cnLFxuICAgIGludGVncml0eTogaW5pdC5pbnRlZ3JpdHkgPz8gJycsXG4gICAgY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhOiBpbml0LmNyeXB0b0dyYXBoaWNzTm9uY2VNZXRhZGF0YSA/PyAnJyxcbiAgICBwYXJzZXJNZXRhZGF0YTogaW5pdC5wYXJzZXJNZXRhZGF0YSA/PyAnJyxcbiAgICByZWxvYWROYXZpZ2F0aW9uOiBpbml0LnJlbG9hZE5hdmlnYXRpb24gPz8gZmFsc2UsXG4gICAgaGlzdG9yeU5hdmlnYXRpb246IGluaXQuaGlzdG9yeU5hdmlnYXRpb24gPz8gZmFsc2UsXG4gICAgdXNlckFjdGl2YXRpb246IGluaXQudXNlckFjdGl2YXRpb24gPz8gZmFsc2UsXG4gICAgdGFpbnRlZE9yaWdpbjogaW5pdC50YWludGVkT3JpZ2luID8/IGZhbHNlLFxuICAgIHJlZGlyZWN0Q291bnQ6IGluaXQucmVkaXJlY3RDb3VudCA/PyAwLFxuICAgIHJlc3BvbnNlVGFpbnRpbmc6IGluaXQucmVzcG9uc2VUYWludGluZyA/PyAnYmFzaWMnLFxuICAgIHByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uOiBpbml0LnByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uID8/IGZhbHNlLFxuICAgIGRvbmU6IGluaXQuZG9uZSA/PyBmYWxzZSxcbiAgICB0aW1pbmdBbGxvd0ZhaWxlZDogaW5pdC50aW1pbmdBbGxvd0ZhaWxlZCA/PyBmYWxzZSxcbiAgICB1cmxMaXN0OiBpbml0LnVybExpc3QsXG4gICAgdXJsOiBpbml0LnVybExpc3RbMF0sXG4gICAgaGVhZGVyc0xpc3Q6IGluaXQuaGVhZGVyc0xpc3RcbiAgICAgID8gbmV3IEhlYWRlcnNMaXN0KGluaXQuaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1jbG9uZVxuZnVuY3Rpb24gY2xvbmVSZXF1ZXN0IChyZXF1ZXN0KSB7XG4gIC8vIFRvIGNsb25lIGEgcmVxdWVzdCByZXF1ZXN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gTGV0IG5ld1JlcXVlc3QgYmUgYSBjb3B5IG9mIHJlcXVlc3QsIGV4Y2VwdCBmb3IgaXRzIGJvZHkuXG4gIGNvbnN0IG5ld1JlcXVlc3QgPSBtYWtlUmVxdWVzdCh7IC4uLnJlcXVlc3QsIGJvZHk6IG51bGwgfSlcblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCBzZXQgbmV3UmVxdWVzdOKAmXMgYm9keSB0byB0aGVcbiAgLy8gcmVzdWx0IG9mIGNsb25pbmcgcmVxdWVzdOKAmXMgYm9keS5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgbmV3UmVxdWVzdC5ib2R5ID0gY2xvbmVCb2R5KHJlcXVlc3QuYm9keSlcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBuZXdSZXF1ZXN0LlxuICByZXR1cm4gbmV3UmVxdWVzdFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtY3JlYXRlXG4gKiBAcGFyYW0ge2FueX0gaW5uZXJSZXF1ZXN0XG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBzaWduYWxcbiAqIEBwYXJhbSB7J3JlcXVlc3QnIHwgJ2ltbXV0YWJsZScgfCAncmVxdWVzdC1uby1jb3JzJyB8ICdyZXNwb25zZScgfCAnbm9uZSd9IGd1YXJkXG4gKiBAcmV0dXJucyB7UmVxdWVzdH1cbiAqL1xuZnVuY3Rpb24gZnJvbUlubmVyUmVxdWVzdCAoaW5uZXJSZXF1ZXN0LCBzaWduYWwsIGd1YXJkKSB7XG4gIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChrQ29uc3RydWN0KVxuICByZXF1ZXN0W2tTdGF0ZV0gPSBpbm5lclJlcXVlc3RcbiAgcmVxdWVzdFtrU2lnbmFsXSA9IHNpZ25hbFxuICByZXF1ZXN0W2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gIHNldEhlYWRlcnNMaXN0KHJlcXVlc3Rba0hlYWRlcnNdLCBpbm5lclJlcXVlc3QuaGVhZGVyc0xpc3QpXG4gIHNldEhlYWRlcnNHdWFyZChyZXF1ZXN0W2tIZWFkZXJzXSwgZ3VhcmQpXG4gIHJldHVybiByZXF1ZXN0XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG4gIG1ldGhvZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNpZ25hbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZHVwbGV4OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZXN0aW5hdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzSGlzdG9yeU5hdmlnYXRpb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzUmVsb2FkTmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2VlcGFsaXZlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpbnRlZ3JpdHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNhY2hlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjcmVkZW50aWFsczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYXR0cmlidXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlclBvbGljeToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVmZXJyZXI6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG1vZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXF1ZXN0JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIFJlcXVlc3RcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RpbmZvXG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgViA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG4gIH1cblxuICBpZiAoViBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdChWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWLCBwcmVmaXgsIGFyZ3VtZW50KVxufVxuXG53ZWJpZGwuY29udmVydGVycy5BYm9ydFNpZ25hbCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIEFib3J0U2lnbmFsXG4pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdtZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9LFxuICB7XG4gICAga2V5OiAnYm9keScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdFxuICAgIClcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlZmVycmVyJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXJQb2xpY3knLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY3lcbiAgICBhbGxvd2VkVmFsdWVzOiByZWZlcnJlclBvbGljeVxuICB9LFxuICB7XG4gICAga2V5OiAnbW9kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1tb2RlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdE1vZGVcbiAgfSxcbiAge1xuICAgIGtleTogJ2NyZWRlbnRpYWxzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNyZWRlbnRpYWxzXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENyZWRlbnRpYWxzXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYWNoZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RjYWNoZVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RDYWNoZVxuICB9LFxuICB7XG4gICAga2V5OiAncmVkaXJlY3QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0cmVkaXJlY3RcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0UmVkaXJlY3RcbiAgfSxcbiAge1xuICAgIGtleTogJ2ludGVncml0eScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfSxcbiAge1xuICAgIGtleTogJ2tlZXBhbGl2ZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzaWduYWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgKHNpZ25hbCkgPT4gd2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwoXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgJ1JlcXVlc3RJbml0JyxcbiAgICAgICAgJ3NpZ25hbCcsXG4gICAgICAgIHsgc3RyaWN0OiBmYWxzZSB9XG4gICAgICApXG4gICAgKVxuICB9LFxuICB7XG4gICAga2V5OiAnd2luZG93JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9LFxuICB7XG4gICAga2V5OiAnZHVwbGV4JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0RHVwbGV4XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkaXNwYXRjaGVyJywgLy8gdW5kaWNpIHNwZWNpZmljIG9wdGlvblxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBSZXF1ZXN0LCBtYWtlUmVxdWVzdCwgZnJvbUlubmVyUmVxdWVzdCwgY2xvbmVSZXF1ZXN0IH1cbiJdLCJuYW1lcyI6WyJleHRyYWN0Qm9keSIsIm1peGluQm9keSIsImNsb25lQm9keSIsInJlcXVpcmUiLCJIZWFkZXJzIiwiZmlsbCIsImZpbGxIZWFkZXJzIiwiSGVhZGVyc0xpc3QiLCJzZXRIZWFkZXJzR3VhcmQiLCJnZXRIZWFkZXJzR3VhcmQiLCJzZXRIZWFkZXJzTGlzdCIsImdldEhlYWRlcnNMaXN0IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJ1dGlsIiwibm9kZVV0aWwiLCJpc1ZhbGlkSFRUUFRva2VuIiwic2FtZU9yaWdpbiIsImVudmlyb25tZW50U2V0dGluZ3NPYmplY3QiLCJmb3JiaWRkZW5NZXRob2RzU2V0IiwiY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0IiwicmVmZXJyZXJQb2xpY3kiLCJyZXF1ZXN0UmVkaXJlY3QiLCJyZXF1ZXN0TW9kZSIsInJlcXVlc3RDcmVkZW50aWFscyIsInJlcXVlc3RDYWNoZSIsInJlcXVlc3REdXBsZXgiLCJrRW51bWVyYWJsZVByb3BlcnR5Iiwibm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlIiwibm9ybWFsaXplZE1ldGhvZFJlY29yZHMiLCJrSGVhZGVycyIsImtTaWduYWwiLCJrU3RhdGUiLCJrRGlzcGF0Y2hlciIsIndlYmlkbCIsIlVSTFNlcmlhbGl6ZXIiLCJrQ29uc3RydWN0IiwiYXNzZXJ0IiwiZ2V0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwiZ2V0RXZlbnRMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwia0Fib3J0Q29udHJvbGxlciIsIlN5bWJvbCIsInJlcXVlc3RGaW5hbGl6ZXIiLCJzaWduYWwiLCJhYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXBlbmRlbnRDb250cm9sbGVyTWFwIiwiV2Vha01hcCIsImJ1aWxkQWJvcnQiLCJhY1JlZiIsImFjIiwiZGVyZWYiLCJ1bmRlZmluZWQiLCJ1bnJlZ2lzdGVyIiwicmVhc29uIiwiY29udHJvbGxlckxpc3QiLCJnZXQiLCJzaXplIiwicmVmIiwiY3RybCIsImNsZWFyIiwiZGVsZXRlIiwicGF0Y2hNZXRob2RXYXJuaW5nIiwiUmVxdWVzdCIsImlucHV0IiwiaW5pdCIsInByZWZpeCIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJjb252ZXJ0ZXJzIiwiUmVxdWVzdEluZm8iLCJSZXF1ZXN0SW5pdCIsInJlcXVlc3QiLCJmYWxsYmFja01vZGUiLCJiYXNlVXJsIiwic2V0dGluZ3NPYmplY3QiLCJkaXNwYXRjaGVyIiwicGFyc2VkVVJMIiwiVVJMIiwiZXJyIiwiVHlwZUVycm9yIiwiY2F1c2UiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwibWFrZVJlcXVlc3QiLCJ1cmxMaXN0Iiwib3JpZ2luIiwid2luZG93IiwibmFtZSIsIm1ldGhvZCIsImhlYWRlcnNMaXN0IiwidW5zYWZlUmVxdWVzdCIsImNsaWVudCIsInByaW9yaXR5IiwicmVmZXJyZXIiLCJtb2RlIiwiY3JlZGVudGlhbHMiLCJjYWNoZSIsInJlZGlyZWN0IiwiaW50ZWdyaXR5Iiwia2VlcGFsaXZlIiwicmVsb2FkTmF2aWdhdGlvbiIsImhpc3RvcnlOYXZpZ2F0aW9uIiwiaW5pdEhhc0tleSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJ1cmwiLCJwYXJzZWRSZWZlcnJlciIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJoZWFkZXIiLCJtZXNzYWdlIiwiU3RyaW5nIiwiQm9vbGVhbiIsIm1heUJlTm9ybWFsaXplZCIsInVwcGVyQ2FzZSIsInRvVXBwZXJDYXNlIiwiaGFzIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiY29kZSIsIkFib3J0Q29udHJvbGxlciIsImFib3J0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiV2Vha1JlZiIsImFkZEFib3J0TGlzdGVuZXIiLCJyZWdpc3RlciIsImhlYWRlcnMiLCJ2YWx1ZSIsInJhd1ZhbHVlcyIsImFwcGVuZCIsImNvb2tpZXMiLCJpbnB1dEJvZHkiLCJib2R5IiwiaW5pdEJvZHkiLCJleHRyYWN0ZWRCb2R5IiwiY29udGVudFR5cGUiLCJjb250YWlucyIsImlucHV0T3JJbml0Qm9keSIsInNvdXJjZSIsImR1cGxleCIsInVzZUNPUlNQcmVmbGlnaHRGbGFnIiwiZmluYWxCb2R5IiwiaXNEaXN0dXJiZWQiLCJzdHJlYW0iLCJsb2NrZWQiLCJpZGVudGl0eVRyYW5zZm9ybSIsIlRyYW5zZm9ybVN0cmVhbSIsInBpcGVUaHJvdWdoIiwicmVhZGFibGUiLCJicmFuZENoZWNrIiwiZGVzdGluYXRpb24iLCJ0b1N0cmluZyIsImlzUmVsb2FkTmF2aWdhdGlvbiIsImlzSGlzdG9yeU5hdmlnYXRpb24iLCJib2R5VXNlZCIsImNsb25lIiwiY2xvbmVkUmVxdWVzdCIsImNsb25lUmVxdWVzdCIsImxpc3QiLCJTZXQiLCJzZXQiLCJhZGQiLCJmcm9tSW5uZXJSZXF1ZXN0IiwiaW5zcGVjdCIsImN1c3RvbSIsImRlcHRoIiwib3B0aW9ucyIsImNvbG9ycyIsInByb3BlcnRpZXMiLCJmb3JtYXRXaXRoT3B0aW9ucyIsImxvY2FsVVJMc09ubHkiLCJyZXNlcnZlZENsaWVudCIsInJlcGxhY2VzQ2xpZW50SWQiLCJzZXJ2aWNlV29ya2VycyIsImluaXRpYXRvciIsInBvbGljeUNvbnRhaW5lciIsInVzZUNyZWRlbnRpYWxzIiwiY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhIiwicGFyc2VyTWV0YWRhdGEiLCJ1c2VyQWN0aXZhdGlvbiIsInRhaW50ZWRPcmlnaW4iLCJyZWRpcmVjdENvdW50IiwicmVzcG9uc2VUYWludGluZyIsInByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uIiwiZG9uZSIsInRpbWluZ0FsbG93RmFpbGVkIiwibmV3UmVxdWVzdCIsImlubmVyUmVxdWVzdCIsImd1YXJkIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsImF0dHJpYnV0ZSIsInRvU3RyaW5nVGFnIiwiY29uZmlndXJhYmxlIiwiaW50ZXJmYWNlQ29udmVydGVyIiwiViIsImFyZ3VtZW50IiwiVVNWU3RyaW5nIiwiQWJvcnRTaWduYWwiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiQnl0ZVN0cmluZyIsIkhlYWRlcnNJbml0IiwibnVsbGFibGVDb252ZXJ0ZXIiLCJCb2R5SW5pdCIsIkRPTVN0cmluZyIsImFsbG93ZWRWYWx1ZXMiLCJib29sZWFuIiwic3RyaWN0IiwiYW55IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/response.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\nconst { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\");\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\");\nconst { kEnumerableProperty } = util;\nconst { isValidReasonPhrase, isCancelled, isAborted, isBlobLike, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode, environmentSettingsObject: relevantRealm } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { redirectStatusSet, nullBodyStatus } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\");\nconst { kState, kHeaders } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\");\nconst { isDisturbed, isErrored } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst textEncoder = new TextEncoder('utf-8');\nconst hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf('v18') !== 0;\nlet registry;\nif (hasFinalizationRegistry) {\n    registry = new FinalizationRegistry((weakRef)=>{\n        const stream = weakRef.deref();\n        if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n            stream.cancel('Response object has been garbage collected').catch(noop);\n        }\n    });\n}\nfunction noop() {}\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n    // Creates network error Response.\n    static error() {\n        // The static error() method steps are to return the result of creating a\n        // Response object, given a new network error, \"immutable\", and this’s\n        // relevant Realm.\n        const responseObject = fromInnerResponse(makeNetworkError(), 'immutable');\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response-json\n    static json(data, init = {}) {\n        webidl.argumentLengthCheck(arguments, 1, 'Response.json');\n        if (init !== null) {\n            init = webidl.converters.ResponseInit(init);\n        }\n        // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n        const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));\n        // 2. Let body be the result of extracting bytes.\n        const body = extractBody(bytes);\n        // 3. Let responseObject be the result of creating a Response object, given a new response,\n        //    \"response\", and this’s relevant Realm.\n        const responseObject = fromInnerResponse(makeResponse({}), 'response');\n        // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n        initializeResponse(responseObject, init, {\n            body: body[0],\n            type: 'application/json'\n        });\n        // 5. Return responseObject.\n        return responseObject;\n    }\n    // Creates a redirect Response that redirects to url with status status.\n    static redirect(url, status = 302) {\n        webidl.argumentLengthCheck(arguments, 1, 'Response.redirect');\n        url = webidl.converters.USVString(url);\n        status = webidl.converters['unsigned short'](status);\n        // 1. Let parsedURL be the result of parsing url with current settings\n        // object’s API base URL.\n        // 2. If parsedURL is failure, then throw a TypeError.\n        // TODO: base-URL?\n        let parsedURL;\n        try {\n            parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);\n        } catch (err) {\n            throw new TypeError(`Failed to parse URL from ${url}`, {\n                cause: err\n            });\n        }\n        // 3. If status is not a redirect status, then throw a RangeError.\n        if (!redirectStatusSet.has(status)) {\n            throw new RangeError(`Invalid status code ${status}`);\n        }\n        // 4. Let responseObject be the result of creating a Response object,\n        // given a new response, \"immutable\", and this’s relevant Realm.\n        const responseObject = fromInnerResponse(makeResponse({}), 'immutable');\n        // 5. Set responseObject’s response’s status to status.\n        responseObject[kState].status = status;\n        // 6. Let value be parsedURL, serialized and isomorphic encoded.\n        const value = isomorphicEncode(URLSerializer(parsedURL));\n        // 7. Append `Location`/value to responseObject’s response’s header list.\n        responseObject[kState].headersList.append('location', value, true);\n        // 8. Return responseObject.\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response\n    constructor(body = null, init = {}){\n        if (body === kConstruct) {\n            return;\n        }\n        if (body !== null) {\n            body = webidl.converters.BodyInit(body);\n        }\n        init = webidl.converters.ResponseInit(init);\n        // 1. Set this’s response to a new response.\n        this[kState] = makeResponse({});\n        // 2. Set this’s headers to a new Headers object with this’s relevant\n        // Realm, whose header list is this’s response’s header list and guard\n        // is \"response\".\n        this[kHeaders] = new Headers(kConstruct);\n        setHeadersGuard(this[kHeaders], 'response');\n        setHeadersList(this[kHeaders], this[kState].headersList);\n        // 3. Let bodyWithType be null.\n        let bodyWithType = null;\n        // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n        if (body != null) {\n            const [extractedBody, type] = extractBody(body);\n            bodyWithType = {\n                body: extractedBody,\n                type\n            };\n        }\n        // 5. Perform initialize a response given this, init, and bodyWithType.\n        initializeResponse(this, init, bodyWithType);\n    }\n    // Returns response’s type, e.g., \"cors\".\n    get type() {\n        webidl.brandCheck(this, Response);\n        // The type getter steps are to return this’s response’s type.\n        return this[kState].type;\n    }\n    // Returns response’s URL, if it has one; otherwise the empty string.\n    get url() {\n        webidl.brandCheck(this, Response);\n        const urlList = this[kState].urlList;\n        // The url getter steps are to return the empty string if this’s\n        // response’s URL is null; otherwise this’s response’s URL,\n        // serialized with exclude fragment set to true.\n        const url = urlList[urlList.length - 1] ?? null;\n        if (url === null) {\n            return '';\n        }\n        return URLSerializer(url, true);\n    }\n    // Returns whether response was obtained through a redirect.\n    get redirected() {\n        webidl.brandCheck(this, Response);\n        // The redirected getter steps are to return true if this’s response’s URL\n        // list has more than one item; otherwise false.\n        return this[kState].urlList.length > 1;\n    }\n    // Returns response’s status.\n    get status() {\n        webidl.brandCheck(this, Response);\n        // The status getter steps are to return this’s response’s status.\n        return this[kState].status;\n    }\n    // Returns whether response’s status is an ok status.\n    get ok() {\n        webidl.brandCheck(this, Response);\n        // The ok getter steps are to return true if this’s response’s status is an\n        // ok status; otherwise false.\n        return this[kState].status >= 200 && this[kState].status <= 299;\n    }\n    // Returns response’s status message.\n    get statusText() {\n        webidl.brandCheck(this, Response);\n        // The statusText getter steps are to return this’s response’s status\n        // message.\n        return this[kState].statusText;\n    }\n    // Returns response’s headers as Headers.\n    get headers() {\n        webidl.brandCheck(this, Response);\n        // The headers getter steps are to return this’s headers.\n        return this[kHeaders];\n    }\n    get body() {\n        webidl.brandCheck(this, Response);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Response);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    // Returns a clone of response.\n    clone() {\n        webidl.brandCheck(this, Response);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body?.locked) {\n            throw webidl.errors.exception({\n                header: 'Response.clone',\n                message: 'Body has already been consumed.'\n            });\n        }\n        // 2. Let clonedResponse be the result of cloning this’s response.\n        const clonedResponse = cloneResponse(this[kState]);\n        // 3. Return the result of creating a Response object, given\n        // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n        return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));\n    }\n    [nodeUtil.inspect.custom](depth, options) {\n        if (options.depth === null) {\n            options.depth = 2;\n        }\n        options.colors ??= true;\n        const properties = {\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            body: this.body,\n            bodyUsed: this.bodyUsed,\n            ok: this.ok,\n            redirected: this.redirected,\n            type: this.type,\n            url: this.url\n        };\n        return `Response ${nodeUtil.formatWithOptions(options, properties)}`;\n    }\n}\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n    type: kEnumerableProperty,\n    url: kEnumerableProperty,\n    status: kEnumerableProperty,\n    ok: kEnumerableProperty,\n    redirected: kEnumerableProperty,\n    statusText: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: 'Response',\n        configurable: true\n    }\n});\nObject.defineProperties(Response, {\n    json: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    error: kEnumerableProperty\n});\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse(response) {\n    // To clone a response response, run these steps:\n    // 1. If response is a filtered response, then return a new identical\n    // filtered response whose internal response is a clone of response’s\n    // internal response.\n    if (response.internalResponse) {\n        return filterResponse(cloneResponse(response.internalResponse), response.type);\n    }\n    // 2. Let newResponse be a copy of response, except for its body.\n    const newResponse = makeResponse({\n        ...response,\n        body: null\n    });\n    // 3. If response’s body is non-null, then set newResponse’s body to the\n    // result of cloning response’s body.\n    if (response.body != null) {\n        newResponse.body = cloneBody(response.body);\n    }\n    // 4. Return newResponse.\n    return newResponse;\n}\nfunction makeResponse(init) {\n    return {\n        aborted: false,\n        rangeRequested: false,\n        timingAllowPassed: false,\n        requestIncludesCredentials: false,\n        type: 'default',\n        status: 200,\n        timingInfo: null,\n        cacheState: '',\n        statusText: '',\n        ...init,\n        headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList(),\n        urlList: init?.urlList ? [\n            ...init.urlList\n        ] : []\n    };\n}\nfunction makeNetworkError(reason) {\n    const isError = isErrorLike(reason);\n    return makeResponse({\n        type: 'error',\n        status: 0,\n        error: isError ? reason : new Error(reason ? String(reason) : reason),\n        aborted: reason && reason.name === 'AbortError'\n    });\n}\n// @see https://fetch.spec.whatwg.org/#concept-network-error\nfunction isNetworkError(response) {\n    return(// A network error is a response whose type is \"error\",\n    response.type === 'error' && // status is 0\n    response.status === 0);\n}\nfunction makeFilteredResponse(response, state) {\n    state = {\n        internalResponse: response,\n        ...state\n    };\n    return new Proxy(response, {\n        get (target, p) {\n            return p in state ? state[p] : target[p];\n        },\n        set (target, p, value) {\n            assert(!(p in state));\n            target[p] = value;\n            return true;\n        }\n    });\n}\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse(response, type) {\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (type === 'basic') {\n        // A basic filtered response is a filtered response whose type is \"basic\"\n        // and header list excludes any headers in internal response’s header list\n        // whose name is a forbidden response-header name.\n        // Note: undici does not implement forbidden response-header names\n        return makeFilteredResponse(response, {\n            type: 'basic',\n            headersList: response.headersList\n        });\n    } else if (type === 'cors') {\n        // A CORS filtered response is a filtered response whose type is \"cors\"\n        // and header list excludes any headers in internal response’s header\n        // list whose name is not a CORS-safelisted response-header name, given\n        // internal response’s CORS-exposed header-name list.\n        // Note: undici does not implement CORS-safelisted response-header names\n        return makeFilteredResponse(response, {\n            type: 'cors',\n            headersList: response.headersList\n        });\n    } else if (type === 'opaque') {\n        // An opaque filtered response is a filtered response whose type is\n        // \"opaque\", URL list is the empty list, status is 0, status message\n        // is the empty byte sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: 'opaque',\n            urlList: Object.freeze([]),\n            status: 0,\n            statusText: '',\n            body: null\n        });\n    } else if (type === 'opaqueredirect') {\n        // An opaque-redirect filtered response is a filtered response whose type\n        // is \"opaqueredirect\", status is 0, status message is the empty byte\n        // sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: 'opaqueredirect',\n            status: 0,\n            statusText: '',\n            headersList: [],\n            body: null\n        });\n    } else {\n        assert(false);\n    }\n}\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError(fetchParams, err = null) {\n    // 1. Assert: fetchParams is canceled.\n    assert(isCancelled(fetchParams));\n    // 2. Return an aborted network error if fetchParams is aborted;\n    // otherwise return a network error.\n    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), {\n        cause: err\n    })) : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), {\n        cause: err\n    }));\n}\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse(response, init, body) {\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    //    throw a RangeError.\n    if (init.status !== null && (init.status < 200 || init.status > 599)) {\n        throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n    }\n    // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n    //    then throw a TypeError.\n    if ('statusText' in init && init.statusText != null) {\n        // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n        //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n        if (!isValidReasonPhrase(String(init.statusText))) {\n            throw new TypeError('Invalid statusText');\n        }\n    }\n    // 3. Set response’s response’s status to init[\"status\"].\n    if ('status' in init && init.status != null) {\n        response[kState].status = init.status;\n    }\n    // 4. Set response’s response’s status message to init[\"statusText\"].\n    if ('statusText' in init && init.statusText != null) {\n        response[kState].statusText = init.statusText;\n    }\n    // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n    if ('headers' in init && init.headers != null) {\n        fill(response[kHeaders], init.headers);\n    }\n    // 6. If body was given, then:\n    if (body) {\n        // 1. If response's status is a null body status, then throw a TypeError.\n        if (nullBodyStatus.includes(response.status)) {\n            throw webidl.errors.exception({\n                header: 'Response constructor',\n                message: `Invalid response status code ${response.status}`\n            });\n        }\n        // 2. Set response's body to body's body.\n        response[kState].body = body.body;\n        // 3. If body's type is non-null and response's header list does not contain\n        //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n        if (body.type != null && !response[kState].headersList.contains('content-type', true)) {\n            response[kState].headersList.append('content-type', body.type, true);\n        }\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#response-create\n * @param {any} innerResponse\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Response}\n */ function fromInnerResponse(innerResponse, guard) {\n    const response = new Response(kConstruct);\n    response[kState] = innerResponse;\n    response[kHeaders] = new Headers(kConstruct);\n    setHeadersList(response[kHeaders], innerResponse.headersList);\n    setHeadersGuard(response[kHeaders], guard);\n    if (hasFinalizationRegistry && innerResponse.body?.stream) {\n        // If the target (response) is reclaimed, the cleanup callback may be called at some point with\n        // the held value provided for it (innerResponse.body.stream). The held value can be any value:\n        // a primitive or an object, even undefined. If the held value is an object, the registry keeps\n        // a strong reference to it (so it can pass it to the cleanup callback later). Reworded from\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n        registry.register(response, new WeakRef(innerResponse.body.stream));\n    }\n    return response;\n}\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {\n    if (typeof V === 'string') {\n        return webidl.converters.USVString(V, prefix, name);\n    }\n    if (isBlobLike(V)) {\n        return webidl.converters.Blob(V, prefix, name, {\n            strict: false\n        });\n    }\n    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n        return webidl.converters.BufferSource(V, prefix, name);\n    }\n    if (util.isFormDataLike(V)) {\n        return webidl.converters.FormData(V, prefix, name, {\n            strict: false\n        });\n    }\n    if (V instanceof URLSearchParams) {\n        return webidl.converters.URLSearchParams(V, prefix, name);\n    }\n    return webidl.converters.DOMString(V, prefix, name);\n};\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function(V, prefix, argument) {\n    if (V instanceof ReadableStream) {\n        return webidl.converters.ReadableStream(V, prefix, argument);\n    }\n    // Note: the spec doesn't include async iterables,\n    // this is an undici extension.\n    if (V?.[Symbol.asyncIterator]) {\n        return V;\n    }\n    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);\n};\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n    {\n        key: 'status',\n        converter: webidl.converters['unsigned short'],\n        defaultValue: ()=>200\n    },\n    {\n        key: 'statusText',\n        converter: webidl.converters.ByteString,\n        defaultValue: ()=>''\n    },\n    {\n        key: 'headers',\n        converter: webidl.converters.HeadersInit\n    }\n]);\nmodule.exports = {\n    isNetworkError,\n    makeNetworkError,\n    makeResponse,\n    makeAppropriateNetworkError,\n    filterResponse,\n    Response,\n    cloneResponse,\n    fromInnerResponse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsRUFBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsdUVBQVc7QUFDNUcsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDLGlFQUFRO0FBQzlELE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDLHFFQUFpQjtBQUN0QyxNQUFNSyxXQUFXTCxtQkFBT0EsQ0FBQyw0QkFBVztBQUNwQyxNQUFNLEVBQUVNLG1CQUFtQixFQUFFLEdBQUdGO0FBQ2hDLE1BQU0sRUFDSkcsbUJBQW1CLEVBQ25CQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxvQ0FBb0MsRUFDcENDLFdBQVcsRUFDWEMsZ0JBQWdCLEVBQ2hCQywyQkFBMkJDLGFBQWEsRUFDekMsR0FBR2YsbUJBQU9BLENBQUMsaUVBQVE7QUFDcEIsTUFBTSxFQUNKZ0IsaUJBQWlCLEVBQ2pCQyxjQUFjLEVBQ2YsR0FBR2pCLG1CQUFPQSxDQUFDLDJFQUFhO0FBQ3pCLE1BQU0sRUFBRWtCLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUduQixtQkFBT0EsQ0FBQyx1RUFBVztBQUNoRCxNQUFNLEVBQUVvQixNQUFNLEVBQUUsR0FBR3BCLG1CQUFPQSxDQUFDLHFFQUFVO0FBQ3JDLE1BQU0sRUFBRXFCLFFBQVEsRUFBRSxHQUFHckIsbUJBQU9BLENBQUMseUVBQVk7QUFDekMsTUFBTSxFQUFFc0IsYUFBYSxFQUFFLEdBQUd0QixtQkFBT0EsQ0FBQyx5RUFBWTtBQUM5QyxNQUFNLEVBQUV1QixVQUFVLEVBQUUsR0FBR3ZCLG1CQUFPQSxDQUFDLDJFQUFvQjtBQUNuRCxNQUFNd0IsU0FBU3hCLG1CQUFPQSxDQUFD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RUEsSUFBSUgsYUFBYUYsaUJBQWlCO1FBQ2hDLE9BQU83SCxPQUFPa0MsVUFBVSxDQUFDMkYsZUFBZSxDQUFDRSxHQUFHQyxRQUFRekI7SUFDdEQ7SUFFQSxPQUFPdkcsT0FBT2tDLFVBQVUsQ0FBQ3NHLFNBQVMsQ0FBQ1QsR0FBR0MsUUFBUXpCO0FBQ2hEO0FBRUEsMENBQTBDO0FBQzFDdkcsT0FBT2tDLFVBQVUsQ0FBQ3dCLFFBQVEsR0FBRyxTQUFVcUUsQ0FBQyxFQUFFQyxNQUFNLEVBQUVTLFFBQVE7SUFDeEQsSUFBSVYsYUFBYUosZ0JBQWdCO1FBQy9CLE9BQU8zSCxPQUFPa0MsVUFBVSxDQUFDeUYsY0FBYyxDQUFDSSxHQUFHQyxRQUFRUztJQUNyRDtJQUVBLGtEQUFrRDtJQUNsRCwrQkFBK0I7SUFDL0IsSUFBSVYsR0FBRyxDQUFDekMsT0FBT29ELGFBQWEsQ0FBQyxFQUFFO1FBQzdCLE9BQU9YO0lBQ1Q7SUFFQSxPQUFPL0gsT0FBT2tDLFVBQVUsQ0FBQzRGLHNCQUFzQixDQUFDQyxHQUFHQyxRQUFRUztBQUM3RDtBQUVBekksT0FBT2tDLFVBQVUsQ0FBQ0MsWUFBWSxHQUFHbkMsT0FBTzJJLG1CQUFtQixDQUFDO0lBQzFEO1FBQ0VDLEtBQUs7UUFDTEMsV0FBVzdJLE9BQU9rQyxVQUFVLENBQUMsaUJBQWlCO1FBQzlDNEcsY0FBYyxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUYsS0FBSztRQUNMQyxXQUFXN0ksT0FBT2tDLFVBQVUsQ0FBQzZHLFVBQVU7UUFDdkNELGNBQWMsSUFBTTtJQUN0QjtJQUNBO1FBQ0VGLEtBQUs7UUFDTEMsV0FBVzdJLE9BQU9rQyxVQUFVLENBQUM4RyxXQUFXO0lBQzFDO0NBQ0Q7QUFFREMsT0FBT0MsT0FBTyxHQUFHO0lBQ2YxQztJQUNBNUU7SUFDQVc7SUFDQTBFO0lBQ0F0QjtJQUNBbkU7SUFDQW1EO0lBQ0FoRDtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXHJlc3BvbnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEhlYWRlcnMsIEhlYWRlcnNMaXN0LCBmaWxsLCBnZXRIZWFkZXJzR3VhcmQsIHNldEhlYWRlcnNHdWFyZCwgc2V0SGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBjbG9uZUJvZHksIG1peGluQm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSB1dGlsXG5jb25zdCB7XG4gIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gIGlzQ2FuY2VsbGVkLFxuICBpc0Fib3J0ZWQsXG4gIGlzQmxvYkxpa2UsXG4gIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyxcbiAgaXNFcnJvckxpa2UsXG4gIGlzb21vcnBoaWNFbmNvZGUsXG4gIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Q6IHJlbGV2YW50UmVhbG1cbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgbnVsbEJvZHlTdGF0dXNcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtTdGF0ZSwga0hlYWRlcnMgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBGb3JtRGF0YSB9ID0gcmVxdWlyZSgnLi9mb3JtZGF0YScpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4vZGF0YS11cmwnKVxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsgaXNEaXN0dXJiZWQsIGlzRXJyb3JlZCB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKVxuXG5jb25zdCBoYXNGaW5hbGl6YXRpb25SZWdpc3RyeSA9IGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxOCcpICE9PSAwXG5sZXQgcmVnaXN0cnlcblxuaWYgKGhhc0ZpbmFsaXphdGlvblJlZ2lzdHJ5KSB7XG4gIHJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh3ZWFrUmVmKSA9PiB7XG4gICAgY29uc3Qgc3RyZWFtID0gd2Vha1JlZi5kZXJlZigpXG4gICAgaWYgKHN0cmVhbSAmJiAhc3RyZWFtLmxvY2tlZCAmJiAhaXNEaXN0dXJiZWQoc3RyZWFtKSAmJiAhaXNFcnJvcmVkKHN0cmVhbSkpIHtcbiAgICAgIHN0cmVhbS5jYW5jZWwoJ1Jlc3BvbnNlIG9iamVjdCBoYXMgYmVlbiBnYXJiYWdlIGNvbGxlY3RlZCcpLmNhdGNoKG5vb3ApXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzc1xuY2xhc3MgUmVzcG9uc2Uge1xuICAvLyBDcmVhdGVzIG5ldHdvcmsgZXJyb3IgUmVzcG9uc2UuXG4gIHN0YXRpYyBlcnJvciAoKSB7XG4gICAgLy8gVGhlIHN0YXRpYyBlcnJvcigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYVxuICAgIC8vIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW4gYSBuZXcgbmV0d29yayBlcnJvciwgXCJpbW11dGFibGVcIiwgYW5kIHRoaXPigJlzXG4gICAgLy8gcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBmcm9tSW5uZXJSZXNwb25zZShtYWtlTmV0d29ya0Vycm9yKCksICdpbW11dGFibGUnKVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlc3BvbnNlLWpzb25cbiAgc3RhdGljIGpzb24gKGRhdGEsIGluaXQgPSB7fSkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ1Jlc3BvbnNlLmpzb24nKVxuXG4gICAgaWYgKGluaXQgIT09IG51bGwpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNlcmlhbGl6ZSBhIEphdmFTY3JpcHQgdmFsdWUgdG8gSlNPTiBieXRlcyBvbiBkYXRhLlxuICAgIGNvbnN0IGJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nKGRhdGEpXG4gICAgKVxuXG4gICAgLy8gMi4gTGV0IGJvZHkgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGJ5dGVzLlxuICAgIGNvbnN0IGJvZHkgPSBleHRyYWN0Qm9keShieXRlcylcblxuICAgIC8vIDMuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlbiBhIG5ldyByZXNwb25zZSxcbiAgICAvLyAgICBcInJlc3BvbnNlXCIsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKG1ha2VSZXNwb25zZSh7fSksICdyZXNwb25zZScpXG5cbiAgICAvLyA0LiBQZXJmb3JtIGluaXRpYWxpemUgYSByZXNwb25zZSBnaXZlbiByZXNwb25zZU9iamVjdCwgaW5pdCwgYW5kIChib2R5LCBcImFwcGxpY2F0aW9uL2pzb25cIikuXG4gICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlT2JqZWN0LCBpbml0LCB7IGJvZHk6IGJvZHlbMF0sIHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KVxuXG4gICAgLy8gNS4gUmV0dXJuIHJlc3BvbnNlT2JqZWN0LlxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIHJlZGlyZWN0IFJlc3BvbnNlIHRoYXQgcmVkaXJlY3RzIHRvIHVybCB3aXRoIHN0YXR1cyBzdGF0dXMuXG4gIHN0YXRpYyByZWRpcmVjdCAodXJsLCBzdGF0dXMgPSAzMDIpIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdSZXNwb25zZS5yZWRpcmVjdCcpXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKVxuICAgIHN0YXR1cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKHN0YXR1cylcblxuICAgIC8vIDEuIExldCBwYXJzZWRVUkwgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHVybCB3aXRoIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAvLyBvYmplY3TigJlzIEFQSSBiYXNlIFVSTC5cbiAgICAvLyAyLiBJZiBwYXJzZWRVUkwgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyBUT0RPOiBiYXNlLVVSTD9cbiAgICBsZXQgcGFyc2VkVVJMXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwodXJsLCByZWxldmFudFJlYWxtLnNldHRpbmdzT2JqZWN0LmJhc2VVcmwpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gJHt1cmx9YCwgeyBjYXVzZTogZXJyIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgc3RhdHVzIGlzIG5vdCBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbiB0aHJvdyBhIFJhbmdlRXJyb3IuXG4gICAgaWYgKCFyZWRpcmVjdFN0YXR1c1NldC5oYXMoc3RhdHVzKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgc3RhdHVzIGNvZGUgJHtzdGF0dXN9YClcbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCxcbiAgICAvLyBnaXZlbiBhIG5ldyByZXNwb25zZSwgXCJpbW11dGFibGVcIiwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UobWFrZVJlc3BvbnNlKHt9KSwgJ2ltbXV0YWJsZScpXG5cbiAgICAvLyA1LiBTZXQgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gc3RhdHVzLlxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uc3RhdHVzID0gc3RhdHVzXG5cbiAgICAvLyA2LiBMZXQgdmFsdWUgYmUgcGFyc2VkVVJMLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgY29uc3QgdmFsdWUgPSBpc29tb3JwaGljRW5jb2RlKFVSTFNlcmlhbGl6ZXIocGFyc2VkVVJMKSlcblxuICAgIC8vIDcuIEFwcGVuZCBgTG9jYXRpb25gL3ZhbHVlIHRvIHJlc3BvbnNlT2JqZWN04oCZcyByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2xvY2F0aW9uJywgdmFsdWUsIHRydWUpXG5cbiAgICAvLyA4LiBSZXR1cm4gcmVzcG9uc2VPYmplY3QuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlc3BvbnNlXG4gIGNvbnN0cnVjdG9yIChib2R5ID0gbnVsbCwgaW5pdCA9IHt9KSB7XG4gICAgaWYgKGJvZHkgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChib2R5ICE9PSBudWxsKSB7XG4gICAgICBib2R5ID0gd2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQoYm9keSlcbiAgICB9XG5cbiAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0KGluaXQpXG5cbiAgICAvLyAxLiBTZXQgdGhpc+KAmXMgcmVzcG9uc2UgdG8gYSBuZXcgcmVzcG9uc2UuXG4gICAgdGhpc1trU3RhdGVdID0gbWFrZVJlc3BvbnNlKHt9KVxuXG4gICAgLy8gMi4gU2V0IHRoaXPigJlzIGhlYWRlcnMgdG8gYSBuZXcgSGVhZGVycyBvYmplY3Qgd2l0aCB0aGlz4oCZcyByZWxldmFudFxuICAgIC8vIFJlYWxtLCB3aG9zZSBoZWFkZXIgbGlzdCBpcyB0aGlz4oCZcyByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgYW5kIGd1YXJkXG4gICAgLy8gaXMgXCJyZXNwb25zZVwiLlxuICAgIHRoaXNba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgICBzZXRIZWFkZXJzR3VhcmQodGhpc1trSGVhZGVyc10sICdyZXNwb25zZScpXG4gICAgc2V0SGVhZGVyc0xpc3QodGhpc1trSGVhZGVyc10sIHRoaXNba1N0YXRlXS5oZWFkZXJzTGlzdClcblxuICAgIC8vIDMuIExldCBib2R5V2l0aFR5cGUgYmUgbnVsbC5cbiAgICBsZXQgYm9keVdpdGhUeXBlID0gbnVsbFxuXG4gICAgLy8gNC4gSWYgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgYm9keVdpdGhUeXBlIHRvIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBib2R5LlxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCB0eXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgICBib2R5V2l0aFR5cGUgPSB7IGJvZHk6IGV4dHJhY3RlZEJvZHksIHR5cGUgfVxuICAgIH1cblxuICAgIC8vIDUuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHRoaXMsIGluaXQsIGFuZCBib2R5V2l0aFR5cGUuXG4gICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHRoaXMsIGluaXQsIGJvZHlXaXRoVHlwZSlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHR5cGUsIGUuZy4sIFwiY29yc1wiLlxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgdHlwZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgdHlwZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnR5cGVcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIFVSTCwgaWYgaXQgaGFzIG9uZTsgb3RoZXJ3aXNlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgY29uc3QgdXJsTGlzdCA9IHRoaXNba1N0YXRlXS51cmxMaXN0XG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcgaWYgdGhpc+KAmXNcbiAgICAvLyByZXNwb25zZeKAmXMgVVJMIGlzIG51bGw7IG90aGVyd2lzZSB0aGlz4oCZcyByZXNwb25zZeKAmXMgVVJMLFxuICAgIC8vIHNlcmlhbGl6ZWQgd2l0aCBleGNsdWRlIGZyYWdtZW50IHNldCB0byB0cnVlLlxuICAgIGNvbnN0IHVybCA9IHVybExpc3RbdXJsTGlzdC5sZW5ndGggLSAxXSA/PyBudWxsXG5cbiAgICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih1cmwsIHRydWUpXG4gIH1cblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgcmVzcG9uc2Ugd2FzIG9idGFpbmVkIHRocm91Z2ggYSByZWRpcmVjdC5cbiAgZ2V0IHJlZGlyZWN0ZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHJlZGlyZWN0ZWQgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXNwb25zZeKAmXMgVVJMXG4gICAgLy8gbGlzdCBoYXMgbW9yZSB0aGFuIG9uZSBpdGVtOyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS51cmxMaXN0Lmxlbmd0aCA+IDFcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgZ2V0IHN0YXR1cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXNcbiAgfVxuXG4gIC8vIFJldHVybnMgd2hldGhlciByZXNwb25zZeKAmXMgc3RhdHVzIGlzIGFuIG9rIHN0YXR1cy5cbiAgZ2V0IG9rICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBvayBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYW5cbiAgICAvLyBvayBzdGF0dXM7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1cyA+PSAyMDAgJiYgdGhpc1trU3RhdGVdLnN0YXR1cyA8PSAyOTlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlLlxuICBnZXQgc3RhdHVzVGV4dCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzVGV4dCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzXG4gICAgLy8gbWVzc2FnZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1c1RleHRcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIGhlYWRlcnMgYXMgSGVhZGVycy5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIGhlYWRlcnMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgaGVhZGVycy5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc11cbiAgfVxuXG4gIGdldCBib2R5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYm9keSA/IHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSA6IG51bGxcbiAgfVxuXG4gIGdldCBib2R5VXNlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICByZXR1cm4gISF0aGlzW2tTdGF0ZV0uYm9keSAmJiB1dGlsLmlzRGlzdHVyYmVkKHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBjbG9uZSBvZiByZXNwb25zZS5cbiAgY2xvbmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodGhpcy5ib2R5VXNlZCB8fCB0aGlzLmJvZHk/LmxvY2tlZCkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXNwb25zZS5jbG9uZScsXG4gICAgICAgIG1lc3NhZ2U6ICdCb2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgY2xvbmVkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBjbG9uaW5nIHRoaXPigJlzIHJlc3BvbnNlLlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZSh0aGlzW2tTdGF0ZV0pXG5cbiAgICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW5cbiAgICAvLyBjbG9uZWRSZXNwb25zZSwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICByZXR1cm4gZnJvbUlubmVyUmVzcG9uc2UoY2xvbmVkUmVzcG9uc2UsIGdldEhlYWRlcnNHdWFyZCh0aGlzW2tIZWFkZXJzXSkpXG4gIH1cblxuICBbbm9kZVV0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRlcHRoID09PSBudWxsKSB7XG4gICAgICBvcHRpb25zLmRlcHRoID0gMlxuICAgIH1cblxuICAgIG9wdGlvbnMuY29sb3JzID8/PSB0cnVlXG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGJvZHk6IHRoaXMuYm9keSxcbiAgICAgIGJvZHlVc2VkOiB0aGlzLmJvZHlVc2VkLFxuICAgICAgb2s6IHRoaXMub2ssXG4gICAgICByZWRpcmVjdGVkOiB0aGlzLnJlZGlyZWN0ZWQsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfVxuXG4gICAgcmV0dXJuIGBSZXNwb25zZSAke25vZGVVdGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHByb3BlcnRpZXMpfWBcbiAgfVxufVxuXG5taXhpbkJvZHkoUmVzcG9uc2UpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLnByb3RvdHlwZSwge1xuICB0eXBlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHN0YXR1czoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb2s6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0ZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHN0YXR1c1RleHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhlYWRlcnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNsb25lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5VXNlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1Jlc3BvbnNlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UsIHtcbiAganNvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVkaXJlY3Q6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXNwb25zZS1jbG9uZVxuZnVuY3Rpb24gY2xvbmVSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgLy8gVG8gY2xvbmUgYSByZXNwb25zZSByZXNwb25zZSwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIDEuIElmIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2UsIHRoZW4gcmV0dXJuIGEgbmV3IGlkZW50aWNhbFxuICAvLyBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSBpbnRlcm5hbCByZXNwb25zZSBpcyBhIGNsb25lIG9mIHJlc3BvbnNl4oCZc1xuICAvLyBpbnRlcm5hbCByZXNwb25zZS5cbiAgaWYgKHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZmlsdGVyUmVzcG9uc2UoXG4gICAgICBjbG9uZVJlc3BvbnNlKHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UpLFxuICAgICAgcmVzcG9uc2UudHlwZVxuICAgIClcbiAgfVxuXG4gIC8vIDIuIExldCBuZXdSZXNwb25zZSBiZSBhIGNvcHkgb2YgcmVzcG9uc2UsIGV4Y2VwdCBmb3IgaXRzIGJvZHkuXG4gIGNvbnN0IG5ld1Jlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgLi4ucmVzcG9uc2UsIGJvZHk6IG51bGwgfSlcblxuICAvLyAzLiBJZiByZXNwb25zZeKAmXMgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgbmV3UmVzcG9uc2XigJlzIGJvZHkgdG8gdGhlXG4gIC8vIHJlc3VsdCBvZiBjbG9uaW5nIHJlc3BvbnNl4oCZcyBib2R5LlxuICBpZiAocmVzcG9uc2UuYm9keSAhPSBudWxsKSB7XG4gICAgbmV3UmVzcG9uc2UuYm9keSA9IGNsb25lQm9keShyZXNwb25zZS5ib2R5KVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIG5ld1Jlc3BvbnNlLlxuICByZXR1cm4gbmV3UmVzcG9uc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVJlc3BvbnNlIChpbml0KSB7XG4gIHJldHVybiB7XG4gICAgYWJvcnRlZDogZmFsc2UsXG4gICAgcmFuZ2VSZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgIHRpbWluZ0FsbG93UGFzc2VkOiBmYWxzZSxcbiAgICByZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFsczogZmFsc2UsXG4gICAgdHlwZTogJ2RlZmF1bHQnLFxuICAgIHN0YXR1czogMjAwLFxuICAgIHRpbWluZ0luZm86IG51bGwsXG4gICAgY2FjaGVTdGF0ZTogJycsXG4gICAgc3RhdHVzVGV4dDogJycsXG4gICAgLi4uaW5pdCxcbiAgICBoZWFkZXJzTGlzdDogaW5pdD8uaGVhZGVyc0xpc3RcbiAgICAgID8gbmV3IEhlYWRlcnNMaXN0KGluaXQ/LmhlYWRlcnNMaXN0KVxuICAgICAgOiBuZXcgSGVhZGVyc0xpc3QoKSxcbiAgICB1cmxMaXN0OiBpbml0Py51cmxMaXN0ID8gWy4uLmluaXQudXJsTGlzdF0gOiBbXVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VOZXR3b3JrRXJyb3IgKHJlYXNvbikge1xuICBjb25zdCBpc0Vycm9yID0gaXNFcnJvckxpa2UocmVhc29uKVxuICByZXR1cm4gbWFrZVJlc3BvbnNlKHtcbiAgICB0eXBlOiAnZXJyb3InLFxuICAgIHN0YXR1czogMCxcbiAgICBlcnJvcjogaXNFcnJvclxuICAgICAgPyByZWFzb25cbiAgICAgIDogbmV3IEVycm9yKHJlYXNvbiA/IFN0cmluZyhyZWFzb24pIDogcmVhc29uKSxcbiAgICBhYm9ydGVkOiByZWFzb24gJiYgcmVhc29uLm5hbWUgPT09ICdBYm9ydEVycm9yJ1xuICB9KVxufVxuXG4vLyBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW5ldHdvcmstZXJyb3JcbmZ1bmN0aW9uIGlzTmV0d29ya0Vycm9yIChyZXNwb25zZSkge1xuICByZXR1cm4gKFxuICAgIC8vIEEgbmV0d29yayBlcnJvciBpcyBhIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJlcnJvclwiLFxuICAgIHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgJiZcbiAgICAvLyBzdGF0dXMgaXMgMFxuICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gMFxuICApXG59XG5cbmZ1bmN0aW9uIG1ha2VGaWx0ZXJlZFJlc3BvbnNlIChyZXNwb25zZSwgc3RhdGUpIHtcbiAgc3RhdGUgPSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZTogcmVzcG9uc2UsXG4gICAgLi4uc3RhdGVcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJveHkocmVzcG9uc2UsIHtcbiAgICBnZXQgKHRhcmdldCwgcCkge1xuICAgICAgcmV0dXJuIHAgaW4gc3RhdGUgPyBzdGF0ZVtwXSA6IHRhcmdldFtwXVxuICAgIH0sXG4gICAgc2V0ICh0YXJnZXQsIHAsIHZhbHVlKSB7XG4gICAgICBhc3NlcnQoIShwIGluIHN0YXRlKSlcbiAgICAgIHRhcmdldFtwXSA9IHZhbHVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZmlsdGVyZWQtcmVzcG9uc2VcbmZ1bmN0aW9uIGZpbHRlclJlc3BvbnNlIChyZXNwb25zZSwgdHlwZSkge1xuICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIGZvbGxvd2luZyBmaWx0ZXJlZCByZXNwb25zZSB3aXRoIHJlc3BvbnNlIGFzIGl0c1xuICAvLyBpbnRlcm5hbCByZXNwb25zZSwgZGVwZW5kaW5nIG9uIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nOlxuICBpZiAodHlwZSA9PT0gJ2Jhc2ljJykge1xuICAgIC8vIEEgYmFzaWMgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlIGlzIFwiYmFzaWNcIlxuICAgIC8vIGFuZCBoZWFkZXIgbGlzdCBleGNsdWRlcyBhbnkgaGVhZGVycyBpbiBpbnRlcm5hbCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3RcbiAgICAvLyB3aG9zZSBuYW1lIGlzIGEgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnYmFzaWMnLFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY29ycycpIHtcbiAgICAvLyBBIENPUlMgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlIGlzIFwiY29yc1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXJcbiAgICAvLyBsaXN0IHdob3NlIG5hbWUgaXMgbm90IGEgQ09SUy1zYWZlbGlzdGVkIHJlc3BvbnNlLWhlYWRlciBuYW1lLCBnaXZlblxuICAgIC8vIGludGVybmFsIHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdC5cblxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgQ09SUy1zYWZlbGlzdGVkIHJlc3BvbnNlLWhlYWRlciBuYW1lc1xuICAgIHJldHVybiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgdHlwZTogJ2NvcnMnLFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BhcXVlJykge1xuICAgIC8vIEFuIG9wYXF1ZSBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXNcbiAgICAvLyBcIm9wYXF1ZVwiLCBVUkwgbGlzdCBpcyB0aGUgZW1wdHkgbGlzdCwgc3RhdHVzIGlzIDAsIHN0YXR1cyBtZXNzYWdlXG4gICAgLy8gaXMgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UsIGhlYWRlciBsaXN0IGlzIGVtcHR5LCBhbmQgYm9keSBpcyBudWxsLlxuXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnb3BhcXVlJyxcbiAgICAgIHVybExpc3Q6IE9iamVjdC5mcmVlemUoW10pLFxuICAgICAgc3RhdHVzOiAwLFxuICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICBib2R5OiBudWxsXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BhcXVlcmVkaXJlY3QnKSB7XG4gICAgLy8gQW4gb3BhcXVlLXJlZGlyZWN0IGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZVxuICAgIC8vIGlzIFwib3BhcXVlcmVkaXJlY3RcIiwgc3RhdHVzIGlzIDAsIHN0YXR1cyBtZXNzYWdlIGlzIHRoZSBlbXB0eSBieXRlXG4gICAgLy8gc2VxdWVuY2UsIGhlYWRlciBsaXN0IGlzIGVtcHR5LCBhbmQgYm9keSBpcyBudWxsLlxuXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnb3BhcXVlcmVkaXJlY3QnLFxuICAgICAgc3RhdHVzOiAwLFxuICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICBoZWFkZXJzTGlzdDogW10sXG4gICAgICBib2R5OiBudWxsXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2FwcHJvcHJpYXRlLW5ldHdvcmstZXJyb3JcbmZ1bmN0aW9uIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvciAoZmV0Y2hQYXJhbXMsIGVyciA9IG51bGwpIHtcbiAgLy8gMS4gQXNzZXJ0OiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZC5cbiAgYXNzZXJ0KGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSlcblxuICAvLyAyLiBSZXR1cm4gYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yIGlmIGZldGNoUGFyYW1zIGlzIGFib3J0ZWQ7XG4gIC8vIG90aGVyd2lzZSByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICByZXR1cm4gaXNBYm9ydGVkKGZldGNoUGFyYW1zKVxuICAgID8gbWFrZU5ldHdvcmtFcnJvcihPYmplY3QuYXNzaWduKG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSwgeyBjYXVzZTogZXJyIH0pKVxuICAgIDogbWFrZU5ldHdvcmtFcnJvcihPYmplY3QuYXNzaWduKG5ldyBET01FeGNlcHRpb24oJ1JlcXVlc3Qgd2FzIGNhbmNlbGxlZC4nKSwgeyBjYXVzZTogZXJyIH0pKVxufVxuXG4vLyBodHRwczovL3doYXRwci5vcmcvZmV0Y2gvMTM5Mi5odG1sI2luaXRpYWxpemUtYS1yZXNwb25zZVxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlc3BvbnNlIChyZXNwb25zZSwgaW5pdCwgYm9keSkge1xuICAvLyAxLiBJZiBpbml0W1wic3RhdHVzXCJdIGlzIG5vdCBpbiB0aGUgcmFuZ2UgMjAwIHRvIDU5OSwgaW5jbHVzaXZlLCB0aGVuXG4gIC8vICAgIHRocm93IGEgUmFuZ2VFcnJvci5cbiAgaWYgKGluaXQuc3RhdHVzICE9PSBudWxsICYmIChpbml0LnN0YXR1cyA8IDIwMCB8fCBpbml0LnN0YXR1cyA+IDU5OSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5pdFtcInN0YXR1c1wiXSBtdXN0IGJlIGluIHRoZSByYW5nZSBvZiAyMDAgdG8gNTk5LCBpbmNsdXNpdmUuJylcbiAgfVxuXG4gIC8vIDIuIElmIGluaXRbXCJzdGF0dXNUZXh0XCJdIGRvZXMgbm90IG1hdGNoIHRoZSByZWFzb24tcGhyYXNlIHRva2VuIHByb2R1Y3Rpb24sXG4gIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmICgnc3RhdHVzVGV4dCcgaW4gaW5pdCAmJiBpbml0LnN0YXR1c1RleHQgIT0gbnVsbCkge1xuICAgIC8vIFNlZSwgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4xLjI6XG4gICAgLy8gICByZWFzb24tcGhyYXNlICA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVxuICAgIGlmICghaXNWYWxpZFJlYXNvblBocmFzZShTdHJpbmcoaW5pdC5zdGF0dXNUZXh0KSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzVGV4dCcpXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gU2V0IHJlc3BvbnNl4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIHRvIGluaXRbXCJzdGF0dXNcIl0uXG4gIGlmICgnc3RhdHVzJyBpbiBpbml0ICYmIGluaXQuc3RhdHVzICE9IG51bGwpIHtcbiAgICByZXNwb25zZVtrU3RhdGVdLnN0YXR1cyA9IGluaXQuc3RhdHVzXG4gIH1cblxuICAvLyA0LiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZSB0byBpbml0W1wic3RhdHVzVGV4dFwiXS5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgcmVzcG9uc2Vba1N0YXRlXS5zdGF0dXNUZXh0ID0gaW5pdC5zdGF0dXNUZXh0XG4gIH1cblxuICAvLyA1LiBJZiBpbml0W1wiaGVhZGVyc1wiXSBleGlzdHMsIHRoZW4gZmlsbCByZXNwb25zZeKAmXMgaGVhZGVycyB3aXRoIGluaXRbXCJoZWFkZXJzXCJdLlxuICBpZiAoJ2hlYWRlcnMnIGluIGluaXQgJiYgaW5pdC5oZWFkZXJzICE9IG51bGwpIHtcbiAgICBmaWxsKHJlc3BvbnNlW2tIZWFkZXJzXSwgaW5pdC5oZWFkZXJzKVxuICB9XG5cbiAgLy8gNi4gSWYgYm9keSB3YXMgZ2l2ZW4sIHRoZW46XG4gIGlmIChib2R5KSB7XG4gICAgLy8gMS4gSWYgcmVzcG9uc2UncyBzdGF0dXMgaXMgYSBudWxsIGJvZHkgc3RhdHVzLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1Jlc3BvbnNlIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgcmVzcG9uc2UncyBib2R5IHRvIGJvZHkncyBib2R5LlxuICAgIHJlc3BvbnNlW2tTdGF0ZV0uYm9keSA9IGJvZHkuYm9keVxuXG4gICAgLy8gMy4gSWYgYm9keSdzIHR5cGUgaXMgbm9uLW51bGwgYW5kIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpblxuICAgIC8vICAgIGBDb250ZW50LVR5cGVgLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtVHlwZWAsIGJvZHkncyB0eXBlKSB0byByZXNwb25zZSdzIGhlYWRlciBsaXN0LlxuICAgIGlmIChib2R5LnR5cGUgIT0gbnVsbCAmJiAhcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5jb250YWlucygnY29udGVudC10eXBlJywgdHJ1ZSkpIHtcbiAgICAgIHJlc3BvbnNlW2tTdGF0ZV0uaGVhZGVyc0xpc3QuYXBwZW5kKCdjb250ZW50LXR5cGUnLCBib2R5LnR5cGUsIHRydWUpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2UtY3JlYXRlXG4gKiBAcGFyYW0ge2FueX0gaW5uZXJSZXNwb25zZVxuICogQHBhcmFtIHsncmVxdWVzdCcgfCAnaW1tdXRhYmxlJyB8ICdyZXF1ZXN0LW5vLWNvcnMnIHwgJ3Jlc3BvbnNlJyB8ICdub25lJ30gZ3VhcmRcbiAqIEByZXR1cm5zIHtSZXNwb25zZX1cbiAqL1xuZnVuY3Rpb24gZnJvbUlubmVyUmVzcG9uc2UgKGlubmVyUmVzcG9uc2UsIGd1YXJkKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGtDb25zdHJ1Y3QpXG4gIHJlc3BvbnNlW2tTdGF0ZV0gPSBpbm5lclJlc3BvbnNlXG4gIHJlc3BvbnNlW2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gIHNldEhlYWRlcnNMaXN0KHJlc3BvbnNlW2tIZWFkZXJzXSwgaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdClcbiAgc2V0SGVhZGVyc0d1YXJkKHJlc3BvbnNlW2tIZWFkZXJzXSwgZ3VhcmQpXG5cbiAgaWYgKGhhc0ZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGlubmVyUmVzcG9uc2UuYm9keT8uc3RyZWFtKSB7XG4gICAgLy8gSWYgdGhlIHRhcmdldCAocmVzcG9uc2UpIGlzIHJlY2xhaW1lZCwgdGhlIGNsZWFudXAgY2FsbGJhY2sgbWF5IGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IHdpdGhcbiAgICAvLyB0aGUgaGVsZCB2YWx1ZSBwcm92aWRlZCBmb3IgaXQgKGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0pLiBUaGUgaGVsZCB2YWx1ZSBjYW4gYmUgYW55IHZhbHVlOlxuICAgIC8vIGEgcHJpbWl0aXZlIG9yIGFuIG9iamVjdCwgZXZlbiB1bmRlZmluZWQuIElmIHRoZSBoZWxkIHZhbHVlIGlzIGFuIG9iamVjdCwgdGhlIHJlZ2lzdHJ5IGtlZXBzXG4gICAgLy8gYSBzdHJvbmcgcmVmZXJlbmNlIHRvIGl0IChzbyBpdCBjYW4gcGFzcyBpdCB0byB0aGUgY2xlYW51cCBjYWxsYmFjayBsYXRlcikuIFJld29yZGVkIGZyb21cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyKHJlc3BvbnNlLCBuZXcgV2Vha1JlZihpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtKSlcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG53ZWJpZGwuY29udmVydGVycy5SZWFkYWJsZVN0cmVhbSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIFJlYWRhYmxlU3RyZWFtXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkZvcm1EYXRhID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgRm9ybURhdGFcbilcblxud2ViaWRsLmNvbnZlcnRlcnMuVVJMU2VhcmNoUGFyYW1zID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgVVJMU2VhcmNoUGFyYW1zXG4pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyN0eXBlZGVmZGVmLXhtbGh0dHByZXF1ZXN0Ym9keWluaXRcbndlYmlkbC5jb252ZXJ0ZXJzLlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgViA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYsIHByZWZpeCwgbmFtZSlcbiAgfVxuXG4gIGlmIChpc0Jsb2JMaWtlKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoViwgcHJlZml4LCBuYW1lLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoVikgfHwgdHlwZXMuaXNBcnJheUJ1ZmZlcihWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UoViwgcHJlZml4LCBuYW1lKVxuICB9XG5cbiAgaWYgKHV0aWwuaXNGb3JtRGF0YUxpa2UoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRm9ybURhdGEoViwgcHJlZml4LCBuYW1lLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgfVxuXG4gIGlmIChWIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVSTFNlYXJjaFBhcmFtcyhWLCBwcmVmaXgsIG5hbWUpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYsIHByZWZpeCwgbmFtZSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHlpbml0XG53ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdCA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIGlmIChWIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuUmVhZGFibGVTdHJlYW0oViwgcHJlZml4LCBhcmd1bWVudClcbiAgfVxuXG4gIC8vIE5vdGU6IHRoZSBzcGVjIGRvZXNuJ3QgaW5jbHVkZSBhc3luYyBpdGVyYWJsZXMsXG4gIC8vIHRoaXMgaXMgYW4gdW5kaWNpIGV4dGVuc2lvbi5cbiAgaWYgKFY/LltTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICByZXR1cm4gVlxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQoViwgcHJlZml4LCBhcmd1bWVudClcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnc3RhdHVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gMjAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzdGF0dXNUZXh0JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNOZXR3b3JrRXJyb3IsXG4gIG1ha2VOZXR3b3JrRXJyb3IsXG4gIG1ha2VSZXNwb25zZSxcbiAgbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLFxuICBmaWx0ZXJSZXNwb25zZSxcbiAgUmVzcG9uc2UsXG4gIGNsb25lUmVzcG9uc2UsXG4gIGZyb21Jbm5lclJlc3BvbnNlXG59XG4iXSwibmFtZXMiOlsiSGVhZGVycyIsIkhlYWRlcnNMaXN0IiwiZmlsbCIsImdldEhlYWRlcnNHdWFyZCIsInNldEhlYWRlcnNHdWFyZCIsInNldEhlYWRlcnNMaXN0IiwicmVxdWlyZSIsImV4dHJhY3RCb2R5IiwiY2xvbmVCb2R5IiwibWl4aW5Cb2R5IiwidXRpbCIsIm5vZGVVdGlsIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImlzVmFsaWRSZWFzb25QaHJhc2UiLCJpc0NhbmNlbGxlZCIsImlzQWJvcnRlZCIsImlzQmxvYkxpa2UiLCJzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmciLCJpc0Vycm9yTGlrZSIsImlzb21vcnBoaWNFbmNvZGUiLCJlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IiwicmVsZXZhbnRSZWFsbSIsInJlZGlyZWN0U3RhdHVzU2V0IiwibnVsbEJvZHlTdGF0dXMiLCJrU3RhdGUiLCJrSGVhZGVycyIsIndlYmlkbCIsIkZvcm1EYXRhIiwiVVJMU2VyaWFsaXplciIsImtDb25zdHJ1Y3QiLCJhc3NlcnQiLCJ0eXBlcyIsImlzRGlzdHVyYmVkIiwiaXNFcnJvcmVkIiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsImhhc0ZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiZ2xvYmFsVGhpcyIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwicHJvY2VzcyIsInZlcnNpb24iLCJpbmRleE9mIiwicmVnaXN0cnkiLCJ3ZWFrUmVmIiwic3RyZWFtIiwiZGVyZWYiLCJsb2NrZWQiLCJjYW5jZWwiLCJjYXRjaCIsIm5vb3AiLCJSZXNwb25zZSIsImVycm9yIiwicmVzcG9uc2VPYmplY3QiLCJmcm9tSW5uZXJSZXNwb25zZSIsIm1ha2VOZXR3b3JrRXJyb3IiLCJqc29uIiwiZGF0YSIsImluaXQiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiY29udmVydGVycyIsIlJlc3BvbnNlSW5pdCIsImJ5dGVzIiwiZW5jb2RlIiwiYm9keSIsIm1ha2VSZXNwb25zZSIsImluaXRpYWxpemVSZXNwb25zZSIsInR5cGUiLCJyZWRpcmVjdCIsInVybCIsInN0YXR1cyIsIlVTVlN0cmluZyIsInBhcnNlZFVSTCIsIlVSTCIsInNldHRpbmdzT2JqZWN0IiwiYmFzZVVybCIsImVyciIsIlR5cGVFcnJvciIsImNhdXNlIiwiaGFzIiwiUmFuZ2VFcnJvciIsInZhbHVlIiwiaGVhZGVyc0xpc3QiLCJhcHBlbmQiLCJCb2R5SW5pdCIsImJvZHlXaXRoVHlwZSIsImV4dHJhY3RlZEJvZHkiLCJicmFuZENoZWNrIiwidXJsTGlzdCIsImxlbmd0aCIsInJlZGlyZWN0ZWQiLCJvayIsInN0YXR1c1RleHQiLCJoZWFkZXJzIiwiYm9keVVzZWQiLCJjbG9uZSIsImVycm9ycyIsImV4Y2VwdGlvbiIsImhlYWRlciIsIm1lc3NhZ2UiLCJjbG9uZWRSZXNwb25zZSIsImNsb25lUmVzcG9uc2UiLCJpbnNwZWN0IiwiY3VzdG9tIiwiZGVwdGgiLCJvcHRpb25zIiwiY29sb3JzIiwicHJvcGVydGllcyIsImZvcm1hdFdpdGhPcHRpb25zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiY29uZmlndXJhYmxlIiwicmVzcG9uc2UiLCJpbnRlcm5hbFJlc3BvbnNlIiwiZmlsdGVyUmVzcG9uc2UiLCJuZXdSZXNwb25zZSIsImFib3J0ZWQiLCJyYW5nZVJlcXVlc3RlZCIsInRpbWluZ0FsbG93UGFzc2VkIiwicmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHMiLCJ0aW1pbmdJbmZvIiwiY2FjaGVTdGF0ZSIsInJlYXNvbiIsImlzRXJyb3IiLCJFcnJvciIsIlN0cmluZyIsIm5hbWUiLCJpc05ldHdvcmtFcnJvciIsIm1ha2VGaWx0ZXJlZFJlc3BvbnNlIiwic3RhdGUiLCJQcm94eSIsImdldCIsInRhcmdldCIsInAiLCJzZXQiLCJmcmVlemUiLCJtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IiLCJmZXRjaFBhcmFtcyIsImFzc2lnbiIsIkRPTUV4Y2VwdGlvbiIsImluY2x1ZGVzIiwiY29udGFpbnMiLCJpbm5lclJlc3BvbnNlIiwiZ3VhcmQiLCJyZWdpc3RlciIsIldlYWtSZWYiLCJSZWFkYWJsZVN0cmVhbSIsImludGVyZmFjZUNvbnZlcnRlciIsIlVSTFNlYXJjaFBhcmFtcyIsIlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQiLCJWIiwicHJlZml4IiwiQmxvYiIsInN0cmljdCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiaXNBcnJheUJ1ZmZlciIsIkJ1ZmZlclNvdXJjZSIsImlzRm9ybURhdGFMaWtlIiwiRE9NU3RyaW5nIiwiYXJndW1lbnQiLCJhc3luY0l0ZXJhdG9yIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsImRlZmF1bHRWYWx1ZSIsIkJ5dGVTdHJpbmciLCJIZWFkZXJzSW5pdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/response.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kUrl: Symbol('url'),\n    kHeaders: Symbol('headers'),\n    kSignal: Symbol('signal'),\n    kState: Symbol('state'),\n    kDispatcher: Symbol('dispatcher')\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsTUFBTUMsT0FBTztJQUNiQyxVQUFVRCxPQUFPO0lBQ2pCRSxTQUFTRixPQUFPO0lBQ2hCRyxRQUFRSCxPQUFPO0lBQ2ZJLGFBQWFKLE9BQU87QUFDdEIiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtVcmw6IFN5bWJvbCgndXJsJyksXG4gIGtIZWFkZXJzOiBTeW1ib2woJ2hlYWRlcnMnKSxcbiAga1NpZ25hbDogU3ltYm9sKCdzaWduYWwnKSxcbiAga1N0YXRlOiBTeW1ib2woJ3N0YXRlJyksXG4gIGtEaXNwYXRjaGVyOiBTeW1ib2woJ2Rpc3BhdGNoZXInKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJrVXJsIiwiU3ltYm9sIiwia0hlYWRlcnMiLCJrU2lnbmFsIiwia1N0YXRlIiwia0Rpc3BhdGNoZXIiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/undici/lib/web/fetch/global.js\");\nconst { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { performance } = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\");\nconst { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { isUint8Array } = __webpack_require__(/*! node:util/types */ \"node:util/types\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nlet supportedHashes = [];\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n    const possibleRelevantHashes = [\n        'sha256',\n        'sha384',\n        'sha512'\n    ];\n    supportedHashes = crypto.getHashes().filter((hash)=>possibleRelevantHashes.includes(hash));\n/* c8 ignore next 3 */ } catch  {}\nfunction responseURL(response) {\n    // https://fetch.spec.whatwg.org/#responses\n    // A response has an associated URL. It is a pointer to the last URL\n    // in response’s URL list and null if response’s URL list is empty.\n    const urlList = response.urlList;\n    const length = urlList.length;\n    return length === 0 ? null : urlList[length - 1].toString();\n}\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n    // 1. If response’s status is not a redirect status, then return null.\n    if (!redirectStatusSet.has(response.status)) {\n        return null;\n    }\n    // 2. Let location be the result of extracting header list values given\n    // `Location` and response’s header list.\n    let location = response.headersList.get('location', true);\n    // 3. If location is a header value, then set location to the result of\n    //    parsing location with response’s URL.\n    if (location !== null && isValidHeaderValue(location)) {\n        if (!isValidEncodedURL(location)) {\n            // Some websites respond location header in UTF-8 form without encoding them as ASCII\n            // and major browsers redirect them to correctly UTF-8 encoded addresses.\n            // Here, we handle that behavior in the same way.\n            location = normalizeBinaryStringToUtf8(location);\n        }\n        location = new URL(location, responseURL(response));\n    }\n    // 4. If location is a URL whose fragment is null, then set location’s\n    // fragment to requestFragment.\n    if (location && !location.hash) {\n        location.hash = requestFragment;\n    }\n    // 5. Return location.\n    return location;\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */ function isValidEncodedURL(url) {\n    for(let i = 0; i < url.length; ++i){\n        const code = url.charCodeAt(i);\n        if (code > 0x7E || // Non-US-ASCII + DEL\n        code < 0x20 // Control characters NUL - US\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */ function normalizeBinaryStringToUtf8(value) {\n    return Buffer.from(value, 'binary').toString('utf8');\n}\n/** @returns {URL} */ function requestCurrentURL(request) {\n    return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n    // 1. Let url be request’s current URL.\n    const url = requestCurrentURL(request);\n    // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n    // then return blocked.\n    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n        return 'blocked';\n    }\n    // 3. Return allowed.\n    return 'allowed';\n}\nfunction isErrorLike(object) {\n    return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';\n}\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n    for(let i = 0; i < statusText.length; ++i){\n        const c = statusText.charCodeAt(i);\n        if (!(c === 0x09 || // HTAB\n        c >= 0x20 && c <= 0x7e || // SP / VCHAR\n        c >= 0x80 && c <= 0xff // obs-text\n        )) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */ const isValidHeaderName = isValidHTTPToken;\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */ function isValidHeaderValue(potentialValue) {\n    // - Has no leading or trailing HTTP tab or space bytes.\n    // - Contains no 0x00 (NUL) or HTTP newline bytes.\n    return (potentialValue[0] === '\\t' || potentialValue[0] === ' ' || potentialValue[potentialValue.length - 1] === '\\t' || potentialValue[potentialValue.length - 1] === ' ' || potentialValue.includes('\\n') || potentialValue.includes('\\r') || potentialValue.includes('\\0')) === false;\n}\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n    //  Given a request request and a response actualResponse, this algorithm\n    //  updates request’s referrer policy according to the Referrer-Policy\n    //  header (if any) in actualResponse.\n    // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n    // from a Referrer-Policy header on actualResponse.\n    // 8.1 Parse a referrer policy from a Referrer-Policy header\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n    const { headersList } = actualResponse;\n    // 2. Let policy be the empty string.\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n    // 4. Return policy.\n    const policyHeader = (headersList.get('referrer-policy', true) ?? '').split(',');\n    // Note: As the referrer-policy can contain multiple policies\n    // separated by comma, we need to loop through all of them\n    // and pick the first valid one.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n    let policy = '';\n    if (policyHeader.length > 0) {\n        // The right-most policy takes precedence.\n        // The left-most policy is the fallback.\n        for(let i = policyHeader.length; i !== 0; i--){\n            const token = policyHeader[i - 1].trim();\n            if (referrerPolicyTokens.has(token)) {\n                policy = token;\n                break;\n            }\n        }\n    }\n    // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n    if (policy !== '') {\n        request.referrerPolicy = policy;\n    }\n}\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n    // TODO\n    return 'allowed';\n}\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n    // TODO\n    return 'success';\n}\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n    // TODO\n    return 'success';\n}\nfunction appendFetchMetadata(httpRequest) {\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n    //  TODO\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n    //  1. Assert: r’s url is a potentially trustworthy URL.\n    //  TODO\n    //  2. Let header be a Structured Header whose value is a token.\n    let header = null;\n    //  3. Set header’s value to r’s mode.\n    header = httpRequest.mode;\n    //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n    httpRequest.headersList.set('sec-fetch-mode', header, true);\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n//  TODO\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n//  TODO\n}\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n    // 1. Let serializedOrigin be the result of byte-serializing a request origin\n    //    with request.\n    // TODO: implement \"byte-serializing a request origin\"\n    let serializedOrigin = request.origin;\n    // - \"'client' is changed to an origin during fetching.\"\n    //   This doesn't happen in undici (in most cases) because undici, by default,\n    //   has no concept of origin.\n    // - request.origin can also be set to request.client.origin (client being\n    //   an environment settings object), which is undefined without using\n    //   setGlobalOrigin.\n    if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n        return;\n    }\n    // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\",\n    //    then append (`Origin`, serializedOrigin) to request’s header list.\n    // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n    if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n        request.headersList.append('origin', serializedOrigin, true);\n    } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n        // 1. Switch on request’s referrer policy:\n        switch(request.referrerPolicy){\n            case 'no-referrer':\n                // Set serializedOrigin to `null`.\n                serializedOrigin = null;\n                break;\n            case 'no-referrer-when-downgrade':\n            case 'strict-origin':\n            case 'strict-origin-when-cross-origin':\n                // If request’s origin is a tuple origin, its scheme is \"https\", and\n                // request’s current URL’s scheme is not \"https\", then set\n                // serializedOrigin to `null`.\n                if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            case 'same-origin':\n                // If request’s origin is not same origin with request’s current URL’s\n                // origin, then set serializedOrigin to `null`.\n                if (!sameOrigin(request, requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            default:\n        }\n        // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n        request.headersList.append('origin', serializedOrigin, true);\n    }\n}\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime(timestamp, crossOriginIsolatedCapability) {\n    // TODO\n    return timestamp;\n}\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n    if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n        return {\n            domainLookupStartTime: defaultStartTime,\n            domainLookupEndTime: defaultStartTime,\n            connectionStartTime: defaultStartTime,\n            connectionEndTime: defaultStartTime,\n            secureConnectionStartTime: defaultStartTime,\n            ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n        };\n    }\n    return {\n        domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n        domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n        connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n        connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n        secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n        ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n    };\n}\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n    return coarsenTime(performance.now(), crossOriginIsolatedCapability);\n}\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n    return {\n        startTime: timingInfo.startTime ?? 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: timingInfo.startTime ?? 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n    // Note: the fetch spec doesn't make use of embedder policy or CSP list\n    return {\n        referrerPolicy: 'strict-origin-when-cross-origin'\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer(policyContainer) {\n    return {\n        referrerPolicy: policyContainer.referrerPolicy\n    };\n}\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n    // 1. Let policy be request's referrer policy.\n    const policy = request.referrerPolicy;\n    // Note: policy cannot (shouldn't) be null or an empty string.\n    assert(policy);\n    // 2. Let environment be request’s client.\n    let referrerSource = null;\n    // 3. Switch on request’s referrer:\n    if (request.referrer === 'client') {\n        // Note: node isn't a browser and doesn't implement document/iframes,\n        // so we bypass this step and replace it with our own.\n        const globalOrigin = getGlobalOrigin();\n        if (!globalOrigin || globalOrigin.origin === 'null') {\n            return 'no-referrer';\n        }\n        // note: we need to clone it as it's mutated\n        referrerSource = new URL(globalOrigin);\n    } else if (request.referrer instanceof URL) {\n        // Let referrerSource be request’s referrer.\n        referrerSource = request.referrer;\n    }\n    // 4. Let request’s referrerURL be the result of stripping referrerSource for\n    //    use as a referrer.\n    let referrerURL = stripURLForReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n    //    a referrer, with the origin-only flag set to true.\n    const referrerOrigin = stripURLForReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is\n    //    greater than 4096, set referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n    }\n    const areSameOrigin = sameOrigin(request, referrerURL);\n    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n    // 8. Execute the switch statements corresponding to the value of policy:\n    switch(policy){\n        case 'origin':\n            return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n        case 'unsafe-url':\n            return referrerURL;\n        case 'same-origin':\n            return areSameOrigin ? referrerOrigin : 'no-referrer';\n        case 'origin-when-cross-origin':\n            return areSameOrigin ? referrerURL : referrerOrigin;\n        case 'strict-origin-when-cross-origin':\n            {\n                const currentURL = requestCurrentURL(request);\n                // 1. If the origin of referrerURL and the origin of request’s current\n                //    URL are the same, then return referrerURL.\n                if (sameOrigin(referrerURL, currentURL)) {\n                    return referrerURL;\n                }\n                // 2. If referrerURL is a potentially trustworthy URL and request’s\n                //    current URL is not a potentially trustworthy URL, then return no\n                //    referrer.\n                if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n                    return 'no-referrer';\n                }\n                // 3. Return referrerOrigin.\n                return referrerOrigin;\n            }\n        case 'strict-origin':\n        /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */ case 'no-referrer-when-downgrade':\n        /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */ default:\n            return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */ function stripURLForReferrer(url, originOnly) {\n    // 1. Assert: url is a URL.\n    assert(url instanceof URL);\n    url = new URL(url);\n    // 2. If url’s scheme is a local scheme, then return no referrer.\n    if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n        return 'no-referrer';\n    }\n    // 3. Set url’s username to the empty string.\n    url.username = '';\n    // 4. Set url’s password to the empty string.\n    url.password = '';\n    // 5. Set url’s fragment to null.\n    url.hash = '';\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 1. Set url’s path to « the empty string ».\n        url.pathname = '';\n        // 2. Set url’s query to null.\n        url.search = '';\n    }\n    // 7. Return url.\n    return url;\n}\nfunction isURLPotentiallyTrustworthy(url) {\n    if (!(url instanceof URL)) {\n        return false;\n    }\n    // If child of about, return true\n    if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n        return true;\n    }\n    // If scheme is data, return true\n    if (url.protocol === 'data:') return true;\n    // If file, return true\n    if (url.protocol === 'file:') return true;\n    return isOriginPotentiallyTrustworthy(url.origin);\n    function isOriginPotentiallyTrustworthy(origin) {\n        // If origin is explicitly null, return false\n        if (origin == null || origin === 'null') return false;\n        const originAsURL = new URL(origin);\n        // If secure, return true\n        if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n            return true;\n        }\n        // If localhost or variants, return true\n        if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) {\n            return true;\n        }\n        // If any other, return false\n        return false;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */ function bytesMatch(bytes, metadataList) {\n    // If node is not built with OpenSSL support, we cannot check\n    // a request's integrity, so allow it by default (the spec will\n    // allow requests if an invalid hash is given, as precedence).\n    /* istanbul ignore if: only if node is built with --without-ssl */ if (crypto === undefined) {\n        return true;\n    }\n    // 1. Let parsedMetadata be the result of parsing metadataList.\n    const parsedMetadata = parseMetadata(metadataList);\n    // 2. If parsedMetadata is no metadata, return true.\n    if (parsedMetadata === 'no metadata') {\n        return true;\n    }\n    // 3. If response is not eligible for integrity validation, return false.\n    // TODO\n    // 4. If parsedMetadata is the empty set, return true.\n    if (parsedMetadata.length === 0) {\n        return true;\n    }\n    // 5. Let metadata be the result of getting the strongest\n    //    metadata from parsedMetadata.\n    const strongest = getStrongestMetadata(parsedMetadata);\n    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);\n    // 6. For each item in metadata:\n    for (const item of metadata){\n        // 1. Let algorithm be the alg component of item.\n        const algorithm = item.algo;\n        // 2. Let expectedValue be the val component of item.\n        const expectedValue = item.hash;\n        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n        // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n        // 3. Let actualValue be the result of applying algorithm to bytes.\n        let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');\n        if (actualValue[actualValue.length - 1] === '=') {\n            if (actualValue[actualValue.length - 2] === '=') {\n                actualValue = actualValue.slice(0, -2);\n            } else {\n                actualValue = actualValue.slice(0, -1);\n            }\n        }\n        // 4. If actualValue is a case-sensitive match for expectedValue,\n        //    return true.\n        if (compareBase64Mixed(actualValue, expectedValue)) {\n            return true;\n        }\n    }\n    // 7. Return false.\n    return false;\n}\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i;\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */ function parseMetadata(metadata) {\n    // 1. Let result be the empty set.\n    /** @type {{ algo: string, hash: string }[]} */ const result = [];\n    // 2. Let empty be equal to true.\n    let empty = true;\n    // 3. For each token returned by splitting metadata on spaces:\n    for (const token of metadata.split(' ')){\n        // 1. Set empty to false.\n        empty = false;\n        // 2. Parse token as a hash-with-options.\n        const parsedToken = parseHashWithOptions.exec(token);\n        // 3. If token does not parse, continue to the next token.\n        if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) {\n            continue;\n        }\n        // 4. Let algorithm be the hash-algo component of token.\n        const algorithm = parsedToken.groups.algo.toLowerCase();\n        // 5. If algorithm is a hash function recognized by the user\n        //    agent, add the parsed token to result.\n        if (supportedHashes.includes(algorithm)) {\n            result.push(parsedToken.groups);\n        }\n    }\n    // 4. Return no metadata if empty is true, otherwise return result.\n    if (empty === true) {\n        return 'no metadata';\n    }\n    return result;\n}\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */ function getStrongestMetadata(metadataList) {\n    // Let algorithm be the algo component of the first item in metadataList.\n    // Can be sha256\n    let algorithm = metadataList[0].algo;\n    // If the algorithm is sha512, then it is the strongest\n    // and we can return immediately\n    if (algorithm[3] === '5') {\n        return algorithm;\n    }\n    for(let i = 1; i < metadataList.length; ++i){\n        const metadata = metadataList[i];\n        // If the algorithm is sha512, then it is the strongest\n        // and we can break the loop immediately\n        if (metadata.algo[3] === '5') {\n            algorithm = 'sha512';\n            break;\n        // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n        } else if (algorithm[3] === '3') {\n            continue;\n        // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n        // the strongest\n        } else if (metadata.algo[3] === '3') {\n            algorithm = 'sha384';\n        }\n    }\n    return algorithm;\n}\nfunction filterMetadataListByAlgorithm(metadataList, algorithm) {\n    if (metadataList.length === 1) {\n        return metadataList;\n    }\n    let pos = 0;\n    for(let i = 0; i < metadataList.length; ++i){\n        if (metadataList[i].algo === algorithm) {\n            metadataList[pos++] = metadataList[i];\n        }\n    }\n    metadataList.length = pos;\n    return metadataList;\n}\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */ function compareBase64Mixed(actualValue, expectedValue) {\n    if (actualValue.length !== expectedValue.length) {\n        return false;\n    }\n    for(let i = 0; i < actualValue.length; ++i){\n        if (actualValue[i] !== expectedValue[i]) {\n            if (actualValue[i] === '+' && expectedValue[i] === '-' || actualValue[i] === '/' && expectedValue[i] === '_') {\n                continue;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n// TODO\n}\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */ function sameOrigin(A, B) {\n    // 1. If A and B are the same opaque origin, then return true.\n    if (A.origin === B.origin && A.origin === 'null') {\n        return true;\n    }\n    // 2. If A and B are both tuple origins and their schemes,\n    //    hosts, and port are identical, then return true.\n    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n        return true;\n    }\n    // 3. Return false.\n    return false;\n}\nfunction createDeferredPromise() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    return {\n        promise,\n        resolve: res,\n        reject: rej\n    };\n}\nfunction isAborted(fetchParams) {\n    return fetchParams.controller.state === 'aborted';\n}\nfunction isCancelled(fetchParams) {\n    return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */ function normalizeMethod(method) {\n    return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;\n}\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n    // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n    const result = JSON.stringify(value);\n    // 2. If result is undefined, then throw a TypeError.\n    if (result === undefined) {\n        throw new TypeError('Value is not JSON serializable');\n    }\n    // 3. Assert: result is a string.\n    assert(typeof result === 'string');\n    // 4. Return result.\n    return result;\n}\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */ function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n    class FastIterableIterator {\n        /** @type {any} */ #target;\n        /** @type {'key' | 'value' | 'key+value'} */ #kind;\n        /** @type {number} */ #index;\n        /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */ constructor(target, kind){\n            this.#target = target;\n            this.#kind = kind;\n            this.#index = 0;\n        }\n        next() {\n            // 1. Let interface be the interface for which the iterator prototype object exists.\n            // 2. Let thisValue be the this value.\n            // 3. Let object be ? ToObject(thisValue).\n            // 4. If object is a platform object, then perform a security\n            //    check, passing:\n            // 5. If object is not a default iterator object for interface,\n            //    then throw a TypeError.\n            if (typeof this !== 'object' || this === null || !(#target in this)) {\n                throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n            }\n            // 6. Let index be object’s index.\n            // 7. Let kind be object’s kind.\n            // 8. Let values be object’s target's value pairs to iterate over.\n            const index = this.#index;\n            const values = this.#target[kInternalIterator];\n            // 9. Let len be the length of values.\n            const len = values.length;\n            // 10. If index is greater than or equal to len, then return\n            //     CreateIterResultObject(undefined, true).\n            if (index >= len) {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            // 11. Let pair be the entry in values at index index.\n            const { [keyIndex]: key, [valueIndex]: value } = values[index];\n            // 12. Set object’s index to index + 1.\n            this.#index = index + 1;\n            // 13. Return the iterator result for pair and kind.\n            // https://webidl.spec.whatwg.org/#iterator-result\n            // 1. Let result be a value determined by the value of kind:\n            let result;\n            switch(this.#kind){\n                case 'key':\n                    // 1. Let idlKey be pair’s key.\n                    // 2. Let key be the result of converting idlKey to an\n                    //    ECMAScript value.\n                    // 3. result is key.\n                    result = key;\n                    break;\n                case 'value':\n                    // 1. Let idlValue be pair’s value.\n                    // 2. Let value be the result of converting idlValue to\n                    //    an ECMAScript value.\n                    // 3. result is value.\n                    result = value;\n                    break;\n                case 'key+value':\n                    // 1. Let idlKey be pair’s key.\n                    // 2. Let idlValue be pair’s value.\n                    // 3. Let key be the result of converting idlKey to an\n                    //    ECMAScript value.\n                    // 4. Let value be the result of converting idlValue to\n                    //    an ECMAScript value.\n                    // 5. Let array be ! ArrayCreate(2).\n                    // 6. Call ! CreateDataProperty(array, \"0\", key).\n                    // 7. Call ! CreateDataProperty(array, \"1\", value).\n                    // 8. result is array.\n                    result = [\n                        key,\n                        value\n                    ];\n                    break;\n            }\n            // 2. Return CreateIterResultObject(result, false).\n            return {\n                value: result,\n                done: false\n            };\n        }\n    }\n    // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n    // @ts-ignore\n    delete FastIterableIterator.prototype.constructor;\n    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);\n    Object.defineProperties(FastIterableIterator.prototype, {\n        [Symbol.toStringTag]: {\n            writable: false,\n            enumerable: false,\n            configurable: true,\n            value: `${name} Iterator`\n        },\n        next: {\n            writable: true,\n            enumerable: true,\n            configurable: true\n        }\n    });\n    /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */ return function(target, kind) {\n        return new FastIterableIterator(target, kind);\n    };\n}\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */ function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);\n    const properties = {\n        keys: {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: function keys() {\n                webidl.brandCheck(this, object);\n                return makeIterator(this, 'key');\n            }\n        },\n        values: {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: function values() {\n                webidl.brandCheck(this, object);\n                return makeIterator(this, 'value');\n            }\n        },\n        entries: {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: function entries() {\n                webidl.brandCheck(this, object);\n                return makeIterator(this, 'key+value');\n            }\n        },\n        forEach: {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: function forEach(callbackfn, thisArg = globalThis) {\n                webidl.brandCheck(this, object);\n                webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);\n                if (typeof callbackfn !== 'function') {\n                    throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);\n                }\n                for (const { 0: key, 1: value } of makeIterator(this, 'key+value')){\n                    callbackfn.call(thisArg, value, key, this);\n                }\n            }\n        }\n    };\n    return Object.defineProperties(object.prototype, {\n        ...properties,\n        [Symbol.iterator]: {\n            writable: true,\n            enumerable: false,\n            configurable: true,\n            value: properties.entries.value\n        }\n    });\n}\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */ async function fullyReadBody(body, processBody, processBodyError) {\n    // 1. If taskDestination is null, then set taskDestination to\n    //    the result of starting a new parallel queue.\n    // 2. Let successSteps given a byte sequence bytes be to queue a\n    //    fetch task to run processBody given bytes, with taskDestination.\n    const successSteps = processBody;\n    // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n    //    with taskDestination.\n    const errorSteps = processBodyError;\n    // 4. Let reader be the result of getting a reader for body’s stream.\n    //    If that threw an exception, then run errorSteps with that\n    //    exception and return.\n    let reader;\n    try {\n        reader = body.stream.getReader();\n    } catch (e) {\n        errorSteps(e);\n        return;\n    }\n    // 5. Read all bytes from reader, given successSteps and errorSteps.\n    try {\n        successSteps(await readAllBytes(reader));\n    } catch (e) {\n        errorSteps(e);\n    }\n}\nfunction isReadableStreamLike(stream) {\n    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === 'ReadableStream' && typeof stream.tee === 'function';\n}\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */ function readableStreamClose(controller) {\n    try {\n        controller.close();\n        controller.byobRequest?.respond(0);\n    } catch (err) {\n        // TODO: add comment explaining why this error occurs.\n        if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n            throw err;\n        }\n    }\n}\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/ // eslint-disable-line\n;\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */ function isomorphicEncode(input) {\n    // 1. Assert: input contains no code points greater than U+00FF.\n    assert(!invalidIsomorphicEncodeValueRegex.test(input));\n    // 2. Return a byte sequence whose length is equal to input’s code\n    //    point length and whose bytes have the same values as the\n    //    values of input’s code points, in the same order\n    return input;\n}\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */ async function readAllBytes(reader) {\n    const bytes = [];\n    let byteLength = 0;\n    while(true){\n        const { done, value: chunk } = await reader.read();\n        if (done) {\n            // 1. Call successSteps with bytes.\n            return Buffer.concat(bytes, byteLength);\n        }\n        // 1. If chunk is not a Uint8Array object, call failureSteps\n        //    with a TypeError and abort these steps.\n        if (!isUint8Array(chunk)) {\n            throw new TypeError('Received non-Uint8Array chunk');\n        }\n        // 2. Append the bytes represented by chunk to bytes.\n        bytes.push(chunk);\n        byteLength += chunk.length;\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */ function urlIsLocal(url) {\n    assert('protocol' in url); // ensure it's a url object\n    const protocol = url.protocol;\n    return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:';\n}\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */ function urlHasHttpsScheme(url) {\n    return typeof url === 'string' && url[5] === ':' && url[0] === 'h' && url[1] === 't' && url[2] === 't' && url[3] === 'p' && url[4] === 's' || url.protocol === 'https:';\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */ function urlIsHttpHttpsScheme(url) {\n    assert('protocol' in url); // ensure it's a url object\n    const protocol = url.protocol;\n    return protocol === 'http:' || protocol === 'https:';\n}\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n */ function simpleRangeHeaderValue(value, allowWhitespace) {\n    // 1. Let data be the isomorphic decoding of value.\n    // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n    // nothing more. We obviously don't need to do that if value is a string already.\n    const data = value;\n    // 2. If data does not start with \"bytes\", then return failure.\n    if (!data.startsWith('bytes')) {\n        return 'failure';\n    }\n    // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n    const position = {\n        position: 5\n    };\n    // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n    //    from data given position.\n    if (allowWhitespace) {\n        collectASequenceOfCodePoints((char)=>char === '\\t' || char === ' ', data, position);\n    }\n    // 5. If the code point at position within data is not U+003D (=), then return failure.\n    if (data.charCodeAt(position.position) !== 0x3D) {\n        return 'failure';\n    }\n    // 6. Advance position by 1.\n    position.position++;\n    // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n    //    data given position.\n    if (allowWhitespace) {\n        collectASequenceOfCodePoints((char)=>char === '\\t' || char === ' ', data, position);\n    }\n    // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n    //    from data given position.\n    const rangeStart = collectASequenceOfCodePoints((char)=>{\n        const code = char.charCodeAt(0);\n        return code >= 0x30 && code <= 0x39;\n    }, data, position);\n    // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n    //    empty string; otherwise null.\n    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;\n    // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n    //     from data given position.\n    if (allowWhitespace) {\n        collectASequenceOfCodePoints((char)=>char === '\\t' || char === ' ', data, position);\n    }\n    // 11. If the code point at position within data is not U+002D (-), then return failure.\n    if (data.charCodeAt(position.position) !== 0x2D) {\n        return 'failure';\n    }\n    // 12. Advance position by 1.\n    position.position++;\n    // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n    //     or space, from data given position.\n    // Note from Khafra: its the same step as in #8 again lol\n    if (allowWhitespace) {\n        collectASequenceOfCodePoints((char)=>char === '\\t' || char === ' ', data, position);\n    }\n    // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n    //     ASCII digits, from data given position.\n    // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n    const rangeEnd = collectASequenceOfCodePoints((char)=>{\n        const code = char.charCodeAt(0);\n        return code >= 0x30 && code <= 0x39;\n    }, data, position);\n    // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n    //     is not the empty string; otherwise null.\n    // Note from Khafra: THE SAME STEP, AGAIN!!!\n    // Note: why interpret as a decimal if we only collect ascii digits?\n    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;\n    // 16. If position is not past the end of data, then return failure.\n    if (position.position < data.length) {\n        return 'failure';\n    }\n    // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n    if (rangeEndValue === null && rangeStartValue === null) {\n        return 'failure';\n    }\n    // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n    //     greater than rangeEndValue, then return failure.\n    // Note: ... when can they not be numbers?\n    if (rangeStartValue > rangeEndValue) {\n        return 'failure';\n    }\n    // 19. Return (rangeStartValue, rangeEndValue).\n    return {\n        rangeStartValue,\n        rangeEndValue\n    };\n}\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */ function buildContentRange(rangeStart, rangeEnd, fullLength) {\n    // 1. Let contentRange be `bytes `.\n    let contentRange = 'bytes ';\n    // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n    contentRange += isomorphicEncode(`${rangeStart}`);\n    // 3. Append 0x2D (-) to contentRange.\n    contentRange += '-';\n    // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n    contentRange += isomorphicEncode(`${rangeEnd}`);\n    // 5. Append 0x2F (/) to contentRange.\n    contentRange += '/';\n    // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n    contentRange += isomorphicEncode(`${fullLength}`);\n    // 7. Return contentRange.\n    return contentRange;\n}\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n    _transform(chunk, encoding, callback) {\n        if (!this._inflateStream) {\n            if (chunk.length === 0) {\n                callback();\n                return;\n            }\n            this._inflateStream = (chunk[0] & 0x0F) === 0x08 ? zlib.createInflate() : zlib.createInflateRaw();\n            this._inflateStream.on('data', this.push.bind(this));\n            this._inflateStream.on('end', ()=>this.push(null));\n            this._inflateStream.on('error', (err)=>this.destroy(err));\n        }\n        this._inflateStream.write(chunk, encoding, callback);\n    }\n    _final(callback) {\n        if (this._inflateStream) {\n            this._inflateStream.end();\n            this._inflateStream = null;\n        }\n        callback();\n    }\n}\nfunction createInflate() {\n    return new InflateStream();\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */ function extractMimeType(headers) {\n    // 1. Let charset be null.\n    let charset = null;\n    // 2. Let essence be null.\n    let essence = null;\n    // 3. Let mimeType be null.\n    let mimeType = null;\n    // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n    const values = getDecodeSplit('content-type', headers);\n    // 5. If values is null, then return failure.\n    if (values === null) {\n        return 'failure';\n    }\n    // 6. For each value of values:\n    for (const value of values){\n        // 6.1. Let temporaryMimeType be the result of parsing value.\n        const temporaryMimeType = parseMIMEType(value);\n        // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n        if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n            continue;\n        }\n        // 6.3. Set mimeType to temporaryMimeType.\n        mimeType = temporaryMimeType;\n        // 6.4. If mimeType’s essence is not essence, then:\n        if (mimeType.essence !== essence) {\n            // 6.4.1. Set charset to null.\n            charset = null;\n            // 6.4.2. If mimeType’s parameters[\"charset\"] exists, then set charset to\n            //        mimeType’s parameters[\"charset\"].\n            if (mimeType.parameters.has('charset')) {\n                charset = mimeType.parameters.get('charset');\n            }\n            // 6.4.3. Set essence to mimeType’s essence.\n            essence = mimeType.essence;\n        } else if (!mimeType.parameters.has('charset') && charset !== null) {\n            // 6.5. Otherwise, if mimeType’s parameters[\"charset\"] does not exist, and\n            //      charset is non-null, set mimeType’s parameters[\"charset\"] to charset.\n            mimeType.parameters.set('charset', charset);\n        }\n    }\n    // 7. If mimeType is null, then return failure.\n    if (mimeType == null) {\n        return 'failure';\n    }\n    // 8. Return mimeType.\n    return mimeType;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */ function gettingDecodingSplitting(value) {\n    // 1. Let input be the result of isomorphic decoding value.\n    const input = value;\n    // 2. Let position be a position variable for input, initially pointing at the start of input.\n    const position = {\n        position: 0\n    };\n    // 3. Let values be a list of strings, initially empty.\n    const values = [];\n    // 4. Let temporaryValue be the empty string.\n    let temporaryValue = '';\n    // 5. While position is not past the end of input:\n    while(position.position < input.length){\n        // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n        //      or U+002C (,) from input, given position, to temporaryValue.\n        temporaryValue += collectASequenceOfCodePoints((char)=>char !== '\"' && char !== ',', input, position);\n        // 5.2. If position is not past the end of input, then:\n        if (position.position < input.length) {\n            // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n            if (input.charCodeAt(position.position) === 0x22) {\n                // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n                temporaryValue += collectAnHTTPQuotedString(input, position);\n                // 5.2.1.2. If position is not past the end of input, then continue.\n                if (position.position < input.length) {\n                    continue;\n                }\n            } else {\n                // 5.2.2. Otherwise:\n                // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n                assert(input.charCodeAt(position.position) === 0x2C);\n                // 5.2.2.2. Advance position by 1.\n                position.position++;\n            }\n        }\n        // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n        temporaryValue = removeChars(temporaryValue, true, true, (char)=>char === 0x9 || char === 0x20);\n        // 5.4. Append temporaryValue to values.\n        values.push(temporaryValue);\n        // 5.6. Set temporaryValue to the empty string.\n        temporaryValue = '';\n    }\n    // 6. Return values.\n    return values;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */ function getDecodeSplit(name, list) {\n    // 1. Let value be the result of getting name from list.\n    const value = list.get(name, true);\n    // 2. If value is null, then return null.\n    if (value === null) {\n        return null;\n    }\n    // 3. Return the result of getting, decoding, and splitting value.\n    return gettingDecodingSplitting(value);\n}\nconst textDecoder = new TextDecoder();\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */ function utf8DecodeBytes(buffer) {\n    if (buffer.length === 0) {\n        return '';\n    }\n    // 1. Let buffer be the result of peeking three bytes from\n    //    ioQueue, converted to a byte sequence.\n    // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n    //    bytes from ioQueue. (Do nothing with those bytes.)\n    if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n        buffer = buffer.subarray(3);\n    }\n    // 3. Process a queue with an instance of UTF-8’s\n    //    decoder, ioQueue, output, and \"replacement\".\n    const output = textDecoder.decode(buffer);\n    // 4. Return output.\n    return output;\n}\nclass EnvironmentSettingsObjectBase {\n    get baseUrl() {\n        return getGlobalOrigin();\n    }\n    get origin() {\n        return this.baseUrl?.origin;\n    }\n    constructor(){\n        this.policyContainer = makePolicyContainer();\n    }\n}\nclass EnvironmentSettingsObject {\n    constructor(){\n        this.settingsObject = new EnvironmentSettingsObjectBase();\n    }\n}\nconst environmentSettingsObject = new EnvironmentSettingsObject();\nmodule.exports = {\n    isAborted,\n    isCancelled,\n    isValidEncodedURL,\n    createDeferredPromise,\n    ReadableStreamFrom,\n    tryUpgradeRequestToAPotentiallyTrustworthyURL,\n    clampAndCoarsenConnectionTimingInfo,\n    coarsenedSharedCurrentTime,\n    determineRequestsReferrer,\n    makePolicyContainer,\n    clonePolicyContainer,\n    appendFetchMetadata,\n    appendRequestOriginHeader,\n    TAOCheck,\n    corsCheck,\n    crossOriginResourcePolicyCheck,\n    createOpaqueTimingInfo,\n    setRequestReferrerPolicyOnRedirect,\n    isValidHTTPToken,\n    requestBadPort,\n    requestCurrentURL,\n    responseURL,\n    responseLocationURL,\n    isBlobLike,\n    isURLPotentiallyTrustworthy,\n    isValidReasonPhrase,\n    sameOrigin,\n    normalizeMethod,\n    serializeJavascriptValueToJSONString,\n    iteratorMixin,\n    createIterator,\n    isValidHeaderName,\n    isValidHeaderValue,\n    isErrorLike,\n    fullyReadBody,\n    bytesMatch,\n    isReadableStreamLike,\n    readableStreamClose,\n    isomorphicEncode,\n    urlIsLocal,\n    urlHasHttpsScheme,\n    urlIsHttpHttpsScheme,\n    readAllBytes,\n    simpleRangeHeaderValue,\n    buildContentRange,\n    parseMetadata,\n    createInflate,\n    extractMimeType,\n    getDecodeSplit,\n    utf8DecodeBytes,\n    environmentSettingsObject\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQzNDLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDLDRCQUFXO0FBQ2hDLE1BQU0sRUFBRUUsaUJBQWlCLEVBQUVDLG1CQUFtQkMsb0JBQW9CLEVBQUVDLFdBQVcsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQywyRUFBYTtBQUN6RyxNQUFNLEVBQUVNLGVBQWUsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQyxxRUFBVTtBQUM5QyxNQUFNLEVBQUVPLDRCQUE0QixFQUFFQyx5QkFBeUIsRUFBRUMsV0FBVyxFQUFFQyxhQUFhLEVBQUUsR0FBR1YsbUJBQU9BLENBQUMseUVBQVk7QUFDcEgsTUFBTSxFQUFFVyxXQUFXLEVBQUUsR0FBR1gsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2pELE1BQU0sRUFBRVksVUFBVSxFQUFFQyxrQkFBa0IsRUFBRUMsZ0JBQWdCLEVBQUVDLDJCQUEyQixFQUFFLEdBQUdmLG1CQUFPQSxDQUFDLHFFQUFpQjtBQUNuSCxNQUFNZ0IsU0FBU2hCLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3BDLE1BQU0sRUFBRWlCLFlBQVksRUFBRSxHQUFHakIsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2xELE1BQU0sRUFBRWtCLE1BQU0sRUFBRSxHQUFHbEIsbUJBQU9BLENBQUMscUVBQVU7QUFFckMsSUFBSW1CLGtCQUFrQixFQUFFO0FBRXhCLGtGQUFrRjtBQUNsRiw2QkFBNkIsR0FDN0IsSUFBSUM7QUFDSixJQUFJO0lBQ0ZBLFNBQVNwQixtQkFBT0EsQ0FBQyxnQ0FBYTtJQUM5QixNQUFNcUIseUJBQXlCO1FBQUM7UUFBVTtRQUFVO0tBQVM7SUFDN0RGLGtCQUFrQkMsT0FBT0UsU0FBUyxHQUFHQyxNQUFNLENBQUMsQ0FBQ0MsT0FBU0gsdUJBQXVCSSxRQUFRLENB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Q2pELGtEQUFrRDtJQUNsRCxNQUFNQyxTQUFTTCxZQUFZTSxNQUFNLENBQUNIO0lBRWxDLG9CQUFvQjtJQUNwQixPQUFPRTtBQUNUO0FBRUEsTUFBTUU7SUFDSixJQUFJQyxVQUFXO1FBQ2IsT0FBT3ZTO0lBQ1Q7SUFFQSxJQUFJMkUsU0FBVTtRQUNaLE9BQU8sSUFBSSxDQUFDNE4sT0FBTyxFQUFFNU47SUFDdkI7O2FBRUFvQyxrQkFBa0JGOztBQUNwQjtBQUVBLE1BQU0yTDs7YUFDSkMsaUJBQWlCLElBQUlIOztBQUN2QjtBQUVBLE1BQU1JLDRCQUE0QixJQUFJRjtBQUV0Q0csT0FBT0MsT0FBTyxHQUFHO0lBQ2YvSDtJQUNBSTtJQUNBaEo7SUFDQXFJO0lBQ0EvSjtJQUNBNEo7SUFDQTlFO0lBQ0FVO0lBQ0FpQjtJQUNBSDtJQUNBQztJQUNBMUM7SUFDQUs7SUFDQU47SUFDQUQ7SUFDQUQ7SUFDQWdDO0lBQ0F4QztJQUNBakQ7SUFDQXFDO0lBQ0FGO0lBQ0F2QjtJQUNBSztJQUNBbkI7SUFDQW1IO0lBQ0FyRTtJQUNBNkI7SUFDQWlHO0lBQ0FDO0lBQ0E2QjtJQUNBcEI7SUFDQXJJO0lBQ0F2QjtJQUNBZ0I7SUFDQTZLO0lBQ0F0RjtJQUNBaUc7SUFDQUc7SUFDQU87SUFDQU07SUFDQXhLO0lBQ0FsQztJQUNBeUw7SUFDQWtCO0lBQ0FXO0lBQ0F6SDtJQUNBaUk7SUFDQVE7SUFDQUs7SUFDQVE7SUFDQVM7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ25vZGU6emxpYicpXG5jb25zdCB7IHJlZGlyZWN0U3RhdHVzU2V0LCByZWZlcnJlclBvbGljeVNldDogcmVmZXJyZXJQb2xpY3lUb2tlbnMsIGJhZFBvcnRzU2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzLCBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLCByZW1vdmVDaGFycywgcGFyc2VNSU1FVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSByZXF1aXJlKCdub2RlOnBlcmZfaG9va3MnKVxuY29uc3QgeyBpc0Jsb2JMaWtlLCBSZWFkYWJsZVN0cmVhbUZyb20sIGlzVmFsaWRIVFRQVG9rZW4sIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgaXNVaW50OEFycmF5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwvdHlwZXMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcblxubGV0IHN1cHBvcnRlZEhhc2hlcyA9IFtdXG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjZGV0ZXJtaW5pbmctaWYtY3J5cHRvLXN1cHBvcnQtaXMtdW5hdmFpbGFibGVcbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ25vZGU6Y3J5cHRvJylcbiAgY29uc3QgcG9zc2libGVSZWxldmFudEhhc2hlcyA9IFsnc2hhMjU2JywgJ3NoYTM4NCcsICdzaGE1MTInXVxuICBzdXBwb3J0ZWRIYXNoZXMgPSBjcnlwdG8uZ2V0SGFzaGVzKCkuZmlsdGVyKChoYXNoKSA9PiBwb3NzaWJsZVJlbGV2YW50SGFzaGVzLmluY2x1ZGVzKGhhc2gpKVxuLyogYzggaWdub3JlIG5leHQgMyAqL1xufSBjYXRjaCB7XG5cbn1cblxuZnVuY3Rpb24gcmVzcG9uc2VVUkwgKHJlc3BvbnNlKSB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZXNcbiAgLy8gQSByZXNwb25zZSBoYXMgYW4gYXNzb2NpYXRlZCBVUkwuIEl0IGlzIGEgcG9pbnRlciB0byB0aGUgbGFzdCBVUkxcbiAgLy8gaW4gcmVzcG9uc2XigJlzIFVSTCBsaXN0IGFuZCBudWxsIGlmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eS5cbiAgY29uc3QgdXJsTGlzdCA9IHJlc3BvbnNlLnVybExpc3RcbiAgY29uc3QgbGVuZ3RoID0gdXJsTGlzdC5sZW5ndGhcbiAgcmV0dXJuIGxlbmd0aCA9PT0gMCA/IG51bGwgOiB1cmxMaXN0W2xlbmd0aCAtIDFdLnRvU3RyaW5nKClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtbG9jYXRpb24tdXJsXG5mdW5jdGlvbiByZXNwb25zZUxvY2F0aW9uVVJMIChyZXNwb25zZSwgcmVxdWVzdEZyYWdtZW50KSB7XG4gIC8vIDEuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHJldHVybiBudWxsLlxuICBpZiAoIXJlZGlyZWN0U3RhdHVzU2V0LmhhcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDIuIExldCBsb2NhdGlvbiBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzIGdpdmVuXG4gIC8vIGBMb2NhdGlvbmAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgbGV0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdsb2NhdGlvbicsIHRydWUpXG5cbiAgLy8gMy4gSWYgbG9jYXRpb24gaXMgYSBoZWFkZXIgdmFsdWUsIHRoZW4gc2V0IGxvY2F0aW9uIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgcGFyc2luZyBsb2NhdGlvbiB3aXRoIHJlc3BvbnNl4oCZcyBVUkwuXG4gIGlmIChsb2NhdGlvbiAhPT0gbnVsbCAmJiBpc1ZhbGlkSGVhZGVyVmFsdWUobG9jYXRpb24pKSB7XG4gICAgaWYgKCFpc1ZhbGlkRW5jb2RlZFVSTChsb2NhdGlvbikpIHtcbiAgICAgIC8vIFNvbWUgd2Vic2l0ZXMgcmVzcG9uZCBsb2NhdGlvbiBoZWFkZXIgaW4gVVRGLTggZm9ybSB3aXRob3V0IGVuY29kaW5nIHRoZW0gYXMgQVNDSUlcbiAgICAgIC8vIGFuZCBtYWpvciBicm93c2VycyByZWRpcmVjdCB0aGVtIHRvIGNvcnJlY3RseSBVVEYtOCBlbmNvZGVkIGFkZHJlc3Nlcy5cbiAgICAgIC8vIEhlcmUsIHdlIGhhbmRsZSB0aGF0IGJlaGF2aW9yIGluIHRoZSBzYW1lIHdheS5cbiAgICAgIGxvY2F0aW9uID0gbm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4KGxvY2F0aW9uKVxuICAgIH1cbiAgICBsb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIGxvY2F0aW9uIGlzIGEgVVJMIHdob3NlIGZyYWdtZW50IGlzIG51bGwsIHRoZW4gc2V0IGxvY2F0aW9u4oCZc1xuICAvLyBmcmFnbWVudCB0byByZXF1ZXN0RnJhZ21lbnQuXG4gIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnRcbiAgfVxuXG4gIC8vIDUuIFJldHVybiBsb2NhdGlvbi5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMTczOCNzZWN0aW9uLTIuMlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbmNvZGVkVVJMICh1cmwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmwubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gdXJsLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPiAweDdFIHx8IC8vIE5vbi1VUy1BU0NJSSArIERFTFxuICAgICAgY29kZSA8IDB4MjAgLy8gQ29udHJvbCBjaGFyYWN0ZXJzIE5VTCAtIFVTXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBJZiBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzc3VtZXMgaXQncyBVVEYtOCBlbmNvZGVkIGFuZCBkZWNvZGVzIGl0LlxuICogU2luY2UgVVRGLTggaXMgYSBzdXBlcnNldCBvZiBBU0NJSSwgdGhpcyB3aWxsIHdvcmsgZm9yIEFTQ0lJIHN0cmluZ3MgYXMgd2VsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4ICh2YWx1ZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICdiaW5hcnknKS50b1N0cmluZygndXRmOCcpXG59XG5cbi8qKiBAcmV0dXJucyB7VVJMfSAqL1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHVybCBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhbiBIVFRQKFMpIHNjaGVtZSBhbmQgdXJs4oCZcyBwb3J0IGlzIGEgYmFkIHBvcnQsXG4gIC8vIHRoZW4gcmV0dXJuIGJsb2NrZWQuXG4gIGlmICh1cmxJc0h0dHBIdHRwc1NjaGVtZSh1cmwpICYmIGJhZFBvcnRzU2V0Lmhhcyh1cmwucG9ydCkpIHtcbiAgICByZXR1cm4gJ2Jsb2NrZWQnXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYWxsb3dlZC5cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFcnJvciB8fCAoXG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vycm9yJyB8fFxuICAgIG9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdET01FeGNlcHRpb24nXG4gIClcbn1cblxuLy8gQ2hlY2sgd2hldGhlciB8c3RhdHVzVGV4dHwgaXMgYSBCeXRlU3RyaW5nIGFuZFxuLy8gbWF0Y2hlcyB0aGUgUmVhc29uLVBocmFzZSB0b2tlbiBwcm9kdWN0aW9uLlxuLy8gUkZDIDI2MTY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2XG4vLyBSRkMgNzIzMDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzBcbi8vIFwicmVhc29uLXBocmFzZSA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVwiXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi85NC4wLjQ2MDQuMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2ZldGNoL3Jlc3BvbnNlLmNjI0wxMTZcbmZ1bmN0aW9uIGlzVmFsaWRSZWFzb25QaHJhc2UgKHN0YXR1c1RleHQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0dXNUZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYyA9IHN0YXR1c1RleHQuY2hhckNvZGVBdChpKVxuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIChcbiAgICAgICAgICBjID09PSAweDA5IHx8IC8vIEhUQUJcbiAgICAgICAgICAoYyA+PSAweDIwICYmIGMgPD0gMHg3ZSkgfHwgLy8gU1AgLyBWQ0hBUlxuICAgICAgICAgIChjID49IDB4ODAgJiYgYyA8PSAweGZmKVxuICAgICAgICApIC8vIG9icy10ZXh0XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gaXNWYWxpZEhUVFBUb2tlblxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gLSBIYXMgbm8gbGVhZGluZyBvciB0cmFpbGluZyBIVFRQIHRhYiBvciBzcGFjZSBieXRlcy5cbiAgLy8gLSBDb250YWlucyBubyAweDAwIChOVUwpIG9yIEhUVFAgbmV3bGluZSBieXRlcy5cbiAgcmV0dXJuIChcbiAgICBwb3RlbnRpYWxWYWx1ZVswXSA9PT0gJ1xcdCcgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZVswXSA9PT0gJyAnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbcG90ZW50aWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcXHQnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbcG90ZW50aWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICcgJyB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXG4nKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXHInKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXDAnKVxuICApID09PSBmYWxzZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc2V0LXJlcXVlc3RzLXJlZmVycmVyLXBvbGljeS1vbi1yZWRpcmVjdFxuZnVuY3Rpb24gc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCAocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpIHtcbiAgLy8gIEdpdmVuIGEgcmVxdWVzdCByZXF1ZXN0IGFuZCBhIHJlc3BvbnNlIGFjdHVhbFJlc3BvbnNlLCB0aGlzIGFsZ29yaXRobVxuICAvLyAgdXBkYXRlcyByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgYWNjb3JkaW5nIHRvIHRoZSBSZWZlcnJlci1Qb2xpY3lcbiAgLy8gIGhlYWRlciAoaWYgYW55KSBpbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyAxLiBMZXQgcG9saWN5IGJlIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnIDguMSBQYXJzZSBhIHJlZmVycmVyIHBvbGljeVxuICAvLyBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlciBvbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyA4LjEgUGFyc2UgYSByZWZlcnJlciBwb2xpY3kgZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXJcbiAgLy8gMS4gTGV0IHBvbGljeS10b2tlbnMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlcyBnaXZlbiBgUmVmZXJyZXItUG9saWN5YCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBjb25zdCB7IGhlYWRlcnNMaXN0IH0gPSBhY3R1YWxSZXNwb25zZVxuICAvLyAyLiBMZXQgcG9saWN5IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIGluIHBvbGljeS10b2tlbnMsIGlmIHRva2VuIGlzIGEgcmVmZXJyZXIgcG9saWN5IGFuZCB0b2tlbiBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcG9saWN5IHRvIHRva2VuLlxuICAvLyA0LiBSZXR1cm4gcG9saWN5LlxuICBjb25zdCBwb2xpY3lIZWFkZXIgPSAoaGVhZGVyc0xpc3QuZ2V0KCdyZWZlcnJlci1wb2xpY3knLCB0cnVlKSA/PyAnJykuc3BsaXQoJywnKVxuXG4gIC8vIE5vdGU6IEFzIHRoZSByZWZlcnJlci1wb2xpY3kgY2FuIGNvbnRhaW4gbXVsdGlwbGUgcG9saWNpZXNcbiAgLy8gc2VwYXJhdGVkIGJ5IGNvbW1hLCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlbVxuICAvLyBhbmQgcGljayB0aGUgZmlyc3QgdmFsaWQgb25lLlxuICAvLyBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZWZlcnJlci1Qb2xpY3kjc3BlY2lmeV9hX2ZhbGxiYWNrX3BvbGljeVxuICBsZXQgcG9saWN5ID0gJydcbiAgaWYgKHBvbGljeUhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgLy8gVGhlIHJpZ2h0LW1vc3QgcG9saWN5IHRha2VzIHByZWNlZGVuY2UuXG4gICAgLy8gVGhlIGxlZnQtbW9zdCBwb2xpY3kgaXMgdGhlIGZhbGxiYWNrLlxuICAgIGZvciAobGV0IGkgPSBwb2xpY3lIZWFkZXIubGVuZ3RoOyBpICE9PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gcG9saWN5SGVhZGVyW2kgLSAxXS50cmltKClcbiAgICAgIGlmIChyZWZlcnJlclBvbGljeVRva2Vucy5oYXModG9rZW4pKSB7XG4gICAgICAgIHBvbGljeSA9IHRva2VuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMi4gSWYgcG9saWN5IGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgdG8gcG9saWN5LlxuICBpZiAocG9saWN5ICE9PSAnJykge1xuICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBwb2xpY3lcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY3Jvc3Mtb3JpZ2luLXJlc291cmNlLXBvbGljeS1jaGVja1xuZnVuY3Rpb24gY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ2FsbG93ZWQnXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWNvcnMtY2hlY2tcbmZ1bmN0aW9uIGNvcnNDaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdzdWNjZXNzJ1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC10YW8tY2hlY2tcbmZ1bmN0aW9uIFRBT0NoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ3N1Y2Nlc3MnXG59XG5cbmZ1bmN0aW9uIGFwcGVuZEZldGNoTWV0YWRhdGEgKGh0dHBSZXF1ZXN0KSB7XG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtZGVzdC1oZWFkZXJcbiAgLy8gIFRPRE9cblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLW1vZGUtaGVhZGVyXG5cbiAgLy8gIDEuIEFzc2VydDogcuKAmXMgdXJsIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLlxuICAvLyAgVE9ET1xuXG4gIC8vICAyLiBMZXQgaGVhZGVyIGJlIGEgU3RydWN0dXJlZCBIZWFkZXIgd2hvc2UgdmFsdWUgaXMgYSB0b2tlbi5cbiAgbGV0IGhlYWRlciA9IG51bGxcblxuICAvLyAgMy4gU2V0IGhlYWRlcuKAmXMgdmFsdWUgdG8gcuKAmXMgbW9kZS5cbiAgaGVhZGVyID0gaHR0cFJlcXVlc3QubW9kZVxuXG4gIC8vICA0LiBTZXQgYSBzdHJ1Y3R1cmVkIGZpZWxkIHZhbHVlIGBTZWMtRmV0Y2gtTW9kZWAvaGVhZGVyIGluIHLigJlzIGhlYWRlciBsaXN0LlxuICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5zZXQoJ3NlYy1mZXRjaC1tb2RlJywgaGVhZGVyLCB0cnVlKVxuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtc2l0ZS1oZWFkZXJcbiAgLy8gIFRPRE9cblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLXVzZXItaGVhZGVyXG4gIC8vICBUT0RPXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhcHBlbmQtYS1yZXF1ZXN0LW9yaWdpbi1oZWFkZXJcbmZ1bmN0aW9uIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHNlcmlhbGl6ZWRPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBieXRlLXNlcmlhbGl6aW5nIGEgcmVxdWVzdCBvcmlnaW5cbiAgLy8gICAgd2l0aCByZXF1ZXN0LlxuICAvLyBUT0RPOiBpbXBsZW1lbnQgXCJieXRlLXNlcmlhbGl6aW5nIGEgcmVxdWVzdCBvcmlnaW5cIlxuICBsZXQgc2VyaWFsaXplZE9yaWdpbiA9IHJlcXVlc3Qub3JpZ2luXG5cbiAgLy8gLSBcIidjbGllbnQnIGlzIGNoYW5nZWQgdG8gYW4gb3JpZ2luIGR1cmluZyBmZXRjaGluZy5cIlxuICAvLyAgIFRoaXMgZG9lc24ndCBoYXBwZW4gaW4gdW5kaWNpIChpbiBtb3N0IGNhc2VzKSBiZWNhdXNlIHVuZGljaSwgYnkgZGVmYXVsdCxcbiAgLy8gICBoYXMgbm8gY29uY2VwdCBvZiBvcmlnaW4uXG4gIC8vIC0gcmVxdWVzdC5vcmlnaW4gY2FuIGFsc28gYmUgc2V0IHRvIHJlcXVlc3QuY2xpZW50Lm9yaWdpbiAoY2xpZW50IGJlaW5nXG4gIC8vICAgYW4gZW52aXJvbm1lbnQgc2V0dGluZ3Mgb2JqZWN0KSwgd2hpY2ggaXMgdW5kZWZpbmVkIHdpdGhvdXQgdXNpbmdcbiAgLy8gICBzZXRHbG9iYWxPcmlnaW4uXG4gIGlmIChzZXJpYWxpemVkT3JpZ2luID09PSAnY2xpZW50JyB8fCBzZXJpYWxpemVkT3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIG9yIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJ3ZWJzb2NrZXRcIixcbiAgLy8gICAgdGhlbiBhcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gMy4gT3RoZXJ3aXNlLCBpZiByZXF1ZXN04oCZcyBtZXRob2QgaXMgbmVpdGhlciBgR0VUYCBub3IgYEhFQURgLCB0aGVuOlxuICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgfHwgcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0Jykge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdvcmlnaW4nLCBzZXJpYWxpemVkT3JpZ2luLCB0cnVlKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgLy8gMS4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeTpcbiAgICBzd2l0Y2ggKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kpIHtcbiAgICAgIGNhc2UgJ25vLXJlZmVycmVyJzpcbiAgICAgICAgLy8gU2V0IHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOlxuICAgICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6XG4gICAgICBjYXNlICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcbiAgICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgb3JpZ2luIGlzIGEgdHVwbGUgb3JpZ2luLCBpdHMgc2NoZW1lIGlzIFwiaHR0cHNcIiwgYW5kXG4gICAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgbm90IFwiaHR0cHNcIiwgdGhlbiBzZXRcbiAgICAgICAgLy8gc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm9yaWdpbiAmJiB1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Lm9yaWdpbikgJiYgIXVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NhbWUtb3JpZ2luJzpcbiAgICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZc1xuICAgICAgICAvLyBvcmlnaW4sIHRoZW4gc2V0IHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBpZiAoIXNhbWVPcmlnaW4ocmVxdWVzdCwgcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnb3JpZ2luJywgc2VyaWFsaXplZE9yaWdpbiwgdHJ1ZSlcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vaHItdGltZS8jZGZuLWNvYXJzZW4tdGltZVxuZnVuY3Rpb24gY29hcnNlblRpbWUgKHRpbWVzdGFtcCwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gdGltZXN0YW1wXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjbGFtcC1hbmQtY29hcnNlbi1jb25uZWN0aW9uLXRpbWluZy1pbmZvXG5mdW5jdGlvbiBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyAoY29ubmVjdGlvblRpbWluZ0luZm8sIGRlZmF1bHRTdGFydFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSB7XG4gIGlmICghY29ubmVjdGlvblRpbWluZ0luZm8/LnN0YXJ0VGltZSB8fCBjb25uZWN0aW9uVGltaW5nSW5mby5zdGFydFRpbWUgPCBkZWZhdWx0U3RhcnRUaW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbWFpbkxvb2t1cFN0YXJ0VGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIGRvbWFpbkxvb2t1cEVuZFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBjb25uZWN0aW9uU3RhcnRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgY29ubmVjdGlvbkVuZFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBzZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgQUxQTk5lZ290aWF0ZWRQcm90b2NvbDogY29ubmVjdGlvblRpbWluZ0luZm8/LkFMUE5OZWdvdGlhdGVkUHJvdG9jb2xcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRvbWFpbkxvb2t1cFN0YXJ0VGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uZG9tYWluTG9va3VwU3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgZG9tYWluTG9va3VwRW5kVGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uZG9tYWluTG9va3VwRW5kVGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIGNvbm5lY3Rpb25TdGFydFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmNvbm5lY3Rpb25TdGFydFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBjb25uZWN0aW9uRW5kVGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uY29ubmVjdGlvbkVuZFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBzZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lOiBjb2Fyc2VuVGltZShjb25uZWN0aW9uVGltaW5nSW5mby5zZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgQUxQTk5lZ290aWF0ZWRQcm90b2NvbDogY29ubmVjdGlvblRpbWluZ0luZm8uQUxQTk5lZ290aWF0ZWRQcm90b2NvbFxuICB9XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9oci10aW1lLyNkZm4tY29hcnNlbmVkLXNoYXJlZC1jdXJyZW50LXRpbWVcbmZ1bmN0aW9uIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lIChjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSkge1xuICByZXR1cm4gY29hcnNlblRpbWUocGVyZm9ybWFuY2Uubm93KCksIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY3JlYXRlLWFuLW9wYXF1ZS10aW1pbmctaW5mb1xuZnVuY3Rpb24gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyAodGltaW5nSW5mbykge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICByZWRpcmVjdFN0YXJ0VGltZTogMCxcbiAgICByZWRpcmVjdEVuZFRpbWU6IDAsXG4gICAgcG9zdFJlZGlyZWN0U3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZSA/PyAwLFxuICAgIGZpbmFsU2VydmljZVdvcmtlclN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lOiAwLFxuICAgIGVuZFRpbWU6IDAsXG4gICAgZW5jb2RlZEJvZHlTaXplOiAwLFxuICAgIGRlY29kZWRCb2R5U2l6ZTogMCxcbiAgICBmaW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvOiBudWxsXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvb3JpZ2luLmh0bWwjcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gbWFrZVBvbGljeUNvbnRhaW5lciAoKSB7XG4gIC8vIE5vdGU6IHRoZSBmZXRjaCBzcGVjIGRvZXNuJ3QgbWFrZSB1c2Ugb2YgZW1iZWRkZXIgcG9saWN5IG9yIENTUCBsaXN0XG4gIHJldHVybiB7XG4gICAgcmVmZXJyZXJQb2xpY3k6ICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJ1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI2Nsb25lLWEtcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gY2xvbmVQb2xpY3lDb250YWluZXIgKHBvbGljeUNvbnRhaW5lcikge1xuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiBwb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3lcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyXG5mdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBwb2xpY3kgYmUgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeS5cbiAgY29uc3QgcG9saWN5ID0gcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuXG4gIC8vIE5vdGU6IHBvbGljeSBjYW5ub3QgKHNob3VsZG4ndCkgYmUgbnVsbCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gIGFzc2VydChwb2xpY3kpXG5cbiAgLy8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3TigJlzIGNsaWVudC5cblxuICBsZXQgcmVmZXJyZXJTb3VyY2UgPSBudWxsXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyOlxuICBpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyBOb3RlOiBub2RlIGlzbid0IGEgYnJvd3NlciBhbmQgZG9lc24ndCBpbXBsZW1lbnQgZG9jdW1lbnQvaWZyYW1lcyxcbiAgICAvLyBzbyB3ZSBieXBhc3MgdGhpcyBzdGVwIGFuZCByZXBsYWNlIGl0IHdpdGggb3VyIG93bi5cblxuICAgIGNvbnN0IGdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpbigpXG5cbiAgICBpZiAoIWdsb2JhbE9yaWdpbiB8fCBnbG9iYWxPcmlnaW4ub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gbm90ZTogd2UgbmVlZCB0byBjbG9uZSBpdCBhcyBpdCdzIG11dGF0ZWRcbiAgICByZWZlcnJlclNvdXJjZSA9IG5ldyBVUkwoZ2xvYmFsT3JpZ2luKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAvLyBMZXQgcmVmZXJyZXJTb3VyY2UgYmUgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gICAgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyXG4gIH1cblxuICAvLyA0LiBMZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yXG4gIC8vICAgIHVzZSBhcyBhIHJlZmVycmVyLlxuICBsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclJlZmVycmVyKHJlZmVycmVyU291cmNlKVxuXG4gIC8vIDUuIExldCByZWZlcnJlck9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIHN0cmlwcGluZyByZWZlcnJlclNvdXJjZSBmb3IgdXNlIGFzXG4gIC8vICAgIGEgcmVmZXJyZXIsIHdpdGggdGhlIG9yaWdpbi1vbmx5IGZsYWcgc2V0IHRvIHRydWUuXG4gIGNvbnN0IHJlZmVycmVyT3JpZ2luID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcblxuICAvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpc1xuICAvLyAgICBncmVhdGVyIHRoYW4gNDA5Niwgc2V0IHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuICBpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG4gICAgcmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpblxuICB9XG5cbiAgY29uc3QgYXJlU2FtZU9yaWdpbiA9IHNhbWVPcmlnaW4ocmVxdWVzdCwgcmVmZXJyZXJVUkwpXG4gIGNvbnN0IGlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSA9IGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiZcbiAgICAhaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlcXVlc3QudXJsKVxuXG4gIC8vIDguIEV4ZWN1dGUgdGhlIHN3aXRjaCBzdGF0ZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbHVlIG9mIHBvbGljeTpcbiAgc3dpdGNoIChwb2xpY3kpIHtcbiAgICBjYXNlICdvcmlnaW4nOiByZXR1cm4gcmVmZXJyZXJPcmlnaW4gIT0gbnVsbCA/IHJlZmVycmVyT3JpZ2luIDogc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcbiAgICBjYXNlICd1bnNhZmUtdXJsJzogcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlck9yaWdpbiA6ICduby1yZWZlcnJlcidcbiAgICBjYXNlICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlclVSTCA6IHJlZmVycmVyT3JpZ2luXG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgICAgIC8vICAgIFVSTCBhcmUgdGhlIHNhbWUsIHRoZW4gcmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgaWYgKHNhbWVPcmlnaW4ocmVmZXJyZXJVUkwsIGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiByZWZlcnJlclVSTFxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm9cbiAgICAgIC8vICAgIHJlZmVycmVyLlxuICAgICAgaWYgKGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG4gICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICB9XG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8qKlxuICAgICAgICAgKiAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmRcbiAgICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICAgKiB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgICAgICAgICogMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICAgICovXG4gICAgY2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvKipcbiAgICAgICAqIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZFxuICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICogdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gICAgICAgKiAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgICovXG5cbiAgICBkZWZhdWx0OiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gaXNOb25Qb3RlbnRpYWxseVRydXN0V29ydGh5ID8gJ25vLXJlZmVycmVyJyA6IHJlZmVycmVyT3JpZ2luXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNzdHJpcC11cmxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IG9yaWdpbk9ubHlcbiAqL1xuZnVuY3Rpb24gc3RyaXBVUkxGb3JSZWZlcnJlciAodXJsLCBvcmlnaW5Pbmx5KSB7XG4gIC8vIDEuIEFzc2VydDogdXJsIGlzIGEgVVJMLlxuICBhc3NlcnQodXJsIGluc3RhbmNlb2YgVVJMKVxuXG4gIHVybCA9IG5ldyBVUkwodXJsKVxuXG4gIC8vIDIuIElmIHVybOKAmXMgc2NoZW1lIGlzIGEgbG9jYWwgc2NoZW1lLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyB8fCB1cmwucHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHVybC5wcm90b2NvbCA9PT0gJ2JsYW5rOicpIHtcbiAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICB9XG5cbiAgLy8gMy4gU2V0IHVybOKAmXMgdXNlcm5hbWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnVzZXJuYW1lID0gJydcblxuICAvLyA0LiBTZXQgdXJs4oCZcyBwYXNzd29yZCB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICB1cmwucGFzc3dvcmQgPSAnJ1xuXG4gIC8vIDUuIFNldCB1cmzigJlzIGZyYWdtZW50IHRvIG51bGwuXG4gIHVybC5oYXNoID0gJydcblxuICAvLyA2LiBJZiB0aGUgb3JpZ2luLW9ubHkgZmxhZyBpcyB0cnVlLCB0aGVuOlxuICBpZiAob3JpZ2luT25seSkge1xuICAgIC8vIDEuIFNldCB1cmzigJlzIHBhdGggdG8gwqsgdGhlIGVtcHR5IHN0cmluZyDCuy5cbiAgICB1cmwucGF0aG5hbWUgPSAnJ1xuXG4gICAgLy8gMi4gU2V0IHVybOKAmXMgcXVlcnkgdG8gbnVsbC5cbiAgICB1cmwuc2VhcmNoID0gJydcbiAgfVxuXG4gIC8vIDcuIFJldHVybiB1cmwuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5ICh1cmwpIHtcbiAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgb2YgYWJvdXQsIHJldHVybiB0cnVlXG4gIGlmICh1cmwuaHJlZiA9PT0gJ2Fib3V0OmJsYW5rJyB8fCB1cmwuaHJlZiA9PT0gJ2Fib3V0OnNyY2RvYycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc2NoZW1lIGlzIGRhdGEsIHJldHVybiB0cnVlXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdkYXRhOicpIHJldHVybiB0cnVlXG5cbiAgLy8gSWYgZmlsZSwgcmV0dXJuIHRydWVcbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JykgcmV0dXJuIHRydWVcblxuICByZXR1cm4gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybC5vcmlnaW4pXG5cbiAgZnVuY3Rpb24gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5IChvcmlnaW4pIHtcbiAgICAvLyBJZiBvcmlnaW4gaXMgZXhwbGljaXRseSBudWxsLCByZXR1cm4gZmFsc2VcbiAgICBpZiAob3JpZ2luID09IG51bGwgfHwgb3JpZ2luID09PSAnbnVsbCcpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3Qgb3JpZ2luQXNVUkwgPSBuZXcgVVJMKG9yaWdpbilcblxuICAgIC8vIElmIHNlY3VyZSwgcmV0dXJuIHRydWVcbiAgICBpZiAob3JpZ2luQXNVUkwucHJvdG9jb2wgPT09ICdodHRwczonIHx8IG9yaWdpbkFzVVJMLnByb3RvY29sID09PSAnd3NzOicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgbG9jYWxob3N0IG9yIHZhcmlhbnRzLCByZXR1cm4gdHJ1ZVxuICAgIGlmICgvXjEyNyg/OlxcLlswLTldKyl7MCwyfVxcLlswLTldKyR8XlxcWyg/OjAqOikqPzo/MCoxXFxdJC8udGVzdChvcmlnaW5Bc1VSTC5ob3N0bmFtZSkgfHxcbiAgICAgKG9yaWdpbkFzVVJMLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBvcmlnaW5Bc1VSTC5ob3N0bmFtZS5pbmNsdWRlcygnbG9jYWxob3N0LicpKSB8fFxuICAgICAob3JpZ2luQXNVUkwuaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QnKSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG90aGVyLCByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI2RvZXMtcmVzcG9uc2UtbWF0Y2gtbWV0YWRhdGFsaXN0XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFMaXN0XG4gKi9cbmZ1bmN0aW9uIGJ5dGVzTWF0Y2ggKGJ5dGVzLCBtZXRhZGF0YUxpc3QpIHtcbiAgLy8gSWYgbm9kZSBpcyBub3QgYnVpbHQgd2l0aCBPcGVuU1NMIHN1cHBvcnQsIHdlIGNhbm5vdCBjaGVja1xuICAvLyBhIHJlcXVlc3QncyBpbnRlZ3JpdHksIHNvIGFsbG93IGl0IGJ5IGRlZmF1bHQgKHRoZSBzcGVjIHdpbGxcbiAgLy8gYWxsb3cgcmVxdWVzdHMgaWYgYW4gaW52YWxpZCBoYXNoIGlzIGdpdmVuLCBhcyBwcmVjZWRlbmNlKS5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBvbmx5IGlmIG5vZGUgaXMgYnVpbHQgd2l0aCAtLXdpdGhvdXQtc3NsICovXG4gIGlmIChjcnlwdG8gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAxLiBMZXQgcGFyc2VkTWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIG1ldGFkYXRhTGlzdC5cbiAgY29uc3QgcGFyc2VkTWV0YWRhdGEgPSBwYXJzZU1ldGFkYXRhKG1ldGFkYXRhTGlzdClcblxuICAvLyAyLiBJZiBwYXJzZWRNZXRhZGF0YSBpcyBubyBtZXRhZGF0YSwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YSA9PT0gJ25vIG1ldGFkYXRhJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAzLiBJZiByZXNwb25zZSBpcyBub3QgZWxpZ2libGUgZm9yIGludGVncml0eSB2YWxpZGF0aW9uLCByZXR1cm4gZmFsc2UuXG4gIC8vIFRPRE9cblxuICAvLyA0LiBJZiBwYXJzZWRNZXRhZGF0YSBpcyB0aGUgZW1wdHkgc2V0LCByZXR1cm4gdHJ1ZS5cbiAgaWYgKHBhcnNlZE1ldGFkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyA1LiBMZXQgbWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIHRoZSBzdHJvbmdlc3RcbiAgLy8gICAgbWV0YWRhdGEgZnJvbSBwYXJzZWRNZXRhZGF0YS5cbiAgY29uc3Qgc3Ryb25nZXN0ID0gZ2V0U3Ryb25nZXN0TWV0YWRhdGEocGFyc2VkTWV0YWRhdGEpXG4gIGNvbnN0IG1ldGFkYXRhID0gZmlsdGVyTWV0YWRhdGFMaXN0QnlBbGdvcml0aG0ocGFyc2VkTWV0YWRhdGEsIHN0cm9uZ2VzdClcblxuICAvLyA2LiBGb3IgZWFjaCBpdGVtIGluIG1ldGFkYXRhOlxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWV0YWRhdGEpIHtcbiAgICAvLyAxLiBMZXQgYWxnb3JpdGhtIGJlIHRoZSBhbGcgY29tcG9uZW50IG9mIGl0ZW0uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gaXRlbS5hbGdvXG5cbiAgICAvLyAyLiBMZXQgZXhwZWN0ZWRWYWx1ZSBiZSB0aGUgdmFsIGNvbXBvbmVudCBvZiBpdGVtLlxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBpdGVtLmhhc2hcblxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9jb21taXQvZTRjNWNjN2E1ZTQ4MDkzMjIwNTI4ZGZkZDFjNDAxMmRjMzgzN2EwZVxuICAgIC8vIFwiYmUgbGliZXJhbCB3aXRoIHBhZGRpbmdcIi4gVGhpcyBpcyBhbm5veWluZywgYW5kIGl0J3Mgbm90IGV2ZW4gaW4gdGhlIHNwZWMuXG5cbiAgICAvLyAzLiBMZXQgYWN0dWFsVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhbGdvcml0aG0gdG8gYnl0ZXMuXG4gICAgbGV0IGFjdHVhbFZhbHVlID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgnYmFzZTY0JylcblxuICAgIGlmIChhY3R1YWxWYWx1ZVthY3R1YWxWYWx1ZS5sZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgICBpZiAoYWN0dWFsVmFsdWVbYWN0dWFsVmFsdWUubGVuZ3RoIC0gMl0gPT09ICc9Jykge1xuICAgICAgICBhY3R1YWxWYWx1ZSA9IGFjdHVhbFZhbHVlLnNsaWNlKDAsIC0yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsVmFsdWUgPSBhY3R1YWxWYWx1ZS5zbGljZSgwLCAtMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJZiBhY3R1YWxWYWx1ZSBpcyBhIGNhc2Utc2Vuc2l0aXZlIG1hdGNoIGZvciBleHBlY3RlZFZhbHVlLFxuICAgIC8vICAgIHJldHVybiB0cnVlLlxuICAgIGlmIChjb21wYXJlQmFzZTY0TWl4ZWQoYWN0dWFsVmFsdWUsIGV4cGVjdGVkVmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuIFJldHVybiBmYWxzZS5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNncmFtbWFyZGVmLWhhc2gtd2l0aC1vcHRpb25zXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvQ1NQMi8jc291cmNlLWxpc3Qtc3ludGF4XG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNTIzNCNhcHBlbmRpeC1CLjFcbmNvbnN0IHBhcnNlSGFzaFdpdGhPcHRpb25zID0gLyg/PGFsZ28+c2hhMjU2fHNoYTM4NHxzaGE1MTIpLSgoPzxoYXNoPltBLVphLXowLTkrL10rfFtBLVphLXowLTlfLV0rKT17MCwyfSg/Olxcc3wkKSggK1shLX5dKik/KT8vaVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI3BhcnNlLW1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXRhZGF0YSAobWV0YWRhdGEpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc2V0LlxuICAvKiogQHR5cGUge3sgYWxnbzogc3RyaW5nLCBoYXNoOiBzdHJpbmcgfVtdfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIC8vIDIuIExldCBlbXB0eSBiZSBlcXVhbCB0byB0cnVlLlxuICBsZXQgZW1wdHkgPSB0cnVlXG5cbiAgLy8gMy4gRm9yIGVhY2ggdG9rZW4gcmV0dXJuZWQgYnkgc3BsaXR0aW5nIG1ldGFkYXRhIG9uIHNwYWNlczpcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBtZXRhZGF0YS5zcGxpdCgnICcpKSB7XG4gICAgLy8gMS4gU2V0IGVtcHR5IHRvIGZhbHNlLlxuICAgIGVtcHR5ID0gZmFsc2VcblxuICAgIC8vIDIuIFBhcnNlIHRva2VuIGFzIGEgaGFzaC13aXRoLW9wdGlvbnMuXG4gICAgY29uc3QgcGFyc2VkVG9rZW4gPSBwYXJzZUhhc2hXaXRoT3B0aW9ucy5leGVjKHRva2VuKVxuXG4gICAgLy8gMy4gSWYgdG9rZW4gZG9lcyBub3QgcGFyc2UsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHRva2VuLlxuICAgIGlmIChcbiAgICAgIHBhcnNlZFRva2VuID09PSBudWxsIHx8XG4gICAgICBwYXJzZWRUb2tlbi5ncm91cHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgcGFyc2VkVG9rZW4uZ3JvdXBzLmFsZ28gPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgLy8gTm90ZTogQ2hyb21pdW0gYmxvY2tzIHRoZSByZXF1ZXN0IGF0IHRoaXMgcG9pbnQsIGJ1dCBGaXJlZm94XG4gICAgICAvLyBnaXZlcyBhIHdhcm5pbmcgdGhhdCBhbiBpbnZhbGlkIGludGVncml0eSB3YXMgZ2l2ZW4uIFRoZVxuICAgICAgLy8gY29ycmVjdCBiZWhhdmlvciBpcyB0byBpZ25vcmUgdGhlc2UsIGFuZCBzdWJzZXF1ZW50bHkgbm90XG4gICAgICAvLyBjaGVjayB0aGUgaW50ZWdyaXR5IG9mIHRoZSByZXNvdXJjZS5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IGFsZ29yaXRobSBiZSB0aGUgaGFzaC1hbGdvIGNvbXBvbmVudCBvZiB0b2tlbi5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBwYXJzZWRUb2tlbi5ncm91cHMuYWxnby50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA1LiBJZiBhbGdvcml0aG0gaXMgYSBoYXNoIGZ1bmN0aW9uIHJlY29nbml6ZWQgYnkgdGhlIHVzZXJcbiAgICAvLyAgICBhZ2VudCwgYWRkIHRoZSBwYXJzZWQgdG9rZW4gdG8gcmVzdWx0LlxuICAgIGlmIChzdXBwb3J0ZWRIYXNoZXMuaW5jbHVkZXMoYWxnb3JpdGhtKSkge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VkVG9rZW4uZ3JvdXBzKVxuICAgIH1cbiAgfVxuXG4gIC8vIDQuIFJldHVybiBubyBtZXRhZGF0YSBpZiBlbXB0eSBpcyB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIHJlc3VsdC5cbiAgaWYgKGVtcHR5ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdubyBtZXRhZGF0YSdcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3sgYWxnbzogJ3NoYTI1NicgfCAnc2hhMzg0JyB8ICdzaGE1MTInIH1bXX0gbWV0YWRhdGFMaXN0XG4gKi9cbmZ1bmN0aW9uIGdldFN0cm9uZ2VzdE1ldGFkYXRhIChtZXRhZGF0YUxpc3QpIHtcbiAgLy8gTGV0IGFsZ29yaXRobSBiZSB0aGUgYWxnbyBjb21wb25lbnQgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gbWV0YWRhdGFMaXN0LlxuICAvLyBDYW4gYmUgc2hhMjU2XG4gIGxldCBhbGdvcml0aG0gPSBtZXRhZGF0YUxpc3RbMF0uYWxnb1xuICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIHNoYTUxMiwgdGhlbiBpdCBpcyB0aGUgc3Ryb25nZXN0XG4gIC8vIGFuZCB3ZSBjYW4gcmV0dXJuIGltbWVkaWF0ZWx5XG4gIGlmIChhbGdvcml0aG1bM10gPT09ICc1Jykge1xuICAgIHJldHVybiBhbGdvcml0aG1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWV0YWRhdGFMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YUxpc3RbaV1cbiAgICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIHNoYTUxMiwgdGhlbiBpdCBpcyB0aGUgc3Ryb25nZXN0XG4gICAgLy8gYW5kIHdlIGNhbiBicmVhayB0aGUgbG9vcCBpbW1lZGlhdGVseVxuICAgIGlmIChtZXRhZGF0YS5hbGdvWzNdID09PSAnNScpIHtcbiAgICAgIGFsZ29yaXRobSA9ICdzaGE1MTInXG4gICAgICBicmVha1xuICAgIC8vIElmIHRoZSBhbGdvcml0aG0gaXMgc2hhMzg0LCB0aGVuIGEgcG90ZW50aWFsIHNoYTI1NiBvciBzaGEzODQgaXMgaWdub3JlZFxuICAgIH0gZWxzZSBpZiAoYWxnb3JpdGhtWzNdID09PSAnMycpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgLy8gYWxnb3JpdGhtIGlzIHNoYTI1NiwgY2hlY2sgaWYgYWxnb3JpdGhtIGlzIHNoYTM4NCBhbmQgaWYgc28sIHNldCBpdCBhc1xuICAgIC8vIHRoZSBzdHJvbmdlc3RcbiAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLmFsZ29bM10gPT09ICczJykge1xuICAgICAgYWxnb3JpdGhtID0gJ3NoYTM4NCdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsZ29yaXRobVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJNZXRhZGF0YUxpc3RCeUFsZ29yaXRobSAobWV0YWRhdGFMaXN0LCBhbGdvcml0aG0pIHtcbiAgaWYgKG1ldGFkYXRhTGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFMaXN0XG4gIH1cblxuICBsZXQgcG9zID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFkYXRhTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChtZXRhZGF0YUxpc3RbaV0uYWxnbyA9PT0gYWxnb3JpdGhtKSB7XG4gICAgICBtZXRhZGF0YUxpc3RbcG9zKytdID0gbWV0YWRhdGFMaXN0W2ldXG4gICAgfVxuICB9XG5cbiAgbWV0YWRhdGFMaXN0Lmxlbmd0aCA9IHBvc1xuXG4gIHJldHVybiBtZXRhZGF0YUxpc3Rcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmFzZTY0IHN0cmluZ3MsIGFsbG93aW5nIGZvciBiYXNlNjR1cmxcbiAqIGluIHRoZSBzZWNvbmQgc3RyaW5nLlxuICpcbiogQHBhcmFtIHtzdHJpbmd9IGFjdHVhbFZhbHVlIGFsd2F5cyBiYXNlNjRcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFZhbHVlIGJhc2U2NCBvciBiYXNlNjR1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlQmFzZTY0TWl4ZWQgKGFjdHVhbFZhbHVlLCBleHBlY3RlZFZhbHVlKSB7XG4gIGlmIChhY3R1YWxWYWx1ZS5sZW5ndGggIT09IGV4cGVjdGVkVmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3R1YWxWYWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhY3R1YWxWYWx1ZVtpXSAhPT0gZXhwZWN0ZWRWYWx1ZVtpXSkge1xuICAgICAgaWYgKFxuICAgICAgICAoYWN0dWFsVmFsdWVbaV0gPT09ICcrJyAmJiBleHBlY3RlZFZhbHVlW2ldID09PSAnLScpIHx8XG4gICAgICAgIChhY3R1YWxWYWx1ZVtpXSA9PT0gJy8nICYmIGV4cGVjdGVkVmFsdWVbaV0gPT09ICdfJylcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy11cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzLyN1cGdyYWRlLXJlcXVlc3RcbmZ1bmN0aW9uIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCAocmVxdWVzdCkge1xuICAvLyBUT0RPXG59XG5cbi8qKlxuICogQGxpbmsge2h0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3NhbWUtb3JpZ2lufVxuICogQHBhcmFtIHtVUkx9IEFcbiAqIEBwYXJhbSB7VVJMfSBCXG4gKi9cbmZ1bmN0aW9uIHNhbWVPcmlnaW4gKEEsIEIpIHtcbiAgLy8gMS4gSWYgQSBhbmQgQiBhcmUgdGhlIHNhbWUgb3BhcXVlIG9yaWdpbiwgdGhlbiByZXR1cm4gdHJ1ZS5cbiAgaWYgKEEub3JpZ2luID09PSBCLm9yaWdpbiAmJiBBLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDIuIElmIEEgYW5kIEIgYXJlIGJvdGggdHVwbGUgb3JpZ2lucyBhbmQgdGhlaXIgc2NoZW1lcyxcbiAgLy8gICAgaG9zdHMsIGFuZCBwb3J0IGFyZSBpZGVudGljYWwsIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLnByb3RvY29sID09PSBCLnByb3RvY29sICYmIEEuaG9zdG5hbWUgPT09IEIuaG9zdG5hbWUgJiYgQS5wb3J0ID09PSBCLnBvcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGZhbHNlLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRQcm9taXNlICgpIHtcbiAgbGV0IHJlc1xuICBsZXQgcmVqXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KVxuXG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmU6IHJlcywgcmVqZWN0OiByZWogfVxufVxuXG5mdW5jdGlvbiBpc0Fib3J0ZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCdcbn1cblxuZnVuY3Rpb24gaXNDYW5jZWxsZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCcgfHxcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAndGVybWluYXRlZCdcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kIChtZXRob2QpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPz8gbWV0aG9kXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1qYXZhc2NyaXB0LXZhbHVlLXRvLWEtanNvbi1zdHJpbmdcbmZ1bmN0aW9uIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyAodmFsdWUpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSA/IENhbGwoJUpTT04uc3RyaW5naWZ5JSwgdW5kZWZpbmVkLCDCqyB2YWx1ZSDCuykuXG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuXG4gIC8vIDIuIElmIHJlc3VsdCBpcyB1bmRlZmluZWQsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZScpXG4gIH1cblxuICAvLyAzLiBBc3NlcnQ6IHJlc3VsdCBpcyBhIHN0cmluZy5cbiAgYXNzZXJ0KHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKVxuXG4gIC8vIDQuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lMjVpdGVyYXRvcnByb3RvdHlwZSUyNS1vYmplY3RcbmNvbnN0IGVzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzeW1ib2x9IGtJbnRlcm5hbEl0ZXJhdG9yXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW2tleUluZGV4XVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFt2YWx1ZUluZGV4XVxuICovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvciAobmFtZSwga0ludGVybmFsSXRlcmF0b3IsIGtleUluZGV4ID0gMCwgdmFsdWVJbmRleCA9IDEpIHtcbiAgY2xhc3MgRmFzdEl0ZXJhYmxlSXRlcmF0b3Ige1xuICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgICN0YXJnZXRcbiAgICAvKiogQHR5cGUgeydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSAqL1xuICAgICNraW5kXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgI2luZGV4XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWRlZmF1bHQtaXRlcmF0b3Itb2JqZWN0XG4gICAgICogQHBhcmFtIHt1bmtub3dufSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSBraW5kXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKHRhcmdldCwga2luZCkge1xuICAgICAgdGhpcy4jdGFyZ2V0ID0gdGFyZ2V0XG4gICAgICB0aGlzLiNraW5kID0ga2luZFxuICAgICAgdGhpcy4jaW5kZXggPSAwXG4gICAgfVxuXG4gICAgbmV4dCAoKSB7XG4gICAgICAvLyAxLiBMZXQgaW50ZXJmYWNlIGJlIHRoZSBpbnRlcmZhY2UgZm9yIHdoaWNoIHRoZSBpdGVyYXRvciBwcm90b3R5cGUgb2JqZWN0IGV4aXN0cy5cbiAgICAgIC8vIDIuIExldCB0aGlzVmFsdWUgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAvLyAzLiBMZXQgb2JqZWN0IGJlID8gVG9PYmplY3QodGhpc1ZhbHVlKS5cbiAgICAgIC8vIDQuIElmIG9iamVjdCBpcyBhIHBsYXRmb3JtIG9iamVjdCwgdGhlbiBwZXJmb3JtIGEgc2VjdXJpdHlcbiAgICAgIC8vICAgIGNoZWNrLCBwYXNzaW5nOlxuICAgICAgLy8gNS4gSWYgb2JqZWN0IGlzIG5vdCBhIGRlZmF1bHQgaXRlcmF0b3Igb2JqZWN0IGZvciBpbnRlcmZhY2UsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JyB8fCB0aGlzID09PSBudWxsIHx8ICEoI3RhcmdldCBpbiB0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnbmV4dCcgY2FsbGVkIG9uIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgJHtuYW1lfSBJdGVyYXRvci5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IGluZGV4IGJlIG9iamVjdOKAmXMgaW5kZXguXG4gICAgICAvLyA3LiBMZXQga2luZCBiZSBvYmplY3TigJlzIGtpbmQuXG4gICAgICAvLyA4LiBMZXQgdmFsdWVzIGJlIG9iamVjdOKAmXMgdGFyZ2V0J3MgdmFsdWUgcGFpcnMgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNpbmRleFxuICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy4jdGFyZ2V0W2tJbnRlcm5hbEl0ZXJhdG9yXVxuXG4gICAgICAvLyA5LiBMZXQgbGVuIGJlIHRoZSBsZW5ndGggb2YgdmFsdWVzLlxuICAgICAgY29uc3QgbGVuID0gdmFsdWVzLmxlbmd0aFxuXG4gICAgICAvLyAxMC4gSWYgaW5kZXggaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGxlbiwgdGhlbiByZXR1cm5cbiAgICAgIC8vICAgICBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSkuXG4gICAgICBpZiAoaW5kZXggPj0gbGVuKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMTEuIExldCBwYWlyIGJlIHRoZSBlbnRyeSBpbiB2YWx1ZXMgYXQgaW5kZXggaW5kZXguXG4gICAgICBjb25zdCB7IFtrZXlJbmRleF06IGtleSwgW3ZhbHVlSW5kZXhdOiB2YWx1ZSB9ID0gdmFsdWVzW2luZGV4XVxuXG4gICAgICAvLyAxMi4gU2V0IG9iamVjdOKAmXMgaW5kZXggdG8gaW5kZXggKyAxLlxuICAgICAgdGhpcy4jaW5kZXggPSBpbmRleCArIDFcblxuICAgICAgLy8gMTMuIFJldHVybiB0aGUgaXRlcmF0b3IgcmVzdWx0IGZvciBwYWlyIGFuZCBraW5kLlxuXG4gICAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2l0ZXJhdG9yLXJlc3VsdFxuXG4gICAgICAvLyAxLiBMZXQgcmVzdWx0IGJlIGEgdmFsdWUgZGV0ZXJtaW5lZCBieSB0aGUgdmFsdWUgb2Yga2luZDpcbiAgICAgIGxldCByZXN1bHRcbiAgICAgIHN3aXRjaCAodGhpcy4ja2luZCkge1xuICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgIC8vIDEuIExldCBpZGxLZXkgYmUgcGFpcuKAmXMga2V5LlxuICAgICAgICAgIC8vIDIuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gMy4gcmVzdWx0IGlzIGtleS5cbiAgICAgICAgICByZXN1bHQgPSBrZXlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbFZhbHVlIGJlIHBhaXLigJlzIHZhbHVlLlxuICAgICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsVmFsdWUgdG9cbiAgICAgICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgICAgIC8vIDMuIHJlc3VsdCBpcyB2YWx1ZS5cbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2tleSt2YWx1ZSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAgICAgLy8gMi4gTGV0IGlkbFZhbHVlIGJlIHBhaXLigJlzIHZhbHVlLlxuICAgICAgICAgIC8vIDMuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gNC4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxWYWx1ZSB0b1xuICAgICAgICAgIC8vICAgIGFuIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gNS4gTGV0IGFycmF5IGJlICEgQXJyYXlDcmVhdGUoMikuXG4gICAgICAgICAgLy8gNi4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIwXCIsIGtleSkuXG4gICAgICAgICAgLy8gNy4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIxXCIsIHZhbHVlKS5cbiAgICAgICAgICAvLyA4LiByZXN1bHQgaXMgYXJyYXkuXG4gICAgICAgICAgcmVzdWx0ID0gW2tleSwgdmFsdWVdXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gUmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVzdWx0LCBmYWxzZSkuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWl0ZXJhdG9yLXByb3RvdHlwZS1vYmplY3RcbiAgLy8gQHRzLWlnbm9yZVxuICBkZWxldGUgRmFzdEl0ZXJhYmxlSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yXG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEZhc3RJdGVyYWJsZUl0ZXJhdG9yLnByb3RvdHlwZSwgZXNJdGVyYXRvclByb3RvdHlwZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGYXN0SXRlcmFibGVJdGVyYXRvci5wcm90b3R5cGUsIHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogYCR7bmFtZX0gSXRlcmF0b3JgXG4gICAgfSxcbiAgICBuZXh0OiB7IHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfVxuICB9KVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3Vua25vd259IHRhcmdldFxuICAgKiBAcGFyYW0geydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSBraW5kXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuICAgIHJldHVybiBuZXcgRmFzdEl0ZXJhYmxlSXRlcmF0b3IodGFyZ2V0LCBraW5kKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBpbnN0YW5jZVxuICogQHBhcmFtIHthbnl9IG9iamVjdCBjbGFzc1xuICogQHBhcmFtIHtzeW1ib2x9IGtJbnRlcm5hbEl0ZXJhdG9yXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW2tleUluZGV4XVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFt2YWx1ZUluZGV4XVxuICovXG5mdW5jdGlvbiBpdGVyYXRvck1peGluIChuYW1lLCBvYmplY3QsIGtJbnRlcm5hbEl0ZXJhdG9yLCBrZXlJbmRleCA9IDAsIHZhbHVlSW5kZXggPSAxKSB7XG4gIGNvbnN0IG1ha2VJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yKG5hbWUsIGtJbnRlcm5hbEl0ZXJhdG9yLCBrZXlJbmRleCwgdmFsdWVJbmRleClcblxuICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgIGtleXM6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzICgpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXMsICdrZXknKVxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzICgpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXMsICd2YWx1ZScpXG4gICAgICB9XG4gICAgfSxcbiAgICBlbnRyaWVzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW50cmllcyAoKSB7XG4gICAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIG9iamVjdClcbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJylcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvckVhY2g6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoIChjYWxsYmFja2ZuLCB0aGlzQXJnID0gZ2xvYmFsVGhpcykge1xuICAgICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBvYmplY3QpXG4gICAgICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgYCR7bmFtZX0uZm9yRWFjaGApXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICcke25hbWV9JzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0Z1bmN0aW9uJy5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeyAwOiBrZXksIDE6IHZhbHVlIH0gb2YgbWFrZUl0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKSkge1xuICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iamVjdC5wcm90b3R5cGUsIHtcbiAgICAuLi5wcm9wZXJ0aWVzLFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHByb3BlcnRpZXMuZW50cmllcy52YWx1ZVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LWZ1bGx5LXJlYWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZnVsbHlSZWFkQm9keSAoYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpIHtcbiAgLy8gMS4gSWYgdGFza0Rlc3RpbmF0aW9uIGlzIG51bGwsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0b1xuICAvLyAgICB0aGUgcmVzdWx0IG9mIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuXG4gIC8vIDIuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzIGJlIHRvIHF1ZXVlIGFcbiAgLy8gICAgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMsIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBzdWNjZXNzU3RlcHMgPSBwcm9jZXNzQm9keVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGJlIHRvIHF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHlFcnJvcixcbiAgLy8gICAgd2l0aCB0YXNrRGVzdGluYXRpb24uXG4gIGNvbnN0IGVycm9yU3RlcHMgPSBwcm9jZXNzQm9keUVycm9yXG5cbiAgLy8gNC4gTGV0IHJlYWRlciBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgYSByZWFkZXIgZm9yIGJvZHnigJlzIHN0cmVhbS5cbiAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHMgd2l0aCB0aGF0XG4gIC8vICAgIGV4Y2VwdGlvbiBhbmQgcmV0dXJuLlxuICBsZXQgcmVhZGVyXG5cbiAgdHJ5IHtcbiAgICByZWFkZXIgPSBib2R5LnN0cmVhbS5nZXRSZWFkZXIoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gNS4gUmVhZCBhbGwgYnl0ZXMgZnJvbSByZWFkZXIsIGdpdmVuIHN1Y2Nlc3NTdGVwcyBhbmQgZXJyb3JTdGVwcy5cbiAgdHJ5IHtcbiAgICBzdWNjZXNzU3RlcHMoYXdhaXQgcmVhZEFsbEJ5dGVzKHJlYWRlcikpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvclN0ZXBzKGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbUxpa2UgKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgKFxuICAgIHN0cmVhbVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnUmVhZGFibGVTdHJlYW0nICYmXG4gICAgdHlwZW9mIHN0cmVhbS50ZWUgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFVpbnQ4QXJyYXk+fSBjb250cm9sbGVyXG4gKi9cbmZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtQ2xvc2UgKGNvbnRyb2xsZXIpIHtcbiAgdHJ5IHtcbiAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRPRE86IGFkZCBjb21tZW50IGV4cGxhaW5pbmcgd2h5IHRoaXMgZXJyb3Igb2NjdXJzLlxuICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0NvbnRyb2xsZXIgaXMgYWxyZWFkeSBjbG9zZWQnKSAmJiAhZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ1JlYWRhYmxlU3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkJykpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpbnZhbGlkSXNvbW9ycGhpY0VuY29kZVZhbHVlUmVnZXggPSAvW15cXHgwMC1cXHhGRl0vIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNpc29tb3JwaGljLWVuY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlzb21vcnBoaWNFbmNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIEFzc2VydDogaW5wdXQgY29udGFpbnMgbm8gY29kZSBwb2ludHMgZ3JlYXRlciB0aGFuIFUrMDBGRi5cbiAgYXNzZXJ0KCFpbnZhbGlkSXNvbW9ycGhpY0VuY29kZVZhbHVlUmVnZXgudGVzdChpbnB1dCkpXG5cbiAgLy8gMi4gUmV0dXJuIGEgYnl0ZSBzZXF1ZW5jZSB3aG9zZSBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGNvZGVcbiAgLy8gICAgcG9pbnQgbGVuZ3RoIGFuZCB3aG9zZSBieXRlcyBoYXZlIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgLy8gICAgdmFsdWVzIG9mIGlucHV04oCZcyBjb2RlIHBvaW50cywgaW4gdGhlIHNhbWUgb3JkZXJcbiAgcmV0dXJuIGlucHV0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbWRlZmF1bHRyZWFkZXItcmVhZC1hbGwtYnl0ZXNcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZC1sb29wXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcn0gcmVhZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRBbGxCeXRlcyAocmVhZGVyKSB7XG4gIGNvbnN0IGJ5dGVzID0gW11cbiAgbGV0IGJ5dGVMZW5ndGggPSAwXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiBjaHVuayB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuXG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIC8vIDEuIENhbGwgc3VjY2Vzc1N0ZXBzIHdpdGggYnl0ZXMuXG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChieXRlcywgYnl0ZUxlbmd0aClcbiAgICB9XG5cbiAgICAvLyAxLiBJZiBjaHVuayBpcyBub3QgYSBVaW50OEFycmF5IG9iamVjdCwgY2FsbCBmYWlsdXJlU3RlcHNcbiAgICAvLyAgICB3aXRoIGEgVHlwZUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlY2VpdmVkIG5vbi1VaW50OEFycmF5IGNodW5rJylcbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgdGhlIGJ5dGVzIHJlcHJlc2VudGVkIGJ5IGNodW5rIHRvIGJ5dGVzLlxuICAgIGJ5dGVzLnB1c2goY2h1bmspXG4gICAgYnl0ZUxlbmd0aCArPSBjaHVuay5sZW5ndGhcblxuICAgIC8vIDMuIFJlYWQtbG9vcCBnaXZlbiByZWFkZXIsIGJ5dGVzLCBzdWNjZXNzU3RlcHMsIGFuZCBmYWlsdXJlU3RlcHMuXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNpcy1sb2NhbFxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxJc0xvY2FsICh1cmwpIHtcbiAgYXNzZXJ0KCdwcm90b2NvbCcgaW4gdXJsKSAvLyBlbnN1cmUgaXQncyBhIHVybCBvYmplY3RcblxuICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbFxuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2Fib3V0OicgfHwgcHJvdG9jb2wgPT09ICdibG9iOicgfHwgcHJvdG9jb2wgPT09ICdkYXRhOidcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVybEhhc0h0dHBzU2NoZW1lICh1cmwpIHtcbiAgcmV0dXJuIChcbiAgICAoXG4gICAgICB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyAmJlxuICAgICAgdXJsWzVdID09PSAnOicgJiZcbiAgICAgIHVybFswXSA9PT0gJ2gnICYmXG4gICAgICB1cmxbMV0gPT09ICd0JyAmJlxuICAgICAgdXJsWzJdID09PSAndCcgJiZcbiAgICAgIHVybFszXSA9PT0gJ3AnICYmXG4gICAgICB1cmxbNF0gPT09ICdzJ1xuICAgICkgfHxcbiAgICB1cmwucHJvdG9jb2wgPT09ICdodHRwczonXG4gIClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXNjaGVtZVxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxJc0h0dHBIdHRwc1NjaGVtZSAodXJsKSB7XG4gIGFzc2VydCgncHJvdG9jb2wnIGluIHVybCkgLy8gZW5zdXJlIGl0J3MgYSB1cmwgb2JqZWN0XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwOicgfHwgcHJvdG9jb2wgPT09ICdodHRwczonXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jc2ltcGxlLXJhbmdlLWhlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93V2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiBzaW1wbGVSYW5nZUhlYWRlclZhbHVlICh2YWx1ZSwgYWxsb3dXaGl0ZXNwYWNlKSB7XG4gIC8vIDEuIExldCBkYXRhIGJlIHRoZSBpc29tb3JwaGljIGRlY29kaW5nIG9mIHZhbHVlLlxuICAvLyBOb3RlOiBpc29tb3JwaGljIGRlY29kaW5nIHRha2VzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgKGllLiBhIFVpbnQ4QXJyYXkpIGFuZCB0dXJucyBpdCBpbnRvIGEgc3RyaW5nLFxuICAvLyBub3RoaW5nIG1vcmUuIFdlIG9idmlvdXNseSBkb24ndCBuZWVkIHRvIGRvIHRoYXQgaWYgdmFsdWUgaXMgYSBzdHJpbmcgYWxyZWFkeS5cbiAgY29uc3QgZGF0YSA9IHZhbHVlXG5cbiAgLy8gMi4gSWYgZGF0YSBkb2VzIG5vdCBzdGFydCB3aXRoIFwiYnl0ZXNcIiwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAzLiBMZXQgcG9zaXRpb24gYmUgYSBwb3NpdGlvbiB2YXJpYWJsZSBmb3IgZGF0YSwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSA1dGggY29kZSBwb2ludCBvZiBkYXRhLlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDUgfVxuXG4gIC8vIDQuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsXG4gIC8vICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gNS4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGRhdGEgaXMgbm90IFUrMDAzRCAoPSksIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChkYXRhLmNoYXJDb2RlQXQocG9zaXRpb24ucG9zaXRpb24pICE9PSAweDNEKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gNy4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYiBvciBzcGFjZSwgZnJvbVxuICAvLyAgICBkYXRhIGdpdmVuIHBvc2l0aW9uLlxuICBpZiAoYWxsb3dXaGl0ZXNwYWNlKSB7XG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnICcsXG4gICAgICBkYXRhLFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gIH1cblxuICAvLyA4LiBMZXQgcmFuZ2VTdGFydCBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBBU0NJSSBkaWdpdHMsXG4gIC8vICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgY29uc3QgcmFuZ2VTdGFydCA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgKGNoYXIpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgICAgcmV0dXJuIGNvZGUgPj0gMHgzMCAmJiBjb2RlIDw9IDB4MzlcbiAgICB9LFxuICAgIGRhdGEsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDkuIExldCByYW5nZVN0YXJ0VmFsdWUgYmUgcmFuZ2VTdGFydCwgaW50ZXJwcmV0ZWQgYXMgZGVjaW1hbCBudW1iZXIsIGlmIHJhbmdlU3RhcnQgaXMgbm90IHRoZVxuICAvLyAgICBlbXB0eSBzdHJpbmc7IG90aGVyd2lzZSBudWxsLlxuICBjb25zdCByYW5nZVN0YXJ0VmFsdWUgPSByYW5nZVN0YXJ0Lmxlbmd0aCA/IE51bWJlcihyYW5nZVN0YXJ0KSA6IG51bGxcblxuICAvLyAxMC4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYiBvciBzcGFjZSxcbiAgLy8gICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gMTEuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBkYXRhIGlzIG5vdCBVKzAwMkQgKC0pLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YS5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSAhPT0gMHgyRCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDEyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyAxMy4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYlxuICAvLyAgICAgb3Igc3BhY2UsIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgLy8gTm90ZSBmcm9tIEtoYWZyYTogaXRzIHRoZSBzYW1lIHN0ZXAgYXMgaW4gIzggYWdhaW4gbG9sXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDE0LiBMZXQgcmFuZ2VFbmQgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmVcbiAgLy8gICAgIEFTQ0lJIGRpZ2l0cywgZnJvbSBkYXRhIGdpdmVuIHBvc2l0aW9uLlxuICAvLyBOb3RlIGZyb20gS2hhZnJhOiB5b3Ugd291bGRuJ3QgZ3Vlc3MgaXQsIGJ1dCB0aGlzIGlzIGFsc28gdGhlIHNhbWUgc3RlcCBhcyAjOFxuICBjb25zdCByYW5nZUVuZCA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgKGNoYXIpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgICAgcmV0dXJuIGNvZGUgPj0gMHgzMCAmJiBjb2RlIDw9IDB4MzlcbiAgICB9LFxuICAgIGRhdGEsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDE1LiBMZXQgcmFuZ2VFbmRWYWx1ZSBiZSByYW5nZUVuZCwgaW50ZXJwcmV0ZWQgYXMgZGVjaW1hbCBudW1iZXIsIGlmIHJhbmdlRW5kXG4gIC8vICAgICBpcyBub3QgdGhlIGVtcHR5IHN0cmluZzsgb3RoZXJ3aXNlIG51bGwuXG4gIC8vIE5vdGUgZnJvbSBLaGFmcmE6IFRIRSBTQU1FIFNURVAsIEFHQUlOISEhXG4gIC8vIE5vdGU6IHdoeSBpbnRlcnByZXQgYXMgYSBkZWNpbWFsIGlmIHdlIG9ubHkgY29sbGVjdCBhc2NpaSBkaWdpdHM/XG4gIGNvbnN0IHJhbmdlRW5kVmFsdWUgPSByYW5nZUVuZC5sZW5ndGggPyBOdW1iZXIocmFuZ2VFbmQpIDogbnVsbFxuXG4gIC8vIDE2LiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGRhdGEsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMTcuIElmIHJhbmdlRW5kVmFsdWUgYW5kIHJhbmdlU3RhcnRWYWx1ZSBhcmUgbnVsbCwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKHJhbmdlRW5kVmFsdWUgPT09IG51bGwgJiYgcmFuZ2VTdGFydFZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMTguIElmIHJhbmdlU3RhcnRWYWx1ZSBhbmQgcmFuZ2VFbmRWYWx1ZSBhcmUgbnVtYmVycywgYW5kIHJhbmdlU3RhcnRWYWx1ZSBpc1xuICAvLyAgICAgZ3JlYXRlciB0aGFuIHJhbmdlRW5kVmFsdWUsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIC8vIE5vdGU6IC4uLiB3aGVuIGNhbiB0aGV5IG5vdCBiZSBudW1iZXJzP1xuICBpZiAocmFuZ2VTdGFydFZhbHVlID4gcmFuZ2VFbmRWYWx1ZSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE5LiBSZXR1cm4gKHJhbmdlU3RhcnRWYWx1ZSwgcmFuZ2VFbmRWYWx1ZSkuXG4gIHJldHVybiB7IHJhbmdlU3RhcnRWYWx1ZSwgcmFuZ2VFbmRWYWx1ZSB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYnVpbGQtYS1jb250ZW50LXJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VTdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlRW5kXG4gKiBAcGFyYW0ge251bWJlcn0gZnVsbExlbmd0aFxuICovXG5mdW5jdGlvbiBidWlsZENvbnRlbnRSYW5nZSAocmFuZ2VTdGFydCwgcmFuZ2VFbmQsIGZ1bGxMZW5ndGgpIHtcbiAgLy8gMS4gTGV0IGNvbnRlbnRSYW5nZSBiZSBgYnl0ZXMgYC5cbiAgbGV0IGNvbnRlbnRSYW5nZSA9ICdieXRlcyAnXG5cbiAgLy8gMi4gQXBwZW5kIHJhbmdlU3RhcnQsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCwgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gaXNvbW9ycGhpY0VuY29kZShgJHtyYW5nZVN0YXJ0fWApXG5cbiAgLy8gMy4gQXBwZW5kIDB4MkQgKC0pIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9ICctJ1xuXG4gIC8vIDQuIEFwcGVuZCByYW5nZUVuZCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9IGlzb21vcnBoaWNFbmNvZGUoYCR7cmFuZ2VFbmR9YClcblxuICAvLyA1LiBBcHBlbmQgMHgyRiAoLykgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gJy8nXG5cbiAgLy8gNi4gQXBwZW5kIGZ1bGxMZW5ndGgsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSBpc29tb3JwaGljRW5jb2RlKGAke2Z1bGxMZW5ndGh9YClcblxuICAvLyA3LiBSZXR1cm4gY29udGVudFJhbmdlLlxuICByZXR1cm4gY29udGVudFJhbmdlXG59XG5cbi8vIEEgU3RyZWFtLCB3aGljaCBwaXBlcyB0aGUgcmVzcG9uc2UgdG8gemxpYi5jcmVhdGVJbmZsYXRlKCkgb3Jcbi8vIHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpIGRlcGVuZGluZyBvbiB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgQnVmZmVyLlxuLy8gSWYgdGhlIGxvd2VyIGJ5dGUgb2YgdGhlIGZpcnN0IGJ5dGUgaXMgMHgwOCwgdGhlbiB0aGUgc3RyZWFtIGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhIHpsaWIgc3RyZWFtLCBvdGhlcndpc2UgaXQncyBpbnRlcnByZXRlZCBhcyBhXG4vLyByYXcgZGVmbGF0ZSBzdHJlYW0uXG5jbGFzcyBJbmZsYXRlU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgX3RyYW5zZm9ybSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5faW5mbGF0ZVN0cmVhbSkge1xuICAgICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbSA9IChjaHVua1swXSAmIDB4MEYpID09PSAweDA4XG4gICAgICAgID8gemxpYi5jcmVhdGVJbmZsYXRlKClcbiAgICAgICAgOiB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKVxuXG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLm9uKCdkYXRhJywgdGhpcy5wdXNoLmJpbmQodGhpcykpXG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB0aGlzLnB1c2gobnVsbCkpXG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHRoaXMuZGVzdHJveShlcnIpKVxuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVTdHJlYW0ud3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgfVxuXG4gIF9maW5hbCAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZVN0cmVhbSkge1xuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbS5lbmQoKVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbSA9IG51bGxcbiAgICB9XG4gICAgY2FsbGJhY2soKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZmxhdGUgKCkge1xuICByZXR1cm4gbmV3IEluZmxhdGVTdHJlYW0oKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWV4dHJhY3QtbWltZS10eXBlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9oZWFkZXJzJykuSGVhZGVyc0xpc3R9IGhlYWRlcnNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdE1pbWVUeXBlIChoZWFkZXJzKSB7XG4gIC8vIDEuIExldCBjaGFyc2V0IGJlIG51bGwuXG4gIGxldCBjaGFyc2V0ID0gbnVsbFxuXG4gIC8vIDIuIExldCBlc3NlbmNlIGJlIG51bGwuXG4gIGxldCBlc3NlbmNlID0gbnVsbFxuXG4gIC8vIDMuIExldCBtaW1lVHlwZSBiZSBudWxsLlxuICBsZXQgbWltZVR5cGUgPSBudWxsXG5cbiAgLy8gNC4gTGV0IHZhbHVlcyBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcsIGRlY29kaW5nLCBhbmQgc3BsaXR0aW5nIGBDb250ZW50LVR5cGVgIGZyb20gaGVhZGVycy5cbiAgY29uc3QgdmFsdWVzID0gZ2V0RGVjb2RlU3BsaXQoJ2NvbnRlbnQtdHlwZScsIGhlYWRlcnMpXG5cbiAgLy8gNS4gSWYgdmFsdWVzIGlzIG51bGwsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA2LiBGb3IgZWFjaCB2YWx1ZSBvZiB2YWx1ZXM6XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgLy8gNi4xLiBMZXQgdGVtcG9yYXJ5TWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHZhbHVlLlxuICAgIGNvbnN0IHRlbXBvcmFyeU1pbWVUeXBlID0gcGFyc2VNSU1FVHlwZSh2YWx1ZSlcblxuICAgIC8vIDYuMi4gSWYgdGVtcG9yYXJ5TWltZVR5cGUgaXMgZmFpbHVyZSBvciBpdHMgZXNzZW5jZSBpcyBcIiovKlwiLCB0aGVuIGNvbnRpbnVlLlxuICAgIGlmICh0ZW1wb3JhcnlNaW1lVHlwZSA9PT0gJ2ZhaWx1cmUnIHx8IHRlbXBvcmFyeU1pbWVUeXBlLmVzc2VuY2UgPT09ICcqLyonKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIDYuMy4gU2V0IG1pbWVUeXBlIHRvIHRlbXBvcmFyeU1pbWVUeXBlLlxuICAgIG1pbWVUeXBlID0gdGVtcG9yYXJ5TWltZVR5cGVcblxuICAgIC8vIDYuNC4gSWYgbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgbm90IGVzc2VuY2UsIHRoZW46XG4gICAgaWYgKG1pbWVUeXBlLmVzc2VuY2UgIT09IGVzc2VuY2UpIHtcbiAgICAgIC8vIDYuNC4xLiBTZXQgY2hhcnNldCB0byBudWxsLlxuICAgICAgY2hhcnNldCA9IG51bGxcblxuICAgICAgLy8gNi40LjIuIElmIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXSBleGlzdHMsIHRoZW4gc2V0IGNoYXJzZXQgdG9cbiAgICAgIC8vICAgICAgICBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0uXG4gICAgICBpZiAobWltZVR5cGUucGFyYW1ldGVycy5oYXMoJ2NoYXJzZXQnKSkge1xuICAgICAgICBjaGFyc2V0ID0gbWltZVR5cGUucGFyYW1ldGVycy5nZXQoJ2NoYXJzZXQnKVxuICAgICAgfVxuXG4gICAgICAvLyA2LjQuMy4gU2V0IGVzc2VuY2UgdG8gbWltZVR5cGXigJlzIGVzc2VuY2UuXG4gICAgICBlc3NlbmNlID0gbWltZVR5cGUuZXNzZW5jZVxuICAgIH0gZWxzZSBpZiAoIW1pbWVUeXBlLnBhcmFtZXRlcnMuaGFzKCdjaGFyc2V0JykgJiYgY2hhcnNldCAhPT0gbnVsbCkge1xuICAgICAgLy8gNi41LiBPdGhlcndpc2UsIGlmIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXSBkb2VzIG5vdCBleGlzdCwgYW5kXG4gICAgICAvLyAgICAgIGNoYXJzZXQgaXMgbm9uLW51bGwsIHNldCBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0gdG8gY2hhcnNldC5cbiAgICAgIG1pbWVUeXBlLnBhcmFtZXRlcnMuc2V0KCdjaGFyc2V0JywgY2hhcnNldClcbiAgICB9XG4gIH1cblxuICAvLyA3LiBJZiBtaW1lVHlwZSBpcyBudWxsLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAobWltZVR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDguIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLXZhbHVlLWdldC1kZWNvZGUtYW5kLXNwbGl0XG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXR0aW5nRGVjb2RpbmdTcGxpdHRpbmcgKHZhbHVlKSB7XG4gIC8vIDEuIExldCBpbnB1dCBiZSB0aGUgcmVzdWx0IG9mIGlzb21vcnBoaWMgZGVjb2RpbmcgdmFsdWUuXG4gIGNvbnN0IGlucHV0ID0gdmFsdWVcblxuICAvLyAyLiBMZXQgcG9zaXRpb24gYmUgYSBwb3NpdGlvbiB2YXJpYWJsZSBmb3IgaW5wdXQsIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgc3RhcnQgb2YgaW5wdXQuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gMy4gTGV0IHZhbHVlcyBiZSBhIGxpc3Qgb2Ygc3RyaW5ncywgaW5pdGlhbGx5IGVtcHR5LlxuICBjb25zdCB2YWx1ZXMgPSBbXVxuXG4gIC8vIDQuIExldCB0ZW1wb3JhcnlWYWx1ZSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgdGVtcG9yYXJ5VmFsdWUgPSAnJ1xuXG4gIC8vIDUuIFdoaWxlIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQ6XG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgIC8vIDUuMS4gQXBwZW5kIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwMjIgKFwiKVxuICAgIC8vICAgICAgb3IgVSswMDJDICgsKSBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbiwgdG8gdGVtcG9yYXJ5VmFsdWUuXG4gICAgdGVtcG9yYXJ5VmFsdWUgKz0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnXCInICYmIGNoYXIgIT09ICcsJyxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyA1LjIuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW46XG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAvLyA1LjIuMS4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzIFUrMDAyMiAoXCIpLCB0aGVuOlxuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24ucG9zaXRpb24pID09PSAweDIyKSB7XG4gICAgICAgIC8vIDUuMi4xLjEuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYW4gSFRUUCBxdW90ZWQgc3RyaW5nIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLCB0byB0ZW1wb3JhcnlWYWx1ZS5cbiAgICAgICAgdGVtcG9yYXJ5VmFsdWUgKz0gY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyhcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApXG5cbiAgICAgICAgLy8gNS4yLjEuMi4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBjb250aW51ZS5cbiAgICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNS4yLjIuIE90aGVyd2lzZTpcblxuICAgICAgICAvLyA1LjIuMi4xLiBBc3NlcnQ6IHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpcyBVKzAwMkMgKCwpLlxuICAgICAgICBhc3NlcnQoaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbi5wb3NpdGlvbikgPT09IDB4MkMpXG5cbiAgICAgICAgLy8gNS4yLjIuMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4zLiBSZW1vdmUgYWxsIEhUVFAgdGFiIG9yIHNwYWNlIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGVtcG9yYXJ5VmFsdWUuXG4gICAgdGVtcG9yYXJ5VmFsdWUgPSByZW1vdmVDaGFycyh0ZW1wb3JhcnlWYWx1ZSwgdHJ1ZSwgdHJ1ZSwgKGNoYXIpID0+IGNoYXIgPT09IDB4OSB8fCBjaGFyID09PSAweDIwKVxuXG4gICAgLy8gNS40LiBBcHBlbmQgdGVtcG9yYXJ5VmFsdWUgdG8gdmFsdWVzLlxuICAgIHZhbHVlcy5wdXNoKHRlbXBvcmFyeVZhbHVlKVxuXG4gICAgLy8gNS42LiBTZXQgdGVtcG9yYXJ5VmFsdWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICB0ZW1wb3JhcnlWYWx1ZSA9ICcnXG4gIH1cblxuICAvLyA2LiBSZXR1cm4gdmFsdWVzLlxuICByZXR1cm4gdmFsdWVzXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1nZXQtZGVjb2RlLXNwbGl0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBsb3dlcmNhc2UgaGVhZGVyIG5hbWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2hlYWRlcnMnKS5IZWFkZXJzTGlzdH0gbGlzdFxuICovXG5mdW5jdGlvbiBnZXREZWNvZGVTcGxpdCAobmFtZSwgbGlzdCkge1xuICAvLyAxLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSBsaXN0LlxuICBjb25zdCB2YWx1ZSA9IGxpc3QuZ2V0KG5hbWUsIHRydWUpXG5cbiAgLy8gMi4gSWYgdmFsdWUgaXMgbnVsbCwgdGhlbiByZXR1cm4gbnVsbC5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIGdldHRpbmcsIGRlY29kaW5nLCBhbmQgc3BsaXR0aW5nIHZhbHVlLlxuICByZXR1cm4gZ2V0dGluZ0RlY29kaW5nU3BsaXR0aW5nKHZhbHVlKVxufVxuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jdXRmLTgtZGVjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHV0ZjhEZWNvZGVCeXRlcyAoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyAxLiBMZXQgYnVmZmVyIGJlIHRoZSByZXN1bHQgb2YgcGVla2luZyB0aHJlZSBieXRlcyBmcm9tXG4gIC8vICAgIGlvUXVldWUsIGNvbnZlcnRlZCB0byBhIGJ5dGUgc2VxdWVuY2UuXG5cbiAgLy8gMi4gSWYgYnVmZmVyIGlzIDB4RUYgMHhCQiAweEJGLCB0aGVuIHJlYWQgdGhyZWVcbiAgLy8gICAgYnl0ZXMgZnJvbSBpb1F1ZXVlLiAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgaWYgKGJ1ZmZlclswXSA9PT0gMHhFRiAmJiBidWZmZXJbMV0gPT09IDB4QkIgJiYgYnVmZmVyWzJdID09PSAweEJGKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KDMpXG4gIH1cblxuICAvLyAzLiBQcm9jZXNzIGEgcXVldWUgd2l0aCBhbiBpbnN0YW5jZSBvZiBVVEYtOOKAmXNcbiAgLy8gICAgZGVjb2RlciwgaW9RdWV1ZSwgb3V0cHV0LCBhbmQgXCJyZXBsYWNlbWVudFwiLlxuICBjb25zdCBvdXRwdXQgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoYnVmZmVyKVxuXG4gIC8vIDQuIFJldHVybiBvdXRwdXQuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuY2xhc3MgRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdEJhc2Uge1xuICBnZXQgYmFzZVVybCAoKSB7XG4gICAgcmV0dXJuIGdldEdsb2JhbE9yaWdpbigpXG4gIH1cblxuICBnZXQgb3JpZ2luICgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVXJsPy5vcmlnaW5cbiAgfVxuXG4gIHBvbGljeUNvbnRhaW5lciA9IG1ha2VQb2xpY3lDb250YWluZXIoKVxufVxuXG5jbGFzcyBFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IHtcbiAgc2V0dGluZ3NPYmplY3QgPSBuZXcgRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdEJhc2UoKVxufVxuXG5jb25zdCBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0ID0gbmV3IEVudmlyb25tZW50U2V0dGluZ3NPYmplY3QoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBYm9ydGVkLFxuICBpc0NhbmNlbGxlZCxcbiAgaXNWYWxpZEVuY29kZWRVUkwsXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gIGNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvLFxuICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSxcbiAgZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcixcbiAgbWFrZVBvbGljeUNvbnRhaW5lcixcbiAgY2xvbmVQb2xpY3lDb250YWluZXIsXG4gIGFwcGVuZEZldGNoTWV0YWRhdGEsXG4gIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIsXG4gIFRBT0NoZWNrLFxuICBjb3JzQ2hlY2ssXG4gIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayxcbiAgY3JlYXRlT3BhcXVlVGltaW5nSW5mbyxcbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCxcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgcmVxdWVzdEJhZFBvcnQsXG4gIHJlcXVlc3RDdXJyZW50VVJMLFxuICByZXNwb25zZVVSTCxcbiAgcmVzcG9uc2VMb2NhdGlvblVSTCxcbiAgaXNCbG9iTGlrZSxcbiAgaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5LFxuICBpc1ZhbGlkUmVhc29uUGhyYXNlLFxuICBzYW1lT3JpZ2luLFxuICBub3JtYWxpemVNZXRob2QsXG4gIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyxcbiAgaXRlcmF0b3JNaXhpbixcbiAgY3JlYXRlSXRlcmF0b3IsXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGlzRXJyb3JMaWtlLFxuICBmdWxseVJlYWRCb2R5LFxuICBieXRlc01hdGNoLFxuICBpc1JlYWRhYmxlU3RyZWFtTGlrZSxcbiAgcmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgaXNvbW9ycGhpY0VuY29kZSxcbiAgdXJsSXNMb2NhbCxcbiAgdXJsSGFzSHR0cHNTY2hlbWUsXG4gIHVybElzSHR0cEh0dHBzU2NoZW1lLFxuICByZWFkQWxsQnl0ZXMsXG4gIHNpbXBsZVJhbmdlSGVhZGVyVmFsdWUsXG4gIGJ1aWxkQ29udGVudFJhbmdlLFxuICBwYXJzZU1ldGFkYXRhLFxuICBjcmVhdGVJbmZsYXRlLFxuICBleHRyYWN0TWltZVR5cGUsXG4gIGdldERlY29kZVNwbGl0LFxuICB1dGY4RGVjb2RlQnl0ZXMsXG4gIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Rcbn1cbiJdLCJuYW1lcyI6WyJUcmFuc2Zvcm0iLCJyZXF1aXJlIiwiemxpYiIsInJlZGlyZWN0U3RhdHVzU2V0IiwicmVmZXJyZXJQb2xpY3lTZXQiLCJyZWZlcnJlclBvbGljeVRva2VucyIsImJhZFBvcnRzU2V0IiwiZ2V0R2xvYmFsT3JpZ2luIiwiY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyIsImNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmciLCJyZW1vdmVDaGFycyIsInBhcnNlTUlNRVR5cGUiLCJwZXJmb3JtYW5jZSIsImlzQmxvYkxpa2UiLCJSZWFkYWJsZVN0cmVhbUZyb20iLCJpc1ZhbGlkSFRUUFRva2VuIiwibm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlIiwiYXNzZXJ0IiwiaXNVaW50OEFycmF5Iiwid2ViaWRsIiwic3VwcG9ydGVkSGFzaGVzIiwiY3J5cHRvIiwicG9zc2libGVSZWxldmFudEhhc2hlcyIsImdldEhhc2hlcyIsImZpbHRlciIsImhhc2giLCJpbmNsdWRlcyIsInJlc3BvbnNlVVJMIiwicmVzcG9uc2UiLCJ1cmxMaXN0IiwibGVuZ3RoIiwidG9TdHJpbmciLCJyZXNwb25zZUxvY2F0aW9uVVJMIiwicmVxdWVzdEZyYWdtZW50IiwiaGFzIiwic3RhdHVzIiwibG9jYXRpb24iLCJoZWFkZXJzTGlzdCIsImdldCIsImlzVmFsaWRIZWFkZXJWYWx1ZSIsImlzVmFsaWRFbmNvZGVkVVJMIiwibm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4IiwiVVJMIiwidXJsIiwiaSIsImNvZGUiLCJjaGFyQ29kZUF0IiwidmFsdWUiLCJCdWZmZXIiLCJmcm9tIiwicmVxdWVzdEN1cnJlbnRVUkwiLCJyZXF1ZXN0IiwicmVxdWVzdEJhZFBvcnQiLCJ1cmxJc0h0dHBIdHRwc1NjaGVtZSIsInBvcnQiLCJpc0Vycm9yTGlrZSIsIm9iamVjdCIsIkVycm9yIiwibmFtZSIsImlzVmFsaWRSZWFzb25QaHJhc2UiLCJzdGF0dXNUZXh0IiwiYyIsImlzVmFsaWRIZWFkZXJOYW1lIiwicG90ZW50aWFsVmFsdWUiLCJzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0IiwiYWN0dWFsUmVzcG9uc2UiLCJwb2xpY3lIZWFkZXIiLCJzcGxpdCIsInBvbGljeSIsInRva2VuIiwidHJpbSIsInJlZmVycmVyUG9saWN5IiwiY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrIiwiY29yc0NoZWNrIiwiVEFPQ2hlY2siLCJhcHBlbmRGZXRjaE1ldGFkYXRhIiwiaHR0cFJlcXVlc3QiLCJoZWFkZXIiLCJtb2RlIiwic2V0IiwiYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciIsInNlcmlhbGl6ZWRPcmlnaW4iLCJvcmlnaW4iLCJ1bmRlZmluZWQiLCJyZXNwb25zZVRhaW50aW5nIiwiYXBwZW5kIiwibWV0aG9kIiwidXJsSGFzSHR0cHNTY2hlbWUiLCJzYW1lT3JpZ2luIiwiY29hcnNlblRpbWUiLCJ0aW1lc3RhbXAiLCJjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSIsImNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvIiwiY29ubmVjdGlvblRpbWluZ0luZm8iLCJkZWZhdWx0U3RhcnRUaW1lIiwic3RhcnRUaW1lIiwiZG9tYWluTG9va3VwU3RhcnRUaW1lIiwiZG9tYWluTG9va3VwRW5kVGltZSIsImNvbm5lY3Rpb25TdGFydFRpbWUiLCJjb25uZWN0aW9uRW5kVGltZSIsInNlY3VyZUNvbm5lY3Rpb25TdGFydFRpbWUiLCJBTFBOTmVnb3RpYXRlZFByb3RvY29sIiwiY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUiLCJub3ciLCJjcmVhdGVPcGFxdWVUaW1pbmdJbmZvIiwidGltaW5nSW5mbyIsInJlZGlyZWN0U3RhcnRUaW1lIiwicmVkaXJlY3RFbmRUaW1lIiwicG9zdFJlZGlyZWN0U3RhcnRUaW1lIiwiZmluYWxTZXJ2aWNlV29ya2VyU3RhcnRUaW1lIiwiZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWUiLCJmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lIiwiZW5kVGltZSIsImVuY29kZWRCb2R5U2l6ZSIsImRlY29kZWRCb2R5U2l6ZSIsImZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm8iLCJtYWtlUG9saWN5Q29udGFpbmVyIiwiY2xvbmVQb2xpY3lDb250YWluZXIiLCJwb2xpY3lDb250YWluZXIiLCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIiwicmVmZXJyZXJTb3VyY2UiLCJyZWZlcnJlciIsImdsb2JhbE9yaWdpbiIsInJlZmVycmVyVVJMIiwic3RyaXBVUkxGb3JSZWZlcnJlciIsInJlZmVycmVyT3JpZ2luIiwiYXJlU2FtZU9yaWdpbiIsImlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSIsImlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsImN1cnJlbnRVUkwiLCJvcmlnaW5Pbmx5IiwicHJvdG9jb2wiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicGF0aG5hbWUiLCJzZWFyY2giLCJocmVmIiwiaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5Iiwib3JpZ2luQXNVUkwiLCJ0ZXN0IiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImJ5dGVzTWF0Y2giLCJieXRlcyIsIm1ldGFkYXRhTGlzdCIsInBhcnNlZE1ldGFkYXRhIiwicGFyc2VNZXRhZGF0YSIsInN0cm9uZ2VzdCIsImdldFN0cm9uZ2VzdE1ldGFkYXRhIiwibWV0YWRhdGEiLCJmaWx0ZXJNZXRhZGF0YUxpc3RCeUFsZ29yaXRobSIsIml0ZW0iLCJhbGdvcml0aG0iLCJhbGdvIiwiZXhwZWN0ZWRWYWx1ZSIsImFjdHVhbFZhbHVlIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImRpZ2VzdCIsInNsaWNlIiwiY29tcGFyZUJhc2U2NE1peGVkIiwicGFyc2VIYXNoV2l0aE9wdGlvbnMiLCJyZXN1bHQiLCJlbXB0eSIsInBhcnNlZFRva2VuIiwiZXhlYyIsImdyb3VwcyIsInRvTG93ZXJDYXNlIiwicHVzaCIsInBvcyIsInRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCIsIkEiLCJCIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaXNBYm9ydGVkIiwiZmV0Y2hQYXJhbXMiLCJjb250cm9sbGVyIiwic3RhdGUiLCJpc0NhbmNlbGxlZCIsIm5vcm1hbGl6ZU1ldGhvZCIsInNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJUeXBlRXJyb3IiLCJlc0l0ZXJhdG9yUHJvdG90eXBlIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNyZWF0ZUl0ZXJhdG9yIiwia0ludGVybmFsSXRlcmF0b3IiLCJrZXlJbmRleCIsInZhbHVlSW5kZXgiLCJGYXN0SXRlcmFibGVJdGVyYXRvciIsInRhcmdldCIsImtpbmQiLCJuZXh0IiwiaW5kZXgiLCJ2YWx1ZXMiLCJsZW4iLCJkb25lIiwia2V5IiwicHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidG9TdHJpbmdUYWciLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJpdGVyYXRvck1peGluIiwibWFrZUl0ZXJhdG9yIiwicHJvcGVydGllcyIsImtleXMiLCJicmFuZENoZWNrIiwiZW50cmllcyIsImZvckVhY2giLCJjYWxsYmFja2ZuIiwidGhpc0FyZyIsImdsb2JhbFRoaXMiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiY2FsbCIsImZ1bGx5UmVhZEJvZHkiLCJib2R5IiwicHJvY2Vzc0JvZHkiLCJwcm9jZXNzQm9keUVycm9yIiwic3VjY2Vzc1N0ZXBzIiwiZXJyb3JTdGVwcyIsInJlYWRlciIsInN0cmVhbSIsImdldFJlYWRlciIsImUiLCJyZWFkQWxsQnl0ZXMiLCJpc1JlYWRhYmxlU3RyZWFtTGlrZSIsIlJlYWRhYmxlU3RyZWFtIiwidGVlIiwicmVhZGFibGVTdHJlYW1DbG9zZSIsImNsb3NlIiwiYnlvYlJlcXVlc3QiLCJyZXNwb25kIiwiZXJyIiwibWVzc2FnZSIsImludmFsaWRJc29tb3JwaGljRW5jb2RlVmFsdWVSZWdleCIsImlzb21vcnBoaWNFbmNvZGUiLCJpbnB1dCIsImJ5dGVMZW5ndGgiLCJjaHVuayIsInJlYWQiLCJjb25jYXQiLCJ1cmxJc0xvY2FsIiwic2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSIsImFsbG93V2hpdGVzcGFjZSIsImRhdGEiLCJzdGFydHNXaXRoIiwicG9zaXRpb24iLCJjaGFyIiwicmFuZ2VTdGFydCIsInJhbmdlU3RhcnRWYWx1ZSIsIk51bWJlciIsInJhbmdlRW5kIiwicmFuZ2VFbmRWYWx1ZSIsImJ1aWxkQ29udGVudFJhbmdlIiwiZnVsbExlbmd0aCIsImNvbnRlbnRSYW5nZSIsIkluZmxhdGVTdHJlYW0iLCJfdHJhbnNmb3JtIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsIl9pbmZsYXRlU3RyZWFtIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUluZmxhdGVSYXciLCJvbiIsImJpbmQiLCJkZXN0cm95Iiwid3JpdGUiLCJfZmluYWwiLCJlbmQiLCJleHRyYWN0TWltZVR5cGUiLCJoZWFkZXJzIiwiY2hhcnNldCIsImVzc2VuY2UiLCJtaW1lVHlwZSIsImdldERlY29kZVNwbGl0IiwidGVtcG9yYXJ5TWltZVR5cGUiLCJwYXJhbWV0ZXJzIiwiZ2V0dGluZ0RlY29kaW5nU3BsaXR0aW5nIiwidGVtcG9yYXJ5VmFsdWUiLCJsaXN0IiwidGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsInV0ZjhEZWNvZGVCeXRlcyIsImJ1ZmZlciIsInN1YmFycmF5Iiwib3V0cHV0IiwiZGVjb2RlIiwiRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdEJhc2UiLCJiYXNlVXJsIiwiRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCIsInNldHRpbmdzT2JqZWN0IiwiZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/webidl.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/webidl.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { types, inspect } = __webpack_require__(/*! node:util */ \"node:util\");\nconst { toUSVString } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\n/** @type {import('../../../types/webidl').Webidl} */ const webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\nwebidl.errors.exception = function(message) {\n    return new TypeError(`${message.header}: ${message.message}`);\n};\nwebidl.errors.conversionFailed = function(context) {\n    const plural = context.types.length === 1 ? '' : ' one of';\n    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(', ')}.`;\n    return webidl.errors.exception({\n        header: context.prefix,\n        message\n    });\n};\nwebidl.errors.invalidArgument = function(context) {\n    return webidl.errors.exception({\n        header: context.prefix,\n        message: `\"${context.value}\" is an invalid ${context.type}.`\n    });\n};\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function(V, I, opts) {\n    if (opts?.strict !== false) {\n        if (!(V instanceof I)) {\n            const err = new TypeError('Illegal invocation');\n            err.code = 'ERR_INVALID_THIS'; // node compat.\n            throw err;\n        }\n    } else {\n        if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {\n            const err = new TypeError('Illegal invocation');\n            err.code = 'ERR_INVALID_THIS'; // node compat.\n            throw err;\n        }\n    }\n};\nwebidl.argumentLengthCheck = function({ length }, min, ctx) {\n    if (length < min) {\n        throw webidl.errors.exception({\n            message: `${min} argument${min !== 1 ? 's' : ''} required, ` + `but${length ? ' only' : ''} ${length} found.`,\n            header: ctx\n        });\n    }\n};\nwebidl.illegalConstructor = function() {\n    throw webidl.errors.exception({\n        header: 'TypeError',\n        message: 'Illegal constructor'\n    });\n};\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function(V) {\n    switch(typeof V){\n        case 'undefined':\n            return 'Undefined';\n        case 'boolean':\n            return 'Boolean';\n        case 'string':\n            return 'String';\n        case 'symbol':\n            return 'Symbol';\n        case 'number':\n            return 'Number';\n        case 'bigint':\n            return 'BigInt';\n        case 'function':\n        case 'object':\n            {\n                if (V === null) {\n                    return 'Null';\n                }\n                return 'Object';\n            }\n    }\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {\n    let upperBound;\n    let lowerBound;\n    // 1. If bitLength is 64, then:\n    if (bitLength === 64) {\n        // 1. Let upperBound be 2^53 − 1.\n        upperBound = Math.pow(2, 53) - 1;\n        // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n        if (signedness === 'unsigned') {\n            lowerBound = 0;\n        } else {\n            // 3. Otherwise let lowerBound be −2^53 + 1.\n            lowerBound = Math.pow(-2, 53) + 1;\n        }\n    } else if (signedness === 'unsigned') {\n        // 2. Otherwise, if signedness is \"unsigned\", then:\n        // 1. Let lowerBound be 0.\n        lowerBound = 0;\n        // 2. Let upperBound be 2^bitLength − 1.\n        upperBound = Math.pow(2, bitLength) - 1;\n    } else {\n        // 3. Otherwise:\n        // 1. Let lowerBound be -2^bitLength − 1.\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        // 2. Let upperBound be 2^bitLength − 1 − 1.\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n    }\n    // 4. Let x be ? ToNumber(V).\n    let x = Number(V);\n    // 5. If x is −0, then set x to +0.\n    if (x === 0) {\n        x = 0;\n    }\n    // 6. If the conversion is to an IDL type associated\n    //    with the [EnforceRange] extended attribute, then:\n    if (opts?.enforceRange === true) {\n        // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n            throw webidl.errors.exception({\n                header: 'Integer conversion',\n                message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n            });\n        }\n        // 2. Set x to IntegerPart(x).\n        x = webidl.util.IntegerPart(x);\n        // 3. If x < lowerBound or x > upperBound, then\n        //    throw a TypeError.\n        if (x < lowerBound || x > upperBound) {\n            throw webidl.errors.exception({\n                header: 'Integer conversion',\n                message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n            });\n        }\n        // 4. Return x.\n        return x;\n    }\n    // 7. If x is not NaN and the conversion is to an IDL\n    //    type associated with the [Clamp] extended\n    //    attribute, then:\n    if (!Number.isNaN(x) && opts?.clamp === true) {\n        // 1. Set x to min(max(x, lowerBound), upperBound).\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        // 2. Round x to the nearest integer, choosing the\n        //    even integer if it lies halfway between two,\n        //    and choosing +0 rather than −0.\n        if (Math.floor(x) % 2 === 0) {\n            x = Math.floor(x);\n        } else {\n            x = Math.ceil(x);\n        }\n        // 3. Return x.\n        return x;\n    }\n    // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n        return 0;\n    }\n    // 9. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x);\n    // 10. Set x to x modulo 2^bitLength.\n    x = x % Math.pow(2, bitLength);\n    // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n    //    then return x − 2^bitLength.\n    if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n        return x - Math.pow(2, bitLength);\n    }\n    // 12. Otherwise, return x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function(n) {\n    // 1. Let r be floor(abs(n)).\n    const r = Math.floor(Math.abs(n));\n    // 2. If n < 0, then return -1 × r.\n    if (n < 0) {\n        return -1 * r;\n    }\n    // 3. Otherwise, return r.\n    return r;\n};\nwebidl.util.Stringify = function(V) {\n    const type = webidl.util.Type(V);\n    switch(type){\n        case 'Symbol':\n            return `Symbol(${V.description})`;\n        case 'Object':\n            return inspect(V);\n        case 'String':\n            return `\"${V}\"`;\n        default:\n            return `${V}`;\n    }\n};\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function(converter) {\n    return (V, prefix, argument, Iterable)=>{\n        // 1. If Type(V) is not Object, throw a TypeError.\n        if (webidl.util.Type(V) !== 'Object') {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n            });\n        }\n        // 2. Let method be ? GetMethod(V, @@iterator).\n        /** @type {Generator} */ const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.();\n        const seq = [];\n        let index = 0;\n        // 3. If method is undefined, throw a TypeError.\n        if (method === undefined || typeof method.next !== 'function') {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `${argument} is not iterable.`\n            });\n        }\n        // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n        while(true){\n            const { done, value } = method.next();\n            if (done) {\n                break;\n            }\n            seq.push(converter(value, prefix, `${argument}[${index++}]`));\n        }\n        return seq;\n    };\n};\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function(keyConverter, valueConverter) {\n    return (O, prefix, argument)=>{\n        // 1. If Type(O) is not Object, throw a TypeError.\n        if (webidl.util.Type(O) !== 'Object') {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `${argument} (\"${webidl.util.Type(O)}\") is not an Object.`\n            });\n        }\n        // 2. Let result be a new empty instance of record<K, V>.\n        const result = {};\n        if (!types.isProxy(O)) {\n            // 1. Let desc be ? O.[[GetOwnProperty]](key).\n            const keys = [\n                ...Object.getOwnPropertyNames(O),\n                ...Object.getOwnPropertySymbols(O)\n            ];\n            for (const key of keys){\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key, prefix, argument);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key], prefix, argument);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n            // 5. Return result.\n            return result;\n        }\n        // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n        const keys = Reflect.ownKeys(O);\n        // 4. For each key of keys.\n        for (const key of keys){\n            // 1. Let desc be ? O.[[GetOwnProperty]](key).\n            const desc = Reflect.getOwnPropertyDescriptor(O, key);\n            // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n            if (desc?.enumerable) {\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key, prefix, argument);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key], prefix, argument);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n        }\n        // 5. Return result.\n        return result;\n    };\n};\nwebidl.interfaceConverter = function(i) {\n    return (V, prefix, argument, opts)=>{\n        if (opts?.strict !== false && !(V instanceof i)) {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${i.name}.`\n            });\n        }\n        return V;\n    };\n};\nwebidl.dictionaryConverter = function(converters) {\n    return (dictionary, prefix, argument)=>{\n        const type = webidl.util.Type(dictionary);\n        const dict = {};\n        if (type === 'Null' || type === 'Undefined') {\n            return dict;\n        } else if (type !== 'Object') {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n            });\n        }\n        for (const options of converters){\n            const { key, defaultValue, required, converter } = options;\n            if (required === true) {\n                if (!Object.hasOwn(dictionary, key)) {\n                    throw webidl.errors.exception({\n                        header: prefix,\n                        message: `Missing required key \"${key}\".`\n                    });\n                }\n            }\n            let value = dictionary[key];\n            const hasDefault = Object.hasOwn(options, 'defaultValue');\n            // Only use defaultValue if value is undefined and\n            // a defaultValue options was provided.\n            if (hasDefault && value !== null) {\n                value ??= defaultValue();\n            }\n            // A key can be optional and have no default value.\n            // When this happens, do not perform a conversion,\n            // and do not assign the key a value.\n            if (required || hasDefault || value !== undefined) {\n                value = converter(value, prefix, `${argument}.${key}`);\n                if (options.allowedValues && !options.allowedValues.includes(value)) {\n                    throw webidl.errors.exception({\n                        header: prefix,\n                        message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n                    });\n                }\n                dict[key] = value;\n            }\n        }\n        return dict;\n    };\n};\nwebidl.nullableConverter = function(converter) {\n    return (V, prefix, argument)=>{\n        if (V === null) {\n            return V;\n        }\n        return converter(V, prefix, argument);\n    };\n};\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function(V, prefix, argument, opts) {\n    // 1. If V is null and the conversion is to an IDL type\n    //    associated with the [LegacyNullToEmptyString]\n    //    extended attribute, then return the DOMString value\n    //    that represents the empty string.\n    if (V === null && opts?.legacyNullToEmptyString) {\n        return '';\n    }\n    // 2. Let x be ? ToString(V).\n    if (typeof V === 'symbol') {\n        throw webidl.errors.exception({\n            header: prefix,\n            message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n        });\n    }\n    // 3. Return the IDL DOMString value that represents the\n    //    same sequence of code units as the one the\n    //    ECMAScript String value x represents.\n    return String(V);\n};\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function(V, prefix, argument) {\n    // 1. Let x be ? ToString(V).\n    // Note: DOMString converter perform ? ToString(V)\n    const x = webidl.converters.DOMString(V, prefix, argument);\n    // 2. If the value of any element of x is greater than\n    //    255, then throw a TypeError.\n    for(let index = 0; index < x.length; index++){\n        if (x.charCodeAt(index) > 255) {\n            throw new TypeError('Cannot convert argument to a ByteString because the character at ' + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);\n        }\n    }\n    // 3. Return an IDL ByteString value whose length is the\n    //    length of x, and where the value of each element is\n    //    the value of the corresponding element of x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: rewrite this so we can control the errors thrown\nwebidl.converters.USVString = toUSVString;\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function(V) {\n    // 1. Let x be the result of computing ToBoolean(V).\n    const x = Boolean(V);\n    // 2. Return the IDL boolean value that is the one that represents\n    //    the same truth value as the ECMAScript Boolean value x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function(V) {\n    return V;\n};\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function(V, prefix, argument) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n    const x = webidl.util.ConvertToInt(V, 64, 'signed', undefined, prefix, argument);\n    // 2. Return the IDL long long value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function(V, prefix, argument) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 64, 'unsigned', undefined, prefix, argument);\n    // 2. Return the IDL unsigned long long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function(V, prefix, argument) {\n    // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 32, 'unsigned', undefined, prefix, argument);\n    // 2. Return the IDL unsigned long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function(V, prefix, argument, opts) {\n    // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts, prefix, argument);\n    // 2. Return the IDL unsigned short value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {\n    // 1. If Type(V) is not Object, or V does not have an\n    //    [[ArrayBufferData]] internal slot, then throw a\n    //    TypeError.\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n    if (webidl.util.Type(V) !== 'Object' || !types.isAnyArrayBuffer(V)) {\n        throw webidl.errors.conversionFailed({\n            prefix,\n            argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n            types: [\n                'ArrayBuffer'\n            ]\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {\n        throw webidl.errors.exception({\n            header: 'ArrayBuffer',\n            message: 'SharedArrayBuffer is not allowed.'\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    if (V.resizable || V.growable) {\n        throw webidl.errors.exception({\n            header: 'ArrayBuffer',\n            message: 'Received a resizable ArrayBuffer.'\n        });\n    }\n    // 4. Return the IDL ArrayBuffer value that is a\n    //    reference to the same object as V.\n    return V;\n};\nwebidl.converters.TypedArray = function(V, T, prefix, name, opts) {\n    // 1. Let T be the IDL type V is being converted to.\n    // 2. If Type(V) is not Object, or V does not have a\n    //    [[TypedArrayName]] internal slot with a value\n    //    equal to T’s name, then throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object' || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n        throw webidl.errors.conversionFailed({\n            prefix,\n            argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n            types: [\n                T.name\n            ]\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: 'ArrayBuffer',\n            message: 'SharedArrayBuffer is not allowed.'\n        });\n    }\n    // 4. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (V.buffer.resizable || V.buffer.growable) {\n        throw webidl.errors.exception({\n            header: 'ArrayBuffer',\n            message: 'Received a resizable ArrayBuffer.'\n        });\n    }\n    // 5. Return the IDL value of type T that is a reference\n    //    to the same object as V.\n    return V;\n};\nwebidl.converters.DataView = function(V, prefix, name, opts) {\n    // 1. If Type(V) is not Object, or V does not have a\n    //    [[DataView]] internal slot, then throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n        throw webidl.errors.exception({\n            header: prefix,\n            message: `${name} is not a DataView.`\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n    //    then throw a TypeError.\n    if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: 'ArrayBuffer',\n            message: 'SharedArrayBuffer is not allowed.'\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (V.buffer.resizable || V.buffer.growable) {\n        throw webidl.errors.exception({\n            header: 'ArrayBuffer',\n            message: 'Received a resizable ArrayBuffer.'\n        });\n    }\n    // 4. Return the IDL DataView value that is a reference\n    //    to the same object as V.\n    return V;\n};\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function(V, prefix, name, opts) {\n    if (types.isAnyArrayBuffer(V)) {\n        return webidl.converters.ArrayBuffer(V, prefix, name, {\n            ...opts,\n            allowShared: false\n        });\n    }\n    if (types.isTypedArray(V)) {\n        return webidl.converters.TypedArray(V, V.constructor, prefix, name, {\n            ...opts,\n            allowShared: false\n        });\n    }\n    if (types.isDataView(V)) {\n        return webidl.converters.DataView(V, prefix, name, {\n            ...opts,\n            allowShared: false\n        });\n    }\n    throw webidl.errors.conversionFailed({\n        prefix,\n        argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n        types: [\n            'BufferSource'\n        ]\n    });\n};\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(webidl.converters['sequence<ByteString>']);\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n    webidl\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvd2ViaWRsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxLQUFLLEVBQUVDLE9BQU8sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyw0QkFBVztBQUM5QyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxxRUFBaUI7QUFFakQsbURBQW1ELEdBQ25ELE1BQU1FLFNBQVMsQ0FBQztBQUNoQkEsT0FBT0MsVUFBVSxHQUFHLENBQUM7QUFDckJELE9BQU9FLElBQUksR0FBRyxDQUFDO0FBQ2ZGLE9BQU9HLE1BQU0sR0FBRyxDQUFDO0FBRWpCSCxPQUFPRyxNQUFNLENBQUNDLFNBQVMsR0FBRyxTQUFVQyxPQUFPO0lBQ3pDLE9BQU8sSUFBSUMsVUFBVSxHQUFHRCxRQUFRRSxNQUFNLENBQUMsRUFBRSxFQUFFRixRQUFRQSxPQUFPLEVBQUU7QUFDOUQ7QUFFQUwsT0FBT0csTUFBTSxDQUFDSyxnQkFBZ0IsR0FBRyxTQUFVQyxPQUFPO0lBQ2hELE1BQU1DLFNBQVNELFFBQVFiLEtBQUssQ0FBQ2UsTUFBTSxLQUFLLElBQUksS0FBSztJQUNqRCxNQUFNTixVQUNKLEdBQUdJLFFBQVFHLFFBQVEsQ0FBQywwQkFBMEIsQ0FBQyxHQUMvQyxHQUFHRixPQUFPLEVBQUUsRUFBRUQsUUFBUWIsS0FBSyxDQUFDaUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTNDLE9BQU9iLE9BQU9HLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDO1FBQzdCRyxRQUFRRSxRQUFRSyxNQUFNO1FBQ3RCVDtJQUNGO0FBQ0Y7QUFFQUwsT0FBT0csTUFBTSxDQUFDWSxlQUFlLEdBQUcsU0FBVU4sT0FBTztJQUMvQyxPQUFPVCxPQUFPRyxNQUFNLENBQUNDLFNBQVMsQ0FBQztRQUM3QkcsUUFBUUUsUUFBUUssTUFBTTtRQUN0QlQsU0FBUyxDQUFDLENBQUMsRUFBRUksUUFBUU8sS0FBSyxDQUFDLGdC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QUMxRXJFLE9BQU9DLFVBQVUsQ0FBQ3NHLFVBQVUsRUFDNUJ2RyxPQUFPQyxVQUFVLENBQUNzRyxVQUFVO0FBRzlCbUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2YzSDtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXHdlYmlkbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB0eXBlcywgaW5zcGVjdCB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcy93ZWJpZGwnKS5XZWJpZGx9ICovXG5jb25zdCB3ZWJpZGwgPSB7fVxud2ViaWRsLmNvbnZlcnRlcnMgPSB7fVxud2ViaWRsLnV0aWwgPSB7fVxud2ViaWRsLmVycm9ycyA9IHt9XG5cbndlYmlkbC5lcnJvcnMuZXhjZXB0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYCR7bWVzc2FnZS5oZWFkZXJ9OiAke21lc3NhZ2UubWVzc2FnZX1gKVxufVxuXG53ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBwbHVyYWwgPSBjb250ZXh0LnR5cGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJyBvbmUgb2YnXG4gIGNvbnN0IG1lc3NhZ2UgPVxuICAgIGAke2NvbnRleHQuYXJndW1lbnR9IGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG9gICtcbiAgICBgJHtwbHVyYWx9OiAke2NvbnRleHQudHlwZXMuam9pbignLCAnKX0uYFxuXG4gIHJldHVybiB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiBjb250ZXh0LnByZWZpeCxcbiAgICBtZXNzYWdlXG4gIH0pXG59XG5cbndlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6IGNvbnRleHQucHJlZml4LFxuICAgIG1lc3NhZ2U6IGBcIiR7Y29udGV4dC52YWx1ZX1cIiBpcyBhbiBpbnZhbGlkICR7Y29udGV4dC50eXBlfS5gXG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaW1wbGVtZW50c1xud2ViaWRsLmJyYW5kQ2hlY2sgPSBmdW5jdGlvbiAoViwgSSwgb3B0cykge1xuICBpZiAob3B0cz8uc3RyaWN0ICE9PSBmYWxzZSkge1xuICAgIGlmICghKFYgaW5zdGFuY2VvZiBJKSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgICAgIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX1RISVMnIC8vIG5vZGUgY29tcGF0LlxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChWPy5bU3ltYm9sLnRvU3RyaW5nVGFnXSAhPT0gSS5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgICAgIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX1RISVMnIC8vIG5vZGUgY29tcGF0LlxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbndlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrID0gZnVuY3Rpb24gKHsgbGVuZ3RoIH0sIG1pbiwgY3R4KSB7XG4gIGlmIChsZW5ndGggPCBtaW4pIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBtZXNzYWdlOiBgJHttaW59IGFyZ3VtZW50JHttaW4gIT09IDEgPyAncycgOiAnJ30gcmVxdWlyZWQsIGAgK1xuICAgICAgICAgICAgICAgYGJ1dCR7bGVuZ3RoID8gJyBvbmx5JyA6ICcnfSAke2xlbmd0aH0gZm91bmQuYCxcbiAgICAgIGhlYWRlcjogY3R4XG4gICAgfSlcbiAgfVxufVxuXG53ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiAnVHlwZUVycm9yJyxcbiAgICBtZXNzYWdlOiAnSWxsZWdhbCBjb25zdHJ1Y3RvcidcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xud2ViaWRsLnV0aWwuVHlwZSA9IGZ1bmN0aW9uIChWKSB7XG4gIHN3aXRjaCAodHlwZW9mIFYpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gJ1VuZGVmaW5lZCdcbiAgICBjYXNlICdib29sZWFuJzogcmV0dXJuICdCb29sZWFuJ1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiAnU3RyaW5nJ1xuICAgIGNhc2UgJ3N5bWJvbCc6IHJldHVybiAnU3ltYm9sJ1xuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnTnVtYmVyJ1xuICAgIGNhc2UgJ2JpZ2ludCc6IHJldHVybiAnQmlnSW50J1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICBpZiAoViA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ051bGwnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT2JqZWN0J1xuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWNvbnZlcnR0b2ludFxud2ViaWRsLnV0aWwuQ29udmVydFRvSW50ID0gZnVuY3Rpb24gKFYsIGJpdExlbmd0aCwgc2lnbmVkbmVzcywgb3B0cykge1xuICBsZXQgdXBwZXJCb3VuZFxuICBsZXQgbG93ZXJCb3VuZFxuXG4gIC8vIDEuIElmIGJpdExlbmd0aCBpcyA2NCwgdGhlbjpcbiAgaWYgKGJpdExlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyAxLiBMZXQgdXBwZXJCb3VuZCBiZSAyXjUzIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCA1MykgLSAxXG5cbiAgICAvLyAyLiBJZiBzaWduZWRuZXNzIGlzIFwidW5zaWduZWRcIiwgdGhlbiBsZXQgbG93ZXJCb3VuZCBiZSAwLlxuICAgIGlmIChzaWduZWRuZXNzID09PSAndW5zaWduZWQnKSB7XG4gICAgICBsb3dlckJvdW5kID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBPdGhlcndpc2UgbGV0IGxvd2VyQm91bmQgYmUg4oiSMl41MyArIDEuXG4gICAgICBsb3dlckJvdW5kID0gTWF0aC5wb3coLTIsIDUzKSArIDFcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2lnbmVkbmVzcyA9PT0gJ3Vuc2lnbmVkJykge1xuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgc2lnbmVkbmVzcyBpcyBcInVuc2lnbmVkXCIsIHRoZW46XG5cbiAgICAvLyAxLiBMZXQgbG93ZXJCb3VuZCBiZSAwLlxuICAgIGxvd2VyQm91bmQgPSAwXG5cbiAgICAvLyAyLiBMZXQgdXBwZXJCb3VuZCBiZSAyXmJpdExlbmd0aCDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDFcbiAgfSBlbHNlIHtcbiAgICAvLyAzLiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBMZXQgbG93ZXJCb3VuZCBiZSAtMl5iaXRMZW5ndGgg4oiSIDEuXG4gICAgbG93ZXJCb3VuZCA9IE1hdGgucG93KC0yLCBiaXRMZW5ndGgpIC0gMVxuXG4gICAgLy8gMi4gTGV0IHVwcGVyQm91bmQgYmUgMl5iaXRMZW5ndGgg4oiSIDEg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCAtIDEpIC0gMVxuICB9XG5cbiAgLy8gNC4gTGV0IHggYmUgPyBUb051bWJlcihWKS5cbiAgbGV0IHggPSBOdW1iZXIoVilcblxuICAvLyA1LiBJZiB4IGlzIOKIkjAsIHRoZW4gc2V0IHggdG8gKzAuXG4gIGlmICh4ID09PSAwKSB7XG4gICAgeCA9IDBcbiAgfVxuXG4gIC8vIDYuIElmIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0VuZm9yY2VSYW5nZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCB0aGVuOlxuICBpZiAob3B0cz8uZW5mb3JjZVJhbmdlID09PSB0cnVlKSB7XG4gICAgLy8gMS4gSWYgeCBpcyBOYU4sICviiJ4sIG9yIOKIkuKIniwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICBOdW1iZXIuaXNOYU4oeCkgfHxcbiAgICAgIHggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgICAgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0ludGVnZXIgY29udmVyc2lvbicsXG4gICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgY29udmVydCAke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX0gdG8gYW4gaW50ZWdlci5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICAgIHggPSB3ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCh4KVxuXG4gICAgLy8gMy4gSWYgeCA8IGxvd2VyQm91bmQgb3IgeCA+IHVwcGVyQm91bmQsIHRoZW5cbiAgICAvLyAgICB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnSW50ZWdlciBjb252ZXJzaW9uJyxcbiAgICAgICAgbWVzc2FnZTogYFZhbHVlIG11c3QgYmUgYmV0d2VlbiAke2xvd2VyQm91bmR9LSR7dXBwZXJCb3VuZH0sIGdvdCAke3h9LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNC4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDcuIElmIHggaXMgbm90IE5hTiBhbmQgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMXG4gIC8vICAgIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBbQ2xhbXBdIGV4dGVuZGVkXG4gIC8vICAgIGF0dHJpYnV0ZSwgdGhlbjpcbiAgaWYgKCFOdW1iZXIuaXNOYU4oeCkgJiYgb3B0cz8uY2xhbXAgPT09IHRydWUpIHtcbiAgICAvLyAxLiBTZXQgeCB0byBtaW4obWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKS5cbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpXG5cbiAgICAvLyAyLiBSb3VuZCB4IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGNob29zaW5nIHRoZVxuICAgIC8vICAgIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28sXG4gICAgLy8gICAgYW5kIGNob29zaW5nICswIHJhdGhlciB0aGFuIOKIkjAuXG4gICAgaWYgKE1hdGguZmxvb3IoeCkgJSAyID09PSAwKSB7XG4gICAgICB4ID0gTWF0aC5mbG9vcih4KVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gTWF0aC5jZWlsKHgpXG4gICAgfVxuXG4gICAgLy8gMy4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDguIElmIHggaXMgTmFOLCArMCwgK+KIniwgb3Ig4oiS4oieLCB0aGVuIHJldHVybiArMC5cbiAgaWYgKFxuICAgIE51bWJlci5pc05hTih4KSB8fFxuICAgICh4ID09PSAwICYmIE9iamVjdC5pcygwLCB4KSkgfHxcbiAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIDkuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAvLyAxMC4gU2V0IHggdG8geCBtb2R1bG8gMl5iaXRMZW5ndGguXG4gIHggPSB4ICUgTWF0aC5wb3coMiwgYml0TGVuZ3RoKVxuXG4gIC8vIDExLiBJZiBzaWduZWRuZXNzIGlzIFwic2lnbmVkXCIgYW5kIHgg4omlIDJeYml0TGVuZ3RoIOKIkiAxLFxuICAvLyAgICB0aGVuIHJldHVybiB4IOKIkiAyXmJpdExlbmd0aC5cbiAgaWYgKHNpZ25lZG5lc3MgPT09ICdzaWduZWQnICYmIHggPj0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDEpIHtcbiAgICByZXR1cm4geCAtIE1hdGgucG93KDIsIGJpdExlbmd0aClcbiAgfVxuXG4gIC8vIDEyLiBPdGhlcndpc2UsIHJldHVybiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWludGVnZXJwYXJ0XG53ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCA9IGZ1bmN0aW9uIChuKSB7XG4gIC8vIDEuIExldCByIGJlIGZsb29yKGFicyhuKSkuXG4gIGNvbnN0IHIgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKVxuXG4gIC8vIDIuIElmIG4gPCAwLCB0aGVuIHJldHVybiAtMSDDlyByLlxuICBpZiAobiA8IDApIHtcbiAgICByZXR1cm4gLTEgKiByXG4gIH1cblxuICAvLyAzLiBPdGhlcndpc2UsIHJldHVybiByLlxuICByZXR1cm4gclxufVxuXG53ZWJpZGwudXRpbC5TdHJpbmdpZnkgPSBmdW5jdGlvbiAoVikge1xuICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShWKVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgICByZXR1cm4gYFN5bWJvbCgke1YuZGVzY3JpcHRpb259KWBcbiAgICBjYXNlICdPYmplY3QnOlxuICAgICAgcmV0dXJuIGluc3BlY3QoVilcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgcmV0dXJuIGBcIiR7Vn1cImBcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGAke1Z9YFxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtc2VxdWVuY2VcbndlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBJdGVyYWJsZSkgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gKCR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfSkgaXMgbm90IGl0ZXJhYmxlLmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IG1ldGhvZCBiZSA/IEdldE1ldGhvZChWLCBAQGl0ZXJhdG9yKS5cbiAgICAvKiogQHR5cGUge0dlbmVyYXRvcn0gKi9cbiAgICBjb25zdCBtZXRob2QgPSB0eXBlb2YgSXRlcmFibGUgPT09ICdmdW5jdGlvbicgPyBJdGVyYWJsZSgpIDogVj8uW1N5bWJvbC5pdGVyYXRvcl0/LigpXG4gICAgY29uc3Qgc2VxID0gW11cbiAgICBsZXQgaW5kZXggPSAwXG5cbiAgICAvLyAzLiBJZiBtZXRob2QgaXMgdW5kZWZpbmVkLCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICBtZXRob2QgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdHlwZW9mIG1ldGhvZC5uZXh0ICE9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gaXMgbm90IGl0ZXJhYmxlLmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNjcmVhdGUtc2VxdWVuY2UtZnJvbS1pdGVyYWJsZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBtZXRob2QubmV4dCgpXG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHNlcS5wdXNoKGNvbnZlcnRlcih2YWx1ZSwgcHJlZml4LCBgJHthcmd1bWVudH1bJHtpbmRleCsrfV1gKSlcbiAgICB9XG5cbiAgICByZXR1cm4gc2VxXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy10by1yZWNvcmRcbndlYmlkbC5yZWNvcmRDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoa2V5Q29udmVydGVyLCB2YWx1ZUNvbnZlcnRlcikge1xuICByZXR1cm4gKE8sIHByZWZpeCwgYXJndW1lbnQpID0+IHtcbiAgICAvLyAxLiBJZiBUeXBlKE8pIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuVHlwZShPKX1cIikgaXMgbm90IGFuIE9iamVjdC5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCByZXN1bHQgYmUgYSBuZXcgZW1wdHkgaW5zdGFuY2Ugb2YgcmVjb3JkPEssIFY+LlxuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG5cbiAgICBpZiAoIXR5cGVzLmlzUHJveHkoTykpIHtcbiAgICAgIC8vIDEuIExldCBkZXNjIGJlID8gTy5bW0dldE93blByb3BlcnR5XV0oa2V5KS5cbiAgICAgIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTyksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTyldXG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGVkS2V5IGJlIGtleSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgSy5cbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXlDb252ZXJ0ZXIoa2V5LCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSwgcHJlZml4LCBhcmd1bWVudClcblxuICAgICAgICAvLyA0LiBTZXQgcmVzdWx0W3R5cGVkS2V5XSB0byB0eXBlZFZhbHVlLlxuICAgICAgICByZXN1bHRbdHlwZWRLZXldID0gdHlwZWRWYWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyA1LiBSZXR1cm4gcmVzdWx0LlxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIDMuIExldCBrZXlzIGJlID8gTy5bW093blByb3BlcnR5S2V5c11dKCkuXG4gICAgY29uc3Qga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhPKVxuXG4gICAgLy8gNC4gRm9yIGVhY2gga2V5IG9mIGtleXMuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgLy8gMS4gTGV0IGRlc2MgYmUgPyBPLltbR2V0T3duUHJvcGVydHldXShrZXkpLlxuICAgICAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSlcblxuICAgICAgLy8gMi4gSWYgZGVzYyBpcyBub3QgdW5kZWZpbmVkIGFuZCBkZXNjLltbRW51bWVyYWJsZV1dIGlzIHRydWU6XG4gICAgICBpZiAoZGVzYz8uZW51bWVyYWJsZSkge1xuICAgICAgICAvLyAxLiBMZXQgdHlwZWRLZXkgYmUga2V5IGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBLLlxuICAgICAgICBjb25zdCB0eXBlZEtleSA9IGtleUNvbnZlcnRlcihrZXksIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgICAgICAgLy8gMi4gTGV0IHZhbHVlIGJlID8gR2V0KE8sIGtleSkuXG4gICAgICAgIC8vIDMuIExldCB0eXBlZFZhbHVlIGJlIHZhbHVlIGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBWLlxuICAgICAgICBjb25zdCB0eXBlZFZhbHVlID0gdmFsdWVDb252ZXJ0ZXIoT1trZXldLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gICAgICAgIC8vIDQuIFNldCByZXN1bHRbdHlwZWRLZXldIHRvIHR5cGVkVmFsdWUuXG4gICAgICAgIHJlc3VsdFt0eXBlZEtleV0gPSB0eXBlZFZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4gUmV0dXJuIHJlc3VsdC5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxud2ViaWRsLmludGVyZmFjZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiAoViwgcHJlZml4LCBhcmd1bWVudCwgb3B0cykgPT4ge1xuICAgIGlmIChvcHRzPy5zdHJpY3QgIT09IGZhbHNlICYmICEoViBpbnN0YW5jZW9mIGkpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJHthcmd1bWVudH0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpIHRvIGJlIGFuIGluc3RhbmNlIG9mICR7aS5uYW1lfS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBWXG4gIH1cbn1cblxud2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVycykge1xuICByZXR1cm4gKGRpY3Rpb25hcnksIHByZWZpeCwgYXJndW1lbnQpID0+IHtcbiAgICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShkaWN0aW9uYXJ5KVxuICAgIGNvbnN0IGRpY3QgPSB7fVxuXG4gICAgaWYgKHR5cGUgPT09ICdOdWxsJyB8fCB0eXBlID09PSAnVW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRpY3RcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJHtkaWN0aW9uYXJ5fSB0byBiZSBvbmUgb2Y6IE51bGwsIFVuZGVmaW5lZCwgT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBvcHRpb25zIG9mIGNvbnZlcnRlcnMpIHtcbiAgICAgIGNvbnN0IHsga2V5LCBkZWZhdWx0VmFsdWUsIHJlcXVpcmVkLCBjb252ZXJ0ZXIgfSA9IG9wdGlvbnNcblxuICAgICAgaWYgKHJlcXVpcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihkaWN0aW9uYXJ5LCBrZXkpKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgICBtZXNzYWdlOiBgTWlzc2luZyByZXF1aXJlZCBrZXkgXCIke2tleX1cIi5gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWUgPSBkaWN0aW9uYXJ5W2tleV1cbiAgICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBPYmplY3QuaGFzT3duKG9wdGlvbnMsICdkZWZhdWx0VmFsdWUnKVxuXG4gICAgICAvLyBPbmx5IHVzZSBkZWZhdWx0VmFsdWUgaWYgdmFsdWUgaXMgdW5kZWZpbmVkIGFuZFxuICAgICAgLy8gYSBkZWZhdWx0VmFsdWUgb3B0aW9ucyB3YXMgcHJvdmlkZWQuXG4gICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA/Pz0gZGVmYXVsdFZhbHVlKClcbiAgICAgIH1cblxuICAgICAgLy8gQSBrZXkgY2FuIGJlIG9wdGlvbmFsIGFuZCBoYXZlIG5vIGRlZmF1bHQgdmFsdWUuXG4gICAgICAvLyBXaGVuIHRoaXMgaGFwcGVucywgZG8gbm90IHBlcmZvcm0gYSBjb252ZXJzaW9uLFxuICAgICAgLy8gYW5kIGRvIG5vdCBhc3NpZ24gdGhlIGtleSBhIHZhbHVlLlxuICAgICAgaWYgKHJlcXVpcmVkIHx8IGhhc0RlZmF1bHQgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IGNvbnZlcnRlcih2YWx1ZSwgcHJlZml4LCBgJHthcmd1bWVudH0uJHtrZXl9YClcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgb3B0aW9ucy5hbGxvd2VkVmFsdWVzICYmXG4gICAgICAgICAgIW9wdGlvbnMuYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHt2YWx1ZX0gaXMgbm90IGFuIGFjY2VwdGVkIHR5cGUuIEV4cGVjdGVkIG9uZSBvZiAke29wdGlvbnMuYWxsb3dlZFZhbHVlcy5qb2luKCcsICcpfS5gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGRpY3Rba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpY3RcbiAgfVxufVxuXG53ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoViwgcHJlZml4LCBhcmd1bWVudCkgPT4ge1xuICAgIGlmIChWID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gVlxuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0ZXIoViwgcHJlZml4LCBhcmd1bWVudClcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLURPTVN0cmluZ1xud2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQsIG9wdHMpIHtcbiAgLy8gMS4gSWYgViBpcyBudWxsIGFuZCB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJREwgdHlwZVxuICAvLyAgICBhc3NvY2lhdGVkIHdpdGggdGhlIFtMZWdhY3lOdWxsVG9FbXB0eVN0cmluZ11cbiAgLy8gICAgZXh0ZW5kZWQgYXR0cmlidXRlLCB0aGVuIHJldHVybiB0aGUgRE9NU3RyaW5nIHZhbHVlXG4gIC8vICAgIHRoYXQgcmVwcmVzZW50cyB0aGUgZW1wdHkgc3RyaW5nLlxuICBpZiAoViA9PT0gbnVsbCAmJiBvcHRzPy5sZWdhY3lOdWxsVG9FbXB0eVN0cmluZykge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gMi4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgaWYgKHR5cGVvZiBWID09PSAnc3ltYm9sJykge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IGlzIGEgc3ltYm9sLCB3aGljaCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgRE9NU3RyaW5nLmBcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHRoZSBJREwgRE9NU3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgLy8gICAgc2FtZSBzZXF1ZW5jZSBvZiBjb2RlIHVuaXRzIGFzIHRoZSBvbmUgdGhlXG4gIC8vICAgIEVDTUFTY3JpcHQgU3RyaW5nIHZhbHVlIHggcmVwcmVzZW50cy5cbiAgcmV0dXJuIFN0cmluZyhWKVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLUJ5dGVTdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IFRvU3RyaW5nKFYpLlxuICAvLyBOb3RlOiBET01TdHJpbmcgY29udmVydGVyIHBlcmZvcm0gPyBUb1N0cmluZyhWKVxuICBjb25zdCB4ID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gSWYgdGhlIHZhbHVlIG9mIGFueSBlbGVtZW50IG9mIHggaXMgZ3JlYXRlciB0aGFuXG4gIC8vICAgIDI1NSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKHguY2hhckNvZGVBdChpbmRleCkgPiAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgY29udmVydCBhcmd1bWVudCB0byBhIEJ5dGVTdHJpbmcgYmVjYXVzZSB0aGUgY2hhcmFjdGVyIGF0ICcgK1xuICAgICAgICBgaW5kZXggJHtpbmRleH0gaGFzIGEgdmFsdWUgb2YgJHt4LmNoYXJDb2RlQXQoaW5kZXgpfSB3aGljaCBpcyBncmVhdGVyIHRoYW4gMjU1LmBcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYW4gSURMIEJ5dGVTdHJpbmcgdmFsdWUgd2hvc2UgbGVuZ3RoIGlzIHRoZVxuICAvLyAgICBsZW5ndGggb2YgeCwgYW5kIHdoZXJlIHRoZSB2YWx1ZSBvZiBlYWNoIGVsZW1lbnQgaXNcbiAgLy8gICAgdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1VU1ZTdHJpbmdcbi8vIFRPRE86IHJld3JpdGUgdGhpcyBzbyB3ZSBjYW4gY29udHJvbCB0aGUgZXJyb3JzIHRocm93blxud2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nID0gdG9VU1ZTdHJpbmdcblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ib29sZWFuXG53ZWJpZGwuY29udmVydGVycy5ib29sZWFuID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgdGhlIHJlc3VsdCBvZiBjb21wdXRpbmcgVG9Cb29sZWFuKFYpLlxuICBjb25zdCB4ID0gQm9vbGVhbihWKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIGJvb2xlYW4gdmFsdWUgdGhhdCBpcyB0aGUgb25lIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSB0cnV0aCB2YWx1ZSBhcyB0aGUgRUNNQVNjcmlwdCBCb29sZWFuIHZhbHVlIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtYW55XG53ZWJpZGwuY29udmVydGVycy5hbnkgPSBmdW5jdGlvbiAoVikge1xuICByZXR1cm4gVlxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWxvbmctbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgNjQsIFwic2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDY0LCAnc2lnbmVkJywgdW5kZWZpbmVkLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIGxvbmcgbG9uZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLWxvbmctbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcgbG9uZyddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgNjQsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgNjQsICd1bnNpZ25lZCcsIHVuZGVmaW5lZCwgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBsb25nIGxvbmcgdmFsdWUgdGhhdFxuICAvLyAgICByZXByZXNlbnRzIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1sb25nXG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgMzIsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMzIsICd1bnNpZ25lZCcsIHVuZGVmaW5lZCwgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBsb25nIHZhbHVlIHRoYXRcbiAgLy8gICAgcmVwcmVzZW50cyB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtc2hvcnRcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQsIG9wdHMpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgMTYsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMTYsICd1bnNpZ25lZCcsIG9wdHMsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgc2hvcnQgdmFsdWUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpZGwtQXJyYXlCdWZmZXJcbndlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQsIG9wdHMpIHtcbiAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYW5cbiAgLy8gICAgW1tBcnJheUJ1ZmZlckRhdGFdXSBpbnRlcm5hbCBzbG90LCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICAvLyBzZWU6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvcGVydGllcy1vZi10aGUtYXJyYXlidWZmZXItaW5zdGFuY2VzXG4gIC8vIHNlZTogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1zaGFyZWRhcnJheWJ1ZmZlci1pbnN0YW5jZXNcbiAgaWYgKFxuICAgIHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8XG4gICAgIXR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVilcbiAgKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeCxcbiAgICAgIGFyZ3VtZW50OiBgJHthcmd1bWVudH0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpYCxcbiAgICAgIHR5cGVzOiBbJ0FycmF5QnVmZmVyJ11cbiAgICB9KVxuICB9XG5cbiAgLy8gMi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYpIGlzIHRydWUsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIGlmIChvcHRzPy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWKSBpcyB0cnVlLCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICBpZiAoVi5yZXNpemFibGUgfHwgVi5ncm93YWJsZSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIEFycmF5QnVmZmVyIHZhbHVlIHRoYXQgaXMgYVxuICAvLyAgICByZWZlcmVuY2UgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoViwgVCwgcHJlZml4LCBuYW1lLCBvcHRzKSB7XG4gIC8vIDEuIExldCBUIGJlIHRoZSBJREwgdHlwZSBWIGlzIGJlaW5nIGNvbnZlcnRlZCB0by5cblxuICAvLyAyLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhXG4gIC8vICAgIFtbVHlwZWRBcnJheU5hbWVdXSBpbnRlcm5hbCBzbG90IHdpdGggYSB2YWx1ZVxuICAvLyAgICBlcXVhbCB0byBU4oCZcyBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoXG4gICAgd2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcgfHxcbiAgICAhdHlwZXMuaXNUeXBlZEFycmF5KFYpIHx8XG4gICAgVi5jb25zdHJ1Y3Rvci5uYW1lICE9PSBULm5hbWVcbiAgKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeCxcbiAgICAgIGFyZ3VtZW50OiBgJHtuYW1lfSAoXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIilgLFxuICAgICAgdHlwZXM6IFtULm5hbWVdXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKG9wdHM/LmFsbG93U2hhcmVkID09PSBmYWxzZSAmJiB0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYuYnVmZmVyKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKFYuYnVmZmVyLnJlc2l6YWJsZSB8fCBWLmJ1ZmZlci5ncm93YWJsZSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDUuIFJldHVybiB0aGUgSURMIHZhbHVlIG9mIHR5cGUgVCB0aGF0IGlzIGEgcmVmZXJlbmNlXG4gIC8vICAgIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG53ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIG5hbWUsIG9wdHMpIHtcbiAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYVxuICAvLyAgICBbW0RhdGFWaWV3XV0gaW50ZXJuYWwgc2xvdCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8ICF0eXBlcy5pc0RhdGFWaWV3KFYpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICBtZXNzYWdlOiBgJHtuYW1lfSBpcyBub3QgYSBEYXRhVmlldy5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKG9wdHM/LmFsbG93U2hhcmVkID09PSBmYWxzZSAmJiB0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYuYnVmZmVyKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKFYuYnVmZmVyLnJlc2l6YWJsZSB8fCBWLmJ1ZmZlci5ncm93YWJsZSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIERhdGFWaWV3IHZhbHVlIHRoYXQgaXMgYSByZWZlcmVuY2VcbiAgLy8gICAgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jQnVmZmVyU291cmNlXG53ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBuYW1lLCBvcHRzKSB7XG4gIGlmICh0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyKFYsIHByZWZpeCwgbmFtZSwgeyAuLi5vcHRzLCBhbGxvd1NoYXJlZDogZmFsc2UgfSlcbiAgfVxuXG4gIGlmICh0eXBlcy5pc1R5cGVkQXJyYXkoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheShWLCBWLmNvbnN0cnVjdG9yLCBwcmVmaXgsIG5hbWUsIHsgLi4ub3B0cywgYWxsb3dTaGFyZWQ6IGZhbHNlIH0pXG4gIH1cblxuICBpZiAodHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyhWLCBwcmVmaXgsIG5hbWUsIHsgLi4ub3B0cywgYWxsb3dTaGFyZWQ6IGZhbHNlIH0pXG4gIH1cblxuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgIHByZWZpeCxcbiAgICBhcmd1bWVudDogYCR7bmFtZX0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpYCxcbiAgICB0eXBlczogWydCdWZmZXJTb3VyY2UnXVxuICB9KVxufVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8Qnl0ZVN0cmluZz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCeXRlU3RyaW5nPiddXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXSA9IHdlYmlkbC5yZWNvcmRDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdlYmlkbFxufVxuIl0sIm5hbWVzIjpbInR5cGVzIiwiaW5zcGVjdCIsInJlcXVpcmUiLCJ0b1VTVlN0cmluZyIsIndlYmlkbCIsImNvbnZlcnRlcnMiLCJ1dGlsIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsIlR5cGVFcnJvciIsImhlYWRlciIsImNvbnZlcnNpb25GYWlsZWQiLCJjb250ZXh0IiwicGx1cmFsIiwibGVuZ3RoIiwiYXJndW1lbnQiLCJqb2luIiwicHJlZml4IiwiaW52YWxpZEFyZ3VtZW50IiwidmFsdWUiLCJ0eXBlIiwiYnJhbmRDaGVjayIsIlYiLCJJIiwib3B0cyIsInN0cmljdCIsImVyciIsImNvZGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInByb3RvdHlwZSIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJtaW4iLCJjdHgiLCJpbGxlZ2FsQ29uc3RydWN0b3IiLCJUeXBlIiwiQ29udmVydFRvSW50IiwiYml0TGVuZ3RoIiwic2lnbmVkbmVzcyIsInVwcGVyQm91bmQiLCJsb3dlckJvdW5kIiwiTWF0aCIsInBvdyIsIngiLCJOdW1iZXIiLCJlbmZvcmNlUmFuZ2UiLCJpc05hTiIsIlBPU0lUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJTdHJpbmdpZnkiLCJJbnRlZ2VyUGFydCIsImNsYW1wIiwibWF4IiwiZmxvb3IiLCJjZWlsIiwiT2JqZWN0IiwiaXMiLCJuIiwiciIsImFicyIsImRlc2NyaXB0aW9uIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJjb252ZXJ0ZXIiLCJJdGVyYWJsZSIsIm1ldGhvZCIsIml0ZXJhdG9yIiwic2VxIiwiaW5kZXgiLCJ1bmRlZmluZWQiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJyZWNvcmRDb252ZXJ0ZXIiLCJrZXlDb252ZXJ0ZXIiLCJ2YWx1ZUNvbnZlcnRlciIsIk8iLCJyZXN1bHQiLCJpc1Byb3h5Iiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJrZXkiLCJ0eXBlZEtleSIsInR5cGVkVmFsdWUiLCJSZWZsZWN0Iiwib3duS2V5cyIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiaW50ZXJmYWNlQ29udmVydGVyIiwiaSIsIm5hbWUiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwiZGljdGlvbmFyeSIsImRpY3QiLCJvcHRpb25zIiwiZGVmYXVsdFZhbHVlIiwicmVxdWlyZWQiLCJoYXNPd24iLCJoYXNEZWZhdWx0IiwiYWxsb3dlZFZhbHVlcyIsImluY2x1ZGVzIiwibnVsbGFibGVDb252ZXJ0ZXIiLCJET01TdHJpbmciLCJsZWdhY3lOdWxsVG9FbXB0eVN0cmluZyIsIlN0cmluZyIsIkJ5dGVTdHJpbmciLCJjaGFyQ29kZUF0IiwiVVNWU3RyaW5nIiwiYm9vbGVhbiIsIkJvb2xlYW4iLCJhbnkiLCJBcnJheUJ1ZmZlciIsImlzQW55QXJyYXlCdWZmZXIiLCJhbGxvd1NoYXJlZCIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJyZXNpemFibGUiLCJncm93YWJsZSIsIlR5cGVkQXJyYXkiLCJUIiwiaXNUeXBlZEFycmF5IiwiYnVmZmVyIiwiRGF0YVZpZXciLCJpc0RhdGFWaWV3IiwiQnVmZmVyU291cmNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/encoding.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n/**\n * @see https://encoding.spec.whatwg.org/#concept-encoding-get\n * @param {string|undefined} label\n */ function getEncoding(label) {\n    if (!label) {\n        return 'failure';\n    }\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    // 2. If label is an ASCII case-insensitive match for any of the\n    //    labels listed in the table below, then return the\n    //    corresponding encoding; otherwise return failure.\n    switch(label.trim().toLowerCase()){\n        case 'unicode-1-1-utf-8':\n        case 'unicode11utf8':\n        case 'unicode20utf8':\n        case 'utf-8':\n        case 'utf8':\n        case 'x-unicode20utf8':\n            return 'UTF-8';\n        case '866':\n        case 'cp866':\n        case 'csibm866':\n        case 'ibm866':\n            return 'IBM866';\n        case 'csisolatin2':\n        case 'iso-8859-2':\n        case 'iso-ir-101':\n        case 'iso8859-2':\n        case 'iso88592':\n        case 'iso_8859-2':\n        case 'iso_8859-2:1987':\n        case 'l2':\n        case 'latin2':\n            return 'ISO-8859-2';\n        case 'csisolatin3':\n        case 'iso-8859-3':\n        case 'iso-ir-109':\n        case 'iso8859-3':\n        case 'iso88593':\n        case 'iso_8859-3':\n        case 'iso_8859-3:1988':\n        case 'l3':\n        case 'latin3':\n            return 'ISO-8859-3';\n        case 'csisolatin4':\n        case 'iso-8859-4':\n        case 'iso-ir-110':\n        case 'iso8859-4':\n        case 'iso88594':\n        case 'iso_8859-4':\n        case 'iso_8859-4:1988':\n        case 'l4':\n        case 'latin4':\n            return 'ISO-8859-4';\n        case 'csisolatincyrillic':\n        case 'cyrillic':\n        case 'iso-8859-5':\n        case 'iso-ir-144':\n        case 'iso8859-5':\n        case 'iso88595':\n        case 'iso_8859-5':\n        case 'iso_8859-5:1988':\n            return 'ISO-8859-5';\n        case 'arabic':\n        case 'asmo-708':\n        case 'csiso88596e':\n        case 'csiso88596i':\n        case 'csisolatinarabic':\n        case 'ecma-114':\n        case 'iso-8859-6':\n        case 'iso-8859-6-e':\n        case 'iso-8859-6-i':\n        case 'iso-ir-127':\n        case 'iso8859-6':\n        case 'iso88596':\n        case 'iso_8859-6':\n        case 'iso_8859-6:1987':\n            return 'ISO-8859-6';\n        case 'csisolatingreek':\n        case 'ecma-118':\n        case 'elot_928':\n        case 'greek':\n        case 'greek8':\n        case 'iso-8859-7':\n        case 'iso-ir-126':\n        case 'iso8859-7':\n        case 'iso88597':\n        case 'iso_8859-7':\n        case 'iso_8859-7:1987':\n        case 'sun_eu_greek':\n            return 'ISO-8859-7';\n        case 'csiso88598e':\n        case 'csisolatinhebrew':\n        case 'hebrew':\n        case 'iso-8859-8':\n        case 'iso-8859-8-e':\n        case 'iso-ir-138':\n        case 'iso8859-8':\n        case 'iso88598':\n        case 'iso_8859-8':\n        case 'iso_8859-8:1988':\n        case 'visual':\n            return 'ISO-8859-8';\n        case 'csiso88598i':\n        case 'iso-8859-8-i':\n        case 'logical':\n            return 'ISO-8859-8-I';\n        case 'csisolatin6':\n        case 'iso-8859-10':\n        case 'iso-ir-157':\n        case 'iso8859-10':\n        case 'iso885910':\n        case 'l6':\n        case 'latin6':\n            return 'ISO-8859-10';\n        case 'iso-8859-13':\n        case 'iso8859-13':\n        case 'iso885913':\n            return 'ISO-8859-13';\n        case 'iso-8859-14':\n        case 'iso8859-14':\n        case 'iso885914':\n            return 'ISO-8859-14';\n        case 'csisolatin9':\n        case 'iso-8859-15':\n        case 'iso8859-15':\n        case 'iso885915':\n        case 'iso_8859-15':\n        case 'l9':\n            return 'ISO-8859-15';\n        case 'iso-8859-16':\n            return 'ISO-8859-16';\n        case 'cskoi8r':\n        case 'koi':\n        case 'koi8':\n        case 'koi8-r':\n        case 'koi8_r':\n            return 'KOI8-R';\n        case 'koi8-ru':\n        case 'koi8-u':\n            return 'KOI8-U';\n        case 'csmacintosh':\n        case 'mac':\n        case 'macintosh':\n        case 'x-mac-roman':\n            return 'macintosh';\n        case 'iso-8859-11':\n        case 'iso8859-11':\n        case 'iso885911':\n        case 'tis-620':\n        case 'windows-874':\n            return 'windows-874';\n        case 'cp1250':\n        case 'windows-1250':\n        case 'x-cp1250':\n            return 'windows-1250';\n        case 'cp1251':\n        case 'windows-1251':\n        case 'x-cp1251':\n            return 'windows-1251';\n        case 'ansi_x3.4-1968':\n        case 'ascii':\n        case 'cp1252':\n        case 'cp819':\n        case 'csisolatin1':\n        case 'ibm819':\n        case 'iso-8859-1':\n        case 'iso-ir-100':\n        case 'iso8859-1':\n        case 'iso88591':\n        case 'iso_8859-1':\n        case 'iso_8859-1:1987':\n        case 'l1':\n        case 'latin1':\n        case 'us-ascii':\n        case 'windows-1252':\n        case 'x-cp1252':\n            return 'windows-1252';\n        case 'cp1253':\n        case 'windows-1253':\n        case 'x-cp1253':\n            return 'windows-1253';\n        case 'cp1254':\n        case 'csisolatin5':\n        case 'iso-8859-9':\n        case 'iso-ir-148':\n        case 'iso8859-9':\n        case 'iso88599':\n        case 'iso_8859-9':\n        case 'iso_8859-9:1989':\n        case 'l5':\n        case 'latin5':\n        case 'windows-1254':\n        case 'x-cp1254':\n            return 'windows-1254';\n        case 'cp1255':\n        case 'windows-1255':\n        case 'x-cp1255':\n            return 'windows-1255';\n        case 'cp1256':\n        case 'windows-1256':\n        case 'x-cp1256':\n            return 'windows-1256';\n        case 'cp1257':\n        case 'windows-1257':\n        case 'x-cp1257':\n            return 'windows-1257';\n        case 'cp1258':\n        case 'windows-1258':\n        case 'x-cp1258':\n            return 'windows-1258';\n        case 'x-mac-cyrillic':\n        case 'x-mac-ukrainian':\n            return 'x-mac-cyrillic';\n        case 'chinese':\n        case 'csgb2312':\n        case 'csiso58gb231280':\n        case 'gb2312':\n        case 'gb_2312':\n        case 'gb_2312-80':\n        case 'gbk':\n        case 'iso-ir-58':\n        case 'x-gbk':\n            return 'GBK';\n        case 'gb18030':\n            return 'gb18030';\n        case 'big5':\n        case 'big5-hkscs':\n        case 'cn-big5':\n        case 'csbig5':\n        case 'x-x-big5':\n            return 'Big5';\n        case 'cseucpkdfmtjapanese':\n        case 'euc-jp':\n        case 'x-euc-jp':\n            return 'EUC-JP';\n        case 'csiso2022jp':\n        case 'iso-2022-jp':\n            return 'ISO-2022-JP';\n        case 'csshiftjis':\n        case 'ms932':\n        case 'ms_kanji':\n        case 'shift-jis':\n        case 'shift_jis':\n        case 'sjis':\n        case 'windows-31j':\n        case 'x-sjis':\n            return 'Shift_JIS';\n        case 'cseuckr':\n        case 'csksc56011987':\n        case 'euc-kr':\n        case 'iso-ir-149':\n        case 'korean':\n        case 'ks_c_5601-1987':\n        case 'ks_c_5601-1989':\n        case 'ksc5601':\n        case 'ksc_5601':\n        case 'windows-949':\n            return 'EUC-KR';\n        case 'csiso2022kr':\n        case 'hz-gb-2312':\n        case 'iso-2022-cn':\n        case 'iso-2022-cn-ext':\n        case 'iso-2022-kr':\n        case 'replacement':\n            return 'replacement';\n        case 'unicodefffe':\n        case 'utf-16be':\n            return 'UTF-16BE';\n        case 'csunicode':\n        case 'iso-10646-ucs-2':\n        case 'ucs-2':\n        case 'unicode':\n        case 'unicodefeff':\n        case 'utf-16':\n        case 'utf-16le':\n            return 'UTF-16LE';\n        case 'x-user-defined':\n            return 'x-user-defined';\n        default:\n            return 'failure';\n    }\n}\nmodule.exports = {\n    getEncoding\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Q0FHQyxHQUNELFNBQVNBLFlBQWFDLEtBQUs7SUFDekIsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBRUEsa0VBQWtFO0lBQ2xFLGdFQUFnRTtJQUNoRSx1REFBdUQ7SUFDdkQsdURBQXVEO0lBQ3ZELE9BQVFBLE1BQU1DLElBQUksR0FBR0MsV0FBVztRQUM5QixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUFTLE9BQU87SUFDbEI7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZkw7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZpbGVhcGlcXGVuY29kaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZW5jb2RpbmctZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGxhYmVsXG4gKi9cbmZ1bmN0aW9uIGdldEVuY29kaW5nIChsYWJlbCkge1xuICBpZiAoIWxhYmVsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMS4gUmVtb3ZlIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlIGZyb20gbGFiZWwuXG4gIC8vIDIuIElmIGxhYmVsIGlzIGFuIEFTQ0lJIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIGFueSBvZiB0aGVcbiAgLy8gICAgbGFiZWxzIGxpc3RlZCBpbiB0aGUgdGFibGUgYmVsb3csIHRoZW4gcmV0dXJuIHRoZVxuICAvLyAgICBjb3JyZXNwb25kaW5nIGVuY29kaW5nOyBvdGhlcndpc2UgcmV0dXJuIGZhaWx1cmUuXG4gIHN3aXRjaCAobGFiZWwudHJpbSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICd1bmljb2RlLTEtMS11dGYtOCc6XG4gICAgY2FzZSAndW5pY29kZTExdXRmOCc6XG4gICAgY2FzZSAndW5pY29kZTIwdXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3gtdW5pY29kZTIwdXRmOCc6XG4gICAgICByZXR1cm4gJ1VURi04J1xuICAgIGNhc2UgJzg2Nic6XG4gICAgY2FzZSAnY3A4NjYnOlxuICAgIGNhc2UgJ2NzaWJtODY2JzpcbiAgICBjYXNlICdpYm04NjYnOlxuICAgICAgcmV0dXJuICdJQk04NjYnXG4gICAgY2FzZSAnY3Npc29sYXRpbjInOlxuICAgIGNhc2UgJ2lzby04ODU5LTInOlxuICAgIGNhc2UgJ2lzby1pci0xMDEnOlxuICAgIGNhc2UgJ2lzbzg4NTktMic6XG4gICAgY2FzZSAnaXNvODg1OTInOlxuICAgIGNhc2UgJ2lzb184ODU5LTInOlxuICAgIGNhc2UgJ2lzb184ODU5LTI6MTk4Nyc6XG4gICAgY2FzZSAnbDInOlxuICAgIGNhc2UgJ2xhdGluMic6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTInXG4gICAgY2FzZSAnY3Npc29sYXRpbjMnOlxuICAgIGNhc2UgJ2lzby04ODU5LTMnOlxuICAgIGNhc2UgJ2lzby1pci0xMDknOlxuICAgIGNhc2UgJ2lzbzg4NTktMyc6XG4gICAgY2FzZSAnaXNvODg1OTMnOlxuICAgIGNhc2UgJ2lzb184ODU5LTMnOlxuICAgIGNhc2UgJ2lzb184ODU5LTM6MTk4OCc6XG4gICAgY2FzZSAnbDMnOlxuICAgIGNhc2UgJ2xhdGluMyc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTMnXG4gICAgY2FzZSAnY3Npc29sYXRpbjQnOlxuICAgIGNhc2UgJ2lzby04ODU5LTQnOlxuICAgIGNhc2UgJ2lzby1pci0xMTAnOlxuICAgIGNhc2UgJ2lzbzg4NTktNCc6XG4gICAgY2FzZSAnaXNvODg1OTQnOlxuICAgIGNhc2UgJ2lzb184ODU5LTQnOlxuICAgIGNhc2UgJ2lzb184ODU5LTQ6MTk4OCc6XG4gICAgY2FzZSAnbDQnOlxuICAgIGNhc2UgJ2xhdGluNCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTQnXG4gICAgY2FzZSAnY3Npc29sYXRpbmN5cmlsbGljJzpcbiAgICBjYXNlICdjeXJpbGxpYyc6XG4gICAgY2FzZSAnaXNvLTg4NTktNSc6XG4gICAgY2FzZSAnaXNvLWlyLTE0NCc6XG4gICAgY2FzZSAnaXNvODg1OS01JzpcbiAgICBjYXNlICdpc284ODU5NSc6XG4gICAgY2FzZSAnaXNvXzg4NTktNSc6XG4gICAgY2FzZSAnaXNvXzg4NTktNToxOTg4JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNSdcbiAgICBjYXNlICdhcmFiaWMnOlxuICAgIGNhc2UgJ2FzbW8tNzA4JzpcbiAgICBjYXNlICdjc2lzbzg4NTk2ZSc6XG4gICAgY2FzZSAnY3Npc284ODU5NmknOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW5hcmFiaWMnOlxuICAgIGNhc2UgJ2VjbWEtMTE0JzpcbiAgICBjYXNlICdpc28tODg1OS02JzpcbiAgICBjYXNlICdpc28tODg1OS02LWUnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYtaSc6XG4gICAgY2FzZSAnaXNvLWlyLTEyNyc6XG4gICAgY2FzZSAnaXNvODg1OS02JzpcbiAgICBjYXNlICdpc284ODU5Nic6XG4gICAgY2FzZSAnaXNvXzg4NTktNic6XG4gICAgY2FzZSAnaXNvXzg4NTktNjoxOTg3JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNidcbiAgICBjYXNlICdjc2lzb2xhdGluZ3JlZWsnOlxuICAgIGNhc2UgJ2VjbWEtMTE4JzpcbiAgICBjYXNlICdlbG90XzkyOCc6XG4gICAgY2FzZSAnZ3JlZWsnOlxuICAgIGNhc2UgJ2dyZWVrOCc6XG4gICAgY2FzZSAnaXNvLTg4NTktNyc6XG4gICAgY2FzZSAnaXNvLWlyLTEyNic6XG4gICAgY2FzZSAnaXNvODg1OS03JzpcbiAgICBjYXNlICdpc284ODU5Nyc6XG4gICAgY2FzZSAnaXNvXzg4NTktNyc6XG4gICAgY2FzZSAnaXNvXzg4NTktNzoxOTg3JzpcbiAgICBjYXNlICdzdW5fZXVfZ3JlZWsnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS03J1xuICAgIGNhc2UgJ2NzaXNvODg1OThlJzpcbiAgICBjYXNlICdjc2lzb2xhdGluaGVicmV3JzpcbiAgICBjYXNlICdoZWJyZXcnOlxuICAgIGNhc2UgJ2lzby04ODU5LTgnOlxuICAgIGNhc2UgJ2lzby04ODU5LTgtZSc6XG4gICAgY2FzZSAnaXNvLWlyLTEzOCc6XG4gICAgY2FzZSAnaXNvODg1OS04JzpcbiAgICBjYXNlICdpc284ODU5OCc6XG4gICAgY2FzZSAnaXNvXzg4NTktOCc6XG4gICAgY2FzZSAnaXNvXzg4NTktODoxOTg4JzpcbiAgICBjYXNlICd2aXN1YWwnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS04J1xuICAgIGNhc2UgJ2NzaXNvODg1OThpJzpcbiAgICBjYXNlICdpc28tODg1OS04LWknOlxuICAgIGNhc2UgJ2xvZ2ljYWwnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS04LUknXG4gICAgY2FzZSAnY3Npc29sYXRpbjYnOlxuICAgIGNhc2UgJ2lzby04ODU5LTEwJzpcbiAgICBjYXNlICdpc28taXItMTU3JzpcbiAgICBjYXNlICdpc284ODU5LTEwJzpcbiAgICBjYXNlICdpc284ODU5MTAnOlxuICAgIGNhc2UgJ2w2JzpcbiAgICBjYXNlICdsYXRpbjYnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xMCdcbiAgICBjYXNlICdpc28tODg1OS0xMyc6XG4gICAgY2FzZSAnaXNvODg1OS0xMyc6XG4gICAgY2FzZSAnaXNvODg1OTEzJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTMnXG4gICAgY2FzZSAnaXNvLTg4NTktMTQnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTQnOlxuICAgIGNhc2UgJ2lzbzg4NTkxNCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTE0J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW45JzpcbiAgICBjYXNlICdpc28tODg1OS0xNSc6XG4gICAgY2FzZSAnaXNvODg1OS0xNSc6XG4gICAgY2FzZSAnaXNvODg1OTE1JzpcbiAgICBjYXNlICdpc29fODg1OS0xNSc6XG4gICAgY2FzZSAnbDknOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xNSdcbiAgICBjYXNlICdpc28tODg1OS0xNic6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTE2J1xuICAgIGNhc2UgJ2Nza29pOHInOlxuICAgIGNhc2UgJ2tvaSc6XG4gICAgY2FzZSAna29pOCc6XG4gICAgY2FzZSAna29pOC1yJzpcbiAgICBjYXNlICdrb2k4X3InOlxuICAgICAgcmV0dXJuICdLT0k4LVInXG4gICAgY2FzZSAna29pOC1ydSc6XG4gICAgY2FzZSAna29pOC11JzpcbiAgICAgIHJldHVybiAnS09JOC1VJ1xuICAgIGNhc2UgJ2NzbWFjaW50b3NoJzpcbiAgICBjYXNlICdtYWMnOlxuICAgIGNhc2UgJ21hY2ludG9zaCc6XG4gICAgY2FzZSAneC1tYWMtcm9tYW4nOlxuICAgICAgcmV0dXJuICdtYWNpbnRvc2gnXG4gICAgY2FzZSAnaXNvLTg4NTktMTEnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTEnOlxuICAgIGNhc2UgJ2lzbzg4NTkxMSc6XG4gICAgY2FzZSAndGlzLTYyMCc6XG4gICAgY2FzZSAnd2luZG93cy04NzQnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTg3NCdcbiAgICBjYXNlICdjcDEyNTAnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1MCc6XG4gICAgY2FzZSAneC1jcDEyNTAnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTAnXG4gICAgY2FzZSAnY3AxMjUxJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTEnOlxuICAgIGNhc2UgJ3gtY3AxMjUxJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUxJ1xuICAgIGNhc2UgJ2Fuc2lfeDMuNC0xOTY4JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnY3AxMjUyJzpcbiAgICBjYXNlICdjcDgxOSc6XG4gICAgY2FzZSAnY3Npc29sYXRpbjEnOlxuICAgIGNhc2UgJ2libTgxOSc6XG4gICAgY2FzZSAnaXNvLTg4NTktMSc6XG4gICAgY2FzZSAnaXNvLWlyLTEwMCc6XG4gICAgY2FzZSAnaXNvODg1OS0xJzpcbiAgICBjYXNlICdpc284ODU5MSc6XG4gICAgY2FzZSAnaXNvXzg4NTktMSc6XG4gICAgY2FzZSAnaXNvXzg4NTktMToxOTg3JzpcbiAgICBjYXNlICdsMSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICd1cy1hc2NpaSc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUyJzpcbiAgICBjYXNlICd4LWNwMTI1Mic6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MidcbiAgICBjYXNlICdjcDEyNTMnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Myc6XG4gICAgY2FzZSAneC1jcDEyNTMnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTMnXG4gICAgY2FzZSAnY3AxMjU0JzpcbiAgICBjYXNlICdjc2lzb2xhdGluNSc6XG4gICAgY2FzZSAnaXNvLTg4NTktOSc6XG4gICAgY2FzZSAnaXNvLWlyLTE0OCc6XG4gICAgY2FzZSAnaXNvODg1OS05JzpcbiAgICBjYXNlICdpc284ODU5OSc6XG4gICAgY2FzZSAnaXNvXzg4NTktOSc6XG4gICAgY2FzZSAnaXNvXzg4NTktOToxOTg5JzpcbiAgICBjYXNlICdsNSc6XG4gICAgY2FzZSAnbGF0aW41JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTQnOlxuICAgIGNhc2UgJ3gtY3AxMjU0JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU0J1xuICAgIGNhc2UgJ2NwMTI1NSc6XG4gICAgY2FzZSAnd2luZG93cy0xMjU1JzpcbiAgICBjYXNlICd4LWNwMTI1NSc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NSdcbiAgICBjYXNlICdjcDEyNTYnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Nic6XG4gICAgY2FzZSAneC1jcDEyNTYnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTYnXG4gICAgY2FzZSAnY3AxMjU3JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTcnOlxuICAgIGNhc2UgJ3gtY3AxMjU3JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU3J1xuICAgIGNhc2UgJ2NwMTI1OCc6XG4gICAgY2FzZSAnd2luZG93cy0xMjU4JzpcbiAgICBjYXNlICd4LWNwMTI1OCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1OCdcbiAgICBjYXNlICd4LW1hYy1jeXJpbGxpYyc6XG4gICAgY2FzZSAneC1tYWMtdWtyYWluaWFuJzpcbiAgICAgIHJldHVybiAneC1tYWMtY3lyaWxsaWMnXG4gICAgY2FzZSAnY2hpbmVzZSc6XG4gICAgY2FzZSAnY3NnYjIzMTInOlxuICAgIGNhc2UgJ2NzaXNvNThnYjIzMTI4MCc6XG4gICAgY2FzZSAnZ2IyMzEyJzpcbiAgICBjYXNlICdnYl8yMzEyJzpcbiAgICBjYXNlICdnYl8yMzEyLTgwJzpcbiAgICBjYXNlICdnYmsnOlxuICAgIGNhc2UgJ2lzby1pci01OCc6XG4gICAgY2FzZSAneC1nYmsnOlxuICAgICAgcmV0dXJuICdHQksnXG4gICAgY2FzZSAnZ2IxODAzMCc6XG4gICAgICByZXR1cm4gJ2diMTgwMzAnXG4gICAgY2FzZSAnYmlnNSc6XG4gICAgY2FzZSAnYmlnNS1oa3Njcyc6XG4gICAgY2FzZSAnY24tYmlnNSc6XG4gICAgY2FzZSAnY3NiaWc1JzpcbiAgICBjYXNlICd4LXgtYmlnNSc6XG4gICAgICByZXR1cm4gJ0JpZzUnXG4gICAgY2FzZSAnY3NldWNwa2RmbXRqYXBhbmVzZSc6XG4gICAgY2FzZSAnZXVjLWpwJzpcbiAgICBjYXNlICd4LWV1Yy1qcCc6XG4gICAgICByZXR1cm4gJ0VVQy1KUCdcbiAgICBjYXNlICdjc2lzbzIwMjJqcCc6XG4gICAgY2FzZSAnaXNvLTIwMjItanAnOlxuICAgICAgcmV0dXJuICdJU08tMjAyMi1KUCdcbiAgICBjYXNlICdjc3NoaWZ0amlzJzpcbiAgICBjYXNlICdtczkzMic6XG4gICAgY2FzZSAnbXNfa2FuamknOlxuICAgIGNhc2UgJ3NoaWZ0LWppcyc6XG4gICAgY2FzZSAnc2hpZnRfamlzJzpcbiAgICBjYXNlICdzamlzJzpcbiAgICBjYXNlICd3aW5kb3dzLTMxaic6XG4gICAgY2FzZSAneC1zamlzJzpcbiAgICAgIHJldHVybiAnU2hpZnRfSklTJ1xuICAgIGNhc2UgJ2NzZXVja3InOlxuICAgIGNhc2UgJ2Nza3NjNTYwMTE5ODcnOlxuICAgIGNhc2UgJ2V1Yy1rcic6XG4gICAgY2FzZSAnaXNvLWlyLTE0OSc6XG4gICAgY2FzZSAna29yZWFuJzpcbiAgICBjYXNlICdrc19jXzU2MDEtMTk4Nyc6XG4gICAgY2FzZSAna3NfY181NjAxLTE5ODknOlxuICAgIGNhc2UgJ2tzYzU2MDEnOlxuICAgIGNhc2UgJ2tzY181NjAxJzpcbiAgICBjYXNlICd3aW5kb3dzLTk0OSc6XG4gICAgICByZXR1cm4gJ0VVQy1LUidcbiAgICBjYXNlICdjc2lzbzIwMjJrcic6XG4gICAgY2FzZSAnaHotZ2ItMjMxMic6XG4gICAgY2FzZSAnaXNvLTIwMjItY24nOlxuICAgIGNhc2UgJ2lzby0yMDIyLWNuLWV4dCc6XG4gICAgY2FzZSAnaXNvLTIwMjIta3InOlxuICAgIGNhc2UgJ3JlcGxhY2VtZW50JzpcbiAgICAgIHJldHVybiAncmVwbGFjZW1lbnQnXG4gICAgY2FzZSAndW5pY29kZWZmZmUnOlxuICAgIGNhc2UgJ3V0Zi0xNmJlJzpcbiAgICAgIHJldHVybiAnVVRGLTE2QkUnXG4gICAgY2FzZSAnY3N1bmljb2RlJzpcbiAgICBjYXNlICdpc28tMTA2NDYtdWNzLTInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1bmljb2RlJzpcbiAgICBjYXNlICd1bmljb2RlZmVmZic6XG4gICAgY2FzZSAndXRmLTE2JzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gJ1VURi0xNkxFJ1xuICAgIGNhc2UgJ3gtdXNlci1kZWZpbmVkJzpcbiAgICAgIHJldHVybiAneC11c2VyLWRlZmluZWQnXG4gICAgZGVmYXVsdDogcmV0dXJuICdmYWlsdXJlJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRFbmNvZGluZ1xufVxuIl0sIm5hbWVzIjpbImdldEVuY29kaW5nIiwibGFiZWwiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/filereader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { staticPropertyDescriptors, readOperation, fireAProgressEvent } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fileapi/util.js\");\nconst { kState, kError, kResult, kEvents, kAborted } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nclass FileReader extends EventTarget {\n    constructor(){\n        super();\n        this[kState] = 'empty';\n        this[kResult] = null;\n        this[kError] = null;\n        this[kEvents] = {\n            loadend: null,\n            error: null,\n            abort: null,\n            load: null,\n            progress: null,\n            loadstart: null\n        };\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer\n   * @param {import('buffer').Blob} blob\n   */ readAsArrayBuffer(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsArrayBuffer');\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsArrayBuffer(blob) method, when invoked,\n        // must initiate a read operation for blob with ArrayBuffer.\n        readOperation(this, blob, 'ArrayBuffer');\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsBinaryString\n   * @param {import('buffer').Blob} blob\n   */ readAsBinaryString(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsBinaryString');\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsBinaryString(blob) method, when invoked,\n        // must initiate a read operation for blob with BinaryString.\n        readOperation(this, blob, 'BinaryString');\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsDataText\n   * @param {import('buffer').Blob} blob\n   * @param {string?} encoding\n   */ readAsText(blob, encoding = undefined) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsText');\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        if (encoding !== undefined) {\n            encoding = webidl.converters.DOMString(encoding, 'FileReader.readAsText', 'encoding');\n        }\n        // The readAsText(blob, encoding) method, when invoked,\n        // must initiate a read operation for blob with Text and encoding.\n        readOperation(this, blob, 'Text', encoding);\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL\n   * @param {import('buffer').Blob} blob\n   */ readAsDataURL(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsDataURL');\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsDataURL(blob) method, when invoked, must\n        // initiate a read operation for blob with DataURL.\n        readOperation(this, blob, 'DataURL');\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-abort\n   */ abort() {\n        // 1. If this's state is \"empty\" or if this's state is\n        //    \"done\" set this's result to null and terminate\n        //    this algorithm.\n        if (this[kState] === 'empty' || this[kState] === 'done') {\n            this[kResult] = null;\n            return;\n        }\n        // 2. If this's state is \"loading\" set this's state to\n        //    \"done\" and set this's result to null.\n        if (this[kState] === 'loading') {\n            this[kState] = 'done';\n            this[kResult] = null;\n        }\n        // 3. If there are any tasks from this on the file reading\n        //    task source in an affiliated task queue, then remove\n        //    those tasks from that task queue.\n        this[kAborted] = true;\n        // 4. Terminate the algorithm for the read method being processed.\n        // TODO\n        // 5. Fire a progress event called abort at this.\n        fireAProgressEvent('abort', this);\n        // 6. If this's state is not \"loading\", fire a progress\n        //    event called loadend at this.\n        if (this[kState] !== 'loading') {\n            fireAProgressEvent('loadend', this);\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate\n   */ get readyState() {\n        webidl.brandCheck(this, FileReader);\n        switch(this[kState]){\n            case 'empty':\n                return this.EMPTY;\n            case 'loading':\n                return this.LOADING;\n            case 'done':\n                return this.DONE;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-result\n   */ get result() {\n        webidl.brandCheck(this, FileReader);\n        // The result attribute’s getter, when invoked, must return\n        // this's result.\n        return this[kResult];\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-error\n   */ get error() {\n        webidl.brandCheck(this, FileReader);\n        // The error attribute’s getter, when invoked, must return\n        // this's error.\n        return this[kError];\n    }\n    get onloadend() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadend;\n    }\n    set onloadend(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadend) {\n            this.removeEventListener('loadend', this[kEvents].loadend);\n        }\n        if (typeof fn === 'function') {\n            this[kEvents].loadend = fn;\n            this.addEventListener('loadend', fn);\n        } else {\n            this[kEvents].loadend = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].error) {\n            this.removeEventListener('error', this[kEvents].error);\n        }\n        if (typeof fn === 'function') {\n            this[kEvents].error = fn;\n            this.addEventListener('error', fn);\n        } else {\n            this[kEvents].error = null;\n        }\n    }\n    get onloadstart() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadstart;\n    }\n    set onloadstart(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadstart) {\n            this.removeEventListener('loadstart', this[kEvents].loadstart);\n        }\n        if (typeof fn === 'function') {\n            this[kEvents].loadstart = fn;\n            this.addEventListener('loadstart', fn);\n        } else {\n            this[kEvents].loadstart = null;\n        }\n    }\n    get onprogress() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].progress;\n    }\n    set onprogress(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].progress) {\n            this.removeEventListener('progress', this[kEvents].progress);\n        }\n        if (typeof fn === 'function') {\n            this[kEvents].progress = fn;\n            this.addEventListener('progress', fn);\n        } else {\n            this[kEvents].progress = null;\n        }\n    }\n    get onload() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].load;\n    }\n    set onload(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].load) {\n            this.removeEventListener('load', this[kEvents].load);\n        }\n        if (typeof fn === 'function') {\n            this[kEvents].load = fn;\n            this.addEventListener('load', fn);\n        } else {\n            this[kEvents].load = null;\n        }\n    }\n    get onabort() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].abort;\n    }\n    set onabort(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].abort) {\n            this.removeEventListener('abort', this[kEvents].abort);\n        }\n        if (typeof fn === 'function') {\n            this[kEvents].abort = fn;\n            this.addEventListener('abort', fn);\n        } else {\n            this[kEvents].abort = null;\n        }\n    }\n}\n// https://w3c.github.io/FileAPI/#dom-filereader-empty\nFileReader.EMPTY = FileReader.prototype.EMPTY = 0;\n// https://w3c.github.io/FileAPI/#dom-filereader-loading\nFileReader.LOADING = FileReader.prototype.LOADING = 1;\n// https://w3c.github.io/FileAPI/#dom-filereader-done\nFileReader.DONE = FileReader.prototype.DONE = 2;\nObject.defineProperties(FileReader.prototype, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors,\n    readAsArrayBuffer: kEnumerableProperty,\n    readAsBinaryString: kEnumerableProperty,\n    readAsText: kEnumerableProperty,\n    readAsDataURL: kEnumerableProperty,\n    abort: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    result: kEnumerableProperty,\n    error: kEnumerableProperty,\n    onloadstart: kEnumerableProperty,\n    onprogress: kEnumerableProperty,\n    onload: kEnumerableProperty,\n    onabort: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onloadend: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: 'FileReader',\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(FileReader, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors\n});\nmodule.exports = {\n    FileReader\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9maWxlcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSx5QkFBeUIsRUFDekJDLGFBQWEsRUFDYkMsa0JBQWtCLEVBQ25CLEdBQUdDLG1CQUFPQSxDQUFDLG1FQUFRO0FBQ3BCLE1BQU0sRUFDSkMsTUFBTSxFQUNOQyxNQUFNLEVBQ05DLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxRQUFRLEVBQ1QsR0FBR0wsbUJBQU9BLENBQUMseUVBQVc7QUFDdkIsTUFBTSxFQUFFTSxNQUFNLEVBQUUsR0FBR04sbUJBQU9BLENBQUMsNEVBQWlCO0FBQzVDLE1BQU0sRUFBRU8sbUJBQW1CLEVBQUUsR0FBR1AsbUJBQU9BLENBQUMscUVBQWlCO0FBRXpELE1BQU1RLG1CQUFtQkM7SUFDdkIsYUFBZTtRQUNiLEtBQUs7UUFFTCxJQUFJLENBQUNSLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0UsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRSxRQUFRLEdBQUc7WUFDZE0sU0FBUztZQUNUQyxPQUFPO1lBQ1BDLE9BQU87WUFDUEMsTUFBTTtZQUNOQyxVQUFVO1lBQ1ZDLFdBQVc7UUFDYjtJQUNGO0lBRUE7OztHQUdDLEdBQ0RDLGtCQUFtQkMsSUFBSSxFQUFFO1FBQ3ZCWCxPQUFPWSxVQUFVLENBQUMsSUFBSSxFQUFFVjtRQUV4QkYsT0FBT2EsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztRQUV6Q0gsT0FBT1gsT0FBT2UsVUFBVSxDQUFDQyxJQUFJLENBQUNMLE1BQU07WUFBRU0sUUFBUTtRQUFNO1FBRXBELG9EQUFvRDtRQUNwRCw0REFBNEQ7UUFDNUR6QixjQUFjLElBQUksRUFBRW1CLE1BQU07SUFDNUI7SUFFQTs7O0dBR0MsR0FDRE8sbUJBQW9CUCxJQUFJLEVBQUU7UUFDeEJYLE9BQU9ZLFVBQVUsQ0FBQyxJQUFJLEVBQUVWO1FB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QUFnQixDQUFDdEMsV0FBV29DLFNBQVMsRUFBRTtJQUM1Q2IsT0FBT2xDO0lBQ1BtQyxTQUFTbkM7SUFDVG9DLE1BQU1wQztJQUNObUIsbUJBQW1CVDtJQUNuQmlCLG9CQUFvQmpCO0lBQ3BCa0IsWUFBWWxCO0lBQ1pzQixlQUFldEI7SUFDZkssT0FBT0w7SUFDUHVCLFlBQVl2QjtJQUNaMkIsUUFBUTNCO0lBQ1JJLE9BQU9KO0lBQ1BpQyxhQUFhakM7SUFDYmtDLFlBQVlsQztJQUNabUMsUUFBUW5DO0lBQ1JvQyxTQUFTcEM7SUFDVGdDLFNBQVNoQztJQUNUNEIsV0FBVzVCO0lBQ1gsQ0FBQ3dDLE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQVAsT0FBT0MsZ0JBQWdCLENBQUN0QyxZQUFZO0lBQ2xDdUIsT0FBT2xDO0lBQ1BtQyxTQUFTbkM7SUFDVG9DLE1BQU1wQztBQUNSO0FBRUF3RCxPQUFPQyxPQUFPLEdBQUc7SUFDZjlDO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmaWxlYXBpXFxmaWxlcmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRPcGVyYXRpb24sXG4gIGZpcmVBUHJvZ3Jlc3NFdmVudFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIGtTdGF0ZSxcbiAga0Vycm9yLFxuICBrUmVzdWx0LFxuICBrRXZlbnRzLFxuICBrQWJvcnRlZFxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcblxuY2xhc3MgRmlsZVJlYWRlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba1N0YXRlXSA9ICdlbXB0eSdcbiAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgIHRoaXNba0Vycm9yXSA9IG51bGxcbiAgICB0aGlzW2tFdmVudHNdID0ge1xuICAgICAgbG9hZGVuZDogbnVsbCxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgYWJvcnQ6IG51bGwsXG4gICAgICBsb2FkOiBudWxsLFxuICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICBsb2Fkc3RhcnQ6IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLXJlYWRBc0FycmF5QnVmZmVyXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNBcnJheUJ1ZmZlciAoYmxvYikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdGaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyJylcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgLy8gVGhlIHJlYWRBc0FycmF5QnVmZmVyKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIG11c3QgaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIEFycmF5QnVmZmVyLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ0FycmF5QnVmZmVyJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNyZWFkQXNCaW5hcnlTdHJpbmdcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICovXG4gIHJlYWRBc0JpbmFyeVN0cmluZyAoYmxvYikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdGaWxlUmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZycpXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNCaW5hcnlTdHJpbmcoYmxvYikgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggQmluYXJ5U3RyaW5nLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ0JpbmFyeVN0cmluZycpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jcmVhZEFzRGF0YVRleHRcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ1xuICAgKi9cbiAgcmVhZEFzVGV4dCAoYmxvYiwgZW5jb2RpbmcgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnRmlsZVJlYWRlci5yZWFkQXNUZXh0JylcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuY29kaW5nID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGVuY29kaW5nLCAnRmlsZVJlYWRlci5yZWFkQXNUZXh0JywgJ2VuY29kaW5nJylcbiAgICB9XG5cbiAgICAvLyBUaGUgcmVhZEFzVGV4dChibG9iLCBlbmNvZGluZykgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggVGV4dCBhbmQgZW5jb2RpbmcuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnVGV4dCcsIGVuY29kaW5nKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1yZWFkQXNEYXRhVVJMXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNEYXRhVVJMIChibG9iKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0ZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTCcpXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNEYXRhVVJMKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLCBtdXN0XG4gICAgLy8gaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIERhdGFVUkwuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnRGF0YVVSTCcpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLWFib3J0XG4gICAqL1xuICBhYm9ydCAoKSB7XG4gICAgLy8gMS4gSWYgdGhpcydzIHN0YXRlIGlzIFwiZW1wdHlcIiBvciBpZiB0aGlzJ3Mgc3RhdGUgaXNcbiAgICAvLyAgICBcImRvbmVcIiBzZXQgdGhpcydzIHJlc3VsdCB0byBudWxsIGFuZCB0ZXJtaW5hdGVcbiAgICAvLyAgICB0aGlzIGFsZ29yaXRobS5cbiAgICBpZiAodGhpc1trU3RhdGVdID09PSAnZW1wdHknIHx8IHRoaXNba1N0YXRlXSA9PT0gJ2RvbmUnKSB7XG4gICAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpcydzIHN0YXRlIGlzIFwibG9hZGluZ1wiIHNldCB0aGlzJ3Mgc3RhdGUgdG9cbiAgICAvLyAgICBcImRvbmVcIiBhbmQgc2V0IHRoaXMncyByZXN1bHQgdG8gbnVsbC5cbiAgICBpZiAodGhpc1trU3RhdGVdID09PSAnbG9hZGluZycpIHtcbiAgICAgIHRoaXNba1N0YXRlXSA9ICdkb25lJ1xuICAgICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyAzLiBJZiB0aGVyZSBhcmUgYW55IHRhc2tzIGZyb20gdGhpcyBvbiB0aGUgZmlsZSByZWFkaW5nXG4gICAgLy8gICAgdGFzayBzb3VyY2UgaW4gYW4gYWZmaWxpYXRlZCB0YXNrIHF1ZXVlLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHRob3NlIHRhc2tzIGZyb20gdGhhdCB0YXNrIHF1ZXVlLlxuICAgIHRoaXNba0Fib3J0ZWRdID0gdHJ1ZVxuXG4gICAgLy8gNC4gVGVybWluYXRlIHRoZSBhbGdvcml0aG0gZm9yIHRoZSByZWFkIG1ldGhvZCBiZWluZyBwcm9jZXNzZWQuXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gNS4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBhYm9ydCBhdCB0aGlzLlxuICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnYWJvcnQnLCB0aGlzKVxuXG4gICAgLy8gNi4gSWYgdGhpcydzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgdGhpcy5cbiAgICBpZiAodGhpc1trU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLXJlYWR5c3RhdGVcbiAgICovXG4gIGdldCByZWFkeVN0YXRlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgc3dpdGNoICh0aGlzW2tTdGF0ZV0pIHtcbiAgICAgIGNhc2UgJ2VtcHR5JzogcmV0dXJuIHRoaXMuRU1QVFlcbiAgICAgIGNhc2UgJ2xvYWRpbmcnOiByZXR1cm4gdGhpcy5MT0FESU5HXG4gICAgICBjYXNlICdkb25lJzogcmV0dXJuIHRoaXMuRE9ORVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1yZXN1bHRcbiAgICovXG4gIGdldCByZXN1bHQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICAvLyBUaGUgcmVzdWx0IGF0dHJpYnV0ZeKAmXMgZ2V0dGVyLCB3aGVuIGludm9rZWQsIG11c3QgcmV0dXJuXG4gICAgLy8gdGhpcydzIHJlc3VsdC5cbiAgICByZXR1cm4gdGhpc1trUmVzdWx0XVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWVycm9yXG4gICAqL1xuICBnZXQgZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICAvLyBUaGUgZXJyb3IgYXR0cmlidXRl4oCZcyBnZXR0ZXIsIHdoZW4gaW52b2tlZCwgbXVzdCByZXR1cm5cbiAgICAvLyB0aGlzJ3MgZXJyb3IuXG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXVxuICB9XG5cbiAgZ2V0IG9ubG9hZGVuZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRlbmRcbiAgfVxuXG4gIHNldCBvbmxvYWRlbmQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmxvYWRlbmQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIHRoaXNba0V2ZW50c10ubG9hZGVuZClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRlbmQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZGVuZCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10uZXJyb3IpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzW2tFdmVudHNdLmVycm9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10uZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmxvYWRzdGFydCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRzdGFydFxuICB9XG5cbiAgc2V0IG9ubG9hZHN0YXJ0IChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ucHJvZ3Jlc3MgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5wcm9ncmVzc1xuICB9XG5cbiAgc2V0IG9ucHJvZ3Jlc3MgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLnByb2dyZXNzKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpc1trRXZlbnRzXS5wcm9ncmVzcylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLnByb2dyZXNzID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5wcm9ncmVzcyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25sb2FkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ubG9hZFxuICB9XG5cbiAgc2V0IG9ubG9hZCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ubG9hZCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpc1trRXZlbnRzXS5sb2FkKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmFib3J0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10uYWJvcnRcbiAgfVxuXG4gIHNldCBvbmFib3J0IChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5hYm9ydCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRoaXNba0V2ZW50c10uYWJvcnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5hYm9ydCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10uYWJvcnQgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1lbXB0eVxuRmlsZVJlYWRlci5FTVBUWSA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkVNUFRZID0gMFxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWxvYWRpbmdcbkZpbGVSZWFkZXIuTE9BRElORyA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkxPQURJTkcgPSAxXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItZG9uZVxuRmlsZVJlYWRlci5ET05FID0gRmlsZVJlYWRlci5wcm90b3R5cGUuRE9ORSA9IDJcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmlsZVJlYWRlci5wcm90b3R5cGUsIHtcbiAgRU1QVFk6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIExPQURJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIERPTkU6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRBc0FycmF5QnVmZmVyOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkQXNCaW5hcnlTdHJpbmc6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc1RleHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc0RhdGFVUkw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFib3J0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZXN1bHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWRzdGFydDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25wcm9ncmVzczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25sb2FkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmFib3J0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWRlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGaWxlUmVhZGVyJyxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZpbGVSZWFkZXIsIHtcbiAgRU1QVFk6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIExPQURJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIERPTkU6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnNcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGaWxlUmVhZGVyXG59XG4iXSwibmFtZXMiOlsic3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyIsInJlYWRPcGVyYXRpb24iLCJmaXJlQVByb2dyZXNzRXZlbnQiLCJyZXF1aXJlIiwia1N0YXRlIiwia0Vycm9yIiwia1Jlc3VsdCIsImtFdmVudHMiLCJrQWJvcnRlZCIsIndlYmlkbCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJGaWxlUmVhZGVyIiwiRXZlbnRUYXJnZXQiLCJsb2FkZW5kIiwiZXJyb3IiLCJhYm9ydCIsImxvYWQiLCJwcm9ncmVzcyIsImxvYWRzdGFydCIsInJlYWRBc0FycmF5QnVmZmVyIiwiYmxvYiIsImJyYW5kQ2hlY2siLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiY29udmVydGVycyIsIkJsb2IiLCJzdHJpY3QiLCJyZWFkQXNCaW5hcnlTdHJpbmciLCJyZWFkQXNUZXh0IiwiZW5jb2RpbmciLCJ1bmRlZmluZWQiLCJET01TdHJpbmciLCJyZWFkQXNEYXRhVVJMIiwicmVhZHlTdGF0ZSIsIkVNUFRZIiwiTE9BRElORyIsIkRPTkUiLCJyZXN1bHQiLCJvbmxvYWRlbmQiLCJmbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25lcnJvciIsIm9ubG9hZHN0YXJ0Iiwib25wcm9ncmVzcyIsIm9ubG9hZCIsIm9uYWJvcnQiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/progressevent.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst kState = Symbol('ProgressEvent state');\n/**\n * @see https://xhr.spec.whatwg.org/#progressevent\n */ class ProgressEvent extends Event {\n    constructor(type, eventInitDict = {}){\n        type = webidl.converters.DOMString(type, 'ProgressEvent constructor', 'type');\n        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});\n        super(type, eventInitDict);\n        this[kState] = {\n            lengthComputable: eventInitDict.lengthComputable,\n            loaded: eventInitDict.loaded,\n            total: eventInitDict.total\n        };\n    }\n    get lengthComputable() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].lengthComputable;\n    }\n    get loaded() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].loaded;\n    }\n    get total() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].total;\n    }\n}\nwebidl.converters.ProgressEventInit = webidl.dictionaryConverter([\n    {\n        key: 'lengthComputable',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'loaded',\n        converter: webidl.converters['unsigned long long'],\n        defaultValue: ()=>0\n    },\n    {\n        key: 'total',\n        converter: webidl.converters['unsigned long long'],\n        defaultValue: ()=>0\n    },\n    {\n        key: 'bubbles',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'cancelable',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'composed',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    }\n]);\nmodule.exports = {\n    ProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9wcm9ncmVzc2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsNEVBQWlCO0FBRTVDLE1BQU1DLFNBQVNDLE9BQU87QUFFdEI7O0NBRUMsR0FDRCxNQUFNQyxzQkFBc0JDO0lBQzFCLFlBQWFDLElBQUksRUFBRUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFFO1FBQ3JDRCxPQUFPTixPQUFPUSxVQUFVLENBQUNDLFNBQVMsQ0FBQ0gsTUFBTSw2QkFBNkI7UUFDdEVDLGdCQUFnQlAsT0FBT1EsVUFBVSxDQUFDRSxpQkFBaUIsQ0FBQ0gsaUJBQWlCLENBQUM7UUFFdEUsS0FBSyxDQUFDRCxNQUFNQztRQUVaLElBQUksQ0FBQ0wsT0FBTyxHQUFHO1lBQ2JTLGtCQUFrQkosY0FBY0ksZ0JBQWdCO1lBQ2hEQyxRQUFRTCxjQUFjSyxNQUFNO1lBQzVCQyxPQUFPTixjQUFjTSxLQUFLO1FBQzVCO0lBQ0Y7SUFFQSxJQUFJRixtQkFBb0I7UUFDdEJYLE9BQU9jLFVBQVUsQ0FBQyxJQUFJLEVBQUVWO1FBRXhCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNTLGdCQUFnQjtJQUN0QztJQUVBLElBQUlDLFNBQVU7UUFDWlosT0FBT2MsVUFBVSxDQUFDLElBQUksRUFBRVY7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1UsTUFBTTtJQUM1QjtJQUVBLElBQUlDLFFBQVM7UUFDWGIsT0FBT2MsVUFBVSxDQUFDLElBQUksRUFBRVY7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1csS0FBSztJQUMzQjtBQUNGO0FBRUFiLE9BQU9RLFVBQVUsQ0FBQ0UsaUJBQWlCLEdBQUdWLE9BQU9lLG1CQUFtQixDQUFDO0lBQy9EO1FBQ0VDLEtBQUs7UUFDTEMsV0FBV2pCLE9BQU9RLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYyxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakIsT0FBT1EsVUFBVSxDQUFDLHFCQUFxQjtRQUNsRFcsY0FBYyxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakIsT0FBT1EsVUFBVSxDQUFDLHFCQUFxQjtRQUNsRFcsY0FBYyxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakIsT0FBT1EsVUFBVSxDQUFDVSxPQUFPO1FBQ3BDQyxjQUFjLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdqQixPQUFPUSxVQUFVLENBQUNVLE9BQU87UUFDcENDLGNBQWMsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2pCLE9BQU9RLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYyxJQUFNO0lBQ3RCO0NBQ0Q7QUFFREMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZqQjtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmlsZWFwaVxccHJvZ3Jlc3NldmVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5cbmNvbnN0IGtTdGF0ZSA9IFN5bWJvbCgnUHJvZ3Jlc3NFdmVudCBzdGF0ZScpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI3Byb2dyZXNzZXZlbnRcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgJ1Byb2dyZXNzRXZlbnQgY29uc3RydWN0b3InLCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0KGV2ZW50SW5pdERpY3QgPz8ge30pXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogZXZlbnRJbml0RGljdC5sZW5ndGhDb21wdXRhYmxlLFxuICAgICAgbG9hZGVkOiBldmVudEluaXREaWN0LmxvYWRlZCxcbiAgICAgIHRvdGFsOiBldmVudEluaXREaWN0LnRvdGFsXG4gICAgfVxuICB9XG5cbiAgZ2V0IGxlbmd0aENvbXB1dGFibGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxlbmd0aENvbXB1dGFibGVcbiAgfVxuXG4gIGdldCBsb2FkZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxvYWRlZFxuICB9XG5cbiAgZ2V0IHRvdGFsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBQcm9ncmVzc0V2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS50b3RhbFxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnbGVuZ3RoQ29tcHV0YWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2xvYWRlZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICd0b3RhbCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdidWJibGVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY2FuY2VsYWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbXBvc2VkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJvZ3Jlc3NFdmVudFxufVxuIl0sIm5hbWVzIjpbIndlYmlkbCIsInJlcXVpcmUiLCJrU3RhdGUiLCJTeW1ib2wiLCJQcm9ncmVzc0V2ZW50IiwiRXZlbnQiLCJ0eXBlIiwiZXZlbnRJbml0RGljdCIsImNvbnZlcnRlcnMiLCJET01TdHJpbmciLCJQcm9ncmVzc0V2ZW50SW5pdCIsImxlbmd0aENvbXB1dGFibGUiLCJsb2FkZWQiLCJ0b3RhbCIsImJyYW5kQ2hlY2siLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiYm9vbGVhbiIsImRlZmF1bHRWYWx1ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/symbols.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kState: Symbol('FileReader state'),\n    kResult: Symbol('FileReader result'),\n    kError: Symbol('FileReader error'),\n    kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),\n    kEvents: Symbol('FileReader events'),\n    kAborted: Symbol('FileReader aborted')\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxRQUFRQyxPQUFPO0lBQ2ZDLFNBQVNELE9BQU87SUFDaEJFLFFBQVFGLE9BQU87SUFDZkcseUJBQXlCSCxPQUFPO0lBQ2hDSSxTQUFTSixPQUFPO0lBQ2hCSyxVQUFVTCxPQUFPO0FBQ25CIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmlsZWFwaVxcc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtTdGF0ZTogU3ltYm9sKCdGaWxlUmVhZGVyIHN0YXRlJyksXG4gIGtSZXN1bHQ6IFN5bWJvbCgnRmlsZVJlYWRlciByZXN1bHQnKSxcbiAga0Vycm9yOiBTeW1ib2woJ0ZpbGVSZWFkZXIgZXJyb3InKSxcbiAga0xhc3RQcm9ncmVzc0V2ZW50RmlyZWQ6IFN5bWJvbCgnRmlsZVJlYWRlciBsYXN0IHByb2dyZXNzIGV2ZW50IGZpcmVkIHRpbWVzdGFtcCcpLFxuICBrRXZlbnRzOiBTeW1ib2woJ0ZpbGVSZWFkZXIgZXZlbnRzJyksXG4gIGtBYm9ydGVkOiBTeW1ib2woJ0ZpbGVSZWFkZXIgYWJvcnRlZCcpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtTdGF0ZSIsIlN5bWJvbCIsImtSZXN1bHQiLCJrRXJyb3IiLCJrTGFzdFByb2dyZXNzRXZlbnRGaXJlZCIsImtFdmVudHMiLCJrQWJvcnRlZCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kState, kError, kResult, kAborted, kLastProgressEventFired } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\");\nconst { ProgressEvent } = __webpack_require__(/*! ./progressevent */ \"(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js\");\nconst { getEncoding } = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js\");\nconst { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\");\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst { btoa } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */ function readOperation(fr, blob, type, encodingName) {\n    // 1. If fr’s state is \"loading\", throw an InvalidStateError\n    //    DOMException.\n    if (fr[kState] === 'loading') {\n        throw new DOMException('Invalid state', 'InvalidStateError');\n    }\n    // 2. Set fr’s state to \"loading\".\n    fr[kState] = 'loading';\n    // 3. Set fr’s result to null.\n    fr[kResult] = null;\n    // 4. Set fr’s error to null.\n    fr[kError] = null;\n    // 5. Let stream be the result of calling get stream on blob.\n    /** @type {import('stream/web').ReadableStream} */ const stream = blob.stream();\n    // 6. Let reader be the result of getting a reader from stream.\n    const reader = stream.getReader();\n    // 7. Let bytes be an empty byte sequence.\n    /** @type {Uint8Array[]} */ const bytes = [];\n    // 8. Let chunkPromise be the result of reading a chunk from\n    //    stream with reader.\n    let chunkPromise = reader.read();\n    // 9. Let isFirstChunk be true.\n    let isFirstChunk = true;\n    (async ()=>{\n        while(!fr[kAborted]){\n            // 1. Wait for chunkPromise to be fulfilled or rejected.\n            try {\n                const { done, value } = await chunkPromise;\n                // 2. If chunkPromise is fulfilled, and isFirstChunk is\n                //    true, queue a task to fire a progress event called\n                //    loadstart at fr.\n                if (isFirstChunk && !fr[kAborted]) {\n                    queueMicrotask(()=>{\n                        fireAProgressEvent('loadstart', fr);\n                    });\n                }\n                // 3. Set isFirstChunk to false.\n                isFirstChunk = false;\n                // 4. If chunkPromise is fulfilled with an object whose\n                //    done property is false and whose value property is\n                //    a Uint8Array object, run these steps:\n                if (!done && types.isUint8Array(value)) {\n                    // 1. Let bs be the byte sequence represented by the\n                    //    Uint8Array object.\n                    // 2. Append bs to bytes.\n                    bytes.push(value);\n                    // 3. If roughly 50ms have passed since these steps\n                    //    were last invoked, queue a task to fire a\n                    //    progress event called progress at fr.\n                    if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {\n                        fr[kLastProgressEventFired] = Date.now();\n                        queueMicrotask(()=>{\n                            fireAProgressEvent('progress', fr);\n                        });\n                    }\n                    // 4. Set chunkPromise to the result of reading a\n                    //    chunk from stream with reader.\n                    chunkPromise = reader.read();\n                } else if (done) {\n                    // 5. Otherwise, if chunkPromise is fulfilled with an\n                    //    object whose done property is true, queue a task\n                    //    to run the following steps and abort this algorithm:\n                    queueMicrotask(()=>{\n                        // 1. Set fr’s state to \"done\".\n                        fr[kState] = 'done';\n                        // 2. Let result be the result of package data given\n                        //    bytes, type, blob’s type, and encodingName.\n                        try {\n                            const result = packageData(bytes, type, blob.type, encodingName);\n                            // 4. Else:\n                            if (fr[kAborted]) {\n                                return;\n                            }\n                            // 1. Set fr’s result to result.\n                            fr[kResult] = result;\n                            // 2. Fire a progress event called load at the fr.\n                            fireAProgressEvent('load', fr);\n                        } catch (error) {\n                            // 3. If package data threw an exception error:\n                            // 1. Set fr’s error to error.\n                            fr[kError] = error;\n                            // 2. Fire a progress event called error at fr.\n                            fireAProgressEvent('error', fr);\n                        }\n                        // 5. If fr’s state is not \"loading\", fire a progress\n                        //    event called loadend at the fr.\n                        if (fr[kState] !== 'loading') {\n                            fireAProgressEvent('loadend', fr);\n                        }\n                    });\n                    break;\n                }\n            } catch (error) {\n                if (fr[kAborted]) {\n                    return;\n                }\n                // 6. Otherwise, if chunkPromise is rejected with an\n                //    error error, queue a task to run the following\n                //    steps and abort this algorithm:\n                queueMicrotask(()=>{\n                    // 1. Set fr’s state to \"done\".\n                    fr[kState] = 'done';\n                    // 2. Set fr’s error to error.\n                    fr[kError] = error;\n                    // 3. Fire a progress event called error at fr.\n                    fireAProgressEvent('error', fr);\n                    // 4. If fr’s state is not \"loading\", fire a progress\n                    //    event called loadend at fr.\n                    if (fr[kState] !== 'loading') {\n                        fireAProgressEvent('loadend', fr);\n                    }\n                });\n                break;\n            }\n        }\n    })();\n}\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */ function fireAProgressEvent(e, reader) {\n    // The progress event e does not bubble. e.bubbles must be false\n    // The progress event e is NOT cancelable. e.cancelable must be false\n    const event = new ProgressEvent(e, {\n        bubbles: false,\n        cancelable: false\n    });\n    reader.dispatchEvent(event);\n}\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */ function packageData(bytes, type, mimeType, encodingName) {\n    // 1. A Blob has an associated package data algorithm, given\n    //    bytes, a type, a optional mimeType, and a optional\n    //    encodingName, which switches on type and runs the\n    //    associated steps:\n    switch(type){\n        case 'DataURL':\n            {\n                // 1. Return bytes as a DataURL [RFC2397] subject to\n                //    the considerations below:\n                //  * Use mimeType as part of the Data URL if it is\n                //    available in keeping with the Data URL\n                //    specification [RFC2397].\n                //  * If mimeType is not available return a Data URL\n                //    without a media-type. [RFC2397].\n                // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n                // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n                // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n                // data       := *urlchar\n                // parameter  := attribute \"=\" value\n                let dataURL = 'data:';\n                const parsed = parseMIMEType(mimeType || 'application/octet-stream');\n                if (parsed !== 'failure') {\n                    dataURL += serializeAMimeType(parsed);\n                }\n                dataURL += ';base64,';\n                const decoder = new StringDecoder('latin1');\n                for (const chunk of bytes){\n                    dataURL += btoa(decoder.write(chunk));\n                }\n                dataURL += btoa(decoder.end());\n                return dataURL;\n            }\n        case 'Text':\n            {\n                // 1. Let encoding be failure\n                let encoding = 'failure';\n                // 2. If the encodingName is present, set encoding to the\n                //    result of getting an encoding from encodingName.\n                if (encodingName) {\n                    encoding = getEncoding(encodingName);\n                }\n                // 3. If encoding is failure, and mimeType is present:\n                if (encoding === 'failure' && mimeType) {\n                    // 1. Let type be the result of parse a MIME type\n                    //    given mimeType.\n                    const type = parseMIMEType(mimeType);\n                    // 2. If type is not failure, set encoding to the result\n                    //    of getting an encoding from type’s parameters[\"charset\"].\n                    if (type !== 'failure') {\n                        encoding = getEncoding(type.parameters.get('charset'));\n                    }\n                }\n                // 4. If encoding is failure, then set encoding to UTF-8.\n                if (encoding === 'failure') {\n                    encoding = 'UTF-8';\n                }\n                // 5. Decode bytes using fallback encoding encoding, and\n                //    return the result.\n                return decode(bytes, encoding);\n            }\n        case 'ArrayBuffer':\n            {\n                // Return a new ArrayBuffer whose contents are bytes.\n                const sequence = combineByteSequences(bytes);\n                return sequence.buffer;\n            }\n        case 'BinaryString':\n            {\n                // Return bytes as a binary string, in which every byte\n                //  is represented by a code unit of equal value [0..255].\n                let binaryString = '';\n                const decoder = new StringDecoder('latin1');\n                for (const chunk of bytes){\n                    binaryString += decoder.write(chunk);\n                }\n                binaryString += decoder.end();\n                return binaryString;\n            }\n    }\n}\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */ function decode(ioQueue, encoding) {\n    const bytes = combineByteSequences(ioQueue);\n    // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n    const BOMEncoding = BOMSniffing(bytes);\n    let slice = 0;\n    // 2. If BOMEncoding is non-null:\n    if (BOMEncoding !== null) {\n        // 1. Set encoding to BOMEncoding.\n        encoding = BOMEncoding;\n        // 2. Read three bytes from ioQueue, if BOMEncoding is\n        //    UTF-8; otherwise read two bytes.\n        //    (Do nothing with those bytes.)\n        slice = BOMEncoding === 'UTF-8' ? 3 : 2;\n    }\n    // 3. Process a queue with an instance of encoding’s\n    //    decoder, ioQueue, output, and \"replacement\".\n    // 4. Return output.\n    const sliced = bytes.slice(slice);\n    return new TextDecoder(encoding).decode(sliced);\n}\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */ function BOMSniffing(ioQueue) {\n    // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n    //    converted to a byte sequence.\n    const [a, b, c] = ioQueue;\n    // 2. For each of the rows in the table below, starting with\n    //    the first one and going down, if BOM starts with the\n    //    bytes given in the first column, then return the\n    //    encoding given in the cell in the second column of that\n    //    row. Otherwise, return null.\n    if (a === 0xEF && b === 0xBB && c === 0xBF) {\n        return 'UTF-8';\n    } else if (a === 0xFE && b === 0xFF) {\n        return 'UTF-16BE';\n    } else if (a === 0xFF && b === 0xFE) {\n        return 'UTF-16LE';\n    }\n    return null;\n}\n/**\n * @param {Uint8Array[]} sequences\n */ function combineByteSequences(sequences) {\n    const size = sequences.reduce((a, b)=>{\n        return a + b.byteLength;\n    }, 0);\n    let offset = 0;\n    return sequences.reduce((a, b)=>{\n        a.set(b, offset);\n        offset += b.byteLength;\n        return a;\n    }, new Uint8Array(size));\n}\nmodule.exports = {\n    staticPropertyDescriptors,\n    readOperation,\n    fireAProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLHVCQUF1QixFQUN4QixHQUFHQyxtQkFBT0EsQ0FBQyx5RUFBVztBQUN2QixNQUFNLEVBQUVDLGFBQWEsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxxRkFBaUI7QUFDbkQsTUFBTSxFQUFFRSxXQUFXLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsMkVBQVk7QUFDNUMsTUFBTSxFQUFFRyxrQkFBa0IsRUFBRUMsYUFBYSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUN6RSxNQUFNLEVBQUVLLEtBQUssRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQyw0QkFBVztBQUNyQyxNQUFNLEVBQUVNLGFBQWEsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFDbEQsTUFBTSxFQUFFTyxJQUFJLEVBQUUsR0FBR1AsbUJBQU9BLENBQUMsZ0NBQWE7QUFFdEMsK0JBQStCLEdBQy9CLE1BQU1RLDRCQUE0QjtJQUNoQ0MsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGNBQWM7QUFDaEI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxjQUFlQyxFQUFFLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxZQUFZO0lBQ2xELDREQUE0RDtJQUM1RCxtQkFBbUI7SUFDbkIsSUFBSUgsRUFBRSxDQUFDbEIsT0FBTyxLQUFLLFdBQVc7UUFDNUIsTUFBTSxJQUFJc0IsYUFBYSxpQkFBaUI7SUFDMUM7SUFFQSxrQ0FBa0M7SUFDbENKLEVBQUUsQ0FBQ2xCLE9BQU8sR0FBRztJQUViLDhCQUE4QjtJQUM5QmtCLEVBQUUsQ0FBQ2hCLFFBQVEsR0FBRztJQUVkLDZCQUE2QjtJQUM3QmdCLEVBQUUsQ0FBQ2pCLE9BQU8sR0FBRztJQUViLDZEQUE2RDtJQUM3RCxnREFB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bm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmaWxlYXBpXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIGtTdGF0ZSxcbiAga0Vycm9yLFxuICBrUmVzdWx0LFxuICBrQWJvcnRlZCxcbiAga0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBQcm9ncmVzc0V2ZW50IH0gPSByZXF1aXJlKCcuL3Byb2dyZXNzZXZlbnQnKVxuY29uc3QgeyBnZXRFbmNvZGluZyB9ID0gcmVxdWlyZSgnLi9lbmNvZGluZycpXG5jb25zdCB7IHNlcmlhbGl6ZUFNaW1lVHlwZSwgcGFyc2VNSU1FVHlwZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsgU3RyaW5nRGVjb2RlciB9ID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKVxuY29uc3QgeyBidG9hIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5cbi8qKiBAdHlwZSB7UHJvcGVydHlEZXNjcmlwdG9yfSAqL1xuY29uc3Qgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jcmVhZE9wZXJhdGlvblxuICogQHBhcmFtIHtpbXBvcnQoJy4vZmlsZXJlYWRlcicpLkZpbGVSZWFkZXJ9IGZyXG4gKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gZW5jb2RpbmdOYW1lXG4gKi9cbmZ1bmN0aW9uIHJlYWRPcGVyYXRpb24gKGZyLCBibG9iLCB0eXBlLCBlbmNvZGluZ05hbWUpIHtcbiAgLy8gMS4gSWYgZnLigJlzIHN0YXRlIGlzIFwibG9hZGluZ1wiLCB0aHJvdyBhbiBJbnZhbGlkU3RhdGVFcnJvclxuICAvLyAgICBET01FeGNlcHRpb24uXG4gIGlmIChmcltrU3RhdGVdID09PSAnbG9hZGluZycpIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIHN0YXRlJywgJ0ludmFsaWRTdGF0ZUVycm9yJylcbiAgfVxuXG4gIC8vIDIuIFNldCBmcuKAmXMgc3RhdGUgdG8gXCJsb2FkaW5nXCIuXG4gIGZyW2tTdGF0ZV0gPSAnbG9hZGluZydcblxuICAvLyAzLiBTZXQgZnLigJlzIHJlc3VsdCB0byBudWxsLlxuICBmcltrUmVzdWx0XSA9IG51bGxcblxuICAvLyA0LiBTZXQgZnLigJlzIGVycm9yIHRvIG51bGwuXG4gIGZyW2tFcnJvcl0gPSBudWxsXG5cbiAgLy8gNS4gTGV0IHN0cmVhbSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZ2V0IHN0cmVhbSBvbiBibG9iLlxuICAvKiogQHR5cGUge2ltcG9ydCgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtfSAqL1xuICBjb25zdCBzdHJlYW0gPSBibG9iLnN0cmVhbSgpXG5cbiAgLy8gNi4gTGV0IHJlYWRlciBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgYSByZWFkZXIgZnJvbSBzdHJlYW0uXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuXG4gIC8vIDcuIExldCBieXRlcyBiZSBhbiBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAvKiogQHR5cGUge1VpbnQ4QXJyYXlbXX0gKi9cbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIC8vIDguIExldCBjaHVua1Byb21pc2UgYmUgdGhlIHJlc3VsdCBvZiByZWFkaW5nIGEgY2h1bmsgZnJvbVxuICAvLyAgICBzdHJlYW0gd2l0aCByZWFkZXIuXG4gIGxldCBjaHVua1Byb21pc2UgPSByZWFkZXIucmVhZCgpXG5cbiAgLy8gOS4gTGV0IGlzRmlyc3RDaHVuayBiZSB0cnVlLlxuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZVxuXG4gIC8vIDEwLiBJbiBwYXJhbGxlbCwgd2hpbGUgdHJ1ZTpcbiAgLy8gTm90ZTogXCJJbiBwYXJhbGxlbFwiIGp1c3QgbWVhbnMgbm9uLWJsb2NraW5nXG4gIC8vIE5vdGUgMjogcmVhZE9wZXJhdGlvbiBpdHNlbGYgY2Fubm90IGJlIGFzeW5jIGFzIGRvdWJsZVxuICAvLyByZWFkaW5nIHRoZSBib2R5IHdvdWxkIHRoZW4gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnN0ZWFkXG4gIC8vIG9mIHRocm93aW5nIGFuIGVycm9yLlxuICA7KGFzeW5jICgpID0+IHtcbiAgICB3aGlsZSAoIWZyW2tBYm9ydGVkXSkge1xuICAgICAgLy8gMS4gV2FpdCBmb3IgY2h1bmtQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGNodW5rUHJvbWlzZVxuXG4gICAgICAgIC8vIDIuIElmIGNodW5rUHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCBpc0ZpcnN0Q2h1bmsgaXNcbiAgICAgICAgLy8gICAgdHJ1ZSwgcXVldWUgYSB0YXNrIHRvIGZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWRcbiAgICAgICAgLy8gICAgbG9hZHN0YXJ0IGF0IGZyLlxuICAgICAgICBpZiAoaXNGaXJzdENodW5rICYmICFmcltrQWJvcnRlZF0pIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRzdGFydCcsIGZyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBTZXQgaXNGaXJzdENodW5rIHRvIGZhbHNlLlxuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZVxuXG4gICAgICAgIC8vIDQuIElmIGNodW5rUHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhbiBvYmplY3Qgd2hvc2VcbiAgICAgICAgLy8gICAgZG9uZSBwcm9wZXJ0eSBpcyBmYWxzZSBhbmQgd2hvc2UgdmFsdWUgcHJvcGVydHkgaXNcbiAgICAgICAgLy8gICAgYSBVaW50OEFycmF5IG9iamVjdCwgcnVuIHRoZXNlIHN0ZXBzOlxuICAgICAgICBpZiAoIWRvbmUgJiYgdHlwZXMuaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgIC8vIDEuIExldCBicyBiZSB0aGUgYnl0ZSBzZXF1ZW5jZSByZXByZXNlbnRlZCBieSB0aGVcbiAgICAgICAgICAvLyAgICBVaW50OEFycmF5IG9iamVjdC5cblxuICAgICAgICAgIC8vIDIuIEFwcGVuZCBicyB0byBieXRlcy5cbiAgICAgICAgICBieXRlcy5wdXNoKHZhbHVlKVxuXG4gICAgICAgICAgLy8gMy4gSWYgcm91Z2hseSA1MG1zIGhhdmUgcGFzc2VkIHNpbmNlIHRoZXNlIHN0ZXBzXG4gICAgICAgICAgLy8gICAgd2VyZSBsYXN0IGludm9rZWQsIHF1ZXVlIGEgdGFzayB0byBmaXJlIGFcbiAgICAgICAgICAvLyAgICBwcm9ncmVzcyBldmVudCBjYWxsZWQgcHJvZ3Jlc3MgYXQgZnIuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBmcltrTGFzdFByb2dyZXNzRXZlbnRGaXJlZF0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICBEYXRlLm5vdygpIC0gZnJba0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRdID49IDUwXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICAhZnJba0Fib3J0ZWRdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmcltrTGFzdFByb2dyZXNzRXZlbnRGaXJlZF0gPSBEYXRlLm5vdygpXG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgncHJvZ3Jlc3MnLCBmcilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4gU2V0IGNodW5rUHJvbWlzZSB0byB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgYVxuICAgICAgICAgIC8vICAgIGNodW5rIGZyb20gc3RyZWFtIHdpdGggcmVhZGVyLlxuICAgICAgICAgIGNodW5rUHJvbWlzZSA9IHJlYWRlci5yZWFkKClcbiAgICAgICAgfSBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiBjaHVua1Byb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW5cbiAgICAgICAgICAvLyAgICBvYmplY3Qgd2hvc2UgZG9uZSBwcm9wZXJ0eSBpcyB0cnVlLCBxdWV1ZSBhIHRhc2tcbiAgICAgICAgICAvLyAgICB0byBydW4gdGhlIGZvbGxvd2luZyBzdGVwcyBhbmQgYWJvcnQgdGhpcyBhbGdvcml0aG06XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyBzdGF0ZSB0byBcImRvbmVcIi5cbiAgICAgICAgICAgIGZyW2tTdGF0ZV0gPSAnZG9uZSdcblxuICAgICAgICAgICAgLy8gMi4gTGV0IHJlc3VsdCBiZSB0aGUgcmVzdWx0IG9mIHBhY2thZ2UgZGF0YSBnaXZlblxuICAgICAgICAgICAgLy8gICAgYnl0ZXMsIHR5cGUsIGJsb2LigJlzIHR5cGUsIGFuZCBlbmNvZGluZ05hbWUuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYWNrYWdlRGF0YShieXRlcywgdHlwZSwgYmxvYi50eXBlLCBlbmNvZGluZ05hbWUpXG5cbiAgICAgICAgICAgICAgLy8gNC4gRWxzZTpcblxuICAgICAgICAgICAgICBpZiAoZnJba0Fib3J0ZWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIHJlc3VsdCB0byByZXN1bHQuXG4gICAgICAgICAgICAgIGZyW2tSZXN1bHRdID0gcmVzdWx0XG5cbiAgICAgICAgICAgICAgLy8gMi4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBsb2FkIGF0IHRoZSBmci5cbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkJywgZnIpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAvLyAzLiBJZiBwYWNrYWdlIGRhdGEgdGhyZXcgYW4gZXhjZXB0aW9uIGVycm9yOlxuXG4gICAgICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgZXJyb3IgdG8gZXJyb3IuXG4gICAgICAgICAgICAgIGZyW2tFcnJvcl0gPSBlcnJvclxuXG4gICAgICAgICAgICAgIC8vIDIuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgZXJyb3IgYXQgZnIuXG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnZXJyb3InLCBmcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gNS4gSWYgZnLigJlzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgICAgICAgICAvLyAgICBldmVudCBjYWxsZWQgbG9hZGVuZCBhdCB0aGUgZnIuXG4gICAgICAgICAgICBpZiAoZnJba1N0YXRlXSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIGZyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZnJba0Fib3J0ZWRdKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyA2LiBPdGhlcndpc2UsIGlmIGNodW5rUHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuXG4gICAgICAgIC8vICAgIGVycm9yIGVycm9yLCBxdWV1ZSBhIHRhc2sgdG8gcnVuIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gICAgc3RlcHMgYW5kIGFib3J0IHRoaXMgYWxnb3JpdGhtOlxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyBzdGF0ZSB0byBcImRvbmVcIi5cbiAgICAgICAgICBmcltrU3RhdGVdID0gJ2RvbmUnXG5cbiAgICAgICAgICAvLyAyLiBTZXQgZnLigJlzIGVycm9yIHRvIGVycm9yLlxuICAgICAgICAgIGZyW2tFcnJvcl0gPSBlcnJvclxuXG4gICAgICAgICAgLy8gMy4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBlcnJvciBhdCBmci5cbiAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2Vycm9yJywgZnIpXG5cbiAgICAgICAgICAvLyA0LiBJZiBmcuKAmXMgc3RhdGUgaXMgbm90IFwibG9hZGluZ1wiLCBmaXJlIGEgcHJvZ3Jlc3NcbiAgICAgICAgICAvLyAgICBldmVudCBjYWxsZWQgbG9hZGVuZCBhdCBmci5cbiAgICAgICAgICBpZiAoZnJba1N0YXRlXSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRlbmQnLCBmcilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0pKClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNmaXJlLWEtcHJvZ3Jlc3MtZXZlbnRcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWV2ZW50LWZpcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vZmlsZXJlYWRlcicpLkZpbGVSZWFkZXJ9IHJlYWRlclxuICovXG5mdW5jdGlvbiBmaXJlQVByb2dyZXNzRXZlbnQgKGUsIHJlYWRlcikge1xuICAvLyBUaGUgcHJvZ3Jlc3MgZXZlbnQgZSBkb2VzIG5vdCBidWJibGUuIGUuYnViYmxlcyBtdXN0IGJlIGZhbHNlXG4gIC8vIFRoZSBwcm9ncmVzcyBldmVudCBlIGlzIE5PVCBjYW5jZWxhYmxlLiBlLmNhbmNlbGFibGUgbXVzdCBiZSBmYWxzZVxuICBjb25zdCBldmVudCA9IG5ldyBQcm9ncmVzc0V2ZW50KGUsIHtcbiAgICBidWJibGVzOiBmYWxzZSxcbiAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICB9KVxuXG4gIHJlYWRlci5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Jsb2ItcGFja2FnZS1kYXRhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXlbXX0gYnl0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZz99IG1pbWVUeXBlXG4gKiBAcGFyYW0ge3N0cmluZz99IGVuY29kaW5nTmFtZVxuICovXG5mdW5jdGlvbiBwYWNrYWdlRGF0YSAoYnl0ZXMsIHR5cGUsIG1pbWVUeXBlLCBlbmNvZGluZ05hbWUpIHtcbiAgLy8gMS4gQSBCbG9iIGhhcyBhbiBhc3NvY2lhdGVkIHBhY2thZ2UgZGF0YSBhbGdvcml0aG0sIGdpdmVuXG4gIC8vICAgIGJ5dGVzLCBhIHR5cGUsIGEgb3B0aW9uYWwgbWltZVR5cGUsIGFuZCBhIG9wdGlvbmFsXG4gIC8vICAgIGVuY29kaW5nTmFtZSwgd2hpY2ggc3dpdGNoZXMgb24gdHlwZSBhbmQgcnVucyB0aGVcbiAgLy8gICAgYXNzb2NpYXRlZCBzdGVwczpcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdEYXRhVVJMJzoge1xuICAgICAgLy8gMS4gUmV0dXJuIGJ5dGVzIGFzIGEgRGF0YVVSTCBbUkZDMjM5N10gc3ViamVjdCB0b1xuICAgICAgLy8gICAgdGhlIGNvbnNpZGVyYXRpb25zIGJlbG93OlxuICAgICAgLy8gICogVXNlIG1pbWVUeXBlIGFzIHBhcnQgb2YgdGhlIERhdGEgVVJMIGlmIGl0IGlzXG4gICAgICAvLyAgICBhdmFpbGFibGUgaW4ga2VlcGluZyB3aXRoIHRoZSBEYXRhIFVSTFxuICAgICAgLy8gICAgc3BlY2lmaWNhdGlvbiBbUkZDMjM5N10uXG4gICAgICAvLyAgKiBJZiBtaW1lVHlwZSBpcyBub3QgYXZhaWxhYmxlIHJldHVybiBhIERhdGEgVVJMXG4gICAgICAvLyAgICB3aXRob3V0IGEgbWVkaWEtdHlwZS4gW1JGQzIzOTddLlxuXG4gICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzIzOTcjc2VjdGlvbi0zXG4gICAgICAvLyBkYXRhdXJsICAgIDo9IFwiZGF0YTpcIiBbIG1lZGlhdHlwZSBdIFsgXCI7YmFzZTY0XCIgXSBcIixcIiBkYXRhXG4gICAgICAvLyBtZWRpYXR5cGUgIDo9IFsgdHlwZSBcIi9cIiBzdWJ0eXBlIF0gKiggXCI7XCIgcGFyYW1ldGVyIClcbiAgICAgIC8vIGRhdGEgICAgICAgOj0gKnVybGNoYXJcbiAgICAgIC8vIHBhcmFtZXRlciAgOj0gYXR0cmlidXRlIFwiPVwiIHZhbHVlXG4gICAgICBsZXQgZGF0YVVSTCA9ICdkYXRhOidcblxuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VNSU1FVHlwZShtaW1lVHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJylcblxuICAgICAgaWYgKHBhcnNlZCAhPT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgIGRhdGFVUkwgKz0gc2VyaWFsaXplQU1pbWVUeXBlKHBhcnNlZClcbiAgICAgIH1cblxuICAgICAgZGF0YVVSTCArPSAnO2Jhc2U2NCwnXG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcignbGF0aW4xJylcblxuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBieXRlcykge1xuICAgICAgICBkYXRhVVJMICs9IGJ0b2EoZGVjb2Rlci53cml0ZShjaHVuaykpXG4gICAgICB9XG5cbiAgICAgIGRhdGFVUkwgKz0gYnRvYShkZWNvZGVyLmVuZCgpKVxuXG4gICAgICByZXR1cm4gZGF0YVVSTFxuICAgIH1cbiAgICBjYXNlICdUZXh0Jzoge1xuICAgICAgLy8gMS4gTGV0IGVuY29kaW5nIGJlIGZhaWx1cmVcbiAgICAgIGxldCBlbmNvZGluZyA9ICdmYWlsdXJlJ1xuXG4gICAgICAvLyAyLiBJZiB0aGUgZW5jb2RpbmdOYW1lIGlzIHByZXNlbnQsIHNldCBlbmNvZGluZyB0byB0aGVcbiAgICAgIC8vICAgIHJlc3VsdCBvZiBnZXR0aW5nIGFuIGVuY29kaW5nIGZyb20gZW5jb2RpbmdOYW1lLlxuICAgICAgaWYgKGVuY29kaW5nTmFtZSkge1xuICAgICAgICBlbmNvZGluZyA9IGdldEVuY29kaW5nKGVuY29kaW5nTmFtZSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgZW5jb2RpbmcgaXMgZmFpbHVyZSwgYW5kIG1pbWVUeXBlIGlzIHByZXNlbnQ6XG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdmYWlsdXJlJyAmJiBtaW1lVHlwZSkge1xuICAgICAgICAvLyAxLiBMZXQgdHlwZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNlIGEgTUlNRSB0eXBlXG4gICAgICAgIC8vICAgIGdpdmVuIG1pbWVUeXBlLlxuICAgICAgICBjb25zdCB0eXBlID0gcGFyc2VNSU1FVHlwZShtaW1lVHlwZSlcblxuICAgICAgICAvLyAyLiBJZiB0eXBlIGlzIG5vdCBmYWlsdXJlLCBzZXQgZW5jb2RpbmcgdG8gdGhlIHJlc3VsdFxuICAgICAgICAvLyAgICBvZiBnZXR0aW5nIGFuIGVuY29kaW5nIGZyb20gdHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0uXG4gICAgICAgIGlmICh0eXBlICE9PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICBlbmNvZGluZyA9IGdldEVuY29kaW5nKHR5cGUucGFyYW1ldGVycy5nZXQoJ2NoYXJzZXQnKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA0LiBJZiBlbmNvZGluZyBpcyBmYWlsdXJlLCB0aGVuIHNldCBlbmNvZGluZyB0byBVVEYtOC5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgIGVuY29kaW5nID0gJ1VURi04J1xuICAgICAgfVxuXG4gICAgICAvLyA1LiBEZWNvZGUgYnl0ZXMgdXNpbmcgZmFsbGJhY2sgZW5jb2RpbmcgZW5jb2RpbmcsIGFuZFxuICAgICAgLy8gICAgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICByZXR1cm4gZGVjb2RlKGJ5dGVzLCBlbmNvZGluZylcbiAgICB9XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOiB7XG4gICAgICAvLyBSZXR1cm4gYSBuZXcgQXJyYXlCdWZmZXIgd2hvc2UgY29udGVudHMgYXJlIGJ5dGVzLlxuICAgICAgY29uc3Qgc2VxdWVuY2UgPSBjb21iaW5lQnl0ZVNlcXVlbmNlcyhieXRlcylcblxuICAgICAgcmV0dXJuIHNlcXVlbmNlLmJ1ZmZlclxuICAgIH1cbiAgICBjYXNlICdCaW5hcnlTdHJpbmcnOiB7XG4gICAgICAvLyBSZXR1cm4gYnl0ZXMgYXMgYSBiaW5hcnkgc3RyaW5nLCBpbiB3aGljaCBldmVyeSBieXRlXG4gICAgICAvLyAgaXMgcmVwcmVzZW50ZWQgYnkgYSBjb2RlIHVuaXQgb2YgZXF1YWwgdmFsdWUgWzAuLjI1NV0uXG4gICAgICBsZXQgYmluYXJ5U3RyaW5nID0gJydcblxuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCdsYXRpbjEnKVxuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGJ5dGVzKSB7XG4gICAgICAgIGJpbmFyeVN0cmluZyArPSBkZWNvZGVyLndyaXRlKGNodW5rKVxuICAgICAgfVxuXG4gICAgICBiaW5hcnlTdHJpbmcgKz0gZGVjb2Rlci5lbmQoKVxuXG4gICAgICByZXR1cm4gYmluYXJ5U3RyaW5nXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jZGVjb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXlbXX0gaW9RdWV1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKi9cbmZ1bmN0aW9uIGRlY29kZSAoaW9RdWV1ZSwgZW5jb2RpbmcpIHtcbiAgY29uc3QgYnl0ZXMgPSBjb21iaW5lQnl0ZVNlcXVlbmNlcyhpb1F1ZXVlKVxuXG4gIC8vIDEuIExldCBCT01FbmNvZGluZyBiZSB0aGUgcmVzdWx0IG9mIEJPTSBzbmlmZmluZyBpb1F1ZXVlLlxuICBjb25zdCBCT01FbmNvZGluZyA9IEJPTVNuaWZmaW5nKGJ5dGVzKVxuXG4gIGxldCBzbGljZSA9IDBcblxuICAvLyAyLiBJZiBCT01FbmNvZGluZyBpcyBub24tbnVsbDpcbiAgaWYgKEJPTUVuY29kaW5nICE9PSBudWxsKSB7XG4gICAgLy8gMS4gU2V0IGVuY29kaW5nIHRvIEJPTUVuY29kaW5nLlxuICAgIGVuY29kaW5nID0gQk9NRW5jb2RpbmdcblxuICAgIC8vIDIuIFJlYWQgdGhyZWUgYnl0ZXMgZnJvbSBpb1F1ZXVlLCBpZiBCT01FbmNvZGluZyBpc1xuICAgIC8vICAgIFVURi04OyBvdGhlcndpc2UgcmVhZCB0d28gYnl0ZXMuXG4gICAgLy8gICAgKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gICAgc2xpY2UgPSBCT01FbmNvZGluZyA9PT0gJ1VURi04JyA/IDMgOiAyXG4gIH1cblxuICAvLyAzLiBQcm9jZXNzIGEgcXVldWUgd2l0aCBhbiBpbnN0YW5jZSBvZiBlbmNvZGluZ+KAmXNcbiAgLy8gICAgZGVjb2RlciwgaW9RdWV1ZSwgb3V0cHV0LCBhbmQgXCJyZXBsYWNlbWVudFwiLlxuXG4gIC8vIDQuIFJldHVybiBvdXRwdXQuXG5cbiAgY29uc3Qgc2xpY2VkID0gYnl0ZXMuc2xpY2Uoc2xpY2UpXG4gIHJldHVybiBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpLmRlY29kZShzbGljZWQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jYm9tLXNuaWZmXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlvUXVldWVcbiAqL1xuZnVuY3Rpb24gQk9NU25pZmZpbmcgKGlvUXVldWUpIHtcbiAgLy8gMS4gTGV0IEJPTSBiZSB0aGUgcmVzdWx0IG9mIHBlZWtpbmcgMyBieXRlcyBmcm9tIGlvUXVldWUsXG4gIC8vICAgIGNvbnZlcnRlZCB0byBhIGJ5dGUgc2VxdWVuY2UuXG4gIGNvbnN0IFthLCBiLCBjXSA9IGlvUXVldWVcblxuICAvLyAyLiBGb3IgZWFjaCBvZiB0aGUgcm93cyBpbiB0aGUgdGFibGUgYmVsb3csIHN0YXJ0aW5nIHdpdGhcbiAgLy8gICAgdGhlIGZpcnN0IG9uZSBhbmQgZ29pbmcgZG93biwgaWYgQk9NIHN0YXJ0cyB3aXRoIHRoZVxuICAvLyAgICBieXRlcyBnaXZlbiBpbiB0aGUgZmlyc3QgY29sdW1uLCB0aGVuIHJldHVybiB0aGVcbiAgLy8gICAgZW5jb2RpbmcgZ2l2ZW4gaW4gdGhlIGNlbGwgaW4gdGhlIHNlY29uZCBjb2x1bW4gb2YgdGhhdFxuICAvLyAgICByb3cuIE90aGVyd2lzZSwgcmV0dXJuIG51bGwuXG4gIGlmIChhID09PSAweEVGICYmIGIgPT09IDB4QkIgJiYgYyA9PT0gMHhCRikge1xuICAgIHJldHVybiAnVVRGLTgnXG4gIH0gZWxzZSBpZiAoYSA9PT0gMHhGRSAmJiBiID09PSAweEZGKSB7XG4gICAgcmV0dXJuICdVVEYtMTZCRSdcbiAgfSBlbHNlIGlmIChhID09PSAweEZGICYmIGIgPT09IDB4RkUpIHtcbiAgICByZXR1cm4gJ1VURi0xNkxFJ1xuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXlbXX0gc2VxdWVuY2VzXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVCeXRlU2VxdWVuY2VzIChzZXF1ZW5jZXMpIHtcbiAgY29uc3Qgc2l6ZSA9IHNlcXVlbmNlcy5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYSArIGIuYnl0ZUxlbmd0aFxuICB9LCAwKVxuXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgcmV0dXJuIHNlcXVlbmNlcy5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICBhLnNldChiLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGIuYnl0ZUxlbmd0aFxuICAgIHJldHVybiBhXG4gIH0sIG5ldyBVaW50OEFycmF5KHNpemUpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgcmVhZE9wZXJhdGlvbixcbiAgZmlyZUFQcm9ncmVzc0V2ZW50XG59XG4iXSwibmFtZXMiOlsia1N0YXRlIiwia0Vycm9yIiwia1Jlc3VsdCIsImtBYm9ydGVkIiwia0xhc3RQcm9ncmVzc0V2ZW50RmlyZWQiLCJyZXF1aXJlIiwiUHJvZ3Jlc3NFdmVudCIsImdldEVuY29kaW5nIiwic2VyaWFsaXplQU1pbWVUeXBlIiwicGFyc2VNSU1FVHlwZSIsInR5cGVzIiwiU3RyaW5nRGVjb2RlciIsImJ0b2EiLCJzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwicmVhZE9wZXJhdGlvbiIsImZyIiwiYmxvYiIsInR5cGUiLCJlbmNvZGluZ05hbWUiLCJET01FeGNlcHRpb24iLCJzdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJieXRlcyIsImNodW5rUHJvbWlzZSIsInJlYWQiLCJpc0ZpcnN0Q2h1bmsiLCJkb25lIiwidmFsdWUiLCJxdWV1ZU1pY3JvdGFzayIsImZpcmVBUHJvZ3Jlc3NFdmVudCIsImlzVWludDhBcnJheSIsInB1c2giLCJ1bmRlZmluZWQiLCJEYXRlIiwibm93IiwicmVzdWx0IiwicGFja2FnZURhdGEiLCJlcnJvciIsImUiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsIm1pbWVUeXBlIiwiZGF0YVVSTCIsInBhcnNlZCIsImRlY29kZXIiLCJjaHVuayIsIndyaXRlIiwiZW5kIiwiZW5jb2RpbmciLCJwYXJhbWV0ZXJzIiwiZ2V0IiwiZGVjb2RlIiwic2VxdWVuY2UiLCJjb21iaW5lQnl0ZVNlcXVlbmNlcyIsImJ1ZmZlciIsImJpbmFyeVN0cmluZyIsImlvUXVldWUiLCJCT01FbmNvZGluZyIsIkJPTVNuaWZmaW5nIiwic2xpY2UiLCJzbGljZWQiLCJUZXh0RGVjb2RlciIsImEiLCJiIiwiYyIsInNlcXVlbmNlcyIsInNpemUiLCJyZWR1Y2UiLCJieXRlTGVuZ3RoIiwib2Zmc2V0Iiwic2V0IiwiVWludDhBcnJheSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst { kReadyState, kSentClose, kByteParser, kReceivedClose, kResponse } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\");\nconst { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\");\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst { CloseEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\");\nconst { Headers, getHeadersList } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\nconst { getDecodeSplit } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\");\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* c8 ignore next 3 */ } catch  {}\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any, extensions: string[] | undefined) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */ function establishWebSocketConnection(url, protocols, client, ws, onEstablish, options) {\n    // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n    //    scheme is \"ws\", and to \"https\" otherwise.\n    const requestURL = url;\n    requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';\n    // 2. Let request be a new request, whose URL is requestURL, client is client,\n    //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n    //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n    //    and redirect mode is \"error\".\n    const request = makeRequest({\n        urlList: [\n            requestURL\n        ],\n        client,\n        serviceWorkers: 'none',\n        referrer: 'no-referrer',\n        mode: 'websocket',\n        credentials: 'include',\n        cache: 'no-store',\n        redirect: 'error'\n    });\n    // Note: undici extension, allow setting custom headers.\n    if (options.headers) {\n        const headersList = getHeadersList(new Headers(options.headers));\n        request.headersList = headersList;\n    }\n    // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n    // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n    // Note: both of these are handled by undici currently.\n    // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n    // 5. Let keyValue be a nonce consisting of a randomly selected\n    //    16-byte value that has been forgiving-base64-encoded and\n    //    isomorphic encoded.\n    const keyValue = crypto.randomBytes(16).toString('base64');\n    // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n    //    header list.\n    request.headersList.append('sec-websocket-key', keyValue);\n    // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n    //    header list.\n    request.headersList.append('sec-websocket-version', '13');\n    // 8. For each protocol in protocols, combine\n    //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n    //    list.\n    for (const protocol of protocols){\n        request.headersList.append('sec-websocket-protocol', protocol);\n    }\n    // 9. Let permessageDeflate be a user-agent defined\n    //    \"permessage-deflate\" extension header value.\n    // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n    const permessageDeflate = 'permessage-deflate; client_max_window_bits';\n    // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n    //     request’s header list.\n    request.headersList.append('sec-websocket-extensions', permessageDeflate);\n    // 11. Fetch request with useParallelQueue set to true, and\n    //     processResponse given response being these steps:\n    const controller = fetching({\n        request,\n        useParallelQueue: true,\n        dispatcher: options.dispatcher,\n        processResponse (response) {\n            // 1. If response is a network error or its status is not 101,\n            //    fail the WebSocket connection.\n            if (response.type === 'error' || response.status !== 101) {\n                failWebsocketConnection(ws, 'Received network error or non-101 status code.');\n                return;\n            }\n            // 2. If protocols is not the empty list and extracting header\n            //    list values given `Sec-WebSocket-Protocol` and response’s\n            //    header list results in null, failure, or the empty byte\n            //    sequence, then fail the WebSocket connection.\n            if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n                failWebsocketConnection(ws, 'Server did not respond with sent protocols.');\n                return;\n            }\n            // 3. Follow the requirements stated step 2 to step 6, inclusive,\n            //    of the last set of steps in section 4.1 of The WebSocket\n            //    Protocol to validate response. This either results in fail\n            //    the WebSocket connection or the WebSocket connection is\n            //    established.\n            // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n            //    header field contains a value that is not an ASCII case-\n            //    insensitive match for the value \"websocket\", the client MUST\n            //    _Fail the WebSocket Connection_.\n            if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n                failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n                return;\n            }\n            // 3. If the response lacks a |Connection| header field or the\n            //    |Connection| header field doesn't contain a token that is an\n            //    ASCII case-insensitive match for the value \"Upgrade\", the client\n            //    MUST _Fail the WebSocket Connection_.\n            if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n                failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n                return;\n            }\n            // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n            //    the |Sec-WebSocket-Accept| contains a value other than the\n            //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n            //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n            //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n            //    trailing whitespace, the client MUST _Fail the WebSocket\n            //    Connection_.\n            const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');\n            const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64');\n            if (secWSAccept !== digest) {\n                failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');\n                return;\n            }\n            // 5. If the response includes a |Sec-WebSocket-Extensions| header\n            //    field and this header field indicates the use of an extension\n            //    that was not present in the client's handshake (the server has\n            //    indicated an extension not requested by the client), the client\n            //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n            //    header field to determine which extensions are requested is\n            //    discussed in Section 9.1.)\n            const secExtension = response.headersList.get('Sec-WebSocket-Extensions');\n            let extensions;\n            if (secExtension !== null) {\n                extensions = parseExtensions(secExtension);\n                if (!extensions.has('permessage-deflate')) {\n                    failWebsocketConnection(ws, 'Sec-WebSocket-Extensions header does not match.');\n                    return;\n                }\n            }\n            // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n            //    and this header field indicates the use of a subprotocol that was\n            //    not present in the client's handshake (the server has indicated a\n            //    subprotocol not requested by the client), the client MUST _Fail\n            //    the WebSocket Connection_.\n            const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');\n            if (secProtocol !== null) {\n                const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList);\n                // The client can request that the server use a specific subprotocol by\n                // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n                // is specified, the server needs to include the same field and one of\n                // the selected subprotocol values in its response for the connection to\n                // be established.\n                if (!requestProtocols.includes(secProtocol)) {\n                    failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');\n                    return;\n                }\n            }\n            response.socket.on('data', onSocketData);\n            response.socket.on('close', onSocketClose);\n            response.socket.on('error', onSocketError);\n            if (channels.open.hasSubscribers) {\n                channels.open.publish({\n                    address: response.socket.address(),\n                    protocol: secProtocol,\n                    extensions: secExtension\n                });\n            }\n            onEstablish(response, extensions);\n        }\n    });\n    return controller;\n}\nfunction closeWebSocketConnection(ws, code, reason, reasonByteLength) {\n    if (isClosing(ws) || isClosed(ws)) {\n    // If this's ready state is CLOSING (2) or CLOSED (3)\n    // Do nothing.\n    } else if (!isEstablished(ws)) {\n        // If the WebSocket connection is not yet established\n        // Fail the WebSocket connection and set this's ready state\n        // to CLOSING (2).\n        failWebsocketConnection(ws, 'Connection was closed before it was established.');\n        ws[kReadyState] = states.CLOSING;\n    } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {\n        // If the WebSocket closing handshake has not yet been started\n        // Start the WebSocket closing handshake and set this's ready\n        // state to CLOSING (2).\n        // - If neither code nor reason is present, the WebSocket Close\n        //   message must not have a body.\n        // - If code is present, then the status code to use in the\n        //   WebSocket Close message must be the integer given by code.\n        // - If reason is also present, then reasonBytes must be\n        //   provided in the Close message after the status code.\n        ws[kSentClose] = sentCloseFrameState.PROCESSING;\n        const frame = new WebsocketFrameSend();\n        // If neither code nor reason is present, the WebSocket Close\n        // message must not have a body.\n        // If code is present, then the status code to use in the\n        // WebSocket Close message must be the integer given by code.\n        if (code !== undefined && reason === undefined) {\n            frame.frameData = Buffer.allocUnsafe(2);\n            frame.frameData.writeUInt16BE(code, 0);\n        } else if (code !== undefined && reason !== undefined) {\n            // If reason is also present, then reasonBytes must be\n            // provided in the Close message after the status code.\n            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n            frame.frameData.writeUInt16BE(code, 0);\n            // the body MAY contain UTF-8-encoded data with value /reason/\n            frame.frameData.write(reason, 2, 'utf-8');\n        } else {\n            frame.frameData = emptyBuffer;\n        }\n        /** @type {import('stream').Duplex} */ const socket = ws[kResponse].socket;\n        socket.write(frame.createFrame(opcodes.CLOSE));\n        ws[kSentClose] = sentCloseFrameState.SENT;\n        // Upon either sending or receiving a Close control frame, it is said\n        // that _The WebSocket Closing Handshake is Started_ and that the\n        // WebSocket connection is in the CLOSING state.\n        ws[kReadyState] = states.CLOSING;\n    } else {\n        // Otherwise\n        // Set this's ready state to CLOSING (2).\n        ws[kReadyState] = states.CLOSING;\n    }\n}\n/**\n * @param {Buffer} chunk\n */ function onSocketData(chunk) {\n    if (!this.ws[kByteParser].write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */ function onSocketClose() {\n    const { ws } = this;\n    const { [kResponse]: response } = ws;\n    response.socket.off('data', onSocketData);\n    response.socket.off('close', onSocketClose);\n    response.socket.off('error', onSocketError);\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];\n    let code = 1005;\n    let reason = '';\n    const result = ws[kByteParser].closingInfo;\n    if (result && !result.error) {\n        code = result.code ?? 1005;\n        reason = result.reason;\n    } else if (!ws[kReceivedClose]) {\n        // If _The WebSocket\n        // Connection is Closed_ and no Close control frame was received by the\n        // endpoint (such as could occur if the underlying transport connection\n        // is lost), _The WebSocket Connection Close Code_ is considered to be\n        // 1006.\n        code = 1006;\n    }\n    // 1. Change the ready state to CLOSED (3).\n    ws[kReadyState] = states.CLOSED;\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    // TODO\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    // TODO: process.nextTick\n    fireEvent('close', ws, (type, init)=>new CloseEvent(type, init), {\n        wasClean,\n        code,\n        reason\n    });\n    if (channels.close.hasSubscribers) {\n        channels.close.publish({\n            websocket: ws,\n            code,\n            reason\n        });\n    }\n}\nfunction onSocketError(error) {\n    const { ws } = this;\n    ws[kReadyState] = states.CLOSING;\n    if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(error);\n    }\n    this.destroy();\n}\nmodule.exports = {\n    establishWebSocketConnection,\n    closeWebSocketConnection\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRUMsV0FBVyxFQUFFQyxPQUFPLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsK0VBQWE7QUFDeEYsTUFBTSxFQUNKQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxjQUFjLEVBQ2RDLFNBQVMsRUFDVixHQUFHTCxtQkFBT0EsQ0FBQywyRUFBVztBQUN2QixNQUFNLEVBQUVNLFNBQVMsRUFBRUMsdUJBQXVCLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLGVBQWUsRUFBRSxHQUFHWCxtQkFBT0EsQ0FBQyxxRUFBUTtBQUNwSCxNQUFNLEVBQUVZLFFBQVEsRUFBRSxHQUFHWixtQkFBT0EsQ0FBQyxtRkFBd0I7QUFDckQsTUFBTSxFQUFFYSxVQUFVLEVBQUUsR0FBR2IsbUJBQU9BLENBQUMseUVBQVU7QUFDekMsTUFBTSxFQUFFYyxXQUFXLEVBQUUsR0FBR2QsbUJBQU9BLENBQUMsOEVBQWtCO0FBQ2xELE1BQU0sRUFBRWUsUUFBUSxFQUFFLEdBQUdmLG1CQUFPQSxDQUFDLDBFQUFnQjtBQUM3QyxNQUFNLEVBQUVnQixPQUFPLEVBQUVDLGNBQWMsRUFBRSxHQUFHakIsbUJBQU9BLENBQUMsOEVBQWtCO0FBQzlELE1BQU0sRUFBRWtCLGNBQWMsRUFBRSxHQUFHbEIsbUJBQU9BLENBQUMsd0VBQWU7QUFDbEQsTUFBTSxFQUFFbUIsa0JBQWtCLEVBQUUsR0FBR25CLG1CQUFPQSxDQUFDLHVFQUFTO0FBRWhELDZCQUE2QixHQUM3QixJQUFJb0I7QUFDSixJQUFJO0lBQ0ZBLFNBQVNwQixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNoQyxvQkFBb0IsR0FDcEIsRUFBRSxPQUFNLENBRVI7QUFFQTs7Ozs7OztDQU9DLEdBQ0Qs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QUFDO1lBQ3JCNkIsV0FBVzVFO1lBQ1hrRDtZQUNBQztRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNQLGNBQWU0QixLQUFLO0lBQzNCLE1BQU0sRUFBRXhFLEVBQUUsRUFBRSxHQUFHLElBQUk7SUFFbkJBLEVBQUUsQ0FBQ3hCLFlBQVksR0FBR0wsT0FBT2tGLE9BQU87SUFFaEMsSUFBSWxFLFNBQVMwRixXQUFXLENBQUMvQixjQUFjLEVBQUU7UUFDdkMzRCxTQUFTMEYsV0FBVyxDQUFDOUIsT0FBTyxDQUFDeUI7SUFDL0I7SUFFQSxJQUFJLENBQUNNLE9BQU87QUFDZDtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZnBGO0lBQ0FxRDtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFxjb25uZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHVpZCwgc3RhdGVzLCBzZW50Q2xvc2VGcmFtZVN0YXRlLCBlbXB0eUJ1ZmZlciwgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBrUmVhZHlTdGF0ZSxcbiAga1NlbnRDbG9zZSxcbiAga0J5dGVQYXJzZXIsXG4gIGtSZWNlaXZlZENsb3NlLFxuICBrUmVzcG9uc2Vcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBmaXJlRXZlbnQsIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLCBpc0Nsb3NpbmcsIGlzQ2xvc2VkLCBpc0VzdGFibGlzaGVkLCBwYXJzZUV4dGVuc2lvbnMgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RpYWdub3N0aWNzJylcbmNvbnN0IHsgQ2xvc2VFdmVudCB9ID0gcmVxdWlyZSgnLi9ldmVudHMnKVxuY29uc3QgeyBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IEhlYWRlcnMsIGdldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcbmNvbnN0IHsgZ2V0RGVjb2RlU3BsaXQgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdub2RlOmNyeXB0bycpXG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG59IGNhdGNoIHtcblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC13ZWJzb2NrZXQtZXN0YWJsaXNoXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcHJvdG9jb2xzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0geyhyZXNwb25zZTogYW55LCBleHRlbnNpb25zOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCkgPT4gdm9pZH0gb25Fc3RhYmxpc2hcbiAqIEBwYXJhbSB7UGFydGlhbDxpbXBvcnQoJy4uLy4uL3R5cGVzL3dlYnNvY2tldCcpLldlYlNvY2tldEluaXQ+fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24gKHVybCwgcHJvdG9jb2xzLCBjbGllbnQsIHdzLCBvbkVzdGFibGlzaCwgb3B0aW9ucykge1xuICAvLyAxLiBMZXQgcmVxdWVzdFVSTCBiZSBhIGNvcHkgb2YgdXJsLCB3aXRoIGl0cyBzY2hlbWUgc2V0IHRvIFwiaHR0cFwiLCBpZiB1cmzigJlzXG4gIC8vICAgIHNjaGVtZSBpcyBcIndzXCIsIGFuZCB0byBcImh0dHBzXCIgb3RoZXJ3aXNlLlxuICBjb25zdCByZXF1ZXN0VVJMID0gdXJsXG5cbiAgcmVxdWVzdFVSTC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gJ3dzOicgPyAnaHR0cDonIDogJ2h0dHBzOidcblxuICAvLyAyLiBMZXQgcmVxdWVzdCBiZSBhIG5ldyByZXF1ZXN0LCB3aG9zZSBVUkwgaXMgcmVxdWVzdFVSTCwgY2xpZW50IGlzIGNsaWVudCxcbiAgLy8gICAgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJub25lXCIsIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgbW9kZSBpc1xuICAvLyAgICBcIndlYnNvY2tldFwiLCBjcmVkZW50aWFscyBtb2RlIGlzIFwiaW5jbHVkZVwiLCBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiAsXG4gIC8vICAgIGFuZCByZWRpcmVjdCBtb2RlIGlzIFwiZXJyb3JcIi5cbiAgY29uc3QgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICB1cmxMaXN0OiBbcmVxdWVzdFVSTF0sXG4gICAgY2xpZW50LFxuICAgIHNlcnZpY2VXb3JrZXJzOiAnbm9uZScsXG4gICAgcmVmZXJyZXI6ICduby1yZWZlcnJlcicsXG4gICAgbW9kZTogJ3dlYnNvY2tldCcsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBjYWNoZTogJ25vLXN0b3JlJyxcbiAgICByZWRpcmVjdDogJ2Vycm9yJ1xuICB9KVxuXG4gIC8vIE5vdGU6IHVuZGljaSBleHRlbnNpb24sIGFsbG93IHNldHRpbmcgY3VzdG9tIGhlYWRlcnMuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJzTGlzdCA9IGdldEhlYWRlcnNMaXN0KG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycykpXG5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0ID0gaGVhZGVyc0xpc3RcbiAgfVxuXG4gIC8vIDMuIEFwcGVuZCAoYFVwZ3JhZGVgLCBgd2Vic29ja2V0YCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDQuIEFwcGVuZCAoYENvbm5lY3Rpb25gLCBgVXBncmFkZWApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyBOb3RlOiBib3RoIG9mIHRoZXNlIGFyZSBoYW5kbGVkIGJ5IHVuZGljaSBjdXJyZW50bHkuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvNjhjMjY5YzQxNDRjNDQ2ZjNmMTIyMDk1MTMzOGRhZWY0YTZiNWVjNC9saWIvY2xpZW50LmpzI0wxMzk3XG5cbiAgLy8gNS4gTGV0IGtleVZhbHVlIGJlIGEgbm9uY2UgY29uc2lzdGluZyBvZiBhIHJhbmRvbWx5IHNlbGVjdGVkXG4gIC8vICAgIDE2LWJ5dGUgdmFsdWUgdGhhdCBoYXMgYmVlbiBmb3JnaXZpbmctYmFzZTY0LWVuY29kZWQgYW5kXG4gIC8vICAgIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgY29uc3Qga2V5VmFsdWUgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4gIC8vIDYuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtS2V5YCwga2V5VmFsdWUpIHRvIHJlcXVlc3TigJlzXG4gIC8vICAgIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1rZXknLCBrZXlWYWx1ZSlcblxuICAvLyA3LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LVZlcnNpb25gLCBgMTNgKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbicsICcxMycpXG5cbiAgLy8gOC4gRm9yIGVhY2ggcHJvdG9jb2wgaW4gcHJvdG9jb2xzLCBjb21iaW5lXG4gIC8vICAgIChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAsIHByb3RvY29sKSBpbiByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcsIHByb3RvY29sKVxuICB9XG5cbiAgLy8gOS4gTGV0IHBlcm1lc3NhZ2VEZWZsYXRlIGJlIGEgdXNlci1hZ2VudCBkZWZpbmVkXG4gIC8vICAgIFwicGVybWVzc2FnZS1kZWZsYXRlXCIgZXh0ZW5zaW9uIGhlYWRlciB2YWx1ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvY2U3ODIzNGY1ZTY1M2E1ZDM5MTY4MTNmZjk5MGYwNTM1MTAyMjdiYy9uZXR3ZXJrL3Byb3RvY29sL3dlYnNvY2tldC9XZWJTb2NrZXRDaGFubmVsLmNwcCNMMjY3M1xuICBjb25zdCBwZXJtZXNzYWdlRGVmbGF0ZSA9ICdwZXJtZXNzYWdlLWRlZmxhdGU7IGNsaWVudF9tYXhfd2luZG93X2JpdHMnXG5cbiAgLy8gMTAuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AsIHBlcm1lc3NhZ2VEZWZsYXRlKSB0b1xuICAvLyAgICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnLCBwZXJtZXNzYWdlRGVmbGF0ZSlcblxuICAvLyAxMS4gRmV0Y2ggcmVxdWVzdCB3aXRoIHVzZVBhcmFsbGVsUXVldWUgc2V0IHRvIHRydWUsIGFuZFxuICAvLyAgICAgcHJvY2Vzc1Jlc3BvbnNlIGdpdmVuIHJlc3BvbnNlIGJlaW5nIHRoZXNlIHN0ZXBzOlxuICBjb25zdCBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgIHJlcXVlc3QsXG4gICAgdXNlUGFyYWxsZWxRdWV1ZTogdHJ1ZSxcbiAgICBkaXNwYXRjaGVyOiBvcHRpb25zLmRpc3BhdGNoZXIsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlIChyZXNwb25zZSkge1xuICAgICAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yIG9yIGl0cyBzdGF0dXMgaXMgbm90IDEwMSxcbiAgICAgIC8vICAgIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgfHwgcmVzcG9uc2Uuc3RhdHVzICE9PSAxMDEpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdSZWNlaXZlZCBuZXR3b3JrIGVycm9yIG9yIG5vbi0xMDEgc3RhdHVzIGNvZGUuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHByb3RvY29scyBpcyBub3QgdGhlIGVtcHR5IGxpc3QgYW5kIGV4dHJhY3RpbmcgaGVhZGVyXG4gICAgICAvLyAgICBsaXN0IHZhbHVlcyBnaXZlbiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgYW5kIHJlc3BvbnNl4oCZc1xuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgcmVzdWx0cyBpbiBudWxsLCBmYWlsdXJlLCBvciB0aGUgZW1wdHkgYnl0ZVxuICAgICAgLy8gICAgc2VxdWVuY2UsIHRoZW4gZmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gMCAmJiAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJykpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCByZXNwb25kIHdpdGggc2VudCBwcm90b2NvbHMuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEZvbGxvdyB0aGUgcmVxdWlyZW1lbnRzIHN0YXRlZCBzdGVwIDIgdG8gc3RlcCA2LCBpbmNsdXNpdmUsXG4gICAgICAvLyAgICBvZiB0aGUgbGFzdCBzZXQgb2Ygc3RlcHMgaW4gc2VjdGlvbiA0LjEgb2YgVGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgUHJvdG9jb2wgdG8gdmFsaWRhdGUgcmVzcG9uc2UuIFRoaXMgZWl0aGVyIHJlc3VsdHMgaW4gZmFpbFxuICAgICAgLy8gICAgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIG9yIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpc1xuICAgICAgLy8gICAgZXN0YWJsaXNoZWQuXG5cbiAgICAgIC8vIDIuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhbiB8VXBncmFkZXwgaGVhZGVyIGZpZWxkIG9yIHRoZSB8VXBncmFkZXxcbiAgICAgIC8vICAgIGhlYWRlciBmaWVsZCBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IGFuIEFTQ0lJIGNhc2UtXG4gICAgICAvLyAgICBpbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwid2Vic29ja2V0XCIsIHRoZSBjbGllbnQgTVVTVFxuICAgICAgLy8gICAgX0ZhaWwgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy5cbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1VwZ3JhZGUnKT8udG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCBzZXQgVXBncmFkZSBoZWFkZXIgdG8gXCJ3ZWJzb2NrZXRcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfENvbm5lY3Rpb258IGhlYWRlciBmaWVsZCBvciB0aGVcbiAgICAgIC8vICAgIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgZG9lc24ndCBjb250YWluIGEgdG9rZW4gdGhhdCBpcyBhblxuICAgICAgLy8gICAgQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwiVXBncmFkZVwiLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdDb25uZWN0aW9uJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd1cGdyYWRlJykge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1NlcnZlciBkaWQgbm90IHNldCBDb25uZWN0aW9uIGhlYWRlciB0byBcInVwZ3JhZGVcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBoZWFkZXIgZmllbGQgb3JcbiAgICAgIC8vICAgIHRoZSB8U2VjLVdlYlNvY2tldC1BY2NlcHR8IGNvbnRhaW5zIGEgdmFsdWUgb3RoZXIgdGhhbiB0aGVcbiAgICAgIC8vICAgIGJhc2U2NC1lbmNvZGVkIFNIQS0xIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB8U2VjLVdlYlNvY2tldC1cbiAgICAgIC8vICAgIEtleXwgKGFzIGEgc3RyaW5nLCBub3QgYmFzZTY0LWRlY29kZWQpIHdpdGggdGhlIHN0cmluZyBcIjI1OEVBRkE1LVxuICAgICAgLy8gICAgRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExXCIgYnV0IGlnbm9yaW5nIGFueSBsZWFkaW5nIGFuZFxuICAgICAgLy8gICAgdHJhaWxpbmcgd2hpdGVzcGFjZSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjV1NBY2NlcHQgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtQWNjZXB0JylcbiAgICAgIGNvbnN0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGtleVZhbHVlICsgdWlkKS5kaWdlc3QoJ2Jhc2U2NCcpXG4gICAgICBpZiAoc2VjV1NBY2NlcHQgIT09IGRpZ2VzdCkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ0luY29ycmVjdCBoYXNoIHJlY2VpdmVkIGluIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlci4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNS4gSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgfFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc3wgaGVhZGVyXG4gICAgICAvLyAgICBmaWVsZCBhbmQgdGhpcyBoZWFkZXIgZmllbGQgaW5kaWNhdGVzIHRoZSB1c2Ugb2YgYW4gZXh0ZW5zaW9uXG4gICAgICAvLyAgICB0aGF0IHdhcyBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhc1xuICAgICAgLy8gICAgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uICAoVGhlIHBhcnNpbmcgb2YgdGhpc1xuICAgICAgLy8gICAgaGVhZGVyIGZpZWxkIHRvIGRldGVybWluZSB3aGljaCBleHRlbnNpb25zIGFyZSByZXF1ZXN0ZWQgaXNcbiAgICAgIC8vICAgIGRpc2N1c3NlZCBpbiBTZWN0aW9uIDkuMS4pXG4gICAgICBjb25zdCBzZWNFeHRlbnNpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycpXG4gICAgICBsZXQgZXh0ZW5zaW9uc1xuXG4gICAgICBpZiAoc2VjRXh0ZW5zaW9uICE9PSBudWxsKSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZUV4dGVuc2lvbnMoc2VjRXh0ZW5zaW9uKVxuXG4gICAgICAgIGlmICghZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGRvZXMgbm90IG1hdGNoLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNi4gSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgfFNlYy1XZWJTb2NrZXQtUHJvdG9jb2x8IGhlYWRlciBmaWVsZFxuICAgICAgLy8gICAgYW5kIHRoaXMgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdXNlIG9mIGEgc3VicHJvdG9jb2wgdGhhdCB3YXNcbiAgICAgIC8vICAgIG5vdCBwcmVzZW50IGluIHRoZSBjbGllbnQncyBoYW5kc2hha2UgKHRoZSBzZXJ2ZXIgaGFzIGluZGljYXRlZCBhXG4gICAgICAvLyAgICBzdWJwcm90b2NvbCBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpLCB0aGUgY2xpZW50IE1VU1QgX0ZhaWxcbiAgICAgIC8vICAgIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBjb25zdCBzZWNQcm90b2NvbCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcpXG5cbiAgICAgIGlmIChzZWNQcm90b2NvbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0UHJvdG9jb2xzID0gZ2V0RGVjb2RlU3BsaXQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnLCByZXF1ZXN0LmhlYWRlcnNMaXN0KVxuXG4gICAgICAgIC8vIFRoZSBjbGllbnQgY2FuIHJlcXVlc3QgdGhhdCB0aGUgc2VydmVyIHVzZSBhIHNwZWNpZmljIHN1YnByb3RvY29sIGJ5XG4gICAgICAgIC8vIGluY2x1ZGluZyB0aGUgfFNlYy1XZWJTb2NrZXQtUHJvdG9jb2x8IGZpZWxkIGluIGl0cyBoYW5kc2hha2UuICBJZiBpdFxuICAgICAgICAvLyBpcyBzcGVjaWZpZWQsIHRoZSBzZXJ2ZXIgbmVlZHMgdG8gaW5jbHVkZSB0aGUgc2FtZSBmaWVsZCBhbmQgb25lIG9mXG4gICAgICAgIC8vIHRoZSBzZWxlY3RlZCBzdWJwcm90b2NvbCB2YWx1ZXMgaW4gaXRzIHJlc3BvbnNlIGZvciB0aGUgY29ubmVjdGlvbiB0b1xuICAgICAgICAvLyBiZSBlc3RhYmxpc2hlZC5cbiAgICAgICAgaWYgKCFyZXF1ZXN0UHJvdG9jb2xzLmluY2x1ZGVzKHNlY1Byb3RvY29sKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUHJvdG9jb2wgd2FzIG5vdCBzZXQgaW4gdGhlIG9wZW5pbmcgaGFuZHNoYWtlLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdkYXRhJywgb25Tb2NrZXREYXRhKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG4gICAgICByZXNwb25zZS5zb2NrZXQub24oJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcblxuICAgICAgaWYgKGNoYW5uZWxzLm9wZW4uaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMub3Blbi5wdWJsaXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiByZXNwb25zZS5zb2NrZXQuYWRkcmVzcygpLFxuICAgICAgICAgIHByb3RvY29sOiBzZWNQcm90b2NvbCxcbiAgICAgICAgICBleHRlbnNpb25zOiBzZWNFeHRlbnNpb25cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgb25Fc3RhYmxpc2gocmVzcG9uc2UsIGV4dGVuc2lvbnMpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBjb250cm9sbGVyXG59XG5cbmZ1bmN0aW9uIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbiAod3MsIGNvZGUsIHJlYXNvbiwgcmVhc29uQnl0ZUxlbmd0aCkge1xuICBpZiAoaXNDbG9zaW5nKHdzKSB8fCBpc0Nsb3NlZCh3cykpIHtcbiAgICAvLyBJZiB0aGlzJ3MgcmVhZHkgc3RhdGUgaXMgQ0xPU0lORyAoMikgb3IgQ0xPU0VEICgzKVxuICAgIC8vIERvIG5vdGhpbmcuXG4gIH0gZWxzZSBpZiAoIWlzRXN0YWJsaXNoZWQod3MpKSB7XG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgZXN0YWJsaXNoZWRcbiAgICAvLyBGYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBhbmQgc2V0IHRoaXMncyByZWFkeSBzdGF0ZVxuICAgIC8vIHRvIENMT1NJTkcgKDIpLlxuICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnQ29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSBpdCB3YXMgZXN0YWJsaXNoZWQuJylcbiAgICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICB9IGVsc2UgaWYgKHdzW2tTZW50Q2xvc2VdID09PSBzZW50Q2xvc2VGcmFtZVN0YXRlLk5PVF9TRU5UKSB7XG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWRcbiAgICAvLyBTdGFydCB0aGUgV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIGFuZCBzZXQgdGhpcydzIHJlYWR5XG4gICAgLy8gc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgLy8gLSBJZiBuZWl0aGVyIGNvZGUgbm9yIHJlYXNvbiBpcyBwcmVzZW50LCB0aGUgV2ViU29ja2V0IENsb3NlXG4gICAgLy8gICBtZXNzYWdlIG11c3Qgbm90IGhhdmUgYSBib2R5LlxuICAgIC8vIC0gSWYgY29kZSBpcyBwcmVzZW50LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlXG4gICAgLy8gICBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgLy8gLSBJZiByZWFzb24gaXMgYWxzbyBwcmVzZW50LCB0aGVuIHJlYXNvbkJ5dGVzIG11c3QgYmVcbiAgICAvLyAgIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cblxuICAgIHdzW2tTZW50Q2xvc2VdID0gc2VudENsb3NlRnJhbWVTdGF0ZS5QUk9DRVNTSU5HXG5cbiAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoKVxuXG4gICAgLy8gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgIC8vIG1lc3NhZ2UgbXVzdCBub3QgaGF2ZSBhIGJvZHkuXG5cbiAgICAvLyBJZiBjb2RlIGlzIHByZXNlbnQsIHRoZW4gdGhlIHN0YXR1cyBjb2RlIHRvIHVzZSBpbiB0aGVcbiAgICAvLyBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiByZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmIHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiByZWFzb24gaXMgYWxzbyBwcmVzZW50LCB0aGVuIHJlYXNvbkJ5dGVzIG11c3QgYmVcbiAgICAgIC8vIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cbiAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgcmVhc29uQnl0ZUxlbmd0aClcbiAgICAgIGZyYW1lLmZyYW1lRGF0YS53cml0ZVVJbnQxNkJFKGNvZGUsIDApXG4gICAgICAvLyB0aGUgYm9keSBNQVkgY29udGFpbiBVVEYtOC1lbmNvZGVkIGRhdGEgd2l0aCB2YWx1ZSAvcmVhc29uL1xuICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlKHJlYXNvbiwgMiwgJ3V0Zi04JylcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gZW1wdHlCdWZmZXJcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnc3RyZWFtJykuRHVwbGV4fSAqL1xuICAgIGNvbnN0IHNvY2tldCA9IHdzW2tSZXNwb25zZV0uc29ja2V0XG5cbiAgICBzb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5DTE9TRSkpXG5cbiAgICB3c1trU2VudENsb3NlXSA9IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVFxuXG4gICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZVxuICAgIC8vIFNldCB0aGlzJ3MgcmVhZHkgc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgd3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICovXG5mdW5jdGlvbiBvblNvY2tldERhdGEgKGNodW5rKSB7XG4gIGlmICghdGhpcy53c1trQnl0ZVBhcnNlcl0ud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS40XG4gKi9cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCB7IHdzIH0gPSB0aGlzXG4gIGNvbnN0IHsgW2tSZXNwb25zZV06IHJlc3BvbnNlIH0gPSB3c1xuXG4gIHJlc3BvbnNlLnNvY2tldC5vZmYoJ2RhdGEnLCBvblNvY2tldERhdGEpXG4gIHJlc3BvbnNlLnNvY2tldC5vZmYoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcbiAgcmVzcG9uc2Uuc29ja2V0Lm9mZignZXJyb3InLCBvblNvY2tldEVycm9yKVxuXG4gIC8vIElmIHRoZSBUQ1AgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFmdGVyIHRoZVxuICAvLyBXZWJTb2NrZXQgY2xvc2luZyBoYW5kc2hha2Ugd2FzIGNvbXBsZXRlZCwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gIC8vIGlzIHNhaWQgdG8gaGF2ZSBiZWVuIGNsb3NlZCBfY2xlYW5seV8uXG4gIGNvbnN0IHdhc0NsZWFuID0gd3Nba1NlbnRDbG9zZV0gPT09IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCAmJiB3c1trUmVjZWl2ZWRDbG9zZV1cblxuICBsZXQgY29kZSA9IDEwMDVcbiAgbGV0IHJlYXNvbiA9ICcnXG5cbiAgY29uc3QgcmVzdWx0ID0gd3Nba0J5dGVQYXJzZXJdLmNsb3NpbmdJbmZvXG5cbiAgaWYgKHJlc3VsdCAmJiAhcmVzdWx0LmVycm9yKSB7XG4gICAgY29kZSA9IHJlc3VsdC5jb2RlID8/IDEwMDVcbiAgICByZWFzb24gPSByZXN1bHQucmVhc29uXG4gIH0gZWxzZSBpZiAoIXdzW2tSZWNlaXZlZENsb3NlXSkge1xuICAgIC8vIElmIF9UaGUgV2ViU29ja2V0XG4gICAgLy8gQ29ubmVjdGlvbiBpcyBDbG9zZWRfIGFuZCBubyBDbG9zZSBjb250cm9sIGZyYW1lIHdhcyByZWNlaXZlZCBieSB0aGVcbiAgICAvLyBlbmRwb2ludCAoc3VjaCBhcyBjb3VsZCBvY2N1ciBpZiB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgY29ubmVjdGlvblxuICAgIC8vIGlzIGxvc3QpLCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLyAxMDA2LlxuICAgIGNvZGUgPSAxMDA2XG4gIH1cblxuICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIENMT1NFRCAoMykuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TRURcblxuICAvLyAyLiBJZiB0aGUgdXNlciBhZ2VudCB3YXMgcmVxdWlyZWQgdG8gZmFpbCB0aGUgV2ViU29ja2V0XG4gIC8vICAgIGNvbm5lY3Rpb24sIG9yIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gIC8vICAgIGFmdGVyIGJlaW5nIGZsYWdnZWQgYXMgZnVsbCwgZmlyZSBhbiBldmVudCBuYW1lZCBlcnJvclxuICAvLyAgICBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgY2xvc2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsXG4gIC8vICAgIHVzaW5nIENsb3NlRXZlbnQsIHdpdGggdGhlIHdhc0NsZWFuIGF0dHJpYnV0ZVxuICAvLyAgICBpbml0aWFsaXplZCB0byB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIGNsb3NlZCBjbGVhbmx5XG4gIC8vICAgIGFuZCBmYWxzZSBvdGhlcndpc2UsIHRoZSBjb2RlIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0b1xuICAvLyAgICB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSwgYW5kIHRoZSByZWFzb25cbiAgLy8gICAgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgVVRGLThcbiAgLy8gICAgZGVjb2RlIHdpdGhvdXQgQk9NIHRvIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZVxuICAvLyAgICByZWFzb24uXG4gIC8vIFRPRE86IHByb2Nlc3MubmV4dFRpY2tcbiAgZmlyZUV2ZW50KCdjbG9zZScsIHdzLCAodHlwZSwgaW5pdCkgPT4gbmV3IENsb3NlRXZlbnQodHlwZSwgaW5pdCksIHtcbiAgICB3YXNDbGVhbiwgY29kZSwgcmVhc29uXG4gIH0pXG5cbiAgaWYgKGNoYW5uZWxzLmNsb3NlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuY2xvc2UucHVibGlzaCh7XG4gICAgICB3ZWJzb2NrZXQ6IHdzLFxuICAgICAgY29kZSxcbiAgICAgIHJlYXNvblxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gb25Tb2NrZXRFcnJvciAoZXJyb3IpIHtcbiAgY29uc3QgeyB3cyB9ID0gdGhpc1xuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG5cbiAgaWYgKGNoYW5uZWxzLnNvY2tldEVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuc29ja2V0RXJyb3IucHVibGlzaChlcnJvcilcbiAgfVxuXG4gIHRoaXMuZGVzdHJveSgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uLFxuICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb25cbn1cbiJdLCJuYW1lcyI6WyJ1aWQiLCJzdGF0ZXMiLCJzZW50Q2xvc2VGcmFtZVN0YXRlIiwiZW1wdHlCdWZmZXIiLCJvcGNvZGVzIiwicmVxdWlyZSIsImtSZWFkeVN0YXRlIiwia1NlbnRDbG9zZSIsImtCeXRlUGFyc2VyIiwia1JlY2VpdmVkQ2xvc2UiLCJrUmVzcG9uc2UiLCJmaXJlRXZlbnQiLCJmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiIsImlzQ2xvc2luZyIsImlzQ2xvc2VkIiwiaXNFc3RhYmxpc2hlZCIsInBhcnNlRXh0ZW5zaW9ucyIsImNoYW5uZWxzIiwiQ2xvc2VFdmVudCIsIm1ha2VSZXF1ZXN0IiwiZmV0Y2hpbmciLCJIZWFkZXJzIiwiZ2V0SGVhZGVyc0xpc3QiLCJnZXREZWNvZGVTcGxpdCIsIldlYnNvY2tldEZyYW1lU2VuZCIsImNyeXB0byIsImVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24iLCJ1cmwiLCJwcm90b2NvbHMiLCJjbGllbnQiLCJ3cyIsIm9uRXN0YWJsaXNoIiwib3B0aW9ucyIsInJlcXVlc3RVUkwiLCJwcm90b2NvbCIsInJlcXVlc3QiLCJ1cmxMaXN0Iiwic2VydmljZVdvcmtlcnMiLCJyZWZlcnJlciIsIm1vZGUiLCJjcmVkZW50aWFscyIsImNhY2hlIiwicmVkaXJlY3QiLCJoZWFkZXJzIiwiaGVhZGVyc0xpc3QiLCJrZXlWYWx1ZSIsInJhbmRvbUJ5dGVzIiwidG9TdHJpbmciLCJhcHBlbmQiLCJwZXJtZXNzYWdlRGVmbGF0ZSIsImNvbnRyb2xsZXIiLCJ1c2VQYXJhbGxlbFF1ZXVlIiwiZGlzcGF0Y2hlciIsInByb2Nlc3NSZXNwb25zZSIsInJlc3BvbnNlIiwidHlwZSIsInN0YXR1cyIsImxlbmd0aCIsImdldCIsInRvTG93ZXJDYXNlIiwic2VjV1NBY2NlcHQiLCJkaWdlc3QiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwic2VjRXh0ZW5zaW9uIiwiZXh0ZW5zaW9ucyIsImhhcyIsInNlY1Byb3RvY29sIiwicmVxdWVzdFByb3RvY29scyIsImluY2x1ZGVzIiwic29ja2V0Iiwib24iLCJvblNvY2tldERhdGEiLCJvblNvY2tldENsb3NlIiwib25Tb2NrZXRFcnJvciIsIm9wZW4iLCJoYXNTdWJzY3JpYmVycyIsInB1Ymxpc2giLCJhZGRyZXNzIiwiY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIiwiY29kZSIsInJlYXNvbiIsInJlYXNvbkJ5dGVMZW5ndGgiLCJDTE9TSU5HIiwiTk9UX1NFTlQiLCJQUk9DRVNTSU5HIiwiZnJhbWUiLCJ1bmRlZmluZWQiLCJmcmFtZURhdGEiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZSIsImNyZWF0ZUZyYW1lIiwiQ0xPU0UiLCJTRU5UIiwiY2h1bmsiLCJwYXVzZSIsIm9mZiIsIndhc0NsZWFuIiwicmVzdWx0IiwiY2xvc2luZ0luZm8iLCJlcnJvciIsIkNMT1NFRCIsImluaXQiLCJjbG9zZSIsIndlYnNvY2tldCIsInNvY2tldEVycm9yIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/constants.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n// This is a Globally Unique Identifier unique used\n// to validate that the endpoint accepts websocket\n// connections.\n// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\nconst uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\nconst states = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\nconst sentCloseFrameState = {\n    NOT_SENT: 0,\n    PROCESSING: 1,\n    SENT: 2\n};\nconst opcodes = {\n    CONTINUATION: 0x0,\n    TEXT: 0x1,\n    BINARY: 0x2,\n    CLOSE: 0x8,\n    PING: 0x9,\n    PONG: 0xA\n};\nconst maxUnsigned16Bit = 2 ** 16 - 1 // 65535\n;\nconst parserStates = {\n    INFO: 0,\n    PAYLOADLENGTH_16: 2,\n    PAYLOADLENGTH_64: 3,\n    READ_DATA: 4\n};\nconst emptyBuffer = Buffer.allocUnsafe(0);\nconst sendHints = {\n    string: 1,\n    typedArray: 2,\n    arrayBuffer: 3,\n    blob: 4\n};\nmodule.exports = {\n    uid,\n    sentCloseFrameState,\n    staticPropertyDescriptors,\n    states,\n    opcodes,\n    maxUnsigned16Bit,\n    parserStates,\n    emptyBuffer,\n    sendHints\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLG1EQUFtRDtBQUNuRCxrREFBa0Q7QUFDbEQsZUFBZTtBQUNmLDhEQUE4RDtBQUM5RCxNQUFNQSxNQUFNO0FBRVosK0JBQStCLEdBQy9CLE1BQU1DLDRCQUE0QjtJQUNoQ0MsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGNBQWM7QUFDaEI7QUFFQSxNQUFNQyxTQUFTO0lBQ2JDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFFBQVE7QUFDVjtBQUVBLE1BQU1DLHNCQUFzQjtJQUMxQkMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLE1BQU07QUFDUjtBQUVBLE1BQU1DLFVBQVU7SUFDZEMsY0FBYztJQUNkQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07QUFDUjtBQUVBLE1BQU1DLG1CQUFtQixLQUFLLEtBQUssRUFBRSxRQUFROztBQUU3QyxNQUFNQyxlQUFlO0lBQ25CQyxNQUFNO0lBQ05DLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxjQUFjQyxPQUFPQyxXQUFXLENBQUM7QUFFdkMsTUFBTUMsWUFBWTtJQUNoQkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLGFBQWE7SUFDYkMsTUFBTTtBQUNSO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUNmcEM7SUFDQVU7SUFDQVQ7SUFDQUk7SUFDQVM7SUFDQU87SUFDQUM7SUFDQUs7SUFDQUc7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBUaGlzIGlzIGEgR2xvYmFsbHkgVW5pcXVlIElkZW50aWZpZXIgdW5pcXVlIHVzZWRcbi8vIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGVuZHBvaW50IGFjY2VwdHMgd2Vic29ja2V0XG4vLyBjb25uZWN0aW9ucy5cbi8vIFNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjQ1NS5odG1sI3NlY3Rpb24tMS4zXG5jb25zdCB1aWQgPSAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJ1xuXG4vKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi9cbmNvbnN0IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufVxuXG5jb25zdCBzdGF0ZXMgPSB7XG4gIENPTk5FQ1RJTkc6IDAsXG4gIE9QRU46IDEsXG4gIENMT1NJTkc6IDIsXG4gIENMT1NFRDogM1xufVxuXG5jb25zdCBzZW50Q2xvc2VGcmFtZVN0YXRlID0ge1xuICBOT1RfU0VOVDogMCxcbiAgUFJPQ0VTU0lORzogMSxcbiAgU0VOVDogMlxufVxuXG5jb25zdCBvcGNvZGVzID0ge1xuICBDT05USU5VQVRJT046IDB4MCxcbiAgVEVYVDogMHgxLFxuICBCSU5BUlk6IDB4MixcbiAgQ0xPU0U6IDB4OCxcbiAgUElORzogMHg5LFxuICBQT05HOiAweEFcbn1cblxuY29uc3QgbWF4VW5zaWduZWQxNkJpdCA9IDIgKiogMTYgLSAxIC8vIDY1NTM1XG5cbmNvbnN0IHBhcnNlclN0YXRlcyA9IHtcbiAgSU5GTzogMCxcbiAgUEFZTE9BRExFTkdUSF8xNjogMixcbiAgUEFZTE9BRExFTkdUSF82NDogMyxcbiAgUkVBRF9EQVRBOiA0XG59XG5cbmNvbnN0IGVtcHR5QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG5cbmNvbnN0IHNlbmRIaW50cyA9IHtcbiAgc3RyaW5nOiAxLFxuICB0eXBlZEFycmF5OiAyLFxuICBhcnJheUJ1ZmZlcjogMyxcbiAgYmxvYjogNFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdWlkLFxuICBzZW50Q2xvc2VGcmFtZVN0YXRlLFxuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBzdGF0ZXMsXG4gIG9wY29kZXMsXG4gIG1heFVuc2lnbmVkMTZCaXQsXG4gIHBhcnNlclN0YXRlcyxcbiAgZW1wdHlCdWZmZXIsXG4gIHNlbmRIaW50c1xufVxuIl0sIm5hbWVzIjpbInVpZCIsInN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJzdGF0ZXMiLCJDT05ORUNUSU5HIiwiT1BFTiIsIkNMT1NJTkciLCJDTE9TRUQiLCJzZW50Q2xvc2VGcmFtZVN0YXRlIiwiTk9UX1NFTlQiLCJQUk9DRVNTSU5HIiwiU0VOVCIsIm9wY29kZXMiLCJDT05USU5VQVRJT04iLCJURVhUIiwiQklOQVJZIiwiQ0xPU0UiLCJQSU5HIiwiUE9ORyIsIm1heFVuc2lnbmVkMTZCaXQiLCJwYXJzZXJTdGF0ZXMiLCJJTkZPIiwiUEFZTE9BRExFTkdUSF8xNiIsIlBBWUxPQURMRU5HVEhfNjQiLCJSRUFEX0RBVEEiLCJlbXB0eUJ1ZmZlciIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwic2VuZEhpbnRzIiwic3RyaW5nIiwidHlwZWRBcnJheSIsImFycmF5QnVmZmVyIiwiYmxvYiIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/events.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { MessagePort } = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\");\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */ class MessageEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        if (type === kConstruct) {\n            super(arguments[1], arguments[2]);\n            return;\n        }\n        const prefix = 'MessageEvent constructor';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        type = webidl.converters.DOMString(type, prefix, 'type');\n        eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, 'eventInitDict');\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get data() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.data;\n    }\n    get origin() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.origin;\n    }\n    get lastEventId() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.lastEventId;\n    }\n    get source() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.source;\n    }\n    get ports() {\n        webidl.brandCheck(this, MessageEvent);\n        if (!Object.isFrozen(this.#eventInit.ports)) {\n            Object.freeze(this.#eventInit.ports);\n        }\n        return this.#eventInit.ports;\n    }\n    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = '', lastEventId = '', source = null, ports = []) {\n        webidl.brandCheck(this, MessageEvent);\n        webidl.argumentLengthCheck(arguments, 1, 'MessageEvent.initMessageEvent');\n        return new MessageEvent(type, {\n            bubbles,\n            cancelable,\n            data,\n            origin,\n            lastEventId,\n            source,\n            ports\n        });\n    }\n    static createFastMessageEvent(type, init) {\n        const messageEvent = new MessageEvent(kConstruct, type, init);\n        messageEvent.#eventInit = init;\n        messageEvent.#eventInit.data ??= null;\n        messageEvent.#eventInit.origin ??= '';\n        messageEvent.#eventInit.lastEventId ??= '';\n        messageEvent.#eventInit.source ??= null;\n        messageEvent.#eventInit.ports ??= [];\n        return messageEvent;\n    }\n}\nconst { createFastMessageEvent } = MessageEvent;\ndelete MessageEvent.createFastMessageEvent;\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */ class CloseEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        const prefix = 'CloseEvent constructor';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        type = webidl.converters.DOMString(type, prefix, 'type');\n        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get wasClean() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.wasClean;\n    }\n    get code() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.code;\n    }\n    get reason() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.reason;\n    }\n}\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict){\n        const prefix = 'ErrorEvent constructor';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        super(type, eventInitDict);\n        type = webidl.converters.DOMString(type, prefix, 'type');\n        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});\n        this.#eventInit = eventInitDict;\n    }\n    get message() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.message;\n    }\n    get filename() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.filename;\n    }\n    get lineno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.lineno;\n    }\n    get colno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.colno;\n    }\n    get error() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.error;\n    }\n}\nObject.defineProperties(MessageEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: 'MessageEvent',\n        configurable: true\n    },\n    data: kEnumerableProperty,\n    origin: kEnumerableProperty,\n    lastEventId: kEnumerableProperty,\n    source: kEnumerableProperty,\n    ports: kEnumerableProperty,\n    initMessageEvent: kEnumerableProperty\n});\nObject.defineProperties(CloseEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: 'CloseEvent',\n        configurable: true\n    },\n    reason: kEnumerableProperty,\n    code: kEnumerableProperty,\n    wasClean: kEnumerableProperty\n});\nObject.defineProperties(ErrorEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: 'ErrorEvent',\n        configurable: true\n    },\n    message: kEnumerableProperty,\n    filename: kEnumerableProperty,\n    lineno: kEnumerableProperty,\n    colno: kEnumerableProperty,\n    error: kEnumerableProperty\n});\nwebidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);\nwebidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(webidl.converters.MessagePort);\nconst eventInit = [\n    {\n        key: 'bubbles',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'cancelable',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'composed',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    }\n];\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: 'data',\n        converter: webidl.converters.any,\n        defaultValue: ()=>null\n    },\n    {\n        key: 'origin',\n        converter: webidl.converters.USVString,\n        defaultValue: ()=>''\n    },\n    {\n        key: 'lastEventId',\n        converter: webidl.converters.DOMString,\n        defaultValue: ()=>''\n    },\n    {\n        key: 'source',\n        // Node doesn't implement WindowProxy or ServiceWorker, so the only\n        // valid value for source is a MessagePort.\n        converter: webidl.nullableConverter(webidl.converters.MessagePort),\n        defaultValue: ()=>null\n    },\n    {\n        key: 'ports',\n        converter: webidl.converters['sequence<MessagePort>'],\n        defaultValue: ()=>new Array(0)\n    }\n]);\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: 'wasClean',\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: 'code',\n        converter: webidl.converters['unsigned short'],\n        defaultValue: ()=>0\n    },\n    {\n        key: 'reason',\n        converter: webidl.converters.USVString,\n        defaultValue: ()=>''\n    }\n]);\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: 'message',\n        converter: webidl.converters.DOMString,\n        defaultValue: ()=>''\n    },\n    {\n        key: 'filename',\n        converter: webidl.converters.USVString,\n        defaultValue: ()=>''\n    },\n    {\n        key: 'lineno',\n        converter: webidl.converters['unsigned long'],\n        defaultValue: ()=>0\n    },\n    {\n        key: 'colno',\n        converter: webidl.converters['unsigned long'],\n        defaultValue: ()=>0\n    },\n    {\n        key: 'error',\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    MessageEvent,\n    CloseEvent,\n    ErrorEvent,\n    createFastMessageEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLDRFQUFpQjtBQUM1QyxNQUFNLEVBQUVDLG1CQUFtQixFQUFFLEdBQUdELG1CQUFPQSxDQUFDLHFFQUFpQjtBQUN6RCxNQUFNLEVBQUVFLFVBQVUsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQywyRUFBb0I7QUFDbkQsTUFBTSxFQUFFRyxXQUFXLEVBQUUsR0FBR0gsbUJBQU9BLENBQUMsZ0RBQXFCO0FBRXJEOztDQUVDLEdBQ0QsTUFBTUkscUJBQXFCQztJQUN6QixVQUFVO0lBRVYsWUFBYUMsSUFBSSxFQUFFQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUU7UUFDckMsSUFBSUQsU0FBU0osWUFBWTtZQUN2QixLQUFLLENBQUNNLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFNBQVMsQ0FBQyxFQUFFO1lBQ2hDO1FBQ0Y7UUFFQSxNQUFNQyxTQUFTO1FBQ2ZWLE9BQU9XLG1CQUFtQixDQUFDRixXQUFXLEdBQUdDO1FBRXpDSCxPQUFPUCxPQUFPWSxVQUFVLENBQUNDLFNBQVMsQ0FBQ04sTUFBTUcsUUFBUTtRQUNqREYsZ0JBQWdCUixPQUFPWSxVQUFVLENBQUNFLGdCQUFnQixDQUFDTixlQUFlRSxRQUFRO1FBRTFFLEtBQUssQ0FBQ0gsTUFBTUM7UUFFWixJQUFJLENBQUMsVUFBVSxHQUFHQTtJQUNwQjtJQUVBLElBQUlPLE9BQVE7UUFDVmYsT0FBT2dCLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQ1UsSUFBSTtJQUM3QjtJQUVBLElBQUlFLFNBQVU7UUFDWmpCLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUNZLE1BQU07SUFDL0I7SUFFQSxJQUFJQyxjQUFlO1FBQ2pCbEIsT0FBT2dCLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQ2EsV0FBVztJQUNwQztJQUVBLElBQUlDLFNBQVU7UUFDWm5CLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUNjLE1BQU07SUFDL0I7SUFFQSxJQUFJQyxRQUFTO1FBQ1hwQixPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsSUFBSSxDQUFDZ0IsT0FBT0MsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUNGLEtBQUssR0FBRztZQUMzQ0MsT0FBT0UsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUNILEtBQUs7UUFDckM7UUFFQSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUNBLEtBQUs7SUFDOUI7SUFFQUksaUJBQ0VqQixJQUFJLEVBQ0prQixVQUFVLEtBQUssRUFDZkMsYUFBYSxLQUFLLEVBQ2xCWCxPQUFPLElBQUksRUFDWEUsU0FBUyxFQUFFLEVBQ1hDLGNBQWMsRUFBRSxFQUNoQkMsU0FBUyxJQUFJLEVBQ2JDLFFBQVEsRUFBRSxFQUNWO1FBQ0FwQixPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEJMLE9BQU9XLG1CQUFtQixDQUFDRixXQUFXLEdBQUc7UUFFekMsT0FBTyxJQUFJSixhQUFhRSxNQUFNO1lBQzVCa0I7WUFBU0M7WUFBWVg7WUFBTUU7WUFBUUM7WUFBYUM7WUFBUUM7UUFDMUQ7SUFDRjtJQUVBLE9BQU9PLHVCQUF3QnBCLElBQUksRUFBRXFCLElBQUksRUFBRTtRQUN6QyxNQUFNQyxlQUFlLElBQUl4QixhQUFhRixZQUFZSSxNQUFNcUI7UUFDeERDLGFBQWEsVUFBVSxHQUFHRDtRQUMxQkMsYUFBYSxVQUFVLENBQUNkLElBQUksS0FBSztRQUNqQ2MsYUFBYSxVQUFVLENBQUNaLE1BQU0sS0FBSztRQUNuQ1ksYUFBYSxVQUFVLENBQUNYLFdBQVcsS0FBSztRQUN4Q1csYUFBYSxVQUFVLENBQUNWLE1BQU0sS0FBSztRQUNuQ1UsYUFBYSxVQUFVLENBQUNULEtBQUssS0FBSyxFQUFFO1FBQ3BDLE9BQU9TO0lBQ1Q7QUFDRjtBQUVBLE1BQU0sRUFBRUYsc0JBQXNCLEVBQUUsR0FBR3RCO0FBQ25DLE9BQU9BLGFBQWFzQixzQkFBc0I7QUFFMUM7O0NBRUMsR0FDRCxNQUFNRyxtQkFBbUJ4QjtJQUN2QixVQUFVO0lBRVYsWUFBYUMsSUFBSSxFQUFFQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUU7UUFDckMsTUFBTUUsU0FBUztRQUNmVixPQUFPVyxtQkFBbUIsQ0FBQ0YsV0FBVyxHQUFHQztRQUV6Q0gsT0FBT1AsT0FBT1ksVUFBVSxDQUFDQyxTQUFTLENBQUNOLE1BQU1HLFFBQVE7UUFDakRGLGdCQUFnQlIsT0FBT1ksVUFBVSxDQUFDbUIsY0FBYyxDQUFDdkI7UUFFakQsS0FBSyxDQUFDRCxNQUFNQztRQUVaLElBQUksQ0FBQyxVQUFVLEdBQUdBO0lBQ3BCO0lBRUEsSUFBSXdCLFdBQVk7UUFDZGhDLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFYztRQUV4QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUNFLFFBQVE7SUFDakM7SUFFQSxJQUFJQyxPQUFRO1FBQ1ZqQyxPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRWM7UUFFeEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDRyxJQUFJO0lBQzdCO0lBRUEsSUFBSUMsU0FBVTtRQUNabEMsT0FBT2dCLFVBQVUsQ0FBQyxJQUFJLEVBQUVjO1FBRXhCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQ0ksTUFBTTtJQUMvQjtBQUNGO0FBRUEsa0ZBQWtGO0FBQ2xGLE1BQU1DLG1CQUFtQjdCO0lBQ3ZCLFVBQVU7SUFFVixZQUFhQyxJQUFJLEVBQUVDLGFBQWEsQ0FBRTtRQUNoQyxNQUFNRSxTQUFTO1FBQ2ZWLE9BQU9XLG1CQUFtQixDQUFDRixXQUFXLEdBQUdDO1FBRXpDLEtBQUssQ0FBQ0gsTUFBTUM7UUFFWkQsT0FBT1AsT0FBT1ksVUFBVSxDQUFDQyxTQUFTLENBQUNOLE1BQU1HLFFBQVE7UUFDakRGLGdCQUFnQlIsT0FBT1ksVUFBVSxDQUFDd0IsY0FBYyxDQUFDNUIsaUJBQWlCLENBQUM7UUFFbkUsSUFBSSxDQUFDLFVBQVUsR0FBR0E7SUFDcEI7SUFFQSxJQUFJNkIsVUFBVztRQUNickMsT0FBT2dCLFVBQVUsQ0FBQyxJQUFJLEVBQUVtQjtRQUV4QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUNFLE9BQU87SUFDaEM7SUFFQSxJQUFJQyxXQUFZO1FBQ2R0QyxPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRW1CO1FBRXhCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQ0csUUFBUTtJQUNqQztJQUVBLElBQUlDLFNBQVU7UUFDWnZDLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFbUI7UUFFeEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDSSxNQUFNO0lBQy9CO0lBRUEsSUFBSUMsUUFBUztRQUNYeEMsT0FBT2dCLFVBQVUsQ0FBQyxJQUFJLEVBQUVtQjtRQUV4QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUNLLEtBQUs7SUFDOUI7SUFFQSxJQUFJQyxRQUFTO1FBQ1h6QyxPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRW1CO1FBRXhCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQ00sS0FBSztJQUM5QjtBQUNGO0FBRUFwQixPQUFPcUIsZ0JBQWdCLENBQUNyQyxhQUFhc0MsU0FBUyxFQUFFO0lBQzlDLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCQyxPQUFPO1FBQ1BDLGNBQWM7SUFDaEI7SUFDQWhDLE1BQU1iO0lBQ05lLFFBQVFmO0lBQ1JnQixhQUFhaEI7SUFDYmlCLFFBQVFqQjtJQUNSa0IsT0FBT2xCO0lBQ1BzQixrQkFBa0J0QjtBQUNwQjtBQUVBbUIsT0FBT3FCLGdCQUFnQixDQUFDWixXQUFXYSxTQUFTLEVBQUU7SUFDNUMsQ0FBQ0MsT0FBT0MsV0FBVyxDQUFDLEVBQUU7UUFDcEJDLE9BQU87UUFDUEMsY0FBYztJQUNoQjtJQUNBYixRQUFRaEM7SUFDUitCLE1BQU0vQjtJQUNOOEIsVUFBVTlCO0FBQ1o7QUFFQW1CLE9BQU9xQixnQkFBZ0IsQ0FBQ1AsV0FBV1EsU0FBUyxFQUFFO0lBQzVDLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCQyxPQUFPO1FBQ1BDLGNBQWM7SUFDaEI7SUFDQVYsU0FBU25DO0lBQ1RvQyxVQUFVcEM7SUFDVnFDLFFBQVFyQztJQUNSc0MsT0FBT3RDO0lBQ1B1QyxPQUFPdkM7QUFDVDtBQUVBRixPQUFPWSxVQUFVLENBQUNSLFdBQVcsR0FBR0osT0FBT2dELGtCQUFrQixDQUFDNUM7QUFFMURKLE9BQU9ZLFVBQVUsQ0FBQyx3QkFBd0IsR0FBR1osT0FBT2lELGlCQUFpQixDQUNuRWpELE9BQU9ZLFVBQVUsQ0FBQ1IsV0FBVztBQUcvQixNQUFNOEMsWUFBWTtJQUNoQjtRQUNFQyxLQUFLO1FBQ0xDLFdBQVdwRCxPQUFPWSxVQUFVLENBQUN5QyxPQUFPO1FBQ3BDQyxjQUFjLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdwRCxPQUFPWSxVQUFVLENBQUN5QyxPQUFPO1FBQ3BDQyxjQUFjLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdwRCxPQUFPWSxVQUFVLENBQUN5QyxPQUFPO1FBQ3BDQyxjQUFjLElBQU07SUFDdEI7Q0FDRDtBQUVEdEQsT0FBT1ksVUFBVSxDQUFDRSxnQkFBZ0IsR0FBR2QsT0FBT3VELG1CQUFtQixDQUFDO09BQzNETDtJQUNIO1FBQ0VDLEtBQUs7UUFDTEMsV0FBV3BELE9BQU9ZLFVBQVUsQ0FBQzRDLEdBQUc7UUFDaENGLGNBQWMsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV3BELE9BQU9ZLFVBQVUsQ0FBQzZDLFNBQVM7UUFDdENILGNBQWMsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV3BELE9BQU9ZLFVBQVUsQ0FBQ0MsU0FBUztRQUN0Q3lDLGNBQWMsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFDTCxtRUFBbUU7UUFDbkUsMkNBQTJDO1FBQzNDQyxXQUFXcEQsT0FBTzBELGlCQUFpQixDQUFDMUQsT0FBT1ksVUFBVSxDQUFDUixXQUFXO1FBQ2pFa0QsY0FBYyxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXcEQsT0FBT1ksVUFBVSxDQUFDLHdCQUF3QjtRQUNyRDBDLGNBQWMsSUFBTSxJQUFJSyxNQUFNO0lBQ2hDO0NBQ0Q7QUFFRDNELE9BQU9ZLFVBQVUsQ0FBQ21CLGNBQWMsR0FBRy9CLE9BQU91RCxtQkFBbUIsQ0FBQztPQUN6REw7SUFDSDtRQUNFQyxLQUFLO1FBQ0xDLFdBQVdwRCxPQUFPWSxVQUFVLENBQUN5QyxPQUFPO1FBQ3BDQyxjQUFjLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdwRCxPQUFPWSxVQUFVLENBQUMsaUJBQWlCO1FBQzlDMEMsY0FBYyxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXcEQsT0FBT1ksVUFBVSxDQUFDNkMsU0FBUztRQUN0Q0gsY0FBYyxJQUFNO0lBQ3RCO0NBQ0Q7QUFFRHRELE9BQU9ZLFVBQVUsQ0FBQ3dCLGNBQWMsR0FBR3BDLE9BQU91RCxtQkFBbUIsQ0FBQztPQUN6REw7SUFDSDtRQUNFQyxLQUFLO1FBQ0xDLFdBQVdwRCxPQUFPWSxVQUFVLENBQUNDLFNBQVM7UUFDdEN5QyxjQUFjLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdwRCxPQUFPWSxVQUFVLENBQUM2QyxTQUFTO1FBQ3RDSCxjQUFjLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdwRCxPQUFPWSxVQUFVLENBQUMsZ0JBQWdCO1FBQzdDMEMsY0FBYyxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXcEQsT0FBT1ksVUFBVSxDQUFDLGdCQUFnQjtRQUM3QzBDLGNBQWMsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV3BELE9BQU9ZLFVBQVUsQ0FBQzRDLEdBQUc7SUFDbEM7Q0FDRDtBQUVESSxPQUFPQyxPQUFPLEdBQUc7SUFDZnhEO0lBQ0F5QjtJQUNBSztJQUNBUjtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFxldmVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBNZXNzYWdlUG9ydCB9ID0gcmVxdWlyZSgnbm9kZTp3b3JrZXJfdGhyZWFkcycpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jb21tcy5odG1sI21lc3NhZ2VldmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gICAgaWYgKHR5cGUgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHN1cGVyKGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ01lc3NhZ2VFdmVudCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgcHJlZml4LCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VFdmVudEluaXQoZXZlbnRJbml0RGljdCwgcHJlZml4LCAnZXZlbnRJbml0RGljdCcpXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICB9XG5cbiAgZ2V0IGRhdGEgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZGF0YVxuICB9XG5cbiAgZ2V0IG9yaWdpbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5vcmlnaW5cbiAgfVxuXG4gIGdldCBsYXN0RXZlbnRJZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5sYXN0RXZlbnRJZFxuICB9XG5cbiAgZ2V0IHNvdXJjZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5zb3VyY2VcbiAgfVxuXG4gIGdldCBwb3J0cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4odGhpcy4jZXZlbnRJbml0LnBvcnRzKSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLiNldmVudEluaXQucG9ydHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5wb3J0c1xuICB9XG5cbiAgaW5pdE1lc3NhZ2VFdmVudCAoXG4gICAgdHlwZSxcbiAgICBidWJibGVzID0gZmFsc2UsXG4gICAgY2FuY2VsYWJsZSA9IGZhbHNlLFxuICAgIGRhdGEgPSBudWxsLFxuICAgIG9yaWdpbiA9ICcnLFxuICAgIGxhc3RFdmVudElkID0gJycsXG4gICAgc291cmNlID0gbnVsbCxcbiAgICBwb3J0cyA9IFtdXG4gICkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ01lc3NhZ2VFdmVudC5pbml0TWVzc2FnZUV2ZW50JylcblxuICAgIHJldHVybiBuZXcgTWVzc2FnZUV2ZW50KHR5cGUsIHtcbiAgICAgIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRhdGEsIG9yaWdpbiwgbGFzdEV2ZW50SWQsIHNvdXJjZSwgcG9ydHNcbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgKHR5cGUsIGluaXQpIHtcbiAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KGtDb25zdHJ1Y3QsIHR5cGUsIGluaXQpXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQgPSBpbml0XG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQuZGF0YSA/Pz0gbnVsbFxuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0Lm9yaWdpbiA/Pz0gJydcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5sYXN0RXZlbnRJZCA/Pz0gJydcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5zb3VyY2UgPz89IG51bGxcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5wb3J0cyA/Pz0gW11cbiAgICByZXR1cm4gbWVzc2FnZUV2ZW50XG4gIH1cbn1cblxuY29uc3QgeyBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50IH0gPSBNZXNzYWdlRXZlbnRcbmRlbGV0ZSBNZXNzYWdlRXZlbnQuY3JlYXRlRmFzdE1lc3NhZ2VFdmVudFxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jdGhlLWNsb3NlZXZlbnQtaW50ZXJmYWNlXG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ0Nsb3NlRXZlbnQgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUsIHByZWZpeCwgJ3R5cGUnKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5DbG9zZUV2ZW50SW5pdChldmVudEluaXREaWN0KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgfVxuXG4gIGdldCB3YXNDbGVhbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQud2FzQ2xlYW5cbiAgfVxuXG4gIGdldCBjb2RlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5jb2RlXG4gIH1cblxuICBnZXQgcmVhc29uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5yZWFzb25cbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjdGhlLWVycm9yZXZlbnQtaW50ZXJmYWNlXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QpIHtcbiAgICBjb25zdCBwcmVmaXggPSAnRXJyb3JFdmVudCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUsIHByZWZpeCwgJ3R5cGUnKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5FcnJvckV2ZW50SW5pdChldmVudEluaXREaWN0ID8/IHt9KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICB9XG5cbiAgZ2V0IG1lc3NhZ2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lm1lc3NhZ2VcbiAgfVxuXG4gIGdldCBmaWxlbmFtZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZmlsZW5hbWVcbiAgfVxuXG4gIGdldCBsaW5lbm8gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmxpbmVub1xuICB9XG5cbiAgZ2V0IGNvbG5vICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5jb2xub1xuICB9XG5cbiAgZ2V0IGVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5lcnJvclxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ01lc3NhZ2VFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIGRhdGE6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9yaWdpbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbGFzdEV2ZW50SWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNvdXJjZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcG9ydHM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGluaXRNZXNzYWdlRXZlbnQ6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENsb3NlRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDbG9zZUV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgcmVhc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjb2RlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB3YXNDbGVhbjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXJyb3JFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Vycm9yRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtZXNzYWdlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBmaWxlbmFtZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbGluZW5vOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjb2xubzoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0ID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihNZXNzYWdlUG9ydClcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPE1lc3NhZ2VQb3J0PiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5NZXNzYWdlUG9ydFxuKVxuXG5jb25zdCBldmVudEluaXQgPSBbXG4gIHtcbiAgICBrZXk6ICdidWJibGVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY2FuY2VsYWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbXBvc2VkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9XG5dXG5cbndlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ2RhdGEnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55LFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAga2V5OiAnb3JpZ2luJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdsYXN0RXZlbnRJZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnc291cmNlJyxcbiAgICAvLyBOb2RlIGRvZXNuJ3QgaW1wbGVtZW50IFdpbmRvd1Byb3h5IG9yIFNlcnZpY2VXb3JrZXIsIHNvIHRoZSBvbmx5XG4gICAgLy8gdmFsaWQgdmFsdWUgZm9yIHNvdXJjZSBpcyBhIE1lc3NhZ2VQb3J0LlxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0KSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGtleTogJ3BvcnRzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxNZXNzYWdlUG9ydD4nXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG5ldyBBcnJheSgwKVxuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5DbG9zZUV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnd2FzQ2xlYW4nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb2RlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gMFxuICB9LFxuICB7XG4gICAga2V5OiAncmVhc29uJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkVycm9yRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICdtZXNzYWdlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdmaWxlbmFtZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnbGluZW5vJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb2xubycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gMFxuICB9LFxuICB7XG4gICAga2V5OiAnZXJyb3InLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNZXNzYWdlRXZlbnQsXG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnRcbn1cbiJdLCJuYW1lcyI6WyJ3ZWJpZGwiLCJyZXF1aXJlIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImtDb25zdHJ1Y3QiLCJNZXNzYWdlUG9ydCIsIk1lc3NhZ2VFdmVudCIsIkV2ZW50IiwidHlwZSIsImV2ZW50SW5pdERpY3QiLCJhcmd1bWVudHMiLCJwcmVmaXgiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiY29udmVydGVycyIsIkRPTVN0cmluZyIsIk1lc3NhZ2VFdmVudEluaXQiLCJkYXRhIiwiYnJhbmRDaGVjayIsIm9yaWdpbiIsImxhc3RFdmVudElkIiwic291cmNlIiwicG9ydHMiLCJPYmplY3QiLCJpc0Zyb3plbiIsImZyZWV6ZSIsImluaXRNZXNzYWdlRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQiLCJpbml0IiwibWVzc2FnZUV2ZW50IiwiQ2xvc2VFdmVudCIsIkNsb3NlRXZlbnRJbml0Iiwid2FzQ2xlYW4iLCJjb2RlIiwicmVhc29uIiwiRXJyb3JFdmVudCIsIkVycm9yRXZlbnRJbml0IiwibWVzc2FnZSIsImZpbGVuYW1lIiwibGluZW5vIiwiY29sbm8iLCJlcnJvciIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiaW50ZXJmYWNlQ29udmVydGVyIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJldmVudEluaXQiLCJrZXkiLCJjb252ZXJ0ZXIiLCJib29sZWFuIiwiZGVmYXVsdFZhbHVlIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImFueSIsIlVTVlN0cmluZyIsIm51bGxhYmxlQ29udmVydGVyIiwiQXJyYXkiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/frame.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/frame.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst BUFFER_SIZE = 16386;\n/** @type {import('crypto')} */ let crypto;\nlet buffer = null;\nlet bufIdx = BUFFER_SIZE;\ntry {\n    crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* c8 ignore next 3 */ } catch  {\n    crypto = {\n        // not full compatibility, but minimum.\n        randomFillSync: function randomFillSync(buffer, _offset, _size) {\n            for(let i = 0; i < buffer.length; ++i){\n                buffer[i] = Math.random() * 255 | 0;\n            }\n            return buffer;\n        }\n    };\n}\nfunction generateMask() {\n    if (bufIdx === BUFFER_SIZE) {\n        bufIdx = 0;\n        crypto.randomFillSync(buffer ??= Buffer.allocUnsafe(BUFFER_SIZE), 0, BUFFER_SIZE);\n    }\n    return [\n        buffer[bufIdx++],\n        buffer[bufIdx++],\n        buffer[bufIdx++],\n        buffer[bufIdx++]\n    ];\n}\nclass WebsocketFrameSend {\n    /**\n   * @param {Buffer|undefined} data\n   */ constructor(data){\n        this.frameData = data;\n    }\n    createFrame(opcode) {\n        const frameData = this.frameData;\n        const maskKey = generateMask();\n        const bodyLength = frameData?.byteLength ?? 0;\n        /** @type {number} */ let payloadLength = bodyLength // 0-125\n        ;\n        let offset = 6;\n        if (bodyLength > maxUnsigned16Bit) {\n            offset += 8; // payload length is next 8 bytes\n            payloadLength = 127;\n        } else if (bodyLength > 125) {\n            offset += 2; // payload length is next 2 bytes\n            payloadLength = 126;\n        }\n        const buffer = Buffer.allocUnsafe(bodyLength + offset);\n        // Clear first 2 bytes, everything else is overwritten\n        buffer[0] = buffer[1] = 0;\n        buffer[0] |= 0x80; // FIN\n        buffer[0] = (buffer[0] & 0xF0) + opcode; // opcode\n        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ buffer[offset - 4] = maskKey[0];\n        buffer[offset - 3] = maskKey[1];\n        buffer[offset - 2] = maskKey[2];\n        buffer[offset - 1] = maskKey[3];\n        buffer[1] = payloadLength;\n        if (payloadLength === 126) {\n            buffer.writeUInt16BE(bodyLength, 2);\n        } else if (payloadLength === 127) {\n            // Clear extended payload length\n            buffer[2] = buffer[3] = 0;\n            buffer.writeUIntBE(bodyLength, 4, 6);\n        }\n        buffer[1] |= 0x80; // MASK\n        // mask body\n        for(let i = 0; i < bodyLength; ++i){\n            buffer[offset + i] = frameData[i] ^ maskKey[i & 3];\n        }\n        return buffer;\n    }\n}\nmodule.exports = {\n    WebsocketFrameSend\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2ZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxnQkFBZ0IsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQywrRUFBYTtBQUVsRCxNQUFNQyxjQUFjO0FBRXBCLDZCQUE2QixHQUM3QixJQUFJQztBQUNKLElBQUlDLFNBQVM7QUFDYixJQUFJQyxTQUFTSDtBQUViLElBQUk7SUFDRkMsU0FBU0YsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaEMsb0JBQW9CLEdBQ3BCLEVBQUUsT0FBTTtJQUNORSxTQUFTO1FBQ1AsdUNBQXVDO1FBQ3ZDRyxnQkFBZ0IsU0FBU0EsZUFBZ0JGLE1BQU0sRUFBRUcsT0FBTyxFQUFFQyxLQUFLO1lBQzdELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxPQUFPTSxNQUFNLEVBQUUsRUFBRUQsRUFBRztnQkFDdENMLE1BQU0sQ0FBQ0ssRUFBRSxHQUFHRSxLQUFLQyxNQUFNLEtBQUssTUFBTTtZQUNwQztZQUNBLE9BQU9SO1FBQ1Q7SUFDRjtBQUNGO0FBRUEsU0FBU1M7SUFDUCxJQUFJUixXQUFXSCxhQUFhO1FBQzFCRyxTQUFTO1FBQ1RGLE9BQU9HLGNBQWMsQ0FBRUYsV0FBV1UsT0FBT0MsV0FBVyxDQUFDYixjQUFlLEdBQUdBO0lBQ3pFO0lBQ0EsT0FBTztRQUFDRSxNQUFNLENBQUNDLFNBQVM7UUFBRUQsTUFBTSxDQUFDQyxTQUFTO1FBQUVELE1BQU0sQ0FBQ0MsU0FBUztRQUFFRCxNQUFNLENBQUNDLFNBQVM7S0FBQztBQUNqRjtBQUVBLE1BQU1XO0lBQ0o7O0dBRUMsR0FDRCxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdEO0lBQ25CO0lBRUFFLFlBQWFDLE1BQU0sRUFBRTtRQUNuQixNQUFNRixZQUFZLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxNQUFNRyxVQUFVUjtRQUNoQixNQUFNUyxhQUFhSixXQUFXSyxjQUFjO1FBRTVDLG1CQUFtQixHQUNuQixJQUFJQyxnQkFBZ0JGLFdBQVcsUUFBUTs7UUFDdkMsSUFBSUcsU0FBUztRQUViLElBQUlILGFBQWF0QixrQkFBa0I7WUFDakN5QixVQUFVLEdBQUUsaUNBQWlDO1lBQzdDRCxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJRixhQUFhLEtBQUs7WUFDM0JHLFVBQVUsR0FBRSxpQ0FBaUM7WUFDN0NELGdCQUFnQjtRQUNsQjtRQUVBLE1BQU1wQixTQUFTVSxPQUFPQyxXQUFXLENBQUNPLGFBQWFHO1FBRS9DLHNEQUFzRDtRQUN0RHJCLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDeEJBLE1BQU0sQ0FBQyxFQUFFLElBQUksTUFBSyxNQUFNO1FBQ3hCQSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUNBLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBRyxJQUFLZ0IsUUFBTyxTQUFTO1FBRWpELDZEQUE2RCxHQUM3RGhCLE1BQU0sQ0FBQ3FCLFNBQVMsRUFBRSxHQUFHSixPQUFPLENBQUMsRUFBRTtRQUMvQmpCLE1BQU0sQ0FBQ3FCLFNBQVMsRUFBRSxHQUFHSixPQUFPLENBQUMsRUFBRTtRQUMvQmpCLE1BQU0sQ0FBQ3FCLFNBQVMsRUFBRSxHQUFHSixPQUFPLENBQUMsRUFBRTtRQUMvQmpCLE1BQU0sQ0FBQ3FCLFNBQVMsRUFBRSxHQUFHSixPQUFPLENBQUMsRUFBRTtRQUUvQmpCLE1BQU0sQ0FBQyxFQUFFLEdBQUdvQjtRQUVaLElBQUlBLGtCQUFrQixLQUFLO1lBQ3pCcEIsT0FBT3NCLGFBQWEsQ0FBQ0osWUFBWTtRQUNuQyxPQUFPLElBQUlFLGtCQUFrQixLQUFLO1lBQ2hDLGdDQUFnQztZQUNoQ3BCLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7WUFDeEJBLE9BQU91QixXQUFXLENBQUNMLFlBQVksR0FBRztRQUNwQztRQUVBbEIsTUFBTSxDQUFDLEVBQUUsSUFBSSxNQUFLLE9BQU87UUFFekIsWUFBWTtRQUNaLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJYSxZQUFZLEVBQUViLEVBQUc7WUFDbkNMLE1BQU0sQ0FBQ3FCLFNBQVNoQixFQUFFLEdBQUdTLFNBQVMsQ0FBQ1QsRUFBRSxHQUFHWSxPQUFPLENBQUNaLElBQUksRUFBRTtRQUNwRDtRQUVBLE9BQU9MO0lBQ1Q7QUFDRjtBQUVBd0IsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZiO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXGZyYW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG1heFVuc2lnbmVkMTZCaXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY29uc3QgQlVGRkVSX1NJWkUgPSAxNjM4NlxuXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG5sZXQgYnVmZmVyID0gbnVsbFxubGV0IGJ1ZklkeCA9IEJVRkZFUl9TSVpFXG5cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ25vZGU6Y3J5cHRvJylcbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbn0gY2F0Y2gge1xuICBjcnlwdG8gPSB7XG4gICAgLy8gbm90IGZ1bGwgY29tcGF0aWJpbGl0eSwgYnV0IG1pbmltdW0uXG4gICAgcmFuZG9tRmlsbFN5bmM6IGZ1bmN0aW9uIHJhbmRvbUZpbGxTeW5jIChidWZmZXIsIF9vZmZzZXQsIF9zaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBidWZmZXJbaV0gPSBNYXRoLnJhbmRvbSgpICogMjU1IHwgMFxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU1hc2sgKCkge1xuICBpZiAoYnVmSWR4ID09PSBCVUZGRVJfU0laRSkge1xuICAgIGJ1ZklkeCA9IDBcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMoKGJ1ZmZlciA/Pz0gQnVmZmVyLmFsbG9jVW5zYWZlKEJVRkZFUl9TSVpFKSksIDAsIEJVRkZFUl9TSVpFKVxuICB9XG4gIHJldHVybiBbYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXV1cbn1cblxuY2xhc3MgV2Vic29ja2V0RnJhbWVTZW5kIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfHVuZGVmaW5lZH0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmZyYW1lRGF0YSA9IGRhdGFcbiAgfVxuXG4gIGNyZWF0ZUZyYW1lIChvcGNvZGUpIHtcbiAgICBjb25zdCBmcmFtZURhdGEgPSB0aGlzLmZyYW1lRGF0YVxuICAgIGNvbnN0IG1hc2tLZXkgPSBnZW5lcmF0ZU1hc2soKVxuICAgIGNvbnN0IGJvZHlMZW5ndGggPSBmcmFtZURhdGE/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBib2R5TGVuZ3RoIC8vIDAtMTI1XG4gICAgbGV0IG9mZnNldCA9IDZcblxuICAgIGlmIChib2R5TGVuZ3RoID4gbWF4VW5zaWduZWQxNkJpdCkge1xuICAgICAgb2Zmc2V0ICs9IDggLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCA4IGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3XG4gICAgfSBlbHNlIGlmIChib2R5TGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMiAvLyBwYXlsb2FkIGxlbmd0aCBpcyBuZXh0IDIgYnl0ZXNcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjZcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYm9keUxlbmd0aCArIG9mZnNldClcblxuICAgIC8vIENsZWFyIGZpcnN0IDIgYnl0ZXMsIGV2ZXJ5dGhpbmcgZWxzZSBpcyBvdmVyd3JpdHRlblxuICAgIGJ1ZmZlclswXSA9IGJ1ZmZlclsxXSA9IDBcbiAgICBidWZmZXJbMF0gfD0gMHg4MCAvLyBGSU5cbiAgICBidWZmZXJbMF0gPSAoYnVmZmVyWzBdICYgMHhGMCkgKyBvcGNvZGUgLy8gb3Bjb2RlXG5cbiAgICAvKiEgd3MuIE1JVCBMaWNlbnNlLiBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT4gKi9cbiAgICBidWZmZXJbb2Zmc2V0IC0gNF0gPSBtYXNrS2V5WzBdXG4gICAgYnVmZmVyW29mZnNldCAtIDNdID0gbWFza0tleVsxXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAyXSA9IG1hc2tLZXlbMl1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMV0gPSBtYXNrS2V5WzNdXG5cbiAgICBidWZmZXJbMV0gPSBwYXlsb2FkTGVuZ3RoXG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICBidWZmZXIud3JpdGVVSW50MTZCRShib2R5TGVuZ3RoLCAyKVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAvLyBDbGVhciBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aFxuICAgICAgYnVmZmVyWzJdID0gYnVmZmVyWzNdID0gMFxuICAgICAgYnVmZmVyLndyaXRlVUludEJFKGJvZHlMZW5ndGgsIDQsIDYpXG4gICAgfVxuXG4gICAgYnVmZmVyWzFdIHw9IDB4ODAgLy8gTUFTS1xuXG4gICAgLy8gbWFzayBib2R5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5TGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGZyYW1lRGF0YVtpXSBeIG1hc2tLZXlbaSAmIDNdXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJzb2NrZXRGcmFtZVNlbmRcbn1cbiJdLCJuYW1lcyI6WyJtYXhVbnNpZ25lZDE2Qml0IiwicmVxdWlyZSIsIkJVRkZFUl9TSVpFIiwiY3J5cHRvIiwiYnVmZmVyIiwiYnVmSWR4IiwicmFuZG9tRmlsbFN5bmMiLCJfb2Zmc2V0IiwiX3NpemUiLCJpIiwibGVuZ3RoIiwiTWF0aCIsInJhbmRvbSIsImdlbmVyYXRlTWFzayIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwiV2Vic29ja2V0RnJhbWVTZW5kIiwiZGF0YSIsImZyYW1lRGF0YSIsImNyZWF0ZUZyYW1lIiwib3Bjb2RlIiwibWFza0tleSIsImJvZHlMZW5ndGgiLCJieXRlTGVuZ3RoIiwicGF5bG9hZExlbmd0aCIsIm9mZnNldCIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnRCRSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/frame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/permessage-deflate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst { isValidClientWindowBits } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\");\nconst tail = Buffer.from([\n    0x00,\n    0x00,\n    0xff,\n    0xff\n]);\nconst kBuffer = Symbol('kBuffer');\nconst kLength = Symbol('kLength');\nclass PerMessageDeflate {\n    /** @type {import('node:zlib').InflateRaw} */ #inflate;\n    #options;\n    constructor(extensions){\n        this.#options = {};\n        this.#options.serverNoContextTakeover = extensions.has('server_no_context_takeover');\n        this.#options.serverMaxWindowBits = extensions.get('server_max_window_bits');\n    }\n    decompress(chunk, fin, callback) {\n        // An endpoint uses the following algorithm to decompress a message.\n        // 1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the\n        //     payload of the message.\n        // 2.  Decompress the resulting data using DEFLATE.\n        if (!this.#inflate) {\n            let windowBits = Z_DEFAULT_WINDOWBITS;\n            if (this.#options.serverMaxWindowBits) {\n                if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {\n                    callback(new Error('Invalid server_max_window_bits'));\n                    return;\n                }\n                windowBits = Number.parseInt(this.#options.serverMaxWindowBits);\n            }\n            this.#inflate = createInflateRaw({\n                windowBits\n            });\n            this.#inflate[kBuffer] = [];\n            this.#inflate[kLength] = 0;\n            this.#inflate.on('data', (data)=>{\n                this.#inflate[kBuffer].push(data);\n                this.#inflate[kLength] += data.length;\n            });\n            this.#inflate.on('error', (err)=>{\n                this.#inflate = null;\n                callback(err);\n            });\n        }\n        this.#inflate.write(chunk);\n        if (fin) {\n            this.#inflate.write(tail);\n        }\n        this.#inflate.flush(()=>{\n            const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);\n            this.#inflate[kBuffer].length = 0;\n            this.#inflate[kLength] = 0;\n            callback(null, full);\n        });\n    }\n}\nmodule.exports = {\n    PerMessageDeflate\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsZ0JBQWdCLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLDRCQUFXO0FBQ3RFLE1BQU0sRUFBRUMsdUJBQXVCLEVBQUUsR0FBR0QsbUJBQU9BLENBQUMscUVBQVE7QUFFcEQsTUFBTUUsT0FBT0MsT0FBT0MsSUFBSSxDQUFDO0lBQUM7SUFBTTtJQUFNO0lBQU07Q0FBSztBQUNqRCxNQUFNQyxVQUFVQyxPQUFPO0FBQ3ZCLE1BQU1DLFVBQVVELE9BQU87QUFFdkIsTUFBTUU7SUFDSiwyQ0FBMkMsR0FDM0MsUUFBUTtJQUVSLFFBQVEsQ0FBSztJQUViLFlBQWFDLFVBQVUsQ0FBRTthQUZ6QixRQUFRLEdBQUcsQ0FBQztRQUdWLElBQUksQ0FBQyxRQUFRLENBQUNDLHVCQUF1QixHQUFHRCxXQUFXRSxHQUFHLENBQUM7UUFDdkQsSUFBSSxDQUFDLFFBQVEsQ0FBQ0MsbUJBQW1CLEdBQUdILFdBQVdJLEdBQUcsQ0FBQztJQUNyRDtJQUVBQyxXQUFZQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFO1FBQ2hDLG9FQUFvRTtRQUNwRSxvRUFBb0U7UUFDcEUsOEJBQThCO1FBQzlCLG1EQUFtRDtRQUVuRCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNsQixJQUFJQyxhQUFhbkI7WUFFakIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDYSxtQkFBbUIsRUFBRTtnQkFDckMsSUFBSSxDQUFDWCx3QkFBd0IsSUFBSSxDQUFDLFFBQVEsQ0FBQ1csbUJBQW1CLEdBQUc7b0JBQy9ESyxTQUFTLElBQUlFLE1BQU07b0JBQ25CO2dCQUNGO2dCQUVBRCxhQUFhRSxPQUFPQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQ1QsbUJBQW1CO1lBQ2hFO1lBRUEsSUFBSSxDQUFDLFFBQVEsR0FBR2QsaUJBQWlCO2dCQUFFb0I7WUFBVztZQUM5QyxJQUFJLENBQUMsUUFBUSxDQUFDYixRQUFRLEdBQUcsRUFBRTtZQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDRSxRQUFRLEdBQUc7WUFFekIsSUFBSSxDQUFDLFFBQVEsQ0FBQ2UsRUFBRSxDQUFDLFFBQVEsQ0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQyxRQUFRLENBQUNsQixRQUFRLENBQUNtQixJQUFJLENBQUNEO2dCQUM1QixJQUFJLENBQUMsUUFBUSxDQUFDaEIsUUFBUSxJQUFJZ0IsS0FBS0UsTUFBTTtZQUN2QztZQUVBLElBQUksQ0FBQyxRQUFRLENBQUNILEVBQUUsQ0FBQyxTQUFTLENBQUNJO2dCQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHO2dCQUNoQlQsU0FBU1M7WUFDWDtRQUNGO1FBRUEsSUFBSSxDQUFDLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDWjtRQUNwQixJQUFJQyxLQUFLO1lBQ1AsSUFBSSxDQUFDLFFBQVEsQ0FBQ1csS0FBSyxDQUFDekI7UUFDdEI7UUFFQSxJQUFJLENBQUMsUUFBUSxDQUFDMEIsS0FBSyxDQUFDO1lBQ2xCLE1BQU1DLE9BQU8xQixPQUFPMkIsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUN6QixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQ0UsUUFBUTtZQUV6RSxJQUFJLENBQUMsUUFBUSxDQUFDRixRQUFRLENBQUNvQixNQUFNLEdBQUc7WUFDaEMsSUFBSSxDQUFDLFFBQVEsQ0FBQ2xCLFFBQVEsR0FBRztZQUV6QlUsU0FBUyxNQUFNWTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHO0lBQUV4QjtBQUFrQiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxccGVybWVzc2FnZS1kZWZsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNyZWF0ZUluZmxhdGVSYXcsIFpfREVGQVVMVF9XSU5ET1dCSVRTIH0gPSByZXF1aXJlKCdub2RlOnpsaWInKVxuY29uc3QgeyBpc1ZhbGlkQ2xpZW50V2luZG93Qml0cyB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuY29uc3QgdGFpbCA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSlcbmNvbnN0IGtCdWZmZXIgPSBTeW1ib2woJ2tCdWZmZXInKVxuY29uc3Qga0xlbmd0aCA9IFN5bWJvbCgna0xlbmd0aCcpXG5cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ25vZGU6emxpYicpLkluZmxhdGVSYXd9ICovXG4gICNpbmZsYXRlXG5cbiAgI29wdGlvbnMgPSB7fVxuXG4gIGNvbnN0cnVjdG9yIChleHRlbnNpb25zKSB7XG4gICAgdGhpcy4jb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9IGV4dGVuc2lvbnMuaGFzKCdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcicpXG4gICAgdGhpcy4jb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID0gZXh0ZW5zaW9ucy5nZXQoJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKVxuICB9XG5cbiAgZGVjb21wcmVzcyAoY2h1bmssIGZpbiwgY2FsbGJhY2spIHtcbiAgICAvLyBBbiBlbmRwb2ludCB1c2VzIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtIHRvIGRlY29tcHJlc3MgYSBtZXNzYWdlLlxuICAgIC8vIDEuICBBcHBlbmQgNCBvY3RldHMgb2YgMHgwMCAweDAwIDB4ZmYgMHhmZiB0byB0aGUgdGFpbCBlbmQgb2YgdGhlXG4gICAgLy8gICAgIHBheWxvYWQgb2YgdGhlIG1lc3NhZ2UuXG4gICAgLy8gMi4gIERlY29tcHJlc3MgdGhlIHJlc3VsdGluZyBkYXRhIHVzaW5nIERFRkxBVEUuXG5cbiAgICBpZiAoIXRoaXMuI2luZmxhdGUpIHtcbiAgICAgIGxldCB3aW5kb3dCaXRzID0gWl9ERUZBVUxUX1dJTkRPV0JJVFNcblxuICAgICAgaWYgKHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykgeyAvLyBlbXB0eSB2YWx1ZXMgZGVmYXVsdCB0byBaX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICBpZiAoIWlzVmFsaWRDbGllbnRXaW5kb3dCaXRzKHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykpIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmVyX21heF93aW5kb3dfYml0cycpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93Qml0cyA9IE51bWJlci5wYXJzZUludCh0aGlzLiNvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2luZmxhdGUgPSBjcmVhdGVJbmZsYXRlUmF3KHsgd2luZG93Qml0cyB9KVxuICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXSA9IFtdXG4gICAgICB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdID0gMFxuXG4gICAgICB0aGlzLiNpbmZsYXRlLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXS5wdXNoKGRhdGEpXG4gICAgICAgIHRoaXMuI2luZmxhdGVba0xlbmd0aF0gKz0gZGF0YS5sZW5ndGhcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuI2luZmxhdGUub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLiNpbmZsYXRlID0gbnVsbFxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuI2luZmxhdGUud3JpdGUoY2h1bmspXG4gICAgaWYgKGZpbikge1xuICAgICAgdGhpcy4jaW5mbGF0ZS53cml0ZSh0YWlsKVxuICAgIH1cblxuICAgIHRoaXMuI2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZnVsbCA9IEJ1ZmZlci5jb25jYXQodGhpcy4jaW5mbGF0ZVtrQnVmZmVyXSwgdGhpcy4jaW5mbGF0ZVtrTGVuZ3RoXSlcblxuICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXS5sZW5ndGggPSAwXG4gICAgICB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdID0gMFxuXG4gICAgICBjYWxsYmFjayhudWxsLCBmdWxsKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFBlck1lc3NhZ2VEZWZsYXRlIH1cbiJdLCJuYW1lcyI6WyJjcmVhdGVJbmZsYXRlUmF3IiwiWl9ERUZBVUxUX1dJTkRPV0JJVFMiLCJyZXF1aXJlIiwiaXNWYWxpZENsaWVudFdpbmRvd0JpdHMiLCJ0YWlsIiwiQnVmZmVyIiwiZnJvbSIsImtCdWZmZXIiLCJTeW1ib2wiLCJrTGVuZ3RoIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJleHRlbnNpb25zIiwic2VydmVyTm9Db250ZXh0VGFrZW92ZXIiLCJoYXMiLCJzZXJ2ZXJNYXhXaW5kb3dCaXRzIiwiZ2V0IiwiZGVjb21wcmVzcyIsImNodW5rIiwiZmluIiwiY2FsbGJhY2siLCJ3aW5kb3dCaXRzIiwiRXJyb3IiLCJOdW1iZXIiLCJwYXJzZUludCIsIm9uIiwiZGF0YSIsInB1c2giLCJsZW5ndGgiLCJlcnIiLCJ3cml0ZSIsImZsdXNoIiwiZnVsbCIsImNvbmNhdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\");\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst { isValidStatusCode, isValidOpcode, failWebsocketConnection, websocketMessageReceived, utf8Decode, isControlFrame, isTextBinaryFrame, isContinuationFrame } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\");\nconst { closeWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/undici/lib/web/websocket/connection.js\");\nconst { PerMessageDeflate } = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\");\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\nclass ByteParser extends Writable {\n    #buffers;\n    #byteOffset;\n    #loop;\n    #state;\n    #info;\n    #fragments;\n    /** @type {Map<string, PerMessageDeflate>} */ #extensions;\n    constructor(ws, extensions){\n        super(), this.#buffers = [], this.#byteOffset = 0, this.#loop = false, this.#state = parserStates.INFO, this.#info = {}, this.#fragments = [];\n        this.ws = ws;\n        this.#extensions = extensions == null ? new Map() : extensions;\n        if (this.#extensions.has('permessage-deflate')) {\n            this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions));\n        }\n    }\n    /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */ _write(chunk, _, callback) {\n        this.#buffers.push(chunk);\n        this.#byteOffset += chunk.length;\n        this.#loop = true;\n        this.run(callback);\n    }\n    /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */ run(callback) {\n        while(this.#loop){\n            if (this.#state === parserStates.INFO) {\n                // If there aren't enough bytes to parse the payload length, etc.\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                const fin = (buffer[0] & 0x80) !== 0;\n                const opcode = buffer[0] & 0x0F;\n                const masked = (buffer[1] & 0x80) === 0x80;\n                const fragmented = !fin && opcode !== opcodes.CONTINUATION;\n                const payloadLength = buffer[1] & 0x7F;\n                const rsv1 = buffer[0] & 0x40;\n                const rsv2 = buffer[0] & 0x20;\n                const rsv3 = buffer[0] & 0x10;\n                if (!isValidOpcode(opcode)) {\n                    failWebsocketConnection(this.ws, 'Invalid opcode received');\n                    return callback();\n                }\n                if (masked) {\n                    failWebsocketConnection(this.ws, 'Frame cannot be masked');\n                    return callback();\n                }\n                // MUST be 0 unless an extension is negotiated that defines meanings\n                // for non-zero values.  If a nonzero value is received and none of\n                // the negotiated extensions defines the meaning of such a nonzero\n                // value, the receiving endpoint MUST _Fail the WebSocket\n                // Connection_.\n                // This document allocates the RSV1 bit of the WebSocket header for\n                // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n                // WebSocket connection where a PMCE is in use, this bit indicates\n                // whether a message is compressed or not.\n                if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n                    failWebsocketConnection(this.ws, 'Expected RSV1 to be clear.');\n                    return;\n                }\n                if (rsv2 !== 0 || rsv3 !== 0) {\n                    failWebsocketConnection(this.ws, 'RSV1, RSV2, RSV3 must be clear');\n                    return;\n                }\n                if (fragmented && !isTextBinaryFrame(opcode)) {\n                    // Only text and binary frames can be fragmented\n                    failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');\n                    return;\n                }\n                // If we are already parsing a text/binary frame and do not receive either\n                // a continuation frame or close frame, fail the connection.\n                if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n                    failWebsocketConnection(this.ws, 'Expected continuation frame');\n                    return;\n                }\n                if (this.#info.fragmented && fragmented) {\n                    // A fragmented frame can't be fragmented itself\n                    failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');\n                    return;\n                }\n                // \"All control frames MUST have a payload length of 125 bytes or less\n                // and MUST NOT be fragmented.\"\n                if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n                    failWebsocketConnection(this.ws, 'Control frame either too large or fragmented');\n                    return;\n                }\n                if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n                    failWebsocketConnection(this.ws, 'Unexpected continuation frame');\n                    return;\n                }\n                if (payloadLength <= 125) {\n                    this.#info.payloadLength = payloadLength;\n                    this.#state = parserStates.READ_DATA;\n                } else if (payloadLength === 126) {\n                    this.#state = parserStates.PAYLOADLENGTH_16;\n                } else if (payloadLength === 127) {\n                    this.#state = parserStates.PAYLOADLENGTH_64;\n                }\n                if (isTextBinaryFrame(opcode)) {\n                    this.#info.binaryType = opcode;\n                    this.#info.compressed = rsv1 !== 0;\n                }\n                this.#info.opcode = opcode;\n                this.#info.masked = masked;\n                this.#info.fin = fin;\n                this.#info.fragmented = fragmented;\n            } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                this.#info.payloadLength = buffer.readUInt16BE(0);\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n                if (this.#byteOffset < 8) {\n                    return callback();\n                }\n                const buffer = this.consume(8);\n                const upper = buffer.readUInt32BE(0);\n                // 2^31 is the maximum bytes an arraybuffer can contain\n                // on 32-bit systems. Although, on 64-bit systems, this is\n                // 2^53-1 bytes.\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n                if (upper > 2 ** 31 - 1) {\n                    failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');\n                    return;\n                }\n                const lower = buffer.readUInt32BE(4);\n                this.#info.payloadLength = (upper << 8) + lower;\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.READ_DATA) {\n                if (this.#byteOffset < this.#info.payloadLength) {\n                    return callback();\n                }\n                const body = this.consume(this.#info.payloadLength);\n                if (isControlFrame(this.#info.opcode)) {\n                    this.#loop = this.parseControlFrame(body);\n                    this.#state = parserStates.INFO;\n                } else {\n                    if (!this.#info.compressed) {\n                        this.#fragments.push(body);\n                        // If the frame is not fragmented, a message has been received.\n                        // If the frame is fragmented, it will terminate with a fin bit set\n                        // and an opcode of 0 (continuation), therefore we handle that when\n                        // parsing continuation frames, not here.\n                        if (!this.#info.fragmented && this.#info.fin) {\n                            const fullMessage = Buffer.concat(this.#fragments);\n                            websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage);\n                            this.#fragments.length = 0;\n                        }\n                        this.#state = parserStates.INFO;\n                    } else {\n                        this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data)=>{\n                            if (error) {\n                                closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);\n                                return;\n                            }\n                            this.#fragments.push(data);\n                            if (!this.#info.fin) {\n                                this.#state = parserStates.INFO;\n                                this.#loop = true;\n                                this.run(callback);\n                                return;\n                            }\n                            websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments));\n                            this.#loop = true;\n                            this.#state = parserStates.INFO;\n                            this.#fragments.length = 0;\n                            this.run(callback);\n                        });\n                        this.#loop = false;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */ consume(n) {\n        if (n > this.#byteOffset) {\n            throw new Error('Called consume() before buffers satiated.');\n        } else if (n === 0) {\n            return emptyBuffer;\n        }\n        if (this.#buffers[0].length === n) {\n            this.#byteOffset -= this.#buffers[0].length;\n            return this.#buffers.shift();\n        }\n        const buffer = Buffer.allocUnsafe(n);\n        let offset = 0;\n        while(offset !== n){\n            const next = this.#buffers[0];\n            const { length } = next;\n            if (length + offset === n) {\n                buffer.set(this.#buffers.shift(), offset);\n                break;\n            } else if (length + offset > n) {\n                buffer.set(next.subarray(0, n - offset), offset);\n                this.#buffers[0] = next.subarray(n - offset);\n                break;\n            } else {\n                buffer.set(this.#buffers.shift(), offset);\n                offset += next.length;\n            }\n        }\n        this.#byteOffset -= n;\n        return buffer;\n    }\n    parseCloseBody(data) {\n        assert(data.length !== 1);\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n        /** @type {number|undefined} */ let code;\n        if (data.length >= 2) {\n            // _The WebSocket Connection Close Code_ is\n            // defined as the status code (Section 7.4) contained in the first Close\n            // control frame received by the application\n            code = data.readUInt16BE(0);\n        }\n        if (code !== undefined && !isValidStatusCode(code)) {\n            return {\n                code: 1002,\n                reason: 'Invalid status code',\n                error: true\n            };\n        }\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n        /** @type {Buffer} */ let reason = data.subarray(2);\n        // Remove BOM\n        if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n            reason = reason.subarray(3);\n        }\n        try {\n            reason = utf8Decode(reason);\n        } catch  {\n            return {\n                code: 1007,\n                reason: 'Invalid UTF-8',\n                error: true\n            };\n        }\n        return {\n            code,\n            reason,\n            error: false\n        };\n    }\n    /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */ parseControlFrame(body) {\n        const { opcode, payloadLength } = this.#info;\n        if (opcode === opcodes.CLOSE) {\n            if (payloadLength === 1) {\n                failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');\n                return false;\n            }\n            this.#info.closeInfo = this.parseCloseBody(body);\n            if (this.#info.closeInfo.error) {\n                const { code, reason } = this.#info.closeInfo;\n                closeWebSocketConnection(this.ws, code, reason, reason.length);\n                failWebsocketConnection(this.ws, reason);\n                return false;\n            }\n            if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {\n                // If an endpoint receives a Close frame and did not previously send a\n                // Close frame, the endpoint MUST send a Close frame in response.  (When\n                // sending a Close frame in response, the endpoint typically echos the\n                // status code it received.)\n                let body = emptyBuffer;\n                if (this.#info.closeInfo.code) {\n                    body = Buffer.allocUnsafe(2);\n                    body.writeUInt16BE(this.#info.closeInfo.code, 0);\n                }\n                const closeFrame = new WebsocketFrameSend(body);\n                this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err)=>{\n                    if (!err) {\n                        this.ws[kSentClose] = sentCloseFrameState.SENT;\n                    }\n                });\n            }\n            // Upon either sending or receiving a Close control frame, it is said\n            // that _The WebSocket Closing Handshake is Started_ and that the\n            // WebSocket connection is in the CLOSING state.\n            this.ws[kReadyState] = states.CLOSING;\n            this.ws[kReceivedClose] = true;\n            return false;\n        } else if (opcode === opcodes.PING) {\n            // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n            // response, unless it already received a Close frame.\n            // A Pong frame sent in response to a Ping frame must have identical\n            // \"Application data\"\n            if (!this.ws[kReceivedClose]) {\n                const frame = new WebsocketFrameSend(body);\n                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));\n                if (channels.ping.hasSubscribers) {\n                    channels.ping.publish({\n                        payload: body\n                    });\n                }\n            }\n        } else if (opcode === opcodes.PONG) {\n            // A Pong frame MAY be sent unsolicited.  This serves as a\n            // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n            // not expected.\n            if (channels.pong.hasSubscribers) {\n                channels.pong.publish({\n                    payload: body\n                });\n            }\n        }\n        return true;\n    }\n    get closingInfo() {\n        return this.#info.closeInfo;\n    }\n}\nmodule.exports = {\n    ByteParser\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDMUMsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsZ0NBQWE7QUFDcEMsTUFBTSxFQUFFRSxZQUFZLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLG1CQUFtQixFQUFFLEdBQUdOLG1CQUFPQSxDQUFDLCtFQUFhO0FBQ2pHLE1BQU0sRUFBRU8sV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsY0FBYyxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDLDJFQUFXO0FBQ2xGLE1BQU0sRUFBRVcsUUFBUSxFQUFFLEdBQUdYLG1CQUFPQSxDQUFDLG1GQUF3QjtBQUNyRCxNQUFNLEVBQ0pZLGlCQUFpQixFQUNqQkMsYUFBYSxFQUNiQyx1QkFBdUIsRUFDdkJDLHdCQUF3QixFQUN4QkMsVUFBVSxFQUNWQyxjQUFjLEVBQ2RDLGlCQUFpQixFQUNqQkMsbUJBQW1CLEVBQ3BCLEdBQUduQixtQkFBT0EsQ0FBQyxxRUFBUTtBQUNwQixNQUFNLEVBQUVvQixrQkFBa0IsRUFBRSxHQUFHcEIsbUJBQU9BLENBQUMsdUVBQVM7QUFDaEQsTUFBTSxFQUFFcUIsd0JBQXdCLEVBQUUsR0FBR3JCLG1CQUFPQSxDQUFDLGlGQUFjO0FBQzNELE1BQU0sRUFBRXNCLGlCQUFpQixFQUFFLEdBQUd0QixtQkFBT0EsQ0FBQyxpR0FBc0I7QUFFNUQsaUVBQWlFO0FBQ2pFLDZEQUE2RDtBQUM3RCxzREFBc0Q7QUFDdEQsa0RBQWtEO0FBRWxELE1BQU11QixtQkFBbUJ4QjtJQUN2QixRQUFRLENBQUs7SUFDYixXQUFXLENBQUk7SUFDZixLQUFLLENBQVE7SUFFYixNQUFNLENBQW9CO0lBRTFCLEtBQUssQ0FBSztJQUNWLFVBQVUsQ0FBSztJQUVmLDJD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cEJDLFNBQVNyQztvQkFDWDtnQkFDRjtZQUNGO1FBQ0YsT0FBTyxJQUFJakIsV0FBV3JDLFFBQVF1RixJQUFJLEVBQUU7WUFDbEMsMERBQTBEO1lBQzFELHdFQUF3RTtZQUN4RSxnQkFBZ0I7WUFFaEIsSUFBSS9FLFNBQVNvRixJQUFJLENBQUNILGNBQWMsRUFBRTtnQkFDaENqRixTQUFTb0YsSUFBSSxDQUFDRixPQUFPLENBQUM7b0JBQ3BCQyxTQUFTckM7Z0JBQ1g7WUFDRjtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRUEsSUFBSXVDLGNBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDakIsU0FBUztJQUM3QjtBQUNGO0FBRUFrQixPQUFPQyxPQUFPLEdBQUc7SUFDZjNFO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxIZWxpeFxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXHJlY2VpdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHBhcnNlclN0YXRlcywgb3Bjb2Rlcywgc3RhdGVzLCBlbXB0eUJ1ZmZlciwgc2VudENsb3NlRnJhbWVTdGF0ZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrUmVhZHlTdGF0ZSwga1NlbnRDbG9zZSwga1Jlc3BvbnNlLCBrUmVjZWl2ZWRDbG9zZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgY2hhbm5lbHMgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGlhZ25vc3RpY3MnKVxuY29uc3Qge1xuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZE9wY29kZSxcbiAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sXG4gIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCxcbiAgdXRmOERlY29kZSxcbiAgaXNDb250cm9sRnJhbWUsXG4gIGlzVGV4dEJpbmFyeUZyYW1lLFxuICBpc0NvbnRpbnVhdGlvbkZyYW1lXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcbmNvbnN0IHsgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBQZXJNZXNzYWdlRGVmbGF0ZSB9ID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKVxuXG4vLyBUaGlzIGNvZGUgd2FzIGluZmx1ZW5jZWQgYnkgd3MgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gQ29weXJpZ2h0IChjKSAyMDExIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPlxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFybm91dCBLYXplbWllciBhbmQgY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgTHVpZ2kgUGluY2EgYW5kIGNvbnRyaWJ1dG9yc1xuXG5jbGFzcyBCeXRlUGFyc2VyIGV4dGVuZHMgV3JpdGFibGUge1xuICAjYnVmZmVycyA9IFtdXG4gICNieXRlT2Zmc2V0ID0gMFxuICAjbG9vcCA9IGZhbHNlXG5cbiAgI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cblxuICAjaW5mbyA9IHt9XG4gICNmcmFnbWVudHMgPSBbXVxuXG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgUGVyTWVzc2FnZURlZmxhdGU+fSAqL1xuICAjZXh0ZW5zaW9uc1xuXG4gIGNvbnN0cnVjdG9yICh3cywgZXh0ZW5zaW9ucykge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMud3MgPSB3c1xuICAgIHRoaXMuI2V4dGVuc2lvbnMgPSBleHRlbnNpb25zID09IG51bGwgPyBuZXcgTWFwKCkgOiBleHRlbnNpb25zXG5cbiAgICBpZiAodGhpcy4jZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICB0aGlzLiNleHRlbnNpb25zLnNldCgncGVybWVzc2FnZS1kZWZsYXRlJywgbmV3IFBlck1lc3NhZ2VEZWZsYXRlKGV4dGVuc2lvbnMpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKi9cbiAgX3dyaXRlIChjaHVuaywgXywgY2FsbGJhY2spIHtcbiAgICB0aGlzLiNidWZmZXJzLnB1c2goY2h1bmspXG4gICAgdGhpcy4jYnl0ZU9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgICB0aGlzLiNsb29wID0gdHJ1ZVxuXG4gICAgdGhpcy5ydW4oY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogUnVucyB3aGVuZXZlciBhIG5ldyBjaHVuayBpcyByZWNlaXZlZC5cbiAgICogQ2FsbGJhY2sgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZXJlIGFyZSBubyBtb3JlIGNodW5rcyBidWZmZXJpbmcsXG4gICAqIG9yIG5vdCBlbm91Z2ggYnl0ZXMgYXJlIGJ1ZmZlcmVkIHRvIHBhcnNlLlxuICAgKi9cbiAgcnVuIChjYWxsYmFjaykge1xuICAgIHdoaWxlICh0aGlzLiNsb29wKSB7XG4gICAgICBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5JTkZPKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBlbm91Z2ggYnl0ZXMgdG8gcGFyc2UgdGhlIHBheWxvYWQgbGVuZ3RoLCBldGMuXG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgMikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoMilcbiAgICAgICAgY29uc3QgZmluID0gKGJ1ZmZlclswXSAmIDB4ODApICE9PSAwXG4gICAgICAgIGNvbnN0IG9wY29kZSA9IGJ1ZmZlclswXSAmIDB4MEZcbiAgICAgICAgY29uc3QgbWFza2VkID0gKGJ1ZmZlclsxXSAmIDB4ODApID09PSAweDgwXG5cbiAgICAgICAgY29uc3QgZnJhZ21lbnRlZCA9ICFmaW4gJiYgb3Bjb2RlICE9PSBvcGNvZGVzLkNPTlRJTlVBVElPTlxuICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gYnVmZmVyWzFdICYgMHg3RlxuXG4gICAgICAgIGNvbnN0IHJzdjEgPSBidWZmZXJbMF0gJiAweDQwXG4gICAgICAgIGNvbnN0IHJzdjIgPSBidWZmZXJbMF0gJiAweDIwXG4gICAgICAgIGNvbnN0IHJzdjMgPSBidWZmZXJbMF0gJiAweDEwXG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkT3Bjb2RlKG9wY29kZSkpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnSW52YWxpZCBvcGNvZGUgcmVjZWl2ZWQnKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFza2VkKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ZyYW1lIGNhbm5vdCBiZSBtYXNrZWQnKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBNVVNUIGJlIDAgdW5sZXNzIGFuIGV4dGVuc2lvbiBpcyBuZWdvdGlhdGVkIHRoYXQgZGVmaW5lcyBtZWFuaW5nc1xuICAgICAgICAvLyBmb3Igbm9uLXplcm8gdmFsdWVzLiAgSWYgYSBub256ZXJvIHZhbHVlIGlzIHJlY2VpdmVkIGFuZCBub25lIG9mXG4gICAgICAgIC8vIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnMgZGVmaW5lcyB0aGUgbWVhbmluZyBvZiBzdWNoIGEgbm9uemVyb1xuICAgICAgICAvLyB2YWx1ZSwgdGhlIHJlY2VpdmluZyBlbmRwb2ludCBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAgICAgLy8gQ29ubmVjdGlvbl8uXG4gICAgICAgIC8vIFRoaXMgZG9jdW1lbnQgYWxsb2NhdGVzIHRoZSBSU1YxIGJpdCBvZiB0aGUgV2ViU29ja2V0IGhlYWRlciBmb3JcbiAgICAgICAgLy8gUE1DRXMgYW5kIGNhbGxzIHRoZSBiaXQgdGhlIFwiUGVyLU1lc3NhZ2UgQ29tcHJlc3NlZFwiIGJpdC4gIE9uIGFcbiAgICAgICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gd2hlcmUgYSBQTUNFIGlzIGluIHVzZSwgdGhpcyBiaXQgaW5kaWNhdGVzXG4gICAgICAgIC8vIHdoZXRoZXIgYSBtZXNzYWdlIGlzIGNvbXByZXNzZWQgb3Igbm90LlxuICAgICAgICBpZiAocnN2MSAhPT0gMCAmJiAhdGhpcy4jZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0V4cGVjdGVkIFJTVjEgdG8gYmUgY2xlYXIuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyc3YyICE9PSAwIHx8IHJzdjMgIT09IDApIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnUlNWMSwgUlNWMiwgUlNWMyBtdXN0IGJlIGNsZWFyJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmFnbWVudGVkICYmICFpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpKSB7XG4gICAgICAgICAgLy8gT25seSB0ZXh0IGFuZCBiaW5hcnkgZnJhbWVzIGNhbiBiZSBmcmFnbWVudGVkXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ludmFsaWQgZnJhbWUgdHlwZSB3YXMgZnJhZ21lbnRlZC4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgcGFyc2luZyBhIHRleHQvYmluYXJ5IGZyYW1lIGFuZCBkbyBub3QgcmVjZWl2ZSBlaXRoZXJcbiAgICAgICAgLy8gYSBjb250aW51YXRpb24gZnJhbWUgb3IgY2xvc2UgZnJhbWUsIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIGlmIChpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpICYmIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0V4cGVjdGVkIGNvbnRpbnVhdGlvbiBmcmFtZScpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4jaW5mby5mcmFnbWVudGVkICYmIGZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAvLyBBIGZyYWdtZW50ZWQgZnJhbWUgY2FuJ3QgYmUgZnJhZ21lbnRlZCBpdHNlbGZcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnRnJhZ21lbnRlZCBmcmFtZSBleGNlZWRlZCAxMjUgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFwiQWxsIGNvbnRyb2wgZnJhbWVzIE1VU1QgaGF2ZSBhIHBheWxvYWQgbGVuZ3RoIG9mIDEyNSBieXRlcyBvciBsZXNzXG4gICAgICAgIC8vIGFuZCBNVVNUIE5PVCBiZSBmcmFnbWVudGVkLlwiXG4gICAgICAgIGlmICgocGF5bG9hZExlbmd0aCA+IDEyNSB8fCBmcmFnbWVudGVkKSAmJiBpc0NvbnRyb2xGcmFtZShvcGNvZGUpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0NvbnRyb2wgZnJhbWUgZWl0aGVyIHRvbyBsYXJnZSBvciBmcmFnbWVudGVkJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NvbnRpbnVhdGlvbkZyYW1lKG9wY29kZSkgJiYgdGhpcy4jZnJhZ21lbnRzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy4jaW5mby5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1VuZXhwZWN0ZWQgY29udGludWF0aW9uIGZyYW1lJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXlsb2FkTGVuZ3RoIDw9IDEyNSkge1xuICAgICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9IHBheWxvYWRMZW5ndGhcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzE2XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF82NFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVGV4dEJpbmFyeUZyYW1lKG9wY29kZSkpIHtcbiAgICAgICAgICB0aGlzLiNpbmZvLmJpbmFyeVR5cGUgPSBvcGNvZGVcbiAgICAgICAgICB0aGlzLiNpbmZvLmNvbXByZXNzZWQgPSByc3YxICE9PSAwXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNpbmZvLm9wY29kZSA9IG9wY29kZVxuICAgICAgICB0aGlzLiNpbmZvLm1hc2tlZCA9IG1hc2tlZFxuICAgICAgICB0aGlzLiNpbmZvLmZpbiA9IGZpblxuICAgICAgICB0aGlzLiNpbmZvLmZyYWdtZW50ZWQgPSBmcmFnbWVudGVkXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF8xNikge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDIpXG5cbiAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MTZCRSgwKVxuICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzY0KSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgOCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoOClcbiAgICAgICAgY29uc3QgdXBwZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDApXG5cbiAgICAgICAgLy8gMl4zMSBpcyB0aGUgbWF4aW11bSBieXRlcyBhbiBhcnJheWJ1ZmZlciBjYW4gY29udGFpblxuICAgICAgICAvLyBvbiAzMi1iaXQgc3lzdGVtcy4gQWx0aG91Z2gsIG9uIDY0LWJpdCBzeXN0ZW1zLCB0aGlzIGlzXG4gICAgICAgIC8vIDJeNTMtMSBieXRlcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0ludmFsaWRfYXJyYXlfbGVuZ3RoXG4gICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnY4L3NyYy9jb21tb24vZ2xvYmFscy5oO2RyYz0xOTQ2MjEyYWMwMTAwNjY4ZjE0ZWI5ZTI4NDNiZGQ4NDZlNTEwYTFlO2Jwdj0xO2JwdD0xO2w9MTI3NVxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp2OC9zcmMvb2JqZWN0cy9qcy1hcnJheS1idWZmZXIuaDtsPTM0O2RyYz0xOTQ2MjEyYWMwMTAwNjY4ZjE0ZWI5ZTI4NDNiZGQ4NDZlNTEwYTFlXG4gICAgICAgIGlmICh1cHBlciA+IDIgKiogMzEgLSAxKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1JlY2VpdmVkIHBheWxvYWQgbGVuZ3RoID4gMl4zMSBieXRlcy4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDQpXG5cbiAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gKHVwcGVyIDw8IDgpICsgbG93ZXJcbiAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBKSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmNvbnN1bWUodGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKVxuXG4gICAgICAgIGlmIChpc0NvbnRyb2xGcmFtZSh0aGlzLiNpbmZvLm9wY29kZSkpIHtcbiAgICAgICAgICB0aGlzLiNsb29wID0gdGhpcy5wYXJzZUNvbnRyb2xGcmFtZShib2R5KVxuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2luZm8uY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgdGhpcy4jZnJhZ21lbnRzLnB1c2goYm9keSlcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGZyYW1lIGlzIG5vdCBmcmFnbWVudGVkLCBhIG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnJhbWUgaXMgZnJhZ21lbnRlZCwgaXQgd2lsbCB0ZXJtaW5hdGUgd2l0aCBhIGZpbiBiaXQgc2V0XG4gICAgICAgICAgICAvLyBhbmQgYW4gb3Bjb2RlIG9mIDAgKGNvbnRpbnVhdGlvbiksIHRoZXJlZm9yZSB3ZSBoYW5kbGUgdGhhdCB3aGVuXG4gICAgICAgICAgICAvLyBwYXJzaW5nIGNvbnRpbnVhdGlvbiBmcmFtZXMsIG5vdCBoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLiNpbmZvLmZyYWdtZW50ZWQgJiYgdGhpcy4jaW5mby5maW4pIHtcbiAgICAgICAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KHRoaXMuI2ZyYWdtZW50cylcbiAgICAgICAgICAgICAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkKHRoaXMud3MsIHRoaXMuI2luZm8uYmluYXJ5VHlwZSwgZnVsbE1lc3NhZ2UpXG4gICAgICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZXh0ZW5zaW9ucy5nZXQoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpLmRlY29tcHJlc3MoYm9keSwgdGhpcy4jaW5mby5maW4sIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcy53cywgMTAwNywgZXJyb3IubWVzc2FnZSwgZXJyb3IubWVzc2FnZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLiNmcmFnbWVudHMucHVzaChkYXRhKVxuXG4gICAgICAgICAgICAgIGlmICghdGhpcy4jaW5mby5maW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgICAgICAgICAgdGhpcy4jbG9vcCA9IHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCh0aGlzLndzLCB0aGlzLiNpbmZvLmJpbmFyeVR5cGUsIEJ1ZmZlci5jb25jYXQodGhpcy4jZnJhZ21lbnRzKSlcblxuICAgICAgICAgICAgICB0aGlzLiNsb29wID0gdHJ1ZVxuICAgICAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgIHRoaXMucnVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGhpcy4jbG9vcCA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIG4gYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgQnVmZmVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKi9cbiAgY29uc3VtZSAobikge1xuICAgIGlmIChuID4gdGhpcy4jYnl0ZU9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsZWQgY29uc3VtZSgpIGJlZm9yZSBidWZmZXJzIHNhdGlhdGVkLicpXG4gICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHlCdWZmZXJcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jYnVmZmVyc1swXS5sZW5ndGggPT09IG4pIHtcbiAgICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gdGhpcy4jYnVmZmVyc1swXS5sZW5ndGhcbiAgICAgIHJldHVybiB0aGlzLiNidWZmZXJzLnNoaWZ0KClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgd2hpbGUgKG9mZnNldCAhPT0gbikge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMuI2J1ZmZlcnNbMF1cbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBuZXh0XG5cbiAgICAgIGlmIChsZW5ndGggKyBvZmZzZXQgPT09IG4pIHtcbiAgICAgICAgYnVmZmVyLnNldCh0aGlzLiNidWZmZXJzLnNoaWZ0KCksIG9mZnNldClcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gbikge1xuICAgICAgICBidWZmZXIuc2V0KG5leHQuc3ViYXJyYXkoMCwgbiAtIG9mZnNldCksIG9mZnNldClcbiAgICAgICAgdGhpcy4jYnVmZmVyc1swXSA9IG5leHQuc3ViYXJyYXkobiAtIG9mZnNldClcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5zZXQodGhpcy4jYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBuZXh0Lmxlbmd0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gblxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgcGFyc2VDbG9zZUJvZHkgKGRhdGEpIHtcbiAgICBhc3NlcnQoZGF0YS5sZW5ndGggIT09IDEpXG5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgY29kZVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDIpIHtcbiAgICAgIC8vIF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gQ2xvc2UgQ29kZV8gaXNcbiAgICAgIC8vIGRlZmluZWQgYXMgdGhlIHN0YXR1cyBjb2RlIChTZWN0aW9uIDcuNCkgY29udGFpbmVkIGluIHRoZSBmaXJzdCBDbG9zZVxuICAgICAgLy8gY29udHJvbCBmcmFtZSByZWNlaXZlZCBieSB0aGUgYXBwbGljYXRpb25cbiAgICAgIGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKVxuICAgIH1cblxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4geyBjb2RlOiAxMDAyLCByZWFzb246ICdJbnZhbGlkIHN0YXR1cyBjb2RlJywgZXJyb3I6IHRydWUgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS42XG4gICAgLyoqIEB0eXBlIHtCdWZmZXJ9ICovXG4gICAgbGV0IHJlYXNvbiA9IGRhdGEuc3ViYXJyYXkoMilcblxuICAgIC8vIFJlbW92ZSBCT01cbiAgICBpZiAocmVhc29uWzBdID09PSAweEVGICYmIHJlYXNvblsxXSA9PT0gMHhCQiAmJiByZWFzb25bMl0gPT09IDB4QkYpIHtcbiAgICAgIHJlYXNvbiA9IHJlYXNvbi5zdWJhcnJheSgzKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZWFzb24gPSB1dGY4RGVjb2RlKHJlYXNvbilcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB7IGNvZGU6IDEwMDcsIHJlYXNvbjogJ0ludmFsaWQgVVRGLTgnLCBlcnJvcjogdHJ1ZSB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29kZSwgcmVhc29uLCBlcnJvcjogZmFsc2UgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBjb250cm9sIGZyYW1lcy5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJvZHlcbiAgICovXG4gIHBhcnNlQ29udHJvbEZyYW1lIChib2R5KSB7XG4gICAgY29uc3QgeyBvcGNvZGUsIHBheWxvYWRMZW5ndGggfSA9IHRoaXMuI2luZm9cblxuICAgIGlmIChvcGNvZGUgPT09IG9wY29kZXMuQ0xPU0UpIHtcbiAgICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdSZWNlaXZlZCBjbG9zZSBmcmFtZSB3aXRoIGEgMS1ieXRlIGJvZHkuJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2luZm8uY2xvc2VJbmZvID0gdGhpcy5wYXJzZUNsb3NlQm9keShib2R5KVxuXG4gICAgICBpZiAodGhpcy4jaW5mby5jbG9zZUluZm8uZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBjb2RlLCByZWFzb24gfSA9IHRoaXMuI2luZm8uY2xvc2VJbmZvXG5cbiAgICAgICAgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsIGNvZGUsIHJlYXNvbiwgcmVhc29uLmxlbmd0aClcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgcmVhc29uKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud3Nba1NlbnRDbG9zZV0gIT09IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCkge1xuICAgICAgICAvLyBJZiBhbiBlbmRwb2ludCByZWNlaXZlcyBhIENsb3NlIGZyYW1lIGFuZCBkaWQgbm90IHByZXZpb3VzbHkgc2VuZCBhXG4gICAgICAgIC8vIENsb3NlIGZyYW1lLCB0aGUgZW5kcG9pbnQgTVVTVCBzZW5kIGEgQ2xvc2UgZnJhbWUgaW4gcmVzcG9uc2UuICAoV2hlblxuICAgICAgICAvLyBzZW5kaW5nIGEgQ2xvc2UgZnJhbWUgaW4gcmVzcG9uc2UsIHRoZSBlbmRwb2ludCB0eXBpY2FsbHkgZWNob3MgdGhlXG4gICAgICAgIC8vIHN0YXR1cyBjb2RlIGl0IHJlY2VpdmVkLilcbiAgICAgICAgbGV0IGJvZHkgPSBlbXB0eUJ1ZmZlclxuICAgICAgICBpZiAodGhpcy4jaW5mby5jbG9zZUluZm8uY29kZSkge1xuICAgICAgICAgIGJvZHkgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMilcbiAgICAgICAgICBib2R5LndyaXRlVUludDE2QkUodGhpcy4jaW5mby5jbG9zZUluZm8uY29kZSwgMClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9zZUZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChib2R5KVxuXG4gICAgICAgIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQud3JpdGUoXG4gICAgICAgICAgY2xvc2VGcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkNMT1NFKSxcbiAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICB0aGlzLndzW2tTZW50Q2xvc2VdID0gc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAgICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDTE9TSU5HIHN0YXRlLlxuICAgICAgdGhpcy53c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICAgICAgdGhpcy53c1trUmVjZWl2ZWRDbG9zZV0gPSB0cnVlXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAob3Bjb2RlID09PSBvcGNvZGVzLlBJTkcpIHtcbiAgICAgIC8vIFVwb24gcmVjZWlwdCBvZiBhIFBpbmcgZnJhbWUsIGFuIGVuZHBvaW50IE1VU1Qgc2VuZCBhIFBvbmcgZnJhbWUgaW5cbiAgICAgIC8vIHJlc3BvbnNlLCB1bmxlc3MgaXQgYWxyZWFkeSByZWNlaXZlZCBhIENsb3NlIGZyYW1lLlxuICAgICAgLy8gQSBQb25nIGZyYW1lIHNlbnQgaW4gcmVzcG9uc2UgdG8gYSBQaW5nIGZyYW1lIG11c3QgaGF2ZSBpZGVudGljYWxcbiAgICAgIC8vIFwiQXBwbGljYXRpb24gZGF0YVwiXG5cbiAgICAgIGlmICghdGhpcy53c1trUmVjZWl2ZWRDbG9zZV0pIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGJvZHkpXG5cbiAgICAgICAgdGhpcy53c1trUmVzcG9uc2VdLnNvY2tldC53cml0ZShmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLlBPTkcpKVxuXG4gICAgICAgIGlmIChjaGFubmVscy5waW5nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgY2hhbm5lbHMucGluZy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGJvZHlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcGNvZGUgPT09IG9wY29kZXMuUE9ORykge1xuICAgICAgLy8gQSBQb25nIGZyYW1lIE1BWSBiZSBzZW50IHVuc29saWNpdGVkLiAgVGhpcyBzZXJ2ZXMgYXMgYVxuICAgICAgLy8gdW5pZGlyZWN0aW9uYWwgaGVhcnRiZWF0LiAgQSByZXNwb25zZSB0byBhbiB1bnNvbGljaXRlZCBQb25nIGZyYW1lIGlzXG4gICAgICAvLyBub3QgZXhwZWN0ZWQuXG5cbiAgICAgIGlmIChjaGFubmVscy5wb25nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIGNoYW5uZWxzLnBvbmcucHVibGlzaCh7XG4gICAgICAgICAgcGF5bG9hZDogYm9keVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBnZXQgY2xvc2luZ0luZm8gKCkge1xuICAgIHJldHVybiB0aGlzLiNpbmZvLmNsb3NlSW5mb1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCeXRlUGFyc2VyXG59XG4iXSwibmFtZXMiOlsiV3JpdGFibGUiLCJyZXF1aXJlIiwiYXNzZXJ0IiwicGFyc2VyU3RhdGVzIiwib3Bjb2RlcyIsInN0YXRlcyIsImVtcHR5QnVmZmVyIiwic2VudENsb3NlRnJhbWVTdGF0ZSIsImtSZWFkeVN0YXRlIiwia1NlbnRDbG9zZSIsImtSZXNwb25zZSIsImtSZWNlaXZlZENsb3NlIiwiY2hhbm5lbHMiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsImlzVmFsaWRPcGNvZGUiLCJmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiIsIndlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCIsInV0ZjhEZWNvZGUiLCJpc0NvbnRyb2xGcmFtZSIsImlzVGV4dEJpbmFyeUZyYW1lIiwiaXNDb250aW51YXRpb25GcmFtZSIsIldlYnNvY2tldEZyYW1lU2VuZCIsImNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbiIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiQnl0ZVBhcnNlciIsIndzIiwiZXh0ZW5zaW9ucyIsIklORk8iLCJNYXAiLCJoYXMiLCJzZXQiLCJfd3JpdGUiLCJjaHVuayIsIl8iLCJjYWxsYmFjayIsInB1c2giLCJsZW5ndGgiLCJydW4iLCJidWZmZXIiLCJjb25zdW1lIiwiZmluIiwib3Bjb2RlIiwibWFza2VkIiwiZnJhZ21lbnRlZCIsIkNPTlRJTlVBVElPTiIsInBheWxvYWRMZW5ndGgiLCJyc3YxIiwicnN2MiIsInJzdjMiLCJjb21wcmVzc2VkIiwiUkVBRF9EQVRBIiwiUEFZTE9BRExFTkdUSF8xNiIsIlBBWUxPQURMRU5HVEhfNjQiLCJiaW5hcnlUeXBlIiwicmVhZFVJbnQxNkJFIiwidXBwZXIiLCJyZWFkVUludDMyQkUiLCJsb3dlciIsImJvZHkiLCJwYXJzZUNvbnRyb2xGcmFtZSIsImZ1bGxNZXNzYWdlIiwiQnVmZmVyIiwiY29uY2F0IiwiZ2V0IiwiZGVjb21wcmVzcyIsImVycm9yIiwiZGF0YSIsIm1lc3NhZ2UiLCJuIiwiRXJyb3IiLCJzaGlmdCIsImFsbG9jVW5zYWZlIiwib2Zmc2V0IiwibmV4dCIsInN1YmFycmF5IiwicGFyc2VDbG9zZUJvZHkiLCJjb2RlIiwidW5kZWZpbmVkIiwicmVhc29uIiwiQ0xPU0UiLCJjbG9zZUluZm8iLCJTRU5UIiwid3JpdGVVSW50MTZCRSIsImNsb3NlRnJhbWUiLCJzb2NrZXQiLCJ3cml0ZSIsImNyZWF0ZUZyYW1lIiwiZXJyIiwiQ0xPU0lORyIsIlBJTkciLCJmcmFtZSIsIlBPTkciLCJwaW5nIiwiaGFzU3Vic2NyaWJlcnMiLCJwdWJsaXNoIiwicGF5bG9hZCIsInBvbmciLCJjbG9zaW5nSW5mbyIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/sender.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/sender.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\");\nconst { opcodes, sendHints } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst FixedQueue = __webpack_require__(/*! ../../dispatcher/fixed-queue */ \"(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\");\n/** @type {typeof Uint8Array} */ const FastBuffer = Buffer[Symbol.species];\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */ class SendQueue {\n    /**\n   * @type {FixedQueue}\n   */ #queue;\n    /**\n   * @type {boolean}\n   */ #running;\n    /** @type {import('node:net').Socket} */ #socket;\n    constructor(socket){\n        this.#queue = new FixedQueue();\n        this.#running = false;\n        this.#socket = socket;\n    }\n    add(item, cb, hint) {\n        if (hint !== sendHints.blob) {\n            const frame = createFrame(item, hint);\n            if (!this.#running) {\n                // fast-path\n                this.#socket.write(frame, cb);\n            } else {\n                /** @type {SendQueueNode} */ const node = {\n                    promise: null,\n                    callback: cb,\n                    frame\n                };\n                this.#queue.push(node);\n            }\n            return;\n        }\n        /** @type {SendQueueNode} */ const node = {\n            promise: item.arrayBuffer().then((ab)=>{\n                node.promise = null;\n                node.frame = createFrame(ab, hint);\n            }),\n            callback: cb,\n            frame: null\n        };\n        this.#queue.push(node);\n        if (!this.#running) {\n            this.#run();\n        }\n    }\n    async #run() {\n        this.#running = true;\n        const queue = this.#queue;\n        while(!queue.isEmpty()){\n            const node = queue.shift();\n            // wait pending promise\n            if (node.promise !== null) {\n                await node.promise;\n            }\n            // write\n            this.#socket.write(node.frame, node.callback);\n            // cleanup\n            node.callback = node.frame = null;\n        }\n        this.#running = false;\n    }\n}\nfunction createFrame(data, hint) {\n    return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);\n}\nfunction toBuffer(data, hint) {\n    switch(hint){\n        case sendHints.string:\n            return Buffer.from(data);\n        case sendHints.arrayBuffer:\n        case sendHints.blob:\n            return new FastBuffer(data);\n        case sendHints.typedArray:\n            return new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n    }\n}\nmodule.exports = {\n    SendQueue\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsa0JBQWtCLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsdUVBQVM7QUFDaEQsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFNBQVMsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQywrRUFBYTtBQUNwRCxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQywrRkFBOEI7QUFFekQsOEJBQThCLEdBQzlCLE1BQU1JLGFBQWFDLE1BQU0sQ0FBQ0MsT0FBT0MsT0FBTyxDQUFDO0FBRXpDOzs7OztDQUtDLEdBRUQsTUFBTUM7SUFDSjs7R0FFQyxHQUNELE1BQU0sQ0FBbUI7SUFFekI7O0dBRUMsR0FDRCxRQUFRLENBQVE7SUFFaEIsc0NBQXNDLEdBQ3RDLE9BQU87SUFFUCxZQUFhQyxNQUFNLENBQUU7YUFWckIsTUFBTSxHQUFHLElBQUlOO2FBS2IsUUFBUSxHQUFHO1FBTVQsSUFBSSxDQUFDLE9BQU8sR0FBR007SUFDakI7SUFFQUMsSUFBS0MsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLElBQUksRUFBRTtRQUNuQixJQUFJQSxTQUFTWCxVQUFVWSxJQUFJLEVBQUU7WUFDM0IsTUFBTUMsUUFBUUMsWUFBWUwsTUFBTUU7WUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2xCLFlBQVk7Z0JBQ1osSUFBSSxDQUFDLE9BQU8sQ0FBQ0ksS0FBSyxDQUFDRixPQUFPSDtZQUM1QixPQUFPO2dCQUNMLDBCQUEwQixHQUMxQixNQUFNTSxPQUFPO29CQUNYQyxTQUFTO29CQUNUQyxVQUFVUjtvQkFDVkc7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDLE1BQU0sQ0FBQ00sSUFBSSxDQUFDSDtZQUNuQjtZQUNBO1FBQ0Y7UUFFQSwwQkFBMEIsR0FDMUIsTUFBTUEsT0FBTztZQUNYQyxTQUFTUixLQUFLVyxXQUFXLEdBQUdDLElBQUksQ0FBQyxDQUFDQztnQkFDaENOLEtBQUtDLE9BQU8sR0FBRztnQkFDZkQsS0FBS0gsS0FBSyxHQUFHQyxZQUFZUSxJQUFJWDtZQUMvQjtZQUNBTyxVQUFVUjtZQUNWRyxPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUMsTUFBTSxDQUFDTSxJQUFJLENBQUNIO1FBRWpCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2xCLElBQUksQ0FBQyxJQUFJO1FBQ1g7SUFDRjtJQUVBLE1BQU0sSUFBSTtRQUNSLElBQUksQ0FBQyxRQUFRLEdBQUc7UUFDaEIsTUFBTU8sUUFBUSxJQUFJLENBQUMsTUFBTTtRQUN6QixNQUFPLENBQUNBLE1BQU1DLE9BQU8sR0FBSTtZQUN2QixNQUFNUixPQUFPTyxNQUFNRSxLQUFLO1lBQ3hCLHVCQUF1QjtZQUN2QixJQUFJVCxLQUFLQyxPQUFPLEtBQUssTUFBTTtnQkFDekIsTUFBTUQsS0FBS0MsT0FBTztZQUNwQjtZQUNBLFFBQVE7WUFDUixJQUFJLENBQUMsT0FBTyxDQUFDRixLQUFLLENBQUNDLEtBQUtILEtBQUssRUFBRUcsS0FBS0UsUUFBUTtZQUM1QyxVQUFVO1lBQ1ZGLEtBQUtFLFFBQVEsR0FBR0YsS0FBS0gsS0FBSyxHQUFHO1FBQy9CO1FBQ0EsSUFBSSxDQUFDLFFBQVEsR0FBRztJQUNsQjtBQUNGO0FBRUEsU0FBU0MsWUFBYVksSUFBSSxFQUFFZixJQUFJO0lBQzlCLE9BQU8sSUFBSWQsbUJBQW1COEIsU0FBU0QsTUFBTWYsT0FBT0csV0FBVyxDQUFDSCxTQUFTWCxVQUFVNEIsTUFBTSxHQUFHN0IsUUFBUThCLElBQUksR0FBRzlCLFFBQVErQixNQUFNO0FBQzNIO0FBRUEsU0FBU0gsU0FBVUQsSUFBSSxFQUFFZixJQUFJO0lBQzNCLE9BQVFBO1FBQ04sS0FBS1gsVUFBVTRCLE1BQU07WUFDbkIsT0FBT3pCLE9BQU80QixJQUFJLENBQUNMO1FBQ3JCLEtBQUsxQixVQUFVb0IsV0FBVztRQUMxQixLQUFLcEIsVUFBVVksSUFBSTtZQUNqQixPQUFPLElBQUlWLFdBQVd3QjtRQUN4QixLQUFLMUIsVUFBVWdDLFVBQVU7WUFDdkIsT0FBTyxJQUFJOUIsV0FBV3dCLEtBQUtPLE1BQU0sRUFBRVAsS0FBS1EsVUFBVSxFQUFFUixLQUFLUyxVQUFVO0lBQ3ZFO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQUUvQjtBQUFVIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFxzZW5kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcbmNvbnN0IHsgb3Bjb2Rlcywgc2VuZEhpbnRzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBGaXhlZFF1ZXVlID0gcmVxdWlyZSgnLi4vLi4vZGlzcGF0Y2hlci9maXhlZC1xdWV1ZScpXG5cbi8qKiBAdHlwZSB7dHlwZW9mIFVpbnQ4QXJyYXl9ICovXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlbmRRdWV1ZU5vZGVcbiAqIEBwcm9wZXJ0eSB7UHJvbWlzZTx2b2lkPiB8IG51bGx9IHByb21pc2VcbiAqIEBwcm9wZXJ0eSB7KCguLi5hcmdzOiBhbnlbXSkgPT4gYW55KX0gY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7QnVmZmVyIHwgbnVsbH0gZnJhbWVcbiAqL1xuXG5jbGFzcyBTZW5kUXVldWUge1xuICAvKipcbiAgICogQHR5cGUge0ZpeGVkUXVldWV9XG4gICAqL1xuICAjcXVldWUgPSBuZXcgRml4ZWRRdWV1ZSgpXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgI3J1bm5pbmcgPSBmYWxzZVxuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdub2RlOm5ldCcpLlNvY2tldH0gKi9cbiAgI3NvY2tldFxuXG4gIGNvbnN0cnVjdG9yIChzb2NrZXQpIHtcbiAgICB0aGlzLiNzb2NrZXQgPSBzb2NrZXRcbiAgfVxuXG4gIGFkZCAoaXRlbSwgY2IsIGhpbnQpIHtcbiAgICBpZiAoaGludCAhPT0gc2VuZEhpbnRzLmJsb2IpIHtcbiAgICAgIGNvbnN0IGZyYW1lID0gY3JlYXRlRnJhbWUoaXRlbSwgaGludClcbiAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAvLyBmYXN0LXBhdGhcbiAgICAgICAgdGhpcy4jc29ja2V0LndyaXRlKGZyYW1lLCBjYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKiBAdHlwZSB7U2VuZFF1ZXVlTm9kZX0gKi9cbiAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICBwcm9taXNlOiBudWxsLFxuICAgICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgICBmcmFtZVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3F1ZXVlLnB1c2gobm9kZSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7U2VuZFF1ZXVlTm9kZX0gKi9cbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgcHJvbWlzZTogaXRlbS5hcnJheUJ1ZmZlcigpLnRoZW4oKGFiKSA9PiB7XG4gICAgICAgIG5vZGUucHJvbWlzZSA9IG51bGxcbiAgICAgICAgbm9kZS5mcmFtZSA9IGNyZWF0ZUZyYW1lKGFiLCBoaW50KVxuICAgICAgfSksXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBmcmFtZTogbnVsbFxuICAgIH1cblxuICAgIHRoaXMuI3F1ZXVlLnB1c2gobm9kZSlcblxuICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgdGhpcy4jcnVuKClcbiAgICB9XG4gIH1cblxuICBhc3luYyAjcnVuICgpIHtcbiAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZVxuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy4jcXVldWVcbiAgICB3aGlsZSAoIXF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHF1ZXVlLnNoaWZ0KClcbiAgICAgIC8vIHdhaXQgcGVuZGluZyBwcm9taXNlXG4gICAgICBpZiAobm9kZS5wcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IG5vZGUucHJvbWlzZVxuICAgICAgfVxuICAgICAgLy8gd3JpdGVcbiAgICAgIHRoaXMuI3NvY2tldC53cml0ZShub2RlLmZyYW1lLCBub2RlLmNhbGxiYWNrKVxuICAgICAgLy8gY2xlYW51cFxuICAgICAgbm9kZS5jYWxsYmFjayA9IG5vZGUuZnJhbWUgPSBudWxsXG4gICAgfVxuICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYW1lIChkYXRhLCBoaW50KSB7XG4gIHJldHVybiBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKHRvQnVmZmVyKGRhdGEsIGhpbnQpKS5jcmVhdGVGcmFtZShoaW50ID09PSBzZW5kSGludHMuc3RyaW5nID8gb3Bjb2Rlcy5URVhUIDogb3Bjb2Rlcy5CSU5BUlkpXG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyIChkYXRhLCBoaW50KSB7XG4gIHN3aXRjaCAoaGludCkge1xuICAgIGNhc2Ugc2VuZEhpbnRzLnN0cmluZzpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKVxuICAgIGNhc2Ugc2VuZEhpbnRzLmFycmF5QnVmZmVyOlxuICAgIGNhc2Ugc2VuZEhpbnRzLmJsb2I6XG4gICAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoZGF0YSlcbiAgICBjYXNlIHNlbmRIaW50cy50eXBlZEFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgU2VuZFF1ZXVlIH1cbiJdLCJuYW1lcyI6WyJXZWJzb2NrZXRGcmFtZVNlbmQiLCJyZXF1aXJlIiwib3Bjb2RlcyIsInNlbmRIaW50cyIsIkZpeGVkUXVldWUiLCJGYXN0QnVmZmVyIiwiQnVmZmVyIiwiU3ltYm9sIiwic3BlY2llcyIsIlNlbmRRdWV1ZSIsInNvY2tldCIsImFkZCIsIml0ZW0iLCJjYiIsImhpbnQiLCJibG9iIiwiZnJhbWUiLCJjcmVhdGVGcmFtZSIsIndyaXRlIiwibm9kZSIsInByb21pc2UiLCJjYWxsYmFjayIsInB1c2giLCJhcnJheUJ1ZmZlciIsInRoZW4iLCJhYiIsInF1ZXVlIiwiaXNFbXB0eSIsInNoaWZ0IiwiZGF0YSIsInRvQnVmZmVyIiwic3RyaW5nIiwiVEVYVCIsIkJJTkFSWSIsImZyb20iLCJ0eXBlZEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/sender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/symbols.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/symbols.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kWebSocketURL: Symbol('url'),\n    kReadyState: Symbol('ready state'),\n    kController: Symbol('controller'),\n    kResponse: Symbol('response'),\n    kBinaryType: Symbol('binary type'),\n    kSentClose: Symbol('sent close'),\n    kReceivedClose: Symbol('received close'),\n    kByteParser: Symbol('byte parser')\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLGVBQWVDLE9BQU87SUFDdEJDLGFBQWFELE9BQU87SUFDcEJFLGFBQWFGLE9BQU87SUFDcEJHLFdBQVdILE9BQU87SUFDbEJJLGFBQWFKLE9BQU87SUFDcEJLLFlBQVlMLE9BQU87SUFDbkJNLGdCQUFnQk4sT0FBTztJQUN2Qk8sYUFBYVAsT0FBTztBQUN0QiIsInNvdXJjZXMiOlsiRDpcXEhlbGl4XFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtXZWJTb2NrZXRVUkw6IFN5bWJvbCgndXJsJyksXG4gIGtSZWFkeVN0YXRlOiBTeW1ib2woJ3JlYWR5IHN0YXRlJyksXG4gIGtDb250cm9sbGVyOiBTeW1ib2woJ2NvbnRyb2xsZXInKSxcbiAga1Jlc3BvbnNlOiBTeW1ib2woJ3Jlc3BvbnNlJyksXG4gIGtCaW5hcnlUeXBlOiBTeW1ib2woJ2JpbmFyeSB0eXBlJyksXG4gIGtTZW50Q2xvc2U6IFN5bWJvbCgnc2VudCBjbG9zZScpLFxuICBrUmVjZWl2ZWRDbG9zZTogU3ltYm9sKCdyZWNlaXZlZCBjbG9zZScpLFxuICBrQnl0ZVBhcnNlcjogU3ltYm9sKCdieXRlIHBhcnNlcicpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtXZWJTb2NrZXRVUkwiLCJTeW1ib2wiLCJrUmVhZHlTdGF0ZSIsImtDb250cm9sbGVyIiwia1Jlc3BvbnNlIiwia0JpbmFyeVR5cGUiLCJrU2VudENsb3NlIiwia1JlY2VpdmVkQ2xvc2UiLCJrQnl0ZVBhcnNlciJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\");\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst { ErrorEvent, createFastMessageEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nconst { isUtf8 } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\n/* globals Blob */ /**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */ function isConnecting(ws) {\n    // If the WebSocket connection is not yet established, and the connection\n    // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n    return ws[kReadyState] === states.CONNECTING;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */ function isEstablished(ws) {\n    // If the server's response is validated as provided for above, it is\n    // said that _The WebSocket Connection is Established_ and that the\n    // WebSocket Connection is in the OPEN state.\n    return ws[kReadyState] === states.OPEN;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */ function isClosing(ws) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    return ws[kReadyState] === states.CLOSING;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */ function isClosed(ws) {\n    return ws[kReadyState] === states.CLOSED;\n}\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n */ function fireEvent(e, target, eventFactory = (type, init)=>new Event(type, init), eventInitDict = {}) {\n    // 1. If eventConstructor is not given, then let eventConstructor be Event.\n    // 2. Let event be the result of creating an event given eventConstructor,\n    //    in the relevant realm of target.\n    // 3. Initialize event’s type attribute to e.\n    const event = eventFactory(e, eventInitDict);\n    // 4. Initialize any other IDL attributes of event as described in the\n    //    invocation of this algorithm.\n    // 5. Return the result of dispatching event at target, with legacy target\n    //    override flag set if set.\n    target.dispatchEvent(event);\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */ function websocketMessageReceived(ws, type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (ws[kReadyState] !== states.OPEN) {\n        return;\n    }\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent;\n    if (type === opcodes.TEXT) {\n        // -> type indicates that the data is Text\n        //      a new DOMString containing data\n        try {\n            dataForEvent = utf8Decode(data);\n        } catch  {\n            failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');\n            return;\n        }\n    } else if (type === opcodes.BINARY) {\n        if (ws[kBinaryType] === 'blob') {\n            // -> type indicates that the data is Binary and binary type is \"blob\"\n            //      a new Blob object, created in the relevant Realm of the WebSocket\n            //      object, that represents data as its raw data\n            dataForEvent = new Blob([\n                data\n            ]);\n        } else {\n            // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n            //      a new ArrayBuffer object, created in the relevant Realm of the\n            //      WebSocket object, whose contents are data\n            dataForEvent = toArrayBuffer(data);\n        }\n    }\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    object’s url's origin, and the data attribute initialized to dataForEvent.\n    fireEvent('message', ws, createFastMessageEvent, {\n        origin: ws[kWebSocketURL].origin,\n        data: dataForEvent\n    });\n}\nfunction toArrayBuffer(buffer) {\n    if (buffer.byteLength === buffer.buffer.byteLength) {\n        return buffer.buffer;\n    }\n    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */ function isValidSubprotocol(protocol) {\n    // If present, this value indicates one\n    // or more comma-separated subprotocol the client wishes to speak,\n    // ordered by preference.  The elements that comprise this value\n    // MUST be non-empty strings with characters in the range U+0021 to\n    // U+007E not including separator characters as defined in\n    // [RFC2616] and MUST all be unique strings.\n    if (protocol.length === 0) {\n        return false;\n    }\n    for(let i = 0; i < protocol.length; ++i){\n        const code = protocol.charCodeAt(i);\n        if (code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n        code > 0x7E || code === 0x22 || // \"\n        code === 0x28 || // (\n        code === 0x29 || // )\n        code === 0x2C || // ,\n        code === 0x2F || // /\n        code === 0x3A || // :\n        code === 0x3B || // ;\n        code === 0x3C || // <\n        code === 0x3D || // =\n        code === 0x3E || // >\n        code === 0x3F || // ?\n        code === 0x40 || // @\n        code === 0x5B || // [\n        code === 0x5C || // \\\n        code === 0x5D || // ]\n        code === 0x7B || // {\n        code === 0x7D // }\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */ function isValidStatusCode(code) {\n    if (code >= 1000 && code < 1015) {\n        return code !== 1004 && // reserved\n        code !== 1005 && // \"MUST NOT be set as a status code\"\n        code !== 1006 // \"MUST NOT be set as a status code\"\n        ;\n    }\n    return code >= 3000 && code <= 4999;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */ function failWebsocketConnection(ws, reason) {\n    const { [kController]: controller, [kResponse]: response } = ws;\n    controller.abort();\n    if (response?.socket && !response.socket.destroyed) {\n        response.socket.destroy();\n    }\n    if (reason) {\n        // TODO: process.nextTick\n        fireEvent('error', ws, (type, init)=>new ErrorEvent(type, init), {\n            error: new Error(reason),\n            message: reason\n        });\n    }\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n */ function isControlFrame(opcode) {\n    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;\n}\nfunction isContinuationFrame(opcode) {\n    return opcode === opcodes.CONTINUATION;\n}\nfunction isTextBinaryFrame(opcode) {\n    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;\n}\nfunction isValidOpcode(opcode) {\n    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);\n}\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */ // TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions(extensions) {\n    const position = {\n        position: 0\n    };\n    const extensionList = new Map();\n    while(position.position < extensions.length){\n        const pair = collectASequenceOfCodePointsFast(';', extensions, position);\n        const [name, value = ''] = pair.split('=');\n        extensionList.set(removeHTTPWhitespace(name, true, false), removeHTTPWhitespace(value, false, true));\n        position.position++;\n    }\n    return extensionList;\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n */ function isValidClientWindowBits(value) {\n    for(let i = 0; i < value.length; i++){\n        const byte = value.charCodeAt(i);\n        if (byte < 0x30 || byte > 0x39) {\n            return false;\n        }\n    }\n    return true;\n}\n// https://nodejs.org/api/intl.html#detecting-internationalization-support\nconst hasIntl = typeof process.versions.icu === 'string';\nconst fatalDecoder = hasIntl ? new TextDecoder('utf-8', {\n    fatal: true\n}) : undefined;\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @param {Buffer} buffer\n */ const utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {\n    if (isUtf8(buffer)) {\n        return buffer.toString('utf-8');\n    }\n    throw new TypeError('Invalid utf-8 received.');\n};\nmodule.exports = {\n    isConnecting,\n    isEstablished,\n    isClosing,\n    isClosed,\n    fireEvent,\n    isValidSubprotocol,\n    isValidStatusCode,\n    failWebsocketConnection,\n    websocketMessageReceived,\n    utf8Decode,\n    isControlFrame,\n    isContinuationFrame,\n    isTextBinaryFrame,\n    isValidOpcode,\n    parseExtensions,\n    isValidClientWindowBits\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsYUFBYSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLDJFQUFXO0FBQy9GLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUMsK0VBQWE7QUFDakQsTUFBTSxFQUFFRyxVQUFVLEVBQUVDLHNCQUFzQixFQUFFLEdBQUdKLG1CQUFPQSxDQUFDLHlFQUFVO0FBQ2pFLE1BQU0sRUFBRUssTUFBTSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3hDLE1BQU0sRUFBRU0sZ0NBQWdDLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdQLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUU5RixnQkFBZ0IsR0FFaEI7OztDQUdDLEdBQ0QsU0FBU1EsYUFBY0MsRUFBRTtJQUN2Qix5RUFBeUU7SUFDekUsK0VBQStFO0lBQy9FLE9BQU9BLEVBQUUsQ0FBQ2QsWUFBWSxLQUFLTSxPQUFPUyxVQUFVO0FBQzlDO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0MsY0FBZUYsRUFBRTtJQUN4QixxRUFBcUU7SUFDckUsbUVBQW1FO0lBQ25FLDZDQUE2QztJQUM3QyxPQUFPQSxFQUFFLENBQUNkLFlBQVksS0FBS00sT0FBT1csSUFBSTtBQUN4QztBQUVBOzs7Q0FHQyxHQUNELFNBQVNDLFVBQVdKLEVBQUU7SUFDcEIscUVBQXFFO0lBQ3JFLGlFQUFpRTtJQUNqRSxnREFBZ0Q7SUFDaEQsT0FBT0EsRUFBRSxDQUFDZCxZQUFZLEtBQUtNLE9BQU9hLE9BQU87QUFDM0M7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxTQUFVTixFQUFFO0lBQ25CLE9BQU9BLEVBQUUsQ0FBQ2QsWUFBWSxLQUFLTSxPQUFPZSxNQUFNO0FBQzFDO0FBRUE7Ozs7OztD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O0lBQ3pCO0lBQ0EsTUFBTSxJQUFJQyxVQUFVO0FBQ3RCO0FBRUZDLE9BQU9DLE9BQU8sR0FBRztJQUNmcEY7SUFDQUc7SUFDQUU7SUFDQUU7SUFDQUU7SUFDQXdCO0lBQ0FNO0lBQ0FmO0lBQ0FMO0lBQ0FJO0lBQ0EyQjtJQUNBSztJQUNBRTtJQUNBQztJQUNBQztJQUNBVTtBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtSZWFkeVN0YXRlLCBrQ29udHJvbGxlciwga1Jlc3BvbnNlLCBrQmluYXJ5VHlwZSwga1dlYlNvY2tldFVSTCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgc3RhdGVzLCBvcGNvZGVzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IEVycm9yRXZlbnQsIGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgfSA9IHJlcXVpcmUoJy4vZXZlbnRzJylcbmNvbnN0IHsgaXNVdGY4IH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCB7IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0LCByZW1vdmVIVFRQV2hpdGVzcGFjZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuXG4vKiBnbG9iYWxzIEJsb2IgKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDb25uZWN0aW5nICh3cykge1xuICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgbm90IHlldCBlc3RhYmxpc2hlZCwgYW5kIHRoZSBjb25uZWN0aW9uXG4gIC8vIGlzIG5vdCB5ZXQgY2xvc2VkLCB0aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ09OTkVDVElORyBzdGF0ZS5cbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLkNPTk5FQ1RJTkdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFc3RhYmxpc2hlZCAod3MpIHtcbiAgLy8gSWYgdGhlIHNlcnZlcidzIHJlc3BvbnNlIGlzIHZhbGlkYXRlZCBhcyBwcm92aWRlZCBmb3IgYWJvdmUsIGl0IGlzXG4gIC8vIHNhaWQgdGhhdCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIEVzdGFibGlzaGVkXyBhbmQgdGhhdCB0aGVcbiAgLy8gV2ViU29ja2V0IENvbm5lY3Rpb24gaXMgaW4gdGhlIE9QRU4gc3RhdGUuXG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5PUEVOXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ2xvc2luZyAod3MpIHtcbiAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDTE9TSU5HIHN0YXRlLlxuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuQ0xPU0lOR1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Nsb3NlZCAod3MpIHtcbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLkNMT1NFRFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWV2ZW50LWZpcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7KC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgRXZlbnQ+KSA9PiBFdmVudH0gZXZlbnRGYWN0b3J5XG4gKiBAcGFyYW0ge0V2ZW50SW5pdCB8IHVuZGVmaW5lZH0gZXZlbnRJbml0RGljdFxuICovXG5mdW5jdGlvbiBmaXJlRXZlbnQgKGUsIHRhcmdldCwgZXZlbnRGYWN0b3J5ID0gKHR5cGUsIGluaXQpID0+IG5ldyBFdmVudCh0eXBlLCBpbml0KSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gIC8vIDEuIElmIGV2ZW50Q29uc3RydWN0b3IgaXMgbm90IGdpdmVuLCB0aGVuIGxldCBldmVudENvbnN0cnVjdG9yIGJlIEV2ZW50LlxuXG4gIC8vIDIuIExldCBldmVudCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGV2ZW50IGdpdmVuIGV2ZW50Q29uc3RydWN0b3IsXG4gIC8vICAgIGluIHRoZSByZWxldmFudCByZWFsbSBvZiB0YXJnZXQuXG4gIC8vIDMuIEluaXRpYWxpemUgZXZlbnTigJlzIHR5cGUgYXR0cmlidXRlIHRvIGUuXG4gIGNvbnN0IGV2ZW50ID0gZXZlbnRGYWN0b3J5KGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgLy8gNC4gSW5pdGlhbGl6ZSBhbnkgb3RoZXIgSURMIGF0dHJpYnV0ZXMgb2YgZXZlbnQgYXMgZGVzY3JpYmVkIGluIHRoZVxuICAvLyAgICBpbnZvY2F0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuXG4gIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGRpc3BhdGNoaW5nIGV2ZW50IGF0IHRhcmdldCwgd2l0aCBsZWdhY3kgdGFyZ2V0XG4gIC8vICAgIG92ZXJyaWRlIGZsYWcgc2V0IGlmIHNldC5cbiAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgT3Bjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBhcHBsaWNhdGlvbiBkYXRhXG4gKi9cbmZ1bmN0aW9uIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCAod3MsIHR5cGUsIGRhdGEpIHtcbiAgLy8gMS4gSWYgcmVhZHkgc3RhdGUgaXMgbm90IE9QRU4gKDEpLCB0aGVuIHJldHVybi5cbiAgaWYgKHdzW2tSZWFkeVN0YXRlXSAhPT0gc3RhdGVzLk9QRU4pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIExldCBkYXRhRm9yRXZlbnQgYmUgZGV0ZXJtaW5lZCBieSBzd2l0Y2hpbmcgb24gdHlwZSBhbmQgYmluYXJ5IHR5cGU6XG4gIGxldCBkYXRhRm9yRXZlbnRcblxuICBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5URVhUKSB7XG4gICAgLy8gLT4gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBUZXh0XG4gICAgLy8gICAgICBhIG5ldyBET01TdHJpbmcgY29udGFpbmluZyBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIGRhdGFGb3JFdmVudCA9IHV0ZjhEZWNvZGUoZGF0YSlcbiAgICB9IGNhdGNoIHtcbiAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUmVjZWl2ZWQgaW52YWxpZCBVVEYtOCBpbiB0ZXh0IGZyYW1lLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5CSU5BUlkpIHtcbiAgICBpZiAod3Nba0JpbmFyeVR5cGVdID09PSAnYmxvYicpIHtcbiAgICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgQmluYXJ5IGFuZCBiaW5hcnkgdHlwZSBpcyBcImJsb2JcIlxuICAgICAgLy8gICAgICBhIG5ldyBCbG9iIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgICBvYmplY3QsIHRoYXQgcmVwcmVzZW50cyBkYXRhIGFzIGl0cyByYXcgZGF0YVxuICAgICAgZGF0YUZvckV2ZW50ID0gbmV3IEJsb2IoW2RhdGFdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeSBhbmQgYmluYXJ5IHR5cGUgaXMgXCJhcnJheWJ1ZmZlclwiXG4gICAgICAvLyAgICAgIGEgbmV3IEFycmF5QnVmZmVyIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlXG4gICAgICAvLyAgICAgIFdlYlNvY2tldCBvYmplY3QsIHdob3NlIGNvbnRlbnRzIGFyZSBkYXRhXG4gICAgICBkYXRhRm9yRXZlbnQgPSB0b0FycmF5QnVmZmVyKGRhdGEpXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gRmlyZSBhbiBldmVudCBuYW1lZCBtZXNzYWdlIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LCB1c2luZyBNZXNzYWdlRXZlbnQsXG4gIC8vICAgIHdpdGggdGhlIG9yaWdpbiBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG8gdGhlIHNlcmlhbGl6YXRpb24gb2YgdGhlIFdlYlNvY2tldFxuICAvLyAgICBvYmplY3TigJlzIHVybCdzIG9yaWdpbiwgYW5kIHRoZSBkYXRhIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byBkYXRhRm9yRXZlbnQuXG4gIGZpcmVFdmVudCgnbWVzc2FnZScsIHdzLCBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50LCB7XG4gICAgb3JpZ2luOiB3c1trV2ViU29ja2V0VVJMXS5vcmlnaW4sXG4gICAgZGF0YTogZGF0YUZvckV2ZW50XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IGJ1ZmZlci5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWZmZXIuYnVmZmVyXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGgpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTVcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyNjE2XG4gKiBAc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM5ODQwN1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdWJwcm90b2NvbCAocHJvdG9jb2wpIHtcbiAgLy8gSWYgcHJlc2VudCwgdGhpcyB2YWx1ZSBpbmRpY2F0ZXMgb25lXG4gIC8vIG9yIG1vcmUgY29tbWEtc2VwYXJhdGVkIHN1YnByb3RvY29sIHRoZSBjbGllbnQgd2lzaGVzIHRvIHNwZWFrLFxuICAvLyBvcmRlcmVkIGJ5IHByZWZlcmVuY2UuICBUaGUgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGlzIHZhbHVlXG4gIC8vIE1VU1QgYmUgbm9uLWVtcHR5IHN0cmluZ3Mgd2l0aCBjaGFyYWN0ZXJzIGluIHRoZSByYW5nZSBVKzAwMjEgdG9cbiAgLy8gVSswMDdFIG5vdCBpbmNsdWRpbmcgc2VwYXJhdG9yIGNoYXJhY3RlcnMgYXMgZGVmaW5lZCBpblxuICAvLyBbUkZDMjYxNl0gYW5kIE1VU1QgYWxsIGJlIHVuaXF1ZSBzdHJpbmdzLlxuICBpZiAocHJvdG9jb2wubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3RvY29sLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHByb3RvY29sLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIxIHx8IC8vIENUTCwgY29udGFpbnMgU1AgKDB4MjApIGFuZCBIVCAoMHgwOSlcbiAgICAgIGNvZGUgPiAweDdFIHx8XG4gICAgICBjb2RlID09PSAweDIyIHx8IC8vIFwiXG4gICAgICBjb2RlID09PSAweDI4IHx8IC8vIChcbiAgICAgIGNvZGUgPT09IDB4MjkgfHwgLy8gKVxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDJGIHx8IC8vIC9cbiAgICAgIGNvZGUgPT09IDB4M0EgfHwgLy8gOlxuICAgICAgY29kZSA9PT0gMHgzQiB8fCAvLyA7XG4gICAgICBjb2RlID09PSAweDNDIHx8IC8vIDxcbiAgICAgIGNvZGUgPT09IDB4M0QgfHwgLy8gPVxuICAgICAgY29kZSA9PT0gMHgzRSB8fCAvLyA+XG4gICAgICBjb2RlID09PSAweDNGIHx8IC8vID9cbiAgICAgIGNvZGUgPT09IDB4NDAgfHwgLy8gQFxuICAgICAgY29kZSA9PT0gMHg1QiB8fCAvLyBbXG4gICAgICBjb2RlID09PSAweDVDIHx8IC8vIFxcXG4gICAgICBjb2RlID09PSAweDVEIHx8IC8vIF1cbiAgICAgIGNvZGUgPT09IDB4N0IgfHwgLy8ge1xuICAgICAgY29kZSA9PT0gMHg3RCAvLyB9XG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy00XG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZSAoY29kZSkge1xuICBpZiAoY29kZSA+PSAxMDAwICYmIGNvZGUgPCAxMDE1KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNvZGUgIT09IDEwMDQgJiYgLy8gcmVzZXJ2ZWRcbiAgICAgIGNvZGUgIT09IDEwMDUgJiYgLy8gXCJNVVNUIE5PVCBiZSBzZXQgYXMgYSBzdGF0dXMgY29kZVwiXG4gICAgICBjb2RlICE9PSAxMDA2IC8vIFwiTVVTVCBOT1QgYmUgc2V0IGFzIGEgc3RhdHVzIGNvZGVcIlxuICAgIClcbiAgfVxuXG4gIHJldHVybiBjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSByZWFzb25cbiAqL1xuZnVuY3Rpb24gZmFpbFdlYnNvY2tldENvbm5lY3Rpb24gKHdzLCByZWFzb24pIHtcbiAgY29uc3QgeyBba0NvbnRyb2xsZXJdOiBjb250cm9sbGVyLCBba1Jlc3BvbnNlXTogcmVzcG9uc2UgfSA9IHdzXG5cbiAgY29udHJvbGxlci5hYm9ydCgpXG5cbiAgaWYgKHJlc3BvbnNlPy5zb2NrZXQgJiYgIXJlc3BvbnNlLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICByZXNwb25zZS5zb2NrZXQuZGVzdHJveSgpXG4gIH1cblxuICBpZiAocmVhc29uKSB7XG4gICAgLy8gVE9ETzogcHJvY2Vzcy5uZXh0VGlja1xuICAgIGZpcmVFdmVudCgnZXJyb3InLCB3cywgKHR5cGUsIGluaXQpID0+IG5ldyBFcnJvckV2ZW50KHR5cGUsIGluaXQpLCB7XG4gICAgICBlcnJvcjogbmV3IEVycm9yKHJlYXNvbiksXG4gICAgICBtZXNzYWdlOiByZWFzb25cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi01LjVcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcGNvZGVcbiAqL1xuZnVuY3Rpb24gaXNDb250cm9sRnJhbWUgKG9wY29kZSkge1xuICByZXR1cm4gKFxuICAgIG9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSB8fFxuICAgIG9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HIHx8XG4gICAgb3Bjb2RlID09PSBvcGNvZGVzLlBPTkdcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0NvbnRpbnVhdGlvbkZyYW1lIChvcGNvZGUpIHtcbiAgcmV0dXJuIG9wY29kZSA9PT0gb3Bjb2Rlcy5DT05USU5VQVRJT05cbn1cblxuZnVuY3Rpb24gaXNUZXh0QmluYXJ5RnJhbWUgKG9wY29kZSkge1xuICByZXR1cm4gb3Bjb2RlID09PSBvcGNvZGVzLlRFWFQgfHwgb3Bjb2RlID09PSBvcGNvZGVzLkJJTkFSWVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkT3Bjb2RlIChvcGNvZGUpIHtcbiAgcmV0dXJuIGlzVGV4dEJpbmFyeUZyYW1lKG9wY29kZSkgfHwgaXNDb250aW51YXRpb25GcmFtZShvcGNvZGUpIHx8IGlzQ29udHJvbEZyYW1lKG9wY29kZSlcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBzdHJpbmc+fVxuICovXG4vLyBUT0RPKEBVemxvcGFrLCBAS2hhZnJhRGV2KTogbWFrZSBjb21wbGlhbnQgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG5mdW5jdGlvbiBwYXJzZUV4dGVuc2lvbnMgKGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cbiAgY29uc3QgZXh0ZW5zaW9uTGlzdCA9IG5ldyBNYXAoKVxuXG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgcGFpciA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KCc7JywgZXh0ZW5zaW9ucywgcG9zaXRpb24pXG4gICAgY29uc3QgW25hbWUsIHZhbHVlID0gJyddID0gcGFpci5zcGxpdCgnPScpXG5cbiAgICBleHRlbnNpb25MaXN0LnNldChcbiAgICAgIHJlbW92ZUhUVFBXaGl0ZXNwYWNlKG5hbWUsIHRydWUsIGZhbHNlKSxcbiAgICAgIHJlbW92ZUhUVFBXaGl0ZXNwYWNlKHZhbHVlLCBmYWxzZSwgdHJ1ZSlcbiAgICApXG5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICByZXR1cm4gZXh0ZW5zaW9uTGlzdFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc2OTIjc2VjdGlvbi03LjEuMi4yXG4gKiBAZGVzY3JpcHRpb24gXCJjbGllbnQtbWF4LXdpbmRvdy1iaXRzID0gMSpESUdJVFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENsaWVudFdpbmRvd0JpdHMgKHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBieXRlID0gdmFsdWUuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKGJ5dGUgPCAweDMwIHx8IGJ5dGUgPiAweDM5KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2ludGwuaHRtbCNkZXRlY3RpbmctaW50ZXJuYXRpb25hbGl6YXRpb24tc3VwcG9ydFxuY29uc3QgaGFzSW50bCA9IHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLmljdSA9PT0gJ3N0cmluZydcbmNvbnN0IGZhdGFsRGVjb2RlciA9IGhhc0ludGwgPyBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSB9KSA6IHVuZGVmaW5lZFxuXG4vKipcbiAqIENvbnZlcnRzIGEgQnVmZmVyIHRvIHV0Zi04LCBldmVuIG9uIHBsYXRmb3JtcyB3aXRob3V0IGljdS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAqL1xuY29uc3QgdXRmOERlY29kZSA9IGhhc0ludGxcbiAgPyBmYXRhbERlY29kZXIuZGVjb2RlLmJpbmQoZmF0YWxEZWNvZGVyKVxuICA6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICBpZiAoaXNVdGY4KGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ3V0Zi04JylcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB1dGYtOCByZWNlaXZlZC4nKVxuICB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0Nvbm5lY3RpbmcsXG4gIGlzRXN0YWJsaXNoZWQsXG4gIGlzQ2xvc2luZyxcbiAgaXNDbG9zZWQsXG4gIGZpcmVFdmVudCxcbiAgaXNWYWxpZFN1YnByb3RvY29sLFxuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sXG4gIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCxcbiAgdXRmOERlY29kZSxcbiAgaXNDb250cm9sRnJhbWUsXG4gIGlzQ29udGludWF0aW9uRnJhbWUsXG4gIGlzVGV4dEJpbmFyeUZyYW1lLFxuICBpc1ZhbGlkT3Bjb2RlLFxuICBwYXJzZUV4dGVuc2lvbnMsXG4gIGlzVmFsaWRDbGllbnRXaW5kb3dCaXRzXG59XG4iXSwibmFtZXMiOlsia1JlYWR5U3RhdGUiLCJrQ29udHJvbGxlciIsImtSZXNwb25zZSIsImtCaW5hcnlUeXBlIiwia1dlYlNvY2tldFVSTCIsInJlcXVpcmUiLCJzdGF0ZXMiLCJvcGNvZGVzIiwiRXJyb3JFdmVudCIsImNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQiLCJpc1V0ZjgiLCJjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCIsInJlbW92ZUhUVFBXaGl0ZXNwYWNlIiwiaXNDb25uZWN0aW5nIiwid3MiLCJDT05ORUNUSU5HIiwiaXNFc3RhYmxpc2hlZCIsIk9QRU4iLCJpc0Nsb3NpbmciLCJDTE9TSU5HIiwiaXNDbG9zZWQiLCJDTE9TRUQiLCJmaXJlRXZlbnQiLCJlIiwidGFyZ2V0IiwiZXZlbnRGYWN0b3J5IiwidHlwZSIsImluaXQiLCJFdmVudCIsImV2ZW50SW5pdERpY3QiLCJldmVudCIsImRpc3BhdGNoRXZlbnQiLCJ3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQiLCJkYXRhIiwiZGF0YUZvckV2ZW50IiwiVEVYVCIsInV0ZjhEZWNvZGUiLCJmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiIsIkJJTkFSWSIsIkJsb2IiLCJ0b0FycmF5QnVmZmVyIiwib3JpZ2luIiwiYnVmZmVyIiwiYnl0ZUxlbmd0aCIsInNsaWNlIiwiYnl0ZU9mZnNldCIsImlzVmFsaWRTdWJwcm90b2NvbCIsInByb3RvY29sIiwibGVuZ3RoIiwiaSIsImNvZGUiLCJjaGFyQ29kZUF0IiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJyZWFzb24iLCJjb250cm9sbGVyIiwicmVzcG9uc2UiLCJhYm9ydCIsInNvY2tldCIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImlzQ29udHJvbEZyYW1lIiwib3Bjb2RlIiwiQ0xPU0UiLCJQSU5HIiwiUE9ORyIsImlzQ29udGludWF0aW9uRnJhbWUiLCJDT05USU5VQVRJT04iLCJpc1RleHRCaW5hcnlGcmFtZSIsImlzVmFsaWRPcGNvZGUiLCJwYXJzZUV4dGVuc2lvbnMiLCJleHRlbnNpb25zIiwicG9zaXRpb24iLCJleHRlbnNpb25MaXN0IiwiTWFwIiwicGFpciIsIm5hbWUiLCJ2YWx1ZSIsInNwbGl0Iiwic2V0IiwiaXNWYWxpZENsaWVudFdpbmRvd0JpdHMiLCJieXRlIiwiaGFzSW50bCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsImljdSIsImZhdGFsRGVjb2RlciIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJ1bmRlZmluZWQiLCJkZWNvZGUiLCJiaW5kIiwidG9TdHJpbmciLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\");\nconst { isConnecting, isEstablished, isClosing, isValidSubprotocol, fireEvent } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\");\nconst { establishWebSocketConnection, closeWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/undici/lib/web/websocket/connection.js\");\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/undici/lib/web/websocket/receiver.js\");\nconst { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(ssr)/./node_modules/undici/lib/global.js\");\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\");\nconst { ErrorEvent, CloseEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nconst { SendQueue } = __webpack_require__(/*! ./sender */ \"(ssr)/./node_modules/undici/lib/web/websocket/sender.js\");\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n    #events;\n    #bufferedAmount;\n    #protocol;\n    #extensions;\n    /** @type {SendQueue} */ #sendQueue;\n    /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */ constructor(url, protocols = []){\n        super(), this.#events = {\n            open: null,\n            error: null,\n            close: null,\n            message: null\n        }, this.#bufferedAmount = 0, this.#protocol = '', this.#extensions = '';\n        const prefix = 'WebSocket constructor';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options');\n        url = webidl.converters.USVString(url, prefix, 'url');\n        protocols = options.protocols;\n        // 1. Let baseURL be this's relevant settings object's API base URL.\n        const baseURL = environmentSettingsObject.settingsObject.baseUrl;\n        // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n        let urlRecord;\n        try {\n            urlRecord = new URL(url, baseURL);\n        } catch (e) {\n            // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n            throw new DOMException(e, 'SyntaxError');\n        }\n        // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n        if (urlRecord.protocol === 'http:') {\n            urlRecord.protocol = 'ws:';\n        } else if (urlRecord.protocol === 'https:') {\n            // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n            urlRecord.protocol = 'wss:';\n        }\n        // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n        if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n            throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');\n        }\n        // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n        //    DOMException.\n        if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n            throw new DOMException('Got fragment', 'SyntaxError');\n        }\n        // 8. If protocols is a string, set protocols to a sequence consisting\n        //    of just that string.\n        if (typeof protocols === 'string') {\n            protocols = [\n                protocols\n            ];\n        }\n        // 9. If any of the values in protocols occur more than once or otherwise\n        //    fail to match the requirements for elements that comprise the value\n        //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n        //    protocol, then throw a \"SyntaxError\" DOMException.\n        if (protocols.length !== new Set(protocols.map((p)=>p.toLowerCase())).size) {\n            throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n        }\n        if (protocols.length > 0 && !protocols.every((p)=>isValidSubprotocol(p))) {\n            throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n        }\n        // 10. Set this's url to urlRecord.\n        this[kWebSocketURL] = new URL(urlRecord.href);\n        // 11. Let client be this's relevant settings object.\n        const client = environmentSettingsObject.settingsObject;\n        // 12. Run this step in parallel:\n        //    1. Establish a WebSocket connection given urlRecord, protocols,\n        //       and client.\n        this[kController] = establishWebSocketConnection(urlRecord, protocols, client, this, (response, extensions)=>this.#onConnectionEstablished(response, extensions), options);\n        // Each WebSocket object has an associated ready state, which is a\n        // number representing the state of the connection. Initially it must\n        // be CONNECTING (0).\n        this[kReadyState] = WebSocket.CONNECTING;\n        this[kSentClose] = sentCloseFrameState.NOT_SENT;\n        // The extensions attribute must initially return the empty string.\n        // The protocol attribute must initially return the empty string.\n        // Each WebSocket object has an associated binary type, which is a\n        // BinaryType. Initially it must be \"blob\".\n        this[kBinaryType] = 'blob';\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */ close(code = undefined, reason = undefined) {\n        webidl.brandCheck(this, WebSocket);\n        const prefix = 'WebSocket.close';\n        if (code !== undefined) {\n            code = webidl.converters['unsigned short'](code, prefix, 'code', {\n                clamp: true\n            });\n        }\n        if (reason !== undefined) {\n            reason = webidl.converters.USVString(reason, prefix, 'reason');\n        }\n        // 1. If code is present, but is neither an integer equal to 1000 nor an\n        //    integer in the range 3000 to 4999, inclusive, throw an\n        //    \"InvalidAccessError\" DOMException.\n        if (code !== undefined) {\n            if (code !== 1000 && (code < 3000 || code > 4999)) {\n                throw new DOMException('invalid code', 'InvalidAccessError');\n            }\n        }\n        let reasonByteLength = 0;\n        // 2. If reason is present, then run these substeps:\n        if (reason !== undefined) {\n            // 1. Let reasonBytes be the result of encoding reason.\n            // 2. If reasonBytes is longer than 123 bytes, then throw a\n            //    \"SyntaxError\" DOMException.\n            reasonByteLength = Buffer.byteLength(reason);\n            if (reasonByteLength > 123) {\n                throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');\n            }\n        }\n        // 3. Run the first matching steps from the following list:\n        closeWebSocketConnection(this, code, reason, reasonByteLength);\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */ send(data) {\n        webidl.brandCheck(this, WebSocket);\n        const prefix = 'WebSocket.send';\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        data = webidl.converters.WebSocketSendData(data, prefix, 'data');\n        // 1. If this's ready state is CONNECTING, then throw an\n        //    \"InvalidStateError\" DOMException.\n        if (isConnecting(this)) {\n            throw new DOMException('Sent before connected.', 'InvalidStateError');\n        }\n        // 2. Run the appropriate set of steps from the following list:\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n        if (!isEstablished(this) || isClosing(this)) {\n            return;\n        }\n        // If data is a string\n        if (typeof data === 'string') {\n            // If the WebSocket connection is established and the WebSocket\n            // closing handshake has not yet started, then the user agent\n            // must send a WebSocket Message comprised of the data argument\n            // using a text frame opcode; if the data cannot be sent, e.g.\n            // because it would need to be buffered but the buffer is full,\n            // the user agent must flag the WebSocket as full and then close\n            // the WebSocket connection. Any invocation of this method with a\n            // string argument that does not throw an exception must increase\n            // the bufferedAmount attribute by the number of bytes needed to\n            // express the argument as UTF-8.\n            const length = Buffer.byteLength(data);\n            this.#bufferedAmount += length;\n            this.#sendQueue.add(data, ()=>{\n                this.#bufferedAmount -= length;\n            }, sendHints.string);\n        } else if (types.isArrayBuffer(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need\n            // to be buffered but the buffer is full, the user agent must flag\n            // the WebSocket as full and then close the WebSocket connection.\n            // The data to be sent is the data stored in the buffer described\n            // by the ArrayBuffer object. Any invocation of this method with an\n            // ArrayBuffer argument that does not throw an exception must\n            // increase the bufferedAmount attribute by the length of the\n            // ArrayBuffer in bytes.\n            this.#bufferedAmount += data.byteLength;\n            this.#sendQueue.add(data, ()=>{\n                this.#bufferedAmount -= data.byteLength;\n            }, sendHints.arrayBuffer);\n        } else if (ArrayBuffer.isView(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The\n            // data to be sent is the data stored in the section of the buffer\n            // described by the ArrayBuffer object that data references. Any\n            // invocation of this method with this kind of argument that does\n            // not throw an exception must increase the bufferedAmount attribute\n            // by the length of data’s buffer in bytes.\n            this.#bufferedAmount += data.byteLength;\n            this.#sendQueue.add(data, ()=>{\n                this.#bufferedAmount -= data.byteLength;\n            }, sendHints.typedArray);\n        } else if (isBlobLike(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The data\n            // to be sent is the raw data represented by the Blob object. Any\n            // invocation of this method with a Blob argument that does not throw\n            // an exception must increase the bufferedAmount attribute by the size\n            // of the Blob object’s raw data, in bytes.\n            this.#bufferedAmount += data.size;\n            this.#sendQueue.add(data, ()=>{\n                this.#bufferedAmount -= data.size;\n            }, sendHints.blob);\n        }\n    }\n    get readyState() {\n        webidl.brandCheck(this, WebSocket);\n        // The readyState getter steps are to return this's ready state.\n        return this[kReadyState];\n    }\n    get bufferedAmount() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#bufferedAmount;\n    }\n    get url() {\n        webidl.brandCheck(this, WebSocket);\n        // The url getter steps are to return this's url, serialized.\n        return URLSerializer(this[kWebSocketURL]);\n    }\n    get extensions() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#extensions;\n    }\n    get protocol() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#protocol;\n    }\n    get onopen() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.open;\n    }\n    set onopen(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.open) {\n            this.removeEventListener('open', this.#events.open);\n        }\n        if (typeof fn === 'function') {\n            this.#events.open = fn;\n            this.addEventListener('open', fn);\n        } else {\n            this.#events.open = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.error) {\n            this.removeEventListener('error', this.#events.error);\n        }\n        if (typeof fn === 'function') {\n            this.#events.error = fn;\n            this.addEventListener('error', fn);\n        } else {\n            this.#events.error = null;\n        }\n    }\n    get onclose() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.close;\n    }\n    set onclose(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.close) {\n            this.removeEventListener('close', this.#events.close);\n        }\n        if (typeof fn === 'function') {\n            this.#events.close = fn;\n            this.addEventListener('close', fn);\n        } else {\n            this.#events.close = null;\n        }\n    }\n    get onmessage() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.message;\n    }\n    set onmessage(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.message) {\n            this.removeEventListener('message', this.#events.message);\n        }\n        if (typeof fn === 'function') {\n            this.#events.message = fn;\n            this.addEventListener('message', fn);\n        } else {\n            this.#events.message = null;\n        }\n    }\n    get binaryType() {\n        webidl.brandCheck(this, WebSocket);\n        return this[kBinaryType];\n    }\n    set binaryType(type) {\n        webidl.brandCheck(this, WebSocket);\n        if (type !== 'blob' && type !== 'arraybuffer') {\n            this[kBinaryType] = 'blob';\n        } else {\n            this[kBinaryType] = type;\n        }\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */ #onConnectionEstablished(response, parsedExtensions) {\n        // processResponse is called when the \"response’s header list has been received and initialized.\"\n        // once this happens, the connection is open\n        this[kResponse] = response;\n        const parser = new ByteParser(this, parsedExtensions);\n        parser.on('drain', onParserDrain);\n        parser.on('error', onParserError.bind(this));\n        response.socket.ws = this;\n        this[kByteParser] = parser;\n        this.#sendQueue = new SendQueue(response.socket);\n        // 1. Change the ready state to OPEN (1).\n        this[kReadyState] = states.OPEN;\n        // 2. Change the extensions attribute’s value to the extensions in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n        const extensions = response.headersList.get('sec-websocket-extensions');\n        if (extensions !== null) {\n            this.#extensions = extensions;\n        }\n        // 3. Change the protocol attribute’s value to the subprotocol in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n        const protocol = response.headersList.get('sec-websocket-protocol');\n        if (protocol !== null) {\n            this.#protocol = protocol;\n        }\n        // 4. Fire an event named open at the WebSocket object.\n        fireEvent('open', this);\n    }\n}\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors,\n    url: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    bufferedAmount: kEnumerableProperty,\n    onopen: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onclose: kEnumerableProperty,\n    close: kEnumerableProperty,\n    onmessage: kEnumerableProperty,\n    binaryType: kEnumerableProperty,\n    send: kEnumerableProperty,\n    extensions: kEnumerableProperty,\n    protocol: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: 'WebSocket',\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(WebSocket, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors\n});\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters['DOMString or sequence<DOMString>'] = function(V, prefix, argument) {\n    if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n        return webidl.converters['sequence<DOMString>'](V);\n    }\n    return webidl.converters.DOMString(V, prefix, argument);\n};\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n    {\n        key: 'protocols',\n        converter: webidl.converters['DOMString or sequence<DOMString>'],\n        defaultValue: ()=>new Array(0)\n    },\n    {\n        key: 'dispatcher',\n        converter: webidl.converters.any,\n        defaultValue: ()=>getGlobalDispatcher()\n    },\n    {\n        key: 'headers',\n        converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n    }\n]);\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function(V) {\n    if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n        return webidl.converters.WebSocketInit(V);\n    }\n    return {\n        protocols: webidl.converters['DOMString or sequence<DOMString>'](V)\n    };\n};\nwebidl.converters.WebSocketSendData = function(V) {\n    if (webidl.util.Type(V) === 'Object') {\n        if (isBlobLike(V)) {\n            return webidl.converters.Blob(V, {\n                strict: false\n            });\n        }\n        if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n            return webidl.converters.BufferSource(V);\n        }\n    }\n    return webidl.converters.USVString(V);\n};\nfunction onParserDrain() {\n    this.ws[kResponse].socket.resume();\n}\nfunction onParserError(err) {\n    let message;\n    let code;\n    if (err instanceof CloseEvent) {\n        message = err.reason;\n        code = err.code;\n    } else {\n        message = err.message;\n    }\n    fireEvent('error', this, ()=>new ErrorEvent('error', {\n            error: err,\n            message\n        }));\n    closeWebSocketConnection(this, code);\n}\nmodule.exports = {\n    WebSocket\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLDRFQUFpQjtBQUM1QyxNQUFNLEVBQUVDLGFBQWEsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxnRkFBbUI7QUFDckQsTUFBTSxFQUFFRSx5QkFBeUIsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQyx3RUFBZTtBQUM3RCxNQUFNLEVBQUVHLHlCQUF5QixFQUFFQyxNQUFNLEVBQUVDLG1CQUFtQixFQUFFQyxTQUFTLEVBQUUsR0FBR04sbUJBQU9BLENBQUMsK0VBQWE7QUFDbkcsTUFBTSxFQUNKTyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1osR0FBR2IsbUJBQU9BLENBQUMsMkVBQVc7QUFDdkIsTUFBTSxFQUNKYyxZQUFZLEVBQ1pDLGFBQWEsRUFDYkMsU0FBUyxFQUNUQyxrQkFBa0IsRUFDbEJDLFNBQVMsRUFDVixHQUFHbEIsbUJBQU9BLENBQUMscUVBQVE7QUFDcEIsTUFBTSxFQUFFbUIsNEJBQTRCLEVBQUVDLHdCQUF3QixFQUFFLEdBQUdwQixtQkFBT0EsQ0FBQyxpRkFBYztBQUN6RixNQUFNLEVBQUVxQixVQUFVLEVBQUUsR0FBR3JCLG1CQUFPQSxDQUFDLDZFQUFZO0FBQzNDLE1BQU0sRUFBRXNCLG1CQUFtQixFQUFFQyxVQUFVLEVBQUUsR0FBR3ZCLG1CQUFPQSxDQUFDLHFFQUFpQjtBQUNyRSxNQUFNLEVBQUV3QixtQkFBbUIsRUFBRSxHQUFHeEIsbUJBQU9BLENBQUMsK0RBQWM7QUFDdEQsTUFBTSxFQUFFeUIsS0FBSyxFQUFFLEdBQUd6QixtQkFBT0EsQ0FBQyw0QkFBVztBQUNyQyxNQUFNLEVBQUUwQixVQUFVLEVBQUVDLFVBQVUsRUFBRSxHQUFHM0Is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VXNHLElBQUl0RyxPQUFPO0lBQ3ZCO0lBRUFsQixVQUFVLFNBQVMsSUFBSSxFQUFFLElBQU0sSUFBSVEsV0FBVyxTQUFTO1lBQUVRLE9BQU93RztZQUFLdEc7UUFBUTtJQUU3RWhCLHlCQUF5QixJQUFJLEVBQUU4QztBQUNqQztBQUVBeUUsT0FBT0MsT0FBTyxHQUFHO0lBQ2YvRztBQUNGIiwic291cmNlcyI6WyJEOlxcSGVsaXhcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFx3ZWJzb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCB7IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLCBzdGF0ZXMsIHNlbnRDbG9zZUZyYW1lU3RhdGUsIHNlbmRIaW50cyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBrV2ViU29ja2V0VVJMLFxuICBrUmVhZHlTdGF0ZSxcbiAga0NvbnRyb2xsZXIsXG4gIGtCaW5hcnlUeXBlLFxuICBrUmVzcG9uc2UsXG4gIGtTZW50Q2xvc2UsXG4gIGtCeXRlUGFyc2VyXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHtcbiAgaXNDb25uZWN0aW5nLFxuICBpc0VzdGFibGlzaGVkLFxuICBpc0Nsb3NpbmcsXG4gIGlzVmFsaWRTdWJwcm90b2NvbCxcbiAgZmlyZUV2ZW50XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiwgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBCeXRlUGFyc2VyIH0gPSByZXF1aXJlKCcuL3JlY2VpdmVyJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSwgaXNCbG9iTGlrZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vLi4vZ2xvYmFsJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IEVycm9yRXZlbnQsIENsb3NlRXZlbnQgfSA9IHJlcXVpcmUoJy4vZXZlbnRzJylcbmNvbnN0IHsgU2VuZFF1ZXVlIH0gPSByZXF1aXJlKCcuL3NlbmRlcicpXG5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1kZWZpbml0aW9uXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICNldmVudHMgPSB7XG4gICAgb3BlbjogbnVsbCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBjbG9zZTogbnVsbCxcbiAgICBtZXNzYWdlOiBudWxsXG4gIH1cblxuICAjYnVmZmVyZWRBbW91bnQgPSAwXG4gICNwcm90b2NvbCA9ICcnXG4gICNleHRlbnNpb25zID0gJydcblxuICAvKiogQHR5cGUge1NlbmRRdWV1ZX0gKi9cbiAgI3NlbmRRdWV1ZVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwcm90b2NvbHNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHByb3RvY29scyA9IFtdKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1dlYlNvY2tldCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4gb3IgV2ViU29ja2V0SW5pdCddKHByb3RvY29scywgcHJlZml4LCAnb3B0aW9ucycpXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsLCBwcmVmaXgsICd1cmwnKVxuICAgIHByb3RvY29scyA9IG9wdGlvbnMucHJvdG9jb2xzXG5cbiAgICAvLyAxLiBMZXQgYmFzZVVSTCBiZSB0aGlzJ3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0J3MgQVBJIGJhc2UgVVJMLlxuICAgIGNvbnN0IGJhc2VVUkwgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0LmJhc2VVcmxcblxuICAgIC8vIDEuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgVVJMIHBhcnNlciB0byB1cmwgd2l0aCBiYXNlVVJMLlxuICAgIGxldCB1cmxSZWNvcmRcblxuICAgIHRyeSB7XG4gICAgICB1cmxSZWNvcmQgPSBuZXcgVVJMKHVybCwgYmFzZVVSTClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyAzLiBJZiB1cmxSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGUsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgXCJodHRwXCIsIHRoZW4gc2V0IHVybFJlY29yZOKAmXMgc2NoZW1lIHRvIFwid3NcIi5cbiAgICBpZiAodXJsUmVjb3JkLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgICB1cmxSZWNvcmQucHJvdG9jb2wgPSAnd3M6J1xuICAgIH0gZWxzZSBpZiAodXJsUmVjb3JkLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB1cmxSZWNvcmTigJlzIHNjaGVtZSBpcyBcImh0dHBzXCIsIHNldCB1cmxSZWNvcmTigJlzIHNjaGVtZSB0byBcIndzc1wiLlxuICAgICAgdXJsUmVjb3JkLnByb3RvY29sID0gJ3dzczonXG4gICAgfVxuXG4gICAgLy8gNi4gSWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgbm90IFwid3NcIiBvciBcIndzc1wiLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAodXJsUmVjb3JkLnByb3RvY29sICE9PSAnd3M6JyAmJiB1cmxSZWNvcmQucHJvdG9jb2wgIT09ICd3c3M6Jykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgYEV4cGVjdGVkIGEgd3M6IG9yIHdzczogcHJvdG9jb2wsIGdvdCAke3VybFJlY29yZC5wcm90b2NvbH1gLFxuICAgICAgICAnU3ludGF4RXJyb3InXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gNy4gSWYgdXJsUmVjb3Jk4oCZcyBmcmFnbWVudCBpcyBub24tbnVsbCwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIlxuICAgIC8vICAgIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAodXJsUmVjb3JkLmhhc2ggfHwgdXJsUmVjb3JkLmhyZWYuZW5kc1dpdGgoJyMnKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignR290IGZyYWdtZW50JywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA4LiBJZiBwcm90b2NvbHMgaXMgYSBzdHJpbmcsIHNldCBwcm90b2NvbHMgdG8gYSBzZXF1ZW5jZSBjb25zaXN0aW5nXG4gICAgLy8gICAgb2YganVzdCB0aGF0IHN0cmluZy5cbiAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdXG4gICAgfVxuXG4gICAgLy8gOS4gSWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gcHJvdG9jb2xzIG9jY3VyIG1vcmUgdGhhbiBvbmNlIG9yIG90aGVyd2lzZVxuICAgIC8vICAgIGZhaWwgdG8gbWF0Y2ggdGhlIHJlcXVpcmVtZW50cyBmb3IgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGUgdmFsdWVcbiAgICAvLyAgICBvZiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgZmllbGRzIGFzIGRlZmluZWQgYnkgVGhlIFdlYlNvY2tldFxuICAgIC8vICAgIHByb3RvY29sLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gbmV3IFNldChwcm90b2NvbHMubWFwKHAgPT4gcC50b0xvd2VyQ2FzZSgpKSkuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCA+IDAgJiYgIXByb3RvY29scy5ldmVyeShwID0+IGlzVmFsaWRTdWJwcm90b2NvbChwKSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCB2YWx1ZScsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gMTAuIFNldCB0aGlzJ3MgdXJsIHRvIHVybFJlY29yZC5cbiAgICB0aGlzW2tXZWJTb2NrZXRVUkxdID0gbmV3IFVSTCh1cmxSZWNvcmQuaHJlZilcblxuICAgIC8vIDExLiBMZXQgY2xpZW50IGJlIHRoaXMncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgY29uc3QgY2xpZW50ID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdFxuXG4gICAgLy8gMTIuIFJ1biB0aGlzIHN0ZXAgaW4gcGFyYWxsZWw6XG5cbiAgICAvLyAgICAxLiBFc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBnaXZlbiB1cmxSZWNvcmQsIHByb3RvY29scyxcbiAgICAvLyAgICAgICBhbmQgY2xpZW50LlxuICAgIHRoaXNba0NvbnRyb2xsZXJdID0gZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbihcbiAgICAgIHVybFJlY29yZCxcbiAgICAgIHByb3RvY29scyxcbiAgICAgIGNsaWVudCxcbiAgICAgIHRoaXMsXG4gICAgICAocmVzcG9uc2UsIGV4dGVuc2lvbnMpID0+IHRoaXMuI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkKHJlc3BvbnNlLCBleHRlbnNpb25zKSxcbiAgICAgIG9wdGlvbnNcbiAgICApXG5cbiAgICAvLyBFYWNoIFdlYlNvY2tldCBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgcmVhZHkgc3RhdGUsIHdoaWNoIGlzIGFcbiAgICAvLyBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbi4gSW5pdGlhbGx5IGl0IG11c3RcbiAgICAvLyBiZSBDT05ORUNUSU5HICgwKS5cbiAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IFdlYlNvY2tldC5DT05ORUNUSU5HXG5cbiAgICB0aGlzW2tTZW50Q2xvc2VdID0gc2VudENsb3NlRnJhbWVTdGF0ZS5OT1RfU0VOVFxuXG4gICAgLy8gVGhlIGV4dGVuc2lvbnMgYXR0cmlidXRlIG11c3QgaW5pdGlhbGx5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgLy8gVGhlIHByb3RvY29sIGF0dHJpYnV0ZSBtdXN0IGluaXRpYWxseSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cblxuICAgIC8vIEVhY2ggV2ViU29ja2V0IG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBiaW5hcnkgdHlwZSwgd2hpY2ggaXMgYVxuICAgIC8vIEJpbmFyeVR5cGUuIEluaXRpYWxseSBpdCBtdXN0IGJlIFwiYmxvYlwiLlxuICAgIHRoaXNba0JpbmFyeVR5cGVdID0gJ2Jsb2InXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NlXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHJlYXNvblxuICAgKi9cbiAgY2xvc2UgKGNvZGUgPSB1bmRlZmluZWQsIHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGNvbnN0IHByZWZpeCA9ICdXZWJTb2NrZXQuY2xvc2UnXG5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2RlID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10oY29kZSwgcHJlZml4LCAnY29kZScsIHsgY2xhbXA6IHRydWUgfSlcbiAgICB9XG5cbiAgICBpZiAocmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlYXNvbiA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhyZWFzb24sIHByZWZpeCwgJ3JlYXNvbicpXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgY29kZSBpcyBwcmVzZW50LCBidXQgaXMgbmVpdGhlciBhbiBpbnRlZ2VyIGVxdWFsIHRvIDEwMDAgbm9yIGFuXG4gICAgLy8gICAgaW50ZWdlciBpbiB0aGUgcmFuZ2UgMzAwMCB0byA0OTk5LCBpbmNsdXNpdmUsIHRocm93IGFuXG4gICAgLy8gICAgXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvZGUgIT09IDEwMDAgJiYgKGNvZGUgPCAzMDAwIHx8IGNvZGUgPiA0OTk5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdpbnZhbGlkIGNvZGUnLCAnSW52YWxpZEFjY2Vzc0Vycm9yJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVhc29uQnl0ZUxlbmd0aCA9IDBcblxuICAgIC8vIDIuIElmIHJlYXNvbiBpcyBwcmVzZW50LCB0aGVuIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICBpZiAocmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCByZWFzb25CeXRlcyBiZSB0aGUgcmVzdWx0IG9mIGVuY29kaW5nIHJlYXNvbi5cbiAgICAgIC8vIDIuIElmIHJlYXNvbkJ5dGVzIGlzIGxvbmdlciB0aGFuIDEyMyBieXRlcywgdGhlbiB0aHJvdyBhXG4gICAgICAvLyAgICBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgcmVhc29uQnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHJlYXNvbilcblxuICAgICAgaWYgKHJlYXNvbkJ5dGVMZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICBgUmVhc29uIG11c3QgYmUgbGVzcyB0aGFuIDEyMyBieXRlczsgcmVjZWl2ZWQgJHtyZWFzb25CeXRlTGVuZ3RofWAsXG4gICAgICAgICAgJ1N5bnRheEVycm9yJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gUnVuIHRoZSBmaXJzdCBtYXRjaGluZyBzdGVwcyBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcywgY29kZSwgcmVhc29uLCByZWFzb25CeXRlTGVuZ3RoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1zZW5kXG4gICAqIEBwYXJhbSB7Tm9kZUpTLlR5cGVkQXJyYXl8QXJyYXlCdWZmZXJ8QmxvYnxzdHJpbmd9IGRhdGFcbiAgICovXG4gIHNlbmQgKGRhdGEpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnV2ViU29ja2V0LnNlbmQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBkYXRhID0gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U2VuZERhdGEoZGF0YSwgcHJlZml4LCAnZGF0YScpXG5cbiAgICAvLyAxLiBJZiB0aGlzJ3MgcmVhZHkgc3RhdGUgaXMgQ09OTkVDVElORywgdGhlbiB0aHJvdyBhblxuICAgIC8vICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKGlzQ29ubmVjdGluZyh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VudCBiZWZvcmUgY29ubmVjdGVkLicsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gMi4gUnVuIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc3RlcHMgZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNi4xXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNS4yXG5cbiAgICBpZiAoIWlzRXN0YWJsaXNoZWQodGhpcykgfHwgaXNDbG9zaW5nKHRoaXMpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBkYXRhIGlzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50XG4gICAgICAvLyBtdXN0IHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgdGhlIGRhdGEgYXJndW1lbnRcbiAgICAgIC8vIHVzaW5nIGEgdGV4dCBmcmFtZSBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuXG4gICAgICAvLyBiZWNhdXNlIGl0IHdvdWxkIG5lZWQgdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCxcbiAgICAgIC8vIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2VcbiAgICAgIC8vIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gQW55IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhXG4gICAgICAvLyBzdHJpbmcgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZVxuICAgICAgLy8gdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0b1xuICAgICAgLy8gZXhwcmVzcyB0aGUgYXJndW1lbnQgYXMgVVRGLTguXG5cbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aFxuICAgICAgdGhpcy4jc2VuZFF1ZXVlLmFkZChkYXRhLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGxlbmd0aFxuICAgICAgfSwgc2VuZEhpbnRzLnN0cmluZylcbiAgICB9IGVsc2UgaWYgKHR5cGVzLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZFxuICAgICAgLy8gdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnXG4gICAgICAvLyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgLy8gVGhlIGRhdGEgdG8gYmUgc2VudCBpcyB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIGJ1ZmZlciBkZXNjcmliZWRcbiAgICAgIC8vIGJ5IHRoZSBBcnJheUJ1ZmZlciBvYmplY3QuIEFueSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYW5cbiAgICAgIC8vIEFycmF5QnVmZmVyIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3RcbiAgICAgIC8vIGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIC8vIEFycmF5QnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy5hcnJheUJ1ZmZlcilcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvXG4gICAgICAvLyBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoZVxuICAgICAgLy8gZGF0YSB0byBiZSBzZW50IGlzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgc2VjdGlvbiBvZiB0aGUgYnVmZmVyXG4gICAgICAvLyBkZXNjcmliZWQgYnkgdGhlIEFycmF5QnVmZmVyIG9iamVjdCB0aGF0IGRhdGEgcmVmZXJlbmNlcy4gQW55XG4gICAgICAvLyBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggdGhpcyBraW5kIG9mIGFyZ3VtZW50IHRoYXQgZG9lc1xuICAgICAgLy8gbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGVcbiAgICAgIC8vIGJ5IHRoZSBsZW5ndGggb2YgZGF0YeKAmXMgYnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy50eXBlZEFycmF5KVxuICAgIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvXG4gICAgICAvLyBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoZSBkYXRhXG4gICAgICAvLyB0byBiZSBzZW50IGlzIHRoZSByYXcgZGF0YSByZXByZXNlbnRlZCBieSB0aGUgQmxvYiBvYmplY3QuIEFueVxuICAgICAgLy8gaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGEgQmxvYiBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93XG4gICAgICAvLyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZSB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBzaXplXG4gICAgICAvLyBvZiB0aGUgQmxvYiBvYmplY3TigJlzIHJhdyBkYXRhLCBpbiBieXRlcy5cblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gZGF0YS5zaXplXG4gICAgICB0aGlzLiNzZW5kUXVldWUuYWRkKGRhdGEsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gZGF0YS5zaXplXG4gICAgICB9LCBzZW5kSGludHMuYmxvYilcbiAgICB9XG4gIH1cblxuICBnZXQgcmVhZHlTdGF0ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgLy8gVGhlIHJlYWR5U3RhdGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpcydzIHJlYWR5IHN0YXRlLlxuICAgIHJldHVybiB0aGlzW2tSZWFkeVN0YXRlXVxuICB9XG5cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jYnVmZmVyZWRBbW91bnRcbiAgfVxuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpcydzIHVybCwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih0aGlzW2tXZWJTb2NrZXRVUkxdKVxuICB9XG5cbiAgZ2V0IGV4dGVuc2lvbnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNleHRlbnNpb25zXG4gIH1cblxuICBnZXQgcHJvdG9jb2wgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNwcm90b2NvbFxuICB9XG5cbiAgZ2V0IG9ub3BlbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5vcGVuXG4gIH1cblxuICBzZXQgb25vcGVuIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMub3Blbikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy4jZXZlbnRzLm9wZW4pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLmVycm9yKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy4jZXZlbnRzLmVycm9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5lcnJvciA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5lcnJvciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25jbG9zZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5jbG9zZVxuICB9XG5cbiAgc2V0IG9uY2xvc2UgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5jbG9zZSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuI2V2ZW50cy5jbG9zZSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuY2xvc2UgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuY2xvc2UgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ubWVzc2FnZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5tZXNzYWdlXG4gIH1cblxuICBzZXQgb25tZXNzYWdlIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMubWVzc2FnZSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy4jZXZlbnRzLm1lc3NhZ2UpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm1lc3NhZ2UgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBiaW5hcnlUeXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpc1trQmluYXJ5VHlwZV1cbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlICh0eXBlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHR5cGUgIT09ICdibG9iJyAmJiB0eXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICB0aGlzW2tCaW5hcnlUeXBlXSA9ICdibG9iJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tCaW5hcnlUeXBlXSA9IHR5cGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICAgKi9cbiAgI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkIChyZXNwb25zZSwgcGFyc2VkRXh0ZW5zaW9ucykge1xuICAgIC8vIHByb2Nlc3NSZXNwb25zZSBpcyBjYWxsZWQgd2hlbiB0aGUgXCJyZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIGluaXRpYWxpemVkLlwiXG4gICAgLy8gb25jZSB0aGlzIGhhcHBlbnMsIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5cbiAgICB0aGlzW2tSZXNwb25zZV0gPSByZXNwb25zZVxuXG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEJ5dGVQYXJzZXIodGhpcywgcGFyc2VkRXh0ZW5zaW9ucylcbiAgICBwYXJzZXIub24oJ2RyYWluJywgb25QYXJzZXJEcmFpbilcbiAgICBwYXJzZXIub24oJ2Vycm9yJywgb25QYXJzZXJFcnJvci5iaW5kKHRoaXMpKVxuXG4gICAgcmVzcG9uc2Uuc29ja2V0LndzID0gdGhpc1xuICAgIHRoaXNba0J5dGVQYXJzZXJdID0gcGFyc2VyXG5cbiAgICB0aGlzLiNzZW5kUXVldWUgPSBuZXcgU2VuZFF1ZXVlKHJlc3BvbnNlLnNvY2tldClcblxuICAgIC8vIDEuIENoYW5nZSB0aGUgcmVhZHkgc3RhdGUgdG8gT1BFTiAoMSkuXG4gICAgdGhpc1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuT1BFTlxuXG4gICAgLy8gMi4gQ2hhbmdlIHRoZSBleHRlbnNpb25zIGF0dHJpYnV0ZeKAmXMgdmFsdWUgdG8gdGhlIGV4dGVuc2lvbnMgaW4gdXNlLCBpZlxuICAgIC8vICAgIGl0IGlzIG5vdCB0aGUgbnVsbCB2YWx1ZS5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICBjb25zdCBleHRlbnNpb25zID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnKVxuXG4gICAgaWYgKGV4dGVuc2lvbnMgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuI2V4dGVuc2lvbnMgPSBleHRlbnNpb25zXG4gICAgfVxuXG4gICAgLy8gMy4gQ2hhbmdlIHRoZSBwcm90b2NvbCBhdHRyaWJ1dGXigJlzIHZhbHVlIHRvIHRoZSBzdWJwcm90b2NvbCBpbiB1c2UsIGlmXG4gICAgLy8gICAgaXQgaXMgbm90IHRoZSBudWxsIHZhbHVlLlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTEuOVxuICAgIGNvbnN0IHByb3RvY29sID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdzZWMtd2Vic29ja2V0LXByb3RvY29sJylcblxuICAgIGlmIChwcm90b2NvbCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy4jcHJvdG9jb2wgPSBwcm90b2NvbFxuICAgIH1cblxuICAgIC8vIDQuIEZpcmUgYW4gZXZlbnQgbmFtZWQgb3BlbiBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgICBmaXJlRXZlbnQoJ29wZW4nLCB0aGlzKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY29ubmVjdGluZ1xuV2ViU29ja2V0LkNPTk5FQ1RJTkcgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSBzdGF0ZXMuQ09OTkVDVElOR1xuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1vcGVuXG5XZWJTb2NrZXQuT1BFTiA9IFdlYlNvY2tldC5wcm90b3R5cGUuT1BFTiA9IHN0YXRlcy5PUEVOXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NpbmdcbldlYlNvY2tldC5DTE9TSU5HID0gV2ViU29ja2V0LnByb3RvdHlwZS5DTE9TSU5HID0gc3RhdGVzLkNMT1NJTkdcbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2VkXG5XZWJTb2NrZXQuQ0xPU0VEID0gV2ViU29ja2V0LnByb3RvdHlwZS5DTE9TRUQgPSBzdGF0ZXMuQ0xPU0VEXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlNvY2tldC5wcm90b3R5cGUsIHtcbiAgQ09OTkVDVElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgT1BFTjogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0lORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0VEOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWR5U3RhdGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJ1ZmZlcmVkQW1vdW50OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm9wZW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJpbmFyeVR5cGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGV4dGVuc2lvbnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHByb3RvY29sOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnV2ViU29ja2V0JyxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlNvY2tldCwge1xuICBDT05ORUNUSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBPUEVOOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TRUQ6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnNcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxET01TdHJpbmc+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0JyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gVikge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8RE9NU3RyaW5nPiddKFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG59XG5cbi8vIFRoaXMgaW1wbGVtZW50cyB0aGUgcHJvcG9zYWwgbWFkZSBpbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3dlYnNvY2tldHMvaXNzdWVzLzQyXG53ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAncHJvdG9jb2xzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbmV3IEFycmF5KDApXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkaXNwYXRjaGVyJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGdldEdsb2JhbERpc3BhdGNoZXIoKVxuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQpXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiBvciBXZWJTb2NrZXRJbml0J10gPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0SW5pdChWKVxuICB9XG5cbiAgcmV0dXJuIHsgcHJvdG9jb2xzOiB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXShWKSB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldFNlbmREYXRhID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnKSB7XG4gICAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgIH1cblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoVikgfHwgdHlwZXMuaXNBcnJheUJ1ZmZlcihWKSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbn1cblxuZnVuY3Rpb24gb25QYXJzZXJEcmFpbiAoKSB7XG4gIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQucmVzdW1lKClcbn1cblxuZnVuY3Rpb24gb25QYXJzZXJFcnJvciAoZXJyKSB7XG4gIGxldCBtZXNzYWdlXG4gIGxldCBjb2RlXG5cbiAgaWYgKGVyciBpbnN0YW5jZW9mIENsb3NlRXZlbnQpIHtcbiAgICBtZXNzYWdlID0gZXJyLnJlYXNvblxuICAgIGNvZGUgPSBlcnIuY29kZVxuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZVxuICB9XG5cbiAgZmlyZUV2ZW50KCdlcnJvcicsIHRoaXMsICgpID0+IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHsgZXJyb3I6IGVyciwgbWVzc2FnZSB9KSlcblxuICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcywgY29kZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlNvY2tldFxufVxuIl0sIm5hbWVzIjpbIndlYmlkbCIsInJlcXVpcmUiLCJVUkxTZXJpYWxpemVyIiwiZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCIsInN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMiLCJzdGF0ZXMiLCJzZW50Q2xvc2VGcmFtZVN0YXRlIiwic2VuZEhpbnRzIiwia1dlYlNvY2tldFVSTCIsImtSZWFkeVN0YXRlIiwia0NvbnRyb2xsZXIiLCJrQmluYXJ5VHlwZSIsImtSZXNwb25zZSIsImtTZW50Q2xvc2UiLCJrQnl0ZVBhcnNlciIsImlzQ29ubmVjdGluZyIsImlzRXN0YWJsaXNoZWQiLCJpc0Nsb3NpbmciLCJpc1ZhbGlkU3VicHJvdG9jb2wiLCJmaXJlRXZlbnQiLCJlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uIiwiY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIiwiQnl0ZVBhcnNlciIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJpc0Jsb2JMaWtlIiwiZ2V0R2xvYmFsRGlzcGF0Y2hlciIsInR5cGVzIiwiRXJyb3JFdmVudCIsIkNsb3NlRXZlbnQiLCJTZW5kUXVldWUiLCJXZWJTb2NrZXQiLCJFdmVudFRhcmdldCIsInVybCIsInByb3RvY29scyIsIm9wZW4iLCJlcnJvciIsImNsb3NlIiwibWVzc2FnZSIsInByZWZpeCIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJvcHRpb25zIiwiY29udmVydGVycyIsIlVTVlN0cmluZyIsImJhc2VVUkwiLCJzZXR0aW5nc09iamVjdCIsImJhc2VVcmwiLCJ1cmxSZWNvcmQiLCJVUkwiLCJlIiwiRE9NRXhjZXB0aW9uIiwicHJvdG9jb2wiLCJoYXNoIiwiaHJlZiIsImVuZHNXaXRoIiwibGVuZ3RoIiwiU2V0IiwibWFwIiwicCIsInRvTG93ZXJDYXNlIiwic2l6ZSIsImV2ZXJ5IiwiY2xpZW50IiwicmVzcG9uc2UiLCJleHRlbnNpb25zIiwiQ09OTkVDVElORyIsIk5PVF9TRU5UIiwiY29kZSIsInVuZGVmaW5lZCIsInJlYXNvbiIsImJyYW5kQ2hlY2siLCJjbGFtcCIsInJlYXNvbkJ5dGVMZW5ndGgiLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwic2VuZCIsImRhdGEiLCJXZWJTb2NrZXRTZW5kRGF0YSIsImFkZCIsInN0cmluZyIsImlzQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwidHlwZWRBcnJheSIsImJsb2IiLCJyZWFkeVN0YXRlIiwiYnVmZmVyZWRBbW91bnQiLCJvbm9wZW4iLCJmbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25lcnJvciIsIm9uY2xvc2UiLCJvbm1lc3NhZ2UiLCJiaW5hcnlUeXBlIiwidHlwZSIsInBhcnNlZEV4dGVuc2lvbnMiLCJwYXJzZXIiLCJvbiIsIm9uUGFyc2VyRHJhaW4iLCJvblBhcnNlckVycm9yIiwiYmluZCIsInNvY2tldCIsIndzIiwiT1BFTiIsImhlYWRlcnNMaXN0IiwiZ2V0IiwicHJvdG90eXBlIiwiQ0xPU0lORyIsIkNMT1NFRCIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJET01TdHJpbmciLCJWIiwiYXJndW1lbnQiLCJ1dGlsIiwiVHlwZSIsIml0ZXJhdG9yIiwiV2ViU29ja2V0SW5pdCIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJrZXkiLCJjb252ZXJ0ZXIiLCJkZWZhdWx0VmFsdWUiLCJBcnJheSIsImFueSIsIm51bGxhYmxlQ29udmVydGVyIiwiSGVhZGVyc0luaXQiLCJCbG9iIiwic3RyaWN0IiwiQnVmZmVyU291cmNlIiwicmVzdW1lIiwiZXJyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/websocket.js\n");

/***/ })

};
;